file_path,api_count,code
test.py,0,"b""import os\nfrom options.test_options import TestOptions\nfrom data import create_dataset\nfrom models import create_model\nfrom util.visualizer import save_images\nfrom itertools import islice\nfrom util import html\n\n\n# options\nopt = TestOptions().parse()\nopt.num_threads = 1   # test code only supports num_threads=1\nopt.batch_size = 1   # test code only supports batch_size=1\nopt.serial_batches = True  # no shuffle\n\n# create dataset\ndataset = create_dataset(opt)\nmodel = create_model(opt)\nmodel.setup(opt)\nmodel.eval()\nprint('Loading model %s' % opt.model)\n\n# create website\nweb_dir = os.path.join(opt.results_dir, opt.phase + '_sync' if opt.sync else opt.phase)\nwebpage = html.HTML(web_dir, 'Training = %s, Phase = %s, Class =%s' % (opt.name, opt.phase, opt.name))\n\n# sample random z\nif opt.sync:\n    z_samples = model.get_z_random(opt.n_samples + 1, opt.nz)\n\n# test stage\nfor i, data in enumerate(islice(dataset, opt.num_test)):\n    model.set_input(data)\n    print('process input image %3.3d/%3.3d' % (i, opt.num_test))\n    if not opt.sync:\n        z_samples = model.get_z_random(opt.n_samples + 1, opt.nz)\n    for nn in range(opt.n_samples + 1):\n        encode = nn == 0 and not opt.no_encode\n        real_A, fake_B, real_B = model.test(z_samples[[nn]], encode=encode)\n        if nn == 0:\n            images = [real_A, real_B, fake_B]\n            names = ['input', 'ground truth', 'encoded']\n        else:\n            images.append(fake_B)\n            names.append('random_sample%2.2d' % nn)\n\n    img_path = 'input_%3.3d' % i\n    save_images(webpage, images, names, img_path, aspect_ratio=opt.aspect_ratio, width=opt.crop_size)\n\nwebpage.save()\n"""
train.py,0,"b'""""""General-purpose training script for image-to-image translation.\nThis script works for various models (with option \'--model\': e.g., bicycle_gan, pix2pix, test) and\ndifferent datasets (with option \'--dataset_mode\': e.g., aligned, single).\nYou need to specify the dataset (\'--dataroot\'), experiment name (\'--name\'), and model (\'--model\').\nIt first creates model, dataset, and visualizer given the option.\nIt then does standard network training. During the training, it also visualize/save the images, print/save the loss plot, and save models.\nThe script supports continue/resume training. Use \'--continue_train\' to resume your previous training.\nExample:\n    Train a BiCycleGAN model:\n        python train.py --dataroot ./datasets/facades --name facades_bicyclegan --model bicycle_gan --direction BtoA\n    Train a pix2pix model:\n        python train.py --dataroot ./datasets/facades --name facades_pix2pix --model pix2pix --direction BtoA\nSee options/base_options.py and options/train_options.py for more training options.\n""""""\nimport time\nfrom options.train_options import TrainOptions\nfrom data import create_dataset\nfrom models import create_model\nfrom util.visualizer import Visualizer\n\nif __name__ == \'__main__\':\n    opt = TrainOptions().parse()   # get training options\n    dataset = create_dataset(opt)  # create a dataset given opt.dataset_mode and other options\n    dataset_size = len(dataset)    # get the number of images in the dataset.\n    print(\'The number of training images = %d\' % dataset_size)\n\n    model = create_model(opt)      # create a model given opt.model and other options\n    model.setup(opt)               # regular setup: load and print networks; create schedulers\n    visualizer = Visualizer(opt)   # create a visualizer that display/save images and plots\n    total_iters = 0                # the total number of training iterations\n\n    for epoch in range(opt.epoch_count, opt.niter + opt.niter_decay + 1):    # outer loop for different epochs; we save the model by <epoch_count>, <epoch_count>+<save_latest_freq>\n        epoch_start_time = time.time()  # timer for entire epoch\n        iter_data_time = time.time()    # timer for data loading per iteration\n        epoch_iter = 0                  # the number of training iterations in current epoch, reset to 0 every epoch\n\n        for i, data in enumerate(dataset):  # inner loop within one epoch\n            iter_start_time = time.time()  # timer for computation per iteration\n            if total_iters % opt.print_freq == 0:\n                t_data = iter_start_time - iter_data_time\n            visualizer.reset()\n            total_iters += opt.batch_size\n            epoch_iter += opt.batch_size\n            model.set_input(data)         # unpack data from dataset and apply preprocessing\n            if not model.is_train():      # if this batch of input data is enough for training.\n                print(\'skip this batch\')\n                continue\n            model.optimize_parameters()   # calculate loss functions, get gradients, update network weights\n\n            if total_iters % opt.display_freq == 0:   # display images on visdom and save images to a HTML file\n                save_result = total_iters % opt.update_html_freq == 0\n                model.compute_visuals()\n                visualizer.display_current_results(model.get_current_visuals(), epoch, save_result)\n\n            if total_iters % opt.print_freq == 0:    # print training losses and save logging information to the disk\n                losses = model.get_current_losses()\n                t_comp = (time.time() - iter_start_time) / opt.batch_size\n                visualizer.print_current_losses(epoch, epoch_iter, losses, t_comp, t_data)\n                if opt.display_id > 0:\n                    visualizer.plot_current_losses(epoch, float(epoch_iter) / dataset_size, losses)\n\n            if total_iters % opt.save_latest_freq == 0:   # cache our latest model every <save_latest_freq> iterations\n                print(\'saving the latest model (epoch %d, total_iters %d)\' % (epoch, total_iters))\n                model.save_networks(\'latest\')\n\n            iter_data_time = time.time()\n        if epoch % opt.save_epoch_freq == 0:              # cache our model every <save_epoch_freq> epochs\n            print(\'saving the model at the end of epoch %d, iters %d\' % (epoch, total_iters))\n            model.save_networks(\'latest\')\n            model.save_networks(epoch)\n\n        print(\'End of epoch %d / %d \\t Time Taken: %d sec\' % (epoch, opt.niter + opt.niter_decay, time.time() - epoch_start_time))\n        model.update_learning_rate()                     # update learning rates at the end of every epoch.\n'"
video.py,1,"b""from options.video_options import VideoOptions\nfrom data import create_dataset\nfrom models import create_model\nfrom itertools import islice\nfrom util import util\nimport numpy as np\nimport moviepy.editor\nimport os\nimport torch\n\n\ndef get_random_z(opt):\n    z_samples = np.random.normal(0, 1, (opt.n_samples + 1, opt.nz))\n    return z_samples\n\n\ndef produce_frame(t):\n    k = int(t * opt.fps)\n    return np.concatenate(frame_rows[k], axis=1 - use_vertical)\n\n\n# hard-code opt\nopt = VideoOptions().parse()\nopt.num_threads = 1   # test code only supports num_threads=1\nopt.batch_size = 1   # test code only supports batch_size=1\nopt.no_encode = True  # do not use encoder\n\ndataset = create_dataset(opt)\nmodel = create_model(opt)\nmodel.setup(opt)\nmodel.eval()\ninterp_mode = 'slerp'\nuse_vertical = 1 if opt.align_mode == 'vertical' else 0\n\nprint('Loading model %s' % opt.model)\n# create website\nresults_dir = opt.results_dir\nutil.mkdir(results_dir)\ntotal_frames = opt.num_frames * opt.n_samples\n\n\nz_samples = get_random_z(opt)\nframe_rows = [[] for n in range(total_frames)]\n\nfor i, data in enumerate(islice(dataset, opt.num_test)):\n    print('process input image %3.3d/%3.3d' % (i, opt.num_test))\n    model.set_input(data)\n    real_A = util.tensor2im(model.real_A)\n    wb = opt.border\n    hb = opt.border\n    h = real_A.shape[0]\n    w = real_A.shape[1]   # border\n    real_A_b = np.full((h + hb, w + wb, opt.output_nc), 255, real_A.dtype)\n    real_A_b[hb:, wb:, :] = real_A\n    frames = [[real_A_b] for n in range(total_frames)]\n\n    for n in range(opt.n_samples):\n        z0 = z_samples[n]\n        z1 = z_samples[n + 1]\n        zs = util.interp_z(z0, z1, num_frames=opt.num_frames, interp_mode=interp_mode)\n        for k in range(opt.num_frames):\n            zs_k = (torch.Tensor(zs[[k]])).to(model.device)\n            _, fake_B_device, _ = model.test(zs_k, encode=False)\n            fake_B = util.tensor2im(fake_B_device)\n            fake_B_b = np.full((h + hb, w + wb, opt.output_nc), 255, fake_B.dtype)\n            fake_B_b[hb:, wb:, :] = fake_B\n            frames[k + opt.num_frames * n].append(fake_B_b)\n\n    for k in range(total_frames):\n        frame_row = np.concatenate(frames[k], axis=use_vertical)\n        frame_rows[k].append(frame_row)\n\n# compile it to a vdieo\nimages_dir = os.path.join(results_dir, 'frames_seed%4.4d' % opt.seed)\nutil.mkdir(images_dir)\n\n\nfor k in range(total_frames):\n    final_frame = np.concatenate(frame_rows[k], axis=1 - use_vertical)\n    util.save_image(final_frame, os.path.join(\n        images_dir, 'frame_%4.4d.jpg' % k))\n\n\nvideo_file = os.path.join(\n    results_dir, 'morphing_video_seed%4.4d_fps%d.mp4' % (opt.seed, opt.fps))\nvideo = moviepy.editor.VideoClip(\n    produce_frame, duration=float(total_frames) / opt.fps)\nvideo.write_videofile(video_file, fps=30, codec='libx264', bitrate='16M')\n"""
data/__init__.py,2,"b'""""""This package includes all the modules related to data loading and preprocessing\n\n To add a custom dataset class called \'dummy\', you need to add a file called \'dummy_dataset.py\' and define a subclass \'DummyDataset\' inherited from BaseDataset.\n You need to implement four functions:\n    -- <__init__>:                      initialize the class, first call BaseDataset.__init__(self, opt).\n    -- <__len__>:                       return the size of dataset.\n    -- <__getitem__>:                   get a data point from data loader.\n    -- <modify_commandline_options>:    (optionally) add dataset-specific options and set default options.\n\nNow you can use the dataset class by specifying flag \'--dataset_mode dummy\'.\nSee our template dataset class \'template_dataset.py\' for more details.\n""""""\nimport importlib\nimport torch.utils.data\nfrom data.base_dataset import BaseDataset\n\n\ndef find_dataset_using_name(dataset_name):\n    """"""Import the module ""data/[dataset_name]_dataset.py"".\n\n    In the file, the class called DatasetNameDataset() will\n    be instantiated. It has to be a subclass of BaseDataset,\n    and it is case-insensitive.\n    """"""\n    dataset_filename = ""data."" + dataset_name + ""_dataset""\n    datasetlib = importlib.import_module(dataset_filename)\n\n    dataset = None\n    target_dataset_name = dataset_name.replace(\'_\', \'\') + \'dataset\'\n    for name, cls in datasetlib.__dict__.items():\n        if name.lower() == target_dataset_name.lower() \\\n           and issubclass(cls, BaseDataset):\n            dataset = cls\n\n    if dataset is None:\n        raise NotImplementedError(""In %s.py, there should be a subclass of BaseDataset with class name that matches %s in lowercase."" % (dataset_filename, target_dataset_name))\n\n    return dataset\n\n\ndef get_option_setter(dataset_name):\n    """"""Return the static method <modify_commandline_options> of the dataset class.""""""\n    dataset_class = find_dataset_using_name(dataset_name)\n    return dataset_class.modify_commandline_options\n\n\ndef create_dataset(opt):\n    """"""Create a dataset given the option.\n\n    This function wraps the class CustomDatasetDataLoader.\n        This is the main interface between this package and \'train.py\'/\'test.py\'\n\n    Example:\n        >>> from data import create_dataset\n        >>> dataset = create_dataset(opt)\n    """"""\n    data_loader = CustomDatasetDataLoader(opt)\n    dataset = data_loader.load_data()\n    return dataset\n\n\nclass CustomDatasetDataLoader():\n    """"""Wrapper class of Dataset class that performs multi-threaded data loading""""""\n\n    def __init__(self, opt):\n        """"""Initialize this class\n\n        Step 1: create a dataset instance given the name [dataset_mode]\n        Step 2: create a multi-threaded data loader.\n        """"""\n        self.opt = opt\n        dataset_class = find_dataset_using_name(opt.dataset_mode)\n        self.dataset = dataset_class(opt)\n        print(""dataset [%s] was created"" % type(self.dataset).__name__)\n        self.dataloader = torch.utils.data.DataLoader(\n            self.dataset,\n            batch_size=opt.batch_size,\n            shuffle=not opt.serial_batches,\n            num_workers=int(opt.num_threads))\n\n    def load_data(self):\n        return self\n\n    def __len__(self):\n        """"""Return the number of data in the dataset""""""\n        return min(len(self.dataset), self.opt.max_dataset_size)\n\n    def __iter__(self):\n        """"""Return a batch of data""""""\n        for i, data in enumerate(self.dataloader):\n            if i * self.opt.batch_size >= self.opt.max_dataset_size:\n                break\n            yield data\n'"
data/aligned_dataset.py,0,"b'import os.path\nfrom data.base_dataset import BaseDataset, get_params, get_transform\nfrom data.image_folder import make_dataset\nfrom PIL import Image\n\n\nclass AlignedDataset(BaseDataset):\n    """"""A dataset class for paired image dataset.\n\n    It assumes that the directory \'/path/to/data/train\' contains image pairs in the form of {A,B}.\n    During test time, you need to prepare a directory \'/path/to/data/test\'.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseDataset.__init__(self, opt)\n        self.dir_AB = os.path.join(opt.dataroot, opt.phase)  # get the image directory\n        self.AB_paths = sorted(make_dataset(self.dir_AB, opt.max_dataset_size))  # get image paths\n        assert(self.opt.load_size >= self.opt.crop_size)   # crop_size should be smaller than the size of loaded image\n        self.input_nc = self.opt.output_nc if self.opt.direction == \'BtoA\' else self.opt.input_nc\n        self.output_nc = self.opt.input_nc if self.opt.direction == \'BtoA\' else self.opt.output_nc\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns a dictionary that contains A, B, A_paths and B_paths\n            A (tensor) - - an image in the input domain\n            B (tensor) - - its corresponding image in the target domain\n            A_paths (str) - - image paths\n            B_paths (str) - - image paths (same as A_paths)\n        """"""\n        # read a image given a random integer index\n        AB_path = self.AB_paths[index]\n        AB = Image.open(AB_path).convert(\'RGB\')\n        # split AB image into A and B\n        w, h = AB.size\n        w2 = int(w / 2)\n        A = AB.crop((0, 0, w2, h))\n        B = AB.crop((w2, 0, w, h))\n\n        # apply the same transform to both A and B\n        transform_params = get_params(self.opt, A.size)\n        A_transform = get_transform(self.opt, transform_params, grayscale=(self.input_nc == 1))\n        B_transform = get_transform(self.opt, transform_params, grayscale=(self.output_nc == 1))\n\n        A = A_transform(A)\n        B = B_transform(B)\n\n        return {\'A\': A, \'B\': B, \'A_paths\': AB_path, \'B_paths\': AB_path}\n\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return len(self.AB_paths)\n'"
data/base_dataset.py,1,"b'""""""This module implements an abstract base class (ABC) \'BaseDataset\' for datasets.\n\nIt also includes common transformation functions (e.g., get_transform, __scale_width), which can be later used in subclasses.\n""""""\nimport random\nimport numpy as np\nimport torch.utils.data as data\nfrom PIL import Image\nimport torchvision.transforms as transforms\nfrom abc import ABC, abstractmethod\n\n\nclass BaseDataset(data.Dataset, ABC):\n    """"""This class is an abstract base class (ABC) for datasets.\n\n    To create a subclass, you need to implement the following four functions:\n    -- <__init__>:                      initialize the class, first call BaseDataset.__init__(self, opt).\n    -- <__len__>:                       return the size of dataset.\n    -- <__getitem__>:                   get a data point.\n    -- <modify_commandline_options>:    (optionally) add dataset-specific options and set default options.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize the class; save the options in the class\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        self.opt = opt\n        self.root = opt.dataroot\n\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        return parser\n\n    @abstractmethod\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return 0\n\n    @abstractmethod\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns:\n            a dictionary of data with their names. It ususally contains the data itself and its metadata information.\n        """"""\n        pass\n\n\ndef get_params(opt, size):\n    w, h = size\n    new_h = h\n    new_w = w\n    if opt.preprocess == \'resize_and_crop\':\n        new_h = new_w = opt.load_size\n    elif opt.preprocess == \'scale_width_and_crop\':\n        new_w = opt.load_size\n        new_h = opt.load_size * h // w\n\n    x = random.randint(0, np.maximum(0, new_w - opt.crop_size))\n    y = random.randint(0, np.maximum(0, new_h - opt.crop_size))\n\n    flip = random.random() > 0.5\n\n    return {\'crop_pos\': (x, y), \'flip\': flip}\n\n\ndef get_transform(opt, params=None, grayscale=False, method=Image.BICUBIC, convert=True):\n    transform_list = []\n    if grayscale:\n        transform_list.append(transforms.Grayscale(1))\n    if \'resize\' in opt.preprocess:\n        osize = [opt.load_size, opt.load_size]\n        transform_list.append(transforms.Resize(osize, method))\n    elif \'scale_width\' in opt.preprocess:\n        transform_list.append(transforms.Lambda(lambda img: __scale_width(img, opt.load_size, method)))\n\n    if \'crop\' in opt.preprocess:\n        if params is None:\n            transform_list.append(transforms.RandomCrop(opt.crop_size))\n        else:\n            transform_list.append(transforms.Lambda(lambda img: __crop(img, params[\'crop_pos\'], opt.crop_size)))\n\n    if opt.preprocess == \'none\':\n        transform_list.append(transforms.Lambda(lambda img: __make_power_2(img, base=4, method=method)))\n\n    if not opt.no_flip:\n        if params is None:\n            transform_list.append(transforms.RandomHorizontalFlip())\n        elif params[\'flip\']:\n            transform_list.append(transforms.Lambda(lambda img: __flip(img, params[\'flip\'])))\n\n    if convert:\n        transform_list += [transforms.ToTensor()]\n        if grayscale:\n            transform_list += [transforms.Normalize((0.5,), (0.5,))]\n        else:\n            transform_list += [transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]\n    return transforms.Compose(transform_list)\n\n\ndef __make_power_2(img, base, method=Image.BICUBIC):\n    ow, oh = img.size\n    h = int(round(oh / base) * base)\n    w = int(round(ow / base) * base)\n    if (h == oh) and (w == ow):\n        return img\n\n    __print_size_warning(ow, oh, w, h)\n    return img.resize((w, h), method)\n\n\ndef __scale_width(img, target_width, method=Image.BICUBIC):\n    ow, oh = img.size\n    if (ow == target_width):\n        return img\n    w = target_width\n    h = int(target_width * oh / ow)\n    return img.resize((w, h), method)\n\n\ndef __crop(img, pos, size):\n    ow, oh = img.size\n    x1, y1 = pos\n    tw = th = size\n    if (ow > tw or oh > th):\n        return img.crop((x1, y1, x1 + tw, y1 + th))\n    return img\n\n\ndef __flip(img, flip):\n    if flip:\n        return img.transpose(Image.FLIP_LEFT_RIGHT)\n    return img\n\n\ndef __print_size_warning(ow, oh, w, h):\n    """"""Print warning information about image size(only print once)""""""\n    if not hasattr(__print_size_warning, \'has_printed\'):\n        print(""The image size needs to be a multiple of 4. ""\n              ""The loaded image size was (%d, %d), so it was adjusted to ""\n              ""(%d, %d). This adjustment will be done to all images ""\n              ""whose sizes are not multiples of 4"" % (ow, oh, w, h))\n        __print_size_warning.has_printed = True\n'"
data/image_folder.py,1,"b'""""""A modified image folder class\n\nWe modify the official PyTorch image folder (https://github.com/pytorch/vision/blob/master/torchvision/datasets/folder.py)\nso that this class can load images from both current directory and its subdirectories.\n""""""\n\nimport torch.utils.data as data\n\nfrom PIL import Image\nimport os\nimport os.path\n\nIMG_EXTENSIONS = [\n    \'.jpg\', \'.JPG\', \'.jpeg\', \'.JPEG\',\n    \'.png\', \'.PNG\', \'.ppm\', \'.PPM\', \'.bmp\', \'.BMP\',\n]\n\n\ndef is_image_file(filename):\n    return any(filename.endswith(extension) for extension in IMG_EXTENSIONS)\n\n\ndef make_dataset(dir, max_dataset_size=float(""inf"")):\n    images = []\n    assert os.path.isdir(dir), \'%s is not a valid directory\' % dir\n\n    for root, _, fnames in sorted(os.walk(dir)):\n        for fname in fnames:\n            if is_image_file(fname):\n                path = os.path.join(root, fname)\n                images.append(path)\n    return images[:min(max_dataset_size, len(images))]\n\n\ndef default_loader(path):\n    return Image.open(path).convert(\'RGB\')\n\n\nclass ImageFolder(data.Dataset):\n\n    def __init__(self, root, transform=None, return_paths=False,\n                 loader=default_loader):\n        imgs = make_dataset(root)\n        if len(imgs) == 0:\n            raise(RuntimeError(""Found 0 images in: "" + root + ""\\n""\n                               ""Supported image extensions are: "" +\n                               "","".join(IMG_EXTENSIONS)))\n\n        self.root = root\n        self.imgs = imgs\n        self.transform = transform\n        self.return_paths = return_paths\n        self.loader = loader\n\n    def __getitem__(self, index):\n        path = self.imgs[index]\n        img = self.loader(path)\n        if self.transform is not None:\n            img = self.transform(img)\n        if self.return_paths:\n            return img, path\n        else:\n            return img\n\n    def __len__(self):\n        return len(self.imgs)\n'"
data/single_dataset.py,0,"b'from data.base_dataset import BaseDataset, get_transform\nfrom data.image_folder import make_dataset\nfrom PIL import Image\n\n\nclass SingleDataset(BaseDataset):\n    """"""This dataset class can load a set of images specified by the path --dataroot /path/to/data.\n\n    It can be used for generating CycleGAN results only for one side with the model option \'-model test\'.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseDataset.__init__(self, opt)\n        self.A_paths = sorted(make_dataset(opt.dataroot, opt.max_dataset_size))\n        input_nc = self.opt.output_nc if self.opt.direction == \'BtoA\' else self.opt.input_nc\n        self.transform = get_transform(opt, grayscale=(input_nc == 1))\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns a dictionary that contains A and A_paths\n            A(tensor) - - an image in one domain\n            A_paths(str) - - the path of the image\n        """"""\n        A_path = self.A_paths[index]\n        A_img = Image.open(A_path).convert(\'RGB\')\n        A = self.transform(A_img)\n        return {\'A\': A, \'A_paths\': A_path}\n\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return len(self.A_paths)\n'"
data/template_dataset.py,0,"b'""""""Dataset class template\n\nThis module provides a template for users to implement custom datasets.\nYou can specify \'--dataset_mode template\' to use this dataset.\nThe class name should be consistent with both the filename and its dataset_mode option.\nThe filename should be <dataset_mode>_dataset.py\nThe class name should be <Dataset_mode>Dataset.py\nYou need to implement the following functions:\n    -- <modify_commandline_options>:\xe3\x80\x80Add dataset-specific options and rewrite default values for existing options.\n    -- <__init__>: Initialize this dataset class.\n    -- <__getitem__>: Return a data point and its metadata information.\n    -- <__len__>: Return the number of images.\n""""""\nfrom data.base_dataset import BaseDataset, get_transform\n# from data.image_folder import make_dataset\n# from PIL import Image\n\n\nclass TemplateDataset(BaseDataset):\n    """"""A template dataset class for you to implement custom datasets.""""""\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        parser.add_argument(\'--new_dataset_option\', type=float, default=1.0, help=\'new dataset option\')\n        parser.set_defaults(max_dataset_size=10, new_dataset_option=2.0)  # specify dataset-specific default values\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n\n        A few things can be done here.\n        - save the options (have been done in BaseDataset)\n        - get image paths and meta information of the dataset.\n        - define the image transformation.\n        """"""\n        # save the option and dataset root\n        BaseDataset.__init__(self, opt)\n        # get the image paths of your dataset;\n        self.image_paths = []  # You can call sorted(make_dataset(self.root, opt.max_dataset_size)) to get all the image paths under the directory self.root\n        # define the default transform function. You can use <base_dataset.get_transform>; You can also define your custom transform function\n        self.transform = get_transform(opt)\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index -- a random integer for data indexing\n\n        Returns:\n            a dictionary of data with their names. It usually contains the data itself and its metadata information.\n\n        Step 1: get a random image path: e.g., path = self.image_paths[index]\n        Step 2: load your data from the disk: e.g., image = Image.open(path).convert(\'RGB\').\n        Step 3: convert your data to a PyTorch tensor. You can use helpder functions such as self.transform. e.g., data = self.transform(image)\n        Step 4: return a data point as a dictionary.\n        """"""\n        path = \'temp\'    # needs to be a string\n        data_A = None    # needs to be a tensor\n        data_B = None    # needs to be a tensor\n        return {\'data_A\': data_A, \'data_B\': data_B, \'path\': path}\n\n    def __len__(self):\n        """"""Return the total number of images.""""""\n        return len(self.image_paths)\n'"
models/__init__.py,0,"b'""""""This package contains modules related to objective functions, optimizations, and network architectures.\nTo add a custom model class called \'dummy\', you need to add a file called \'dummy_model.py\' and define a subclass DummyModel inherited from BaseModel.\nYou need to implement the following five functions:\n    -- <__init__>:                      initialize the class; first call BaseModel.__init__(self, opt).\n    -- <set_input>:                     unpack data from dataset and apply preprocessing.\n    -- <forward>:                       produce intermediate results.\n    -- <optimize_parameters>:           calculate loss, gradients, and update network weights.\n    -- <modify_commandline_options>:    (optionally) add model-specific options and set default options.\nIn the function <__init__>, you need to define four lists:\n    -- self.loss_names (str list):          specify the training losses that you want to plot and save.\n    -- self.model_names (str list):         specify the images that you want to display and save.\n    -- self.visual_names (str list):        define networks used in our training.\n    -- self.optimizers (optimizer list):    define and initialize optimizers. You can define one optimizer for each network. If two networks are updated at the same time, you can use itertools.chain to group them. See cycle_gan_model.py for an example.\nNow you can use the model class by specifying flag \'--model dummy\'.\nSee our template model class \'template_model.py\' for an example.\n""""""\n\nimport importlib\nfrom models.base_model import BaseModel\n\n\ndef find_model_using_name(model_name):\n    """"""Import the module ""models/[model_name]_model.py"".\n    In the file, the class called DatasetNameModel() will\n    be instantiated. It has to be a subclass of BaseModel,\n    and it is case-insensitive.\n    """"""\n    model_filename = ""models."" + model_name + ""_model""\n    modellib = importlib.import_module(model_filename)\n    model = None\n    target_model_name = model_name.replace(\'_\', \'\') + \'model\'\n    for name, cls in modellib.__dict__.items():\n        if name.lower() == target_model_name.lower() \\\n           and issubclass(cls, BaseModel):\n            model = cls\n\n    if model is None:\n        print(""In %s.py, there should be a subclass of BaseModel with class name that matches %s in lowercase."" % (model_filename, target_model_name))\n        exit(0)\n\n    return model\n\n\ndef get_option_setter(model_name):\n    """"""Return the static method <modify_commandline_options> of the model class.""""""\n    model_class = find_model_using_name(model_name)\n    return model_class.modify_commandline_options\n\n\ndef create_model(opt):\n    """"""Create a model given the option.\n    This function warps the class CustomDatasetDataLoader.\n    This is the main interface between this package and \'train.py\'/\'test.py\'\n    Example:\n        >>> from models import create_model\n        >>> model = create_model(opt)\n    """"""\n    model = find_model_using_name(opt.model)\n    instance = model(opt)\n    print(""model [%s] was created"" % type(instance).__name__)\n    return instance\n'"
models/base_model.py,8,"b'import os\nimport torch\nfrom collections import OrderedDict\nfrom abc import ABC, abstractmethod\nfrom . import networks\n\n\nclass BaseModel(ABC):\n    """"""This class is an abstract base class (ABC) for models.\n    To create a subclass, you need to implement the following five functions:\n        -- <__init__>:                      initialize the class; first call BaseModel.__init__(self, opt).\n        -- <set_input>:                     unpack data from dataset and apply preprocessing.\n        -- <forward>:                       produce intermediate results.\n        -- <optimize_parameters>:           calculate losses, gradients, and update network weights.\n        -- <modify_commandline_options>:    (optionally) add model-specific options and set default options.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize the BaseModel class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n\n        When creating your custom class, you need to implement your own initialization.\n        In this fucntion, you should first call  `BaseModel.__init__(self, opt)`\n        Then, you need to define four lists:\n            -- self.loss_names (str list):          specify the training losses that you want to plot and save.\n            -- self.model_names (str list):         specify the images that you want to display and save.\n            -- self.visual_names (str list):        define networks used in our training.\n            -- self.optimizers (optimizer list):    define and initialize optimizers. You can define one optimizer for each network. If two networks are updated at the same time, you can use itertools.chain to group them. See cycle_gan_model.py for an example.\n        """"""\n        self.opt = opt\n        self.gpu_ids = opt.gpu_ids\n        self.isTrain = opt.isTrain\n        self.device = torch.device(\'cuda:{}\'.format(self.gpu_ids[0])) if self.gpu_ids else torch.device(\'cpu\')  # get device name: CPU or GPU\n        self.save_dir = os.path.join(opt.checkpoints_dir, opt.name)  # save all the checkpoints to save_dir\n        if opt.preprocess != \'scale_width\':  # with [scale_width], input images might have different sizes, which hurts the performance of cudnn.benchmark.\n            torch.backends.cudnn.benchmark = True\n        self.loss_names = []\n        self.model_names = []\n        self.visual_names = []\n        self.optimizers = []\n        self.image_paths = []\n\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new model-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        return parser\n\n    @abstractmethod\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input (dict): includes the data itself and its metadata information.\n        """"""\n        pass\n\n    @abstractmethod\n    def forward(self):\n        """"""Run forward pass; called by both functions <optimize_parameters> and <test>.""""""\n        pass\n\n    def is_train(self):\n        """"""check if the current batch is good for training.""""""\n        return True\n\n    @abstractmethod\n    def optimize_parameters(self):\n        """"""Calculate losses, gradients, and update network weights; called in every training iteration""""""\n        pass\n\n    def setup(self, opt):\n        """"""Load and print networks; create schedulers\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        if self.isTrain:\n            self.schedulers = [networks.get_scheduler(optimizer, opt) for optimizer in self.optimizers]\n        if not self.isTrain or opt.continue_train:\n            self.load_networks(opt.epoch)\n        self.print_networks(opt.verbose)\n\n    def eval(self):\n        """"""Make models eval mode during test time""""""\n        for name in self.model_names:\n            if isinstance(name, str):\n                net = getattr(self, \'net\' + name)\n                net.eval()\n\n    def test(self):\n        """"""Forward function used in test time.\n\n        This function wraps <forward> function in no_grad() so we don\'t save intermediate steps for backprop\n        It also calls <compute_visuals> to produce additional visualization results\n        """"""\n        with torch.no_grad():\n            self.forward()\n            self.compute_visuals()\n\n    def compute_visuals(self):\n        """"""Calculate additional output images for visdom and HTML visualization""""""\n        pass\n\n    def get_image_paths(self):\n        """""" Return image paths that are used to load current data""""""\n        return self.image_paths\n\n    def update_learning_rate(self):\n        """"""Update learning rates for all the networks; called at the end of every epoch""""""\n        for scheduler in self.schedulers:\n            scheduler.step()\n        lr = self.optimizers[0].param_groups[0][\'lr\']\n        print(\'learning rate = %.7f\' % lr)\n\n    def get_current_visuals(self):\n        """"""Return visualization images. train.py will display these images with visdom, and save the images to a HTML""""""\n        visual_ret = OrderedDict()\n        for name in self.visual_names:\n            if isinstance(name, str):\n                visual_ret[name] = getattr(self, name)\n        return visual_ret\n\n    def get_current_losses(self):\n        """"""Return traning losses / errors. train.py will print out these errors on console, and save them to a file""""""\n        errors_ret = OrderedDict()\n        for name in self.loss_names:\n            if isinstance(name, str):\n                errors_ret[name] = float(getattr(self, \'loss_\' + name))  # float(...) works for both scalar tensor and float number\n        return errors_ret\n\n    def save_networks(self, epoch):\n        """"""Save all the networks to the disk.\n\n        Parameters:\n            epoch (int) -- current epoch; used in the file name \'%s_net_%s.pth\' % (epoch, name)\n        """"""\n        for name in self.model_names:\n            if isinstance(name, str):\n                save_filename = \'%s_net_%s.pth\' % (epoch, name)\n                save_path = os.path.join(self.save_dir, save_filename)\n                net = getattr(self, \'net\' + name)\n\n                if len(self.gpu_ids) > 0 and torch.cuda.is_available():\n                    torch.save(net.module.cpu().state_dict(), save_path)\n                    net.cuda(self.gpu_ids[0])\n                else:\n                    torch.save(net.cpu().state_dict(), save_path)\n\n    def __patch_instance_norm_state_dict(self, state_dict, module, keys, i=0):\n        """"""Fix InstanceNorm checkpoints incompatibility (prior to 0.4)""""""\n        key = keys[i]\n        if i + 1 == len(keys):  # at the end, pointing to a parameter/buffer\n            if module.__class__.__name__.startswith(\'InstanceNorm\') and \\\n                    (key == \'running_mean\' or key == \'running_var\'):\n                if getattr(module, key) is None:\n                    state_dict.pop(\'.\'.join(keys))\n            if module.__class__.__name__.startswith(\'InstanceNorm\') and \\\n               (key == \'num_batches_tracked\'):\n                state_dict.pop(\'.\'.join(keys))\n        else:\n            self.__patch_instance_norm_state_dict(state_dict, getattr(module, key), keys, i + 1)\n\n    def load_networks(self, epoch):\n        """"""Load all the networks from the disk.\n\n        Parameters:\n            epoch (int) -- current epoch; used in the file name \'%s_net_%s.pth\' % (epoch, name)\n        """"""\n        for name in self.model_names:\n            if isinstance(name, str):\n                load_filename = \'%s_net_%s.pth\' % (epoch, name)\n                load_path = os.path.join(self.save_dir, load_filename)\n                net = getattr(self, \'net\' + name)\n                if isinstance(net, torch.nn.DataParallel):\n                    net = net.module\n                print(\'loading the model from %s\' % load_path)\n                # if you are using PyTorch newer than 0.4 (e.g., built from\n                # GitHub source), you can remove str() on self.device\n                state_dict = torch.load(load_path, map_location=str(self.device))\n                if hasattr(state_dict, \'_metadata\'):\n                    del state_dict._metadata\n\n                # patch InstanceNorm checkpoints prior to 0.4\n                for key in list(state_dict.keys()):  # need to copy keys here because we mutate in loop\n                    self.__patch_instance_norm_state_dict(state_dict, net, key.split(\'.\'))\n                net.load_state_dict(state_dict)\n\n    def print_networks(self, verbose):\n        """"""Print the total number of parameters in the network and (if verbose) network architecture\n\n        Parameters:\n            verbose (bool) -- if verbose: print the network architecture\n        """"""\n        print(\'---------- Networks initialized -------------\')\n        for name in self.model_names:\n            if isinstance(name, str):\n                net = getattr(self, \'net\' + name)\n                num_params = 0\n                for param in net.parameters():\n                    num_params += param.numel()\n                if verbose:\n                    print(net)\n                print(\'[Network %s] Total number of parameters : %.3f M\' % (name, num_params / 1e6))\n        print(\'-----------------------------------------------\')\n\n    def set_requires_grad(self, nets, requires_grad=False):\n        """"""Set requires_grad=False for all the networks to avoid unnecessary computations\n        Parameters:\n            nets (network list)   -- a list of networks\n            requires_grad (bool)  -- whether the networks require gradients or not\n        """"""\n        if not isinstance(nets, list):\n            nets = [nets]\n        for net in nets:\n            if net is not None:\n                for param in net.parameters():\n                    param.requires_grad = requires_grad\n'"
models/bicycle_gan_model.py,15,"b'import torch\nfrom .base_model import BaseModel\nfrom . import networks\n\n\nclass BiCycleGANModel(BaseModel):\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        return parser\n\n    def __init__(self, opt):\n        if opt.isTrain:\n            assert opt.batch_size % 2 == 0  # load two images at one time.\n\n        BaseModel.__init__(self, opt)\n        # specify the training losses you want to print out. The program will call base_model.get_current_losses\n        self.loss_names = [\'G_GAN\', \'D\', \'G_GAN2\', \'D2\', \'G_L1\', \'z_L1\', \'kl\']\n        # specify the images you want to save/display. The program will call base_model.get_current_visuals\n        self.visual_names = [\'real_A_encoded\', \'real_B_encoded\', \'fake_B_random\', \'fake_B_encoded\']\n        # specify the models you want to save to the disk. The program will call base_model.save_networks and base_model.load_networks\n        use_D = opt.isTrain and opt.lambda_GAN > 0.0\n        use_D2 = opt.isTrain and opt.lambda_GAN2 > 0.0 and not opt.use_same_D\n        use_E = opt.isTrain or not opt.no_encode\n        use_vae = True\n        self.model_names = [\'G\']\n        self.netG = networks.define_G(opt.input_nc, opt.output_nc, opt.nz, opt.ngf, netG=opt.netG,\n                                      norm=opt.norm, nl=opt.nl, use_dropout=opt.use_dropout, init_type=opt.init_type, init_gain=opt.init_gain,\n                                      gpu_ids=self.gpu_ids, where_add=opt.where_add, upsample=opt.upsample)\n        D_output_nc = opt.input_nc + opt.output_nc if opt.conditional_D else opt.output_nc\n        if use_D:\n            self.model_names += [\'D\']\n            self.netD = networks.define_D(D_output_nc, opt.ndf, netD=opt.netD, norm=opt.norm, nl=opt.nl,\n                                          init_type=opt.init_type, init_gain=opt.init_gain, num_Ds=opt.num_Ds, gpu_ids=self.gpu_ids)\n        if use_D2:\n            self.model_names += [\'D2\']\n            self.netD2 = networks.define_D(D_output_nc, opt.ndf, netD=opt.netD2, norm=opt.norm, nl=opt.nl,\n                                           init_type=opt.init_type, init_gain=opt.init_gain, num_Ds=opt.num_Ds, gpu_ids=self.gpu_ids)\n        else:\n            self.netD2 = None\n        if use_E:\n            self.model_names += [\'E\']\n            self.netE = networks.define_E(opt.output_nc, opt.nz, opt.nef, netE=opt.netE, norm=opt.norm, nl=opt.nl,\n                                          init_type=opt.init_type, init_gain=opt.init_gain, gpu_ids=self.gpu_ids, vaeLike=use_vae)\n\n        if opt.isTrain:\n            self.criterionGAN = networks.GANLoss(gan_mode=opt.gan_mode).to(self.device)\n            self.criterionL1 = torch.nn.L1Loss()\n            self.criterionZ = torch.nn.L1Loss()\n            # initialize optimizers\n            self.optimizers = []\n            self.optimizer_G = torch.optim.Adam(self.netG.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizers.append(self.optimizer_G)\n            if use_E:\n                self.optimizer_E = torch.optim.Adam(self.netE.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n                self.optimizers.append(self.optimizer_E)\n\n            if use_D:\n                self.optimizer_D = torch.optim.Adam(self.netD.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n                self.optimizers.append(self.optimizer_D)\n            if use_D2:\n                self.optimizer_D2 = torch.optim.Adam(self.netD2.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n                self.optimizers.append(self.optimizer_D2)\n\n    def is_train(self):\n        """"""check if the current batch is good for training.""""""\n        return self.opt.isTrain and self.real_A.size(0) == self.opt.batch_size\n\n    def set_input(self, input):\n        AtoB = self.opt.direction == \'AtoB\'\n        self.real_A = input[\'A\' if AtoB else \'B\'].to(self.device)\n        self.real_B = input[\'B\' if AtoB else \'A\'].to(self.device)\n        self.image_paths = input[\'A_paths\' if AtoB else \'B_paths\']\n\n    def get_z_random(self, batch_size, nz, random_type=\'gauss\'):\n        if random_type == \'uni\':\n            z = torch.rand(batch_size, nz) * 2.0 - 1.0\n        elif random_type == \'gauss\':\n            z = torch.randn(batch_size, nz)\n        return z.to(self.device)\n\n    def encode(self, input_image):\n        mu, logvar = self.netE.forward(input_image)\n        std = logvar.mul(0.5).exp_()\n        eps = self.get_z_random(std.size(0), std.size(1))\n        z = eps.mul(std).add_(mu)\n        return z, mu, logvar\n\n    def test(self, z0=None, encode=False):\n        with torch.no_grad():\n            if encode:  # use encoded z\n                z0, _ = self.netE(self.real_B)\n            if z0 is None:\n                z0 = self.get_z_random(self.real_A.size(0), self.opt.nz)\n            self.fake_B = self.netG(self.real_A, z0)\n            return self.real_A, self.fake_B, self.real_B\n\n    def forward(self):\n        # get real images\n        half_size = self.opt.batch_size // 2\n        # A1, B1 for encoded; A2, B2 for random\n        self.real_A_encoded = self.real_A[0:half_size]\n        self.real_B_encoded = self.real_B[0:half_size]\n        self.real_A_random = self.real_A[half_size:]\n        self.real_B_random = self.real_B[half_size:]\n        # get encoded z\n        self.z_encoded, self.mu, self.logvar = self.encode(self.real_B_encoded)\n        # get random z\n        self.z_random = self.get_z_random(self.real_A_encoded.size(0), self.opt.nz)\n        # generate fake_B_encoded\n        self.fake_B_encoded = self.netG(self.real_A_encoded, self.z_encoded)\n        # generate fake_B_random\n        self.fake_B_random = self.netG(self.real_A_encoded, self.z_random)\n        if self.opt.conditional_D:   # tedious conditoinal data\n            self.fake_data_encoded = torch.cat([self.real_A_encoded, self.fake_B_encoded], 1)\n            self.real_data_encoded = torch.cat([self.real_A_encoded, self.real_B_encoded], 1)\n            self.fake_data_random = torch.cat([self.real_A_encoded, self.fake_B_random], 1)\n            self.real_data_random = torch.cat([self.real_A_random, self.real_B_random], 1)\n        else:\n            self.fake_data_encoded = self.fake_B_encoded\n            self.fake_data_random = self.fake_B_random\n            self.real_data_encoded = self.real_B_encoded\n            self.real_data_random = self.real_B_random\n\n        # compute z_predict\n        if self.opt.lambda_z > 0.0:\n            self.mu2, logvar2 = self.netE(self.fake_B_random)  # mu2 is a point estimate\n\n    def backward_D(self, netD, real, fake):\n        # Fake, stop backprop to the generator by detaching fake_B\n        pred_fake = netD(fake.detach())\n        # real\n        pred_real = netD(real)\n        loss_D_fake, _ = self.criterionGAN(pred_fake, False)\n        loss_D_real, _ = self.criterionGAN(pred_real, True)\n        # Combined loss\n        loss_D = loss_D_fake + loss_D_real\n        loss_D.backward()\n        return loss_D, [loss_D_fake, loss_D_real]\n\n    def backward_G_GAN(self, fake, netD=None, ll=0.0):\n        if ll > 0.0:\n            pred_fake = netD(fake)\n            loss_G_GAN, _ = self.criterionGAN(pred_fake, True)\n        else:\n            loss_G_GAN = 0\n        return loss_G_GAN * ll\n\n    def backward_EG(self):\n        # 1, G(A) should fool D\n        self.loss_G_GAN = self.backward_G_GAN(self.fake_data_encoded, self.netD, self.opt.lambda_GAN)\n        if self.opt.use_same_D:\n            self.loss_G_GAN2 = self.backward_G_GAN(self.fake_data_random, self.netD, self.opt.lambda_GAN2)\n        else:\n            self.loss_G_GAN2 = self.backward_G_GAN(self.fake_data_random, self.netD2, self.opt.lambda_GAN2)\n        # 2. KL loss\n        if self.opt.lambda_kl > 0.0:\n            self.loss_kl = torch.sum(1 + self.logvar - self.mu.pow(2) - self.logvar.exp()) * (-0.5 * self.opt.lambda_kl)\n        else:\n            self.loss_kl = 0\n        # 3, reconstruction |fake_B-real_B|\n        if self.opt.lambda_L1 > 0.0:\n            self.loss_G_L1 = self.criterionL1(self.fake_B_encoded, self.real_B_encoded) * self.opt.lambda_L1\n        else:\n            self.loss_G_L1 = 0.0\n\n        self.loss_G = self.loss_G_GAN + self.loss_G_GAN2 + self.loss_G_L1 + self.loss_kl\n        self.loss_G.backward(retain_graph=True)\n\n    def update_D(self):\n        self.set_requires_grad([self.netD, self.netD2], True)\n        # update D1\n        if self.opt.lambda_GAN > 0.0:\n            self.optimizer_D.zero_grad()\n            self.loss_D, self.losses_D = self.backward_D(self.netD, self.real_data_encoded, self.fake_data_encoded)\n            if self.opt.use_same_D:\n                self.loss_D2, self.losses_D2 = self.backward_D(self.netD, self.real_data_random, self.fake_data_random)\n            self.optimizer_D.step()\n\n        if self.opt.lambda_GAN2 > 0.0 and not self.opt.use_same_D:\n            self.optimizer_D2.zero_grad()\n            self.loss_D2, self.losses_D2 = self.backward_D(self.netD2, self.real_data_random, self.fake_data_random)\n            self.optimizer_D2.step()\n\n    def backward_G_alone(self):\n        # 3, reconstruction |(E(G(A, z_random)))-z_random|\n        if self.opt.lambda_z > 0.0:\n            self.loss_z_L1 = torch.mean(torch.abs(self.mu2 - self.z_random)) * self.opt.lambda_z\n            self.loss_z_L1.backward()\n        else:\n            self.loss_z_L1 = 0.0\n\n    def update_G_and_E(self):\n        # update G and E\n        self.set_requires_grad([self.netD, self.netD2], False)\n        self.optimizer_E.zero_grad()\n        self.optimizer_G.zero_grad()\n        self.backward_EG()\n        self.optimizer_G.step()\n        self.optimizer_E.step()\n        # update G only\n        if self.opt.lambda_z > 0.0:\n            self.optimizer_G.zero_grad()\n            self.optimizer_E.zero_grad()\n            self.backward_G_alone()\n            self.optimizer_G.step()\n\n    def optimize_parameters(self):\n        self.forward()\n        self.update_G_and_E()\n        self.update_D()\n'"
models/networks.py,20,"b'import torch\nimport torch.nn as nn\nfrom torch.nn import init\nimport functools\nfrom torch.optim import lr_scheduler\n\n###############################################################################\n# Helper functions\n###############################################################################\n\n\ndef init_weights(net, init_type=\'normal\', init_gain=0.02):\n    """"""Initialize network weights.\n    Parameters:\n        net (network)   -- network to be initialized\n        init_type (str) -- the name of an initialization method: normal | xavier | kaiming | orthogonal\n        init_gain (float)    -- scaling factor for normal, xavier and orthogonal.\n    We use \'normal\' in the original pix2pix and CycleGAN paper. But xavier and kaiming might\n    work better for some applications. Feel free to try yourself.\n    """"""\n    def init_func(m):  # define the initialization function\n        classname = m.__class__.__name__\n        if hasattr(m, \'weight\') and (classname.find(\'Conv\') != -1 or classname.find(\'Linear\') != -1):\n            if init_type == \'normal\':\n                init.normal_(m.weight.data, 0.0, init_gain)\n            elif init_type == \'xavier\':\n                init.xavier_normal_(m.weight.data, gain=init_gain)\n            elif init_type == \'kaiming\':\n                init.kaiming_normal_(m.weight.data, a=0, mode=\'fan_in\')\n            elif init_type == \'orthogonal\':\n                init.orthogonal_(m.weight.data, gain=init_gain)\n            else:\n                raise NotImplementedError(\'initialization method [%s] is not implemented\' % init_type)\n            if hasattr(m, \'bias\') and m.bias is not None:\n                init.constant_(m.bias.data, 0.0)\n        elif classname.find(\'BatchNorm2d\') != -1:  # BatchNorm Layer\'s weight is not a matrix; only normal distribution applies.\n            init.normal_(m.weight.data, 1.0, init_gain)\n            init.constant_(m.bias.data, 0.0)\n\n    print(\'initialize network with %s\' % init_type)\n    net.apply(init_func)  # apply the initialization function <init_func>\n\n\ndef init_net(net, init_type=\'normal\', init_gain=0.02, gpu_ids=[]):\n    """"""Initialize a network: 1. register CPU/GPU device (with multi-GPU support); 2. initialize the network weights\n    Parameters:\n        net (network)      -- the network to be initialized\n        init_type (str)    -- the name of an initialization method: normal | xavier | kaiming | orthogonal\n        gain (float)       -- scaling factor for normal, xavier and orthogonal.\n        gpu_ids (int list) -- which GPUs the network runs on: e.g., 0,1,2\n    Return an initialized network.\n    """"""\n    if len(gpu_ids) > 0:\n        assert(torch.cuda.is_available())\n        net.to(gpu_ids[0])\n        net = torch.nn.DataParallel(net, gpu_ids)  # multi-GPUs\n    init_weights(net, init_type, init_gain=init_gain)\n    return net\n\n\ndef get_scheduler(optimizer, opt):\n    """"""Return a learning rate scheduler\n    Parameters:\n        optimizer          -- the optimizer of the network\n        opt (option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\xef\xbc\x8e\xe3\x80\x80\n                              opt.lr_policy is the name of learning rate policy: linear | step | plateau | cosine\n    For \'linear\', we keep the same learning rate for the first <opt.niter> epochs\n    and linearly decay the rate to zero over the next <opt.niter_decay> epochs.\n    For other schedulers (step, plateau, and cosine), we use the default PyTorch schedulers.\n    See https://pytorch.org/docs/stable/optim.html for more details.\n    """"""\n    if opt.lr_policy == \'linear\':\n        def lambda_rule(epoch):\n            lr_l = 1.0 - max(0, epoch + opt.epoch_count - opt.niter) / float(opt.niter_decay + 1)\n            return lr_l\n        scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda_rule)\n    elif opt.lr_policy == \'step\':\n        scheduler = lr_scheduler.StepLR(optimizer, step_size=opt.lr_decay_iters, gamma=0.1)\n    elif opt.lr_policy == \'plateau\':\n        scheduler = lr_scheduler.ReduceLROnPlateau(optimizer, mode=\'min\', factor=0.2, threshold=0.01, patience=5)\n    elif opt.lr_policy == \'cosine\':\n        scheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=opt.niter, eta_min=0)\n    else:\n        return NotImplementedError(\'learning rate policy [%s] is not implemented\', opt.lr_policy)\n    return scheduler\n\n\ndef get_norm_layer(norm_type=\'instance\'):\n    """"""Return a normalization layer\n    Parameters:\n        norm_type (str) -- the name of the normalization layer: batch | instance | none\n    For BatchNorm, we use learnable affine parameters and track running statistics (mean/stddev).\n    For InstanceNorm, we do not use learnable affine parameters. We do not track running statistics.\n    """"""\n    if norm_type == \'batch\':\n        norm_layer = functools.partial(nn.BatchNorm2d, affine=True, track_running_stats=True)\n    elif norm_type == \'instance\':\n        norm_layer = functools.partial(nn.InstanceNorm2d, affine=False, track_running_stats=False)\n    elif norm_type == \'none\':\n        norm_layer = None\n    else:\n        raise NotImplementedError(\'normalization layer [%s] is not found\' % norm_type)\n    return norm_layer\n\n\ndef get_non_linearity(layer_type=\'relu\'):\n    if layer_type == \'relu\':\n        nl_layer = functools.partial(nn.ReLU, inplace=True)\n    elif layer_type == \'lrelu\':\n        nl_layer = functools.partial(\n            nn.LeakyReLU, negative_slope=0.2, inplace=True)\n    elif layer_type == \'elu\':\n        nl_layer = functools.partial(nn.ELU, inplace=True)\n    else:\n        raise NotImplementedError(\n            \'nonlinearity activitation [%s] is not found\' % layer_type)\n    return nl_layer\n\n\ndef define_G(input_nc, output_nc, nz, ngf, netG=\'unet_128\', norm=\'batch\', nl=\'relu\',\n             use_dropout=False, init_type=\'xavier\', init_gain=0.02, gpu_ids=[], where_add=\'input\', upsample=\'bilinear\'):\n    net = None\n    norm_layer = get_norm_layer(norm_type=norm)\n    nl_layer = get_non_linearity(layer_type=nl)\n\n    if nz == 0:\n        where_add = \'input\'\n\n    if netG == \'unet_128\' and where_add == \'input\':\n        net = G_Unet_add_input(input_nc, output_nc, nz, 7, ngf, norm_layer=norm_layer, nl_layer=nl_layer,\n                               use_dropout=use_dropout, upsample=upsample)\n    elif netG == \'unet_256\' and where_add == \'input\':\n        net = G_Unet_add_input(input_nc, output_nc, nz, 8, ngf, norm_layer=norm_layer, nl_layer=nl_layer,\n                               use_dropout=use_dropout, upsample=upsample)\n    elif netG == \'unet_128\' and where_add == \'all\':\n        net = G_Unet_add_all(input_nc, output_nc, nz, 7, ngf, norm_layer=norm_layer, nl_layer=nl_layer,\n                             use_dropout=use_dropout, upsample=upsample)\n    elif netG == \'unet_256\' and where_add == \'all\':\n        net = G_Unet_add_all(input_nc, output_nc, nz, 8, ngf, norm_layer=norm_layer, nl_layer=nl_layer,\n                             use_dropout=use_dropout, upsample=upsample)\n    else:\n        raise NotImplementedError(\'Generator model name [%s] is not recognized\' % net)\n\n    return init_net(net, init_type, init_gain, gpu_ids)\n\n\ndef define_D(input_nc, ndf, netD, norm=\'batch\', nl=\'lrelu\', init_type=\'xavier\', init_gain=0.02, num_Ds=1, gpu_ids=[]):\n    net = None\n    norm_layer = get_norm_layer(norm_type=norm)\n    nl = \'lrelu\'  # use leaky relu for D\n    nl_layer = get_non_linearity(layer_type=nl)\n\n    if netD == \'basic_128\':\n        net = D_NLayers(input_nc, ndf, n_layers=2, norm_layer=norm_layer, nl_layer=nl_layer)\n    elif netD == \'basic_256\':\n        net = D_NLayers(input_nc, ndf, n_layers=3, norm_layer=norm_layer, nl_layer=nl_layer)\n    elif netD == \'basic_128_multi\':\n        net = D_NLayersMulti(input_nc=input_nc, ndf=ndf, n_layers=2, norm_layer=norm_layer, num_D=num_Ds)\n    elif netD == \'basic_256_multi\':\n        net = D_NLayersMulti(input_nc=input_nc, ndf=ndf, n_layers=3, norm_layer=norm_layer, num_D=num_Ds)\n    else:\n        raise NotImplementedError(\'Discriminator model name [%s] is not recognized\' % net)\n    return init_net(net, init_type, init_gain, gpu_ids)\n\n\ndef define_E(input_nc, output_nc, ndf, netE,\n             norm=\'batch\', nl=\'lrelu\',\n             init_type=\'xavier\', init_gain=0.02, gpu_ids=[], vaeLike=False):\n    net = None\n    norm_layer = get_norm_layer(norm_type=norm)\n    nl = \'lrelu\'  # use leaky relu for E\n    nl_layer = get_non_linearity(layer_type=nl)\n    if netE == \'resnet_128\':\n        net = E_ResNet(input_nc, output_nc, ndf, n_blocks=4, norm_layer=norm_layer,\n                       nl_layer=nl_layer, vaeLike=vaeLike)\n    elif netE == \'resnet_256\':\n        net = E_ResNet(input_nc, output_nc, ndf, n_blocks=5, norm_layer=norm_layer,\n                       nl_layer=nl_layer, vaeLike=vaeLike)\n    elif netE == \'conv_128\':\n        net = E_NLayers(input_nc, output_nc, ndf, n_layers=4, norm_layer=norm_layer,\n                        nl_layer=nl_layer, vaeLike=vaeLike)\n    elif netE == \'conv_256\':\n        net = E_NLayers(input_nc, output_nc, ndf, n_layers=5, norm_layer=norm_layer,\n                        nl_layer=nl_layer, vaeLike=vaeLike)\n    else:\n        raise NotImplementedError(\'Encoder model name [%s] is not recognized\' % net)\n\n    return init_net(net, init_type, init_gain, gpu_ids)\n\n\nclass D_NLayersMulti(nn.Module):\n    def __init__(self, input_nc, ndf=64, n_layers=3,\n                 norm_layer=nn.BatchNorm2d, num_D=1):\n        super(D_NLayersMulti, self).__init__()\n        # st()\n        self.num_D = num_D\n        if num_D == 1:\n            layers = self.get_layers(input_nc, ndf, n_layers, norm_layer)\n            self.model = nn.Sequential(*layers)\n        else:\n            layers = self.get_layers(input_nc, ndf, n_layers, norm_layer)\n            self.add_module(""model_0"", nn.Sequential(*layers))\n            self.down = nn.AvgPool2d(3, stride=2, padding=[\n                                     1, 1], count_include_pad=False)\n            for i in range(1, num_D):\n                ndf_i = int(round(ndf / (2**i)))\n                layers = self.get_layers(input_nc, ndf_i, n_layers, norm_layer)\n                self.add_module(""model_%d"" % i, nn.Sequential(*layers))\n\n    def get_layers(self, input_nc, ndf=64, n_layers=3, norm_layer=nn.BatchNorm2d):\n        kw = 4\n        padw = 1\n        sequence = [nn.Conv2d(input_nc, ndf, kernel_size=kw,\n                              stride=2, padding=padw), nn.LeakyReLU(0.2, True)]\n\n        nf_mult = 1\n        nf_mult_prev = 1\n        for n in range(1, n_layers):\n            nf_mult_prev = nf_mult\n            nf_mult = min(2**n, 8)\n            sequence += [\n                nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult,\n                          kernel_size=kw, stride=2, padding=padw),\n                norm_layer(ndf * nf_mult),\n                nn.LeakyReLU(0.2, True)\n            ]\n\n        nf_mult_prev = nf_mult\n        nf_mult = min(2**n_layers, 8)\n        sequence += [\n            nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult,\n                      kernel_size=kw, stride=1, padding=padw),\n            norm_layer(ndf * nf_mult),\n            nn.LeakyReLU(0.2, True)\n        ]\n\n        sequence += [nn.Conv2d(ndf * nf_mult, 1,\n                               kernel_size=kw, stride=1, padding=padw)]\n\n        return sequence\n\n    def forward(self, input):\n        if self.num_D == 1:\n            return self.model(input)\n        result = []\n        down = input\n        for i in range(self.num_D):\n            model = getattr(self, ""model_%d"" % i)\n            result.append(model(down))\n            if i != self.num_D - 1:\n                down = self.down(down)\n        return result\n\n\nclass D_NLayers(nn.Module):\n    """"""Defines a PatchGAN discriminator""""""\n\n    def __init__(self, input_nc, ndf=64, n_layers=3, norm_layer=nn.BatchNorm2d):\n        """"""Construct a PatchGAN discriminator\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            ndf (int)       -- the number of filters in the last conv layer\n            n_layers (int)  -- the number of conv layers in the discriminator\n            norm_layer      -- normalization layer\n        """"""\n        super(D_NLayers, self).__init__()\n        if type(norm_layer) == functools.partial:  # no need to use bias as BatchNorm2d has affine parameters\n            use_bias = norm_layer.func != nn.BatchNorm2d\n        else:\n            use_bias = norm_layer != nn.BatchNorm2d\n\n        kw = 4\n        padw = 1\n        sequence = [nn.Conv2d(input_nc, ndf, kernel_size=kw, stride=2, padding=padw), nn.LeakyReLU(0.2, True)]\n        nf_mult = 1\n        nf_mult_prev = 1\n        for n in range(1, n_layers):  # gradually increase the number of filters\n            nf_mult_prev = nf_mult\n            nf_mult = min(2 ** n, 8)\n            sequence += [\n                nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult, kernel_size=kw, stride=2, padding=padw, bias=use_bias),\n                norm_layer(ndf * nf_mult),\n                nn.LeakyReLU(0.2, True)\n            ]\n\n        nf_mult_prev = nf_mult\n        nf_mult = min(2 ** n_layers, 8)\n        sequence += [\n            nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult, kernel_size=kw, stride=1, padding=padw, bias=use_bias),\n            norm_layer(ndf * nf_mult),\n            nn.LeakyReLU(0.2, True)\n        ]\n\n        sequence += [nn.Conv2d(ndf * nf_mult, 1, kernel_size=kw, stride=1, padding=padw)]  # output 1 channel prediction map\n        self.model = nn.Sequential(*sequence)\n\n    def forward(self, input):\n        """"""Standard forward.""""""\n        return self.model(input)\n\n\n##############################################################################\n# Classes\n##############################################################################\nclass RecLoss(nn.Module):\n    def __init__(self, use_L2=True):\n        super(RecLoss, self).__init__()\n        self.use_L2 = use_L2\n\n    def __call__(self, input, target, batch_mean=True):\n        if self.use_L2:\n            diff = (input - target) ** 2\n        else:\n            diff = torch.abs(input - target)\n        if batch_mean:\n            return torch.mean(diff)\n        else:\n            return torch.mean(torch.mean(torch.mean(diff, dim=1), dim=2), dim=3)\n\n\n# Defines the GAN loss which uses either LSGAN or the regular GAN.\n# When LSGAN is used, it is basically same as MSELoss,\n# but it abstracts away the need to create the target label tensor\n# that has the same size as the input\nclass GANLoss(nn.Module):\n    """"""Define different GAN objectives.\n\n    The GANLoss class abstracts away the need to create the target label tensor\n    that has the same size as the input.\n    """"""\n\n    def __init__(self, gan_mode, target_real_label=1.0, target_fake_label=0.0):\n        """""" Initialize the GANLoss class.\n\n        Parameters:\n            gan_mode (str) - - the type of GAN objective. It currently supports vanilla, lsgan, and wgangp.\n            target_real_label (bool) - - label for a real image\n            target_fake_label (bool) - - label of a fake image\n\n        Note: Do not use sigmoid as the last layer of Discriminator.\n        LSGAN needs no sigmoid. vanilla GANs will handle it with BCEWithLogitsLoss.\n        """"""\n        super(GANLoss, self).__init__()\n        self.register_buffer(\'real_label\', torch.tensor(target_real_label))\n        self.register_buffer(\'fake_label\', torch.tensor(target_fake_label))\n        self.gan_mode = gan_mode\n        if gan_mode == \'lsgan\':\n            self.loss = nn.MSELoss()\n        elif gan_mode == \'vanilla\':\n            self.loss = nn.BCEWithLogitsLoss()\n        elif gan_mode in [\'wgangp\']:\n            self.loss = None\n        else:\n            raise NotImplementedError(\'gan mode %s not implemented\' % gan_mode)\n\n    def get_target_tensor(self, prediction, target_is_real):\n        """"""Create label tensors with the same size as the input.\n\n        Parameters:\n            prediction (tensor) - - tpyically the prediction from a discriminator\n            target_is_real (bool) - - if the ground truth label is for real images or fake images\n\n        Returns:\n            A label tensor filled with ground truth label, and with the size of the input\n        """"""\n\n        if target_is_real:\n            target_tensor = self.real_label\n        else:\n            target_tensor = self.fake_label\n        return target_tensor.expand_as(prediction)\n\n    def __call__(self, predictions, target_is_real):\n        """"""Calculate loss given Discriminator\'s output and grount truth labels.\n\n        Parameters:\n            prediction (tensor list) - - tpyically the prediction output from a discriminator; supports multi Ds.\n            target_is_real (bool) - - if the ground truth label is for real images or fake images\n\n        Returns:\n            the calculated loss.\n        """"""\n        all_losses = []\n        for prediction in predictions:\n            if self.gan_mode in [\'lsgan\', \'vanilla\']:\n                target_tensor = self.get_target_tensor(prediction, target_is_real)\n                loss = self.loss(prediction, target_tensor)\n            elif self.gan_mode == \'wgangp\':\n                if target_is_real:\n                    loss = -prediction.mean()\n                else:\n                    loss = prediction.mean()\n            all_losses.append(loss)\n        total_loss = sum(all_losses)\n        return total_loss, all_losses\n\n\ndef cal_gradient_penalty(netD, real_data, fake_data, device, type=\'mixed\', constant=1.0, lambda_gp=10.0):\n    """"""Calculate the gradient penalty loss, used in WGAN-GP paper https://arxiv.org/abs/1704.00028\n    Arguments:\n        netD (network)              -- discriminator network\n        real_data (tensor array)    -- real images\n        fake_data (tensor array)    -- generated images from the generator\n        device (str)                -- GPU / CPU: from torch.device(\'cuda:{}\'.format(self.gpu_ids[0])) if self.gpu_ids else torch.device(\'cpu\')\n        type (str)                  -- if we mix real and fake data or not [real | fake | mixed].\n        constant (float)            -- the constant used in formula ( | |gradient||_2 - constant)^2\n        lambda_gp (float)           -- weight for this loss\n    Returns the gradient penalty loss\n    """"""\n    if lambda_gp > 0.0:\n        if type == \'real\':   # either use real images, fake images, or a linear interpolation of two.\n            interpolatesv = real_data\n        elif type == \'fake\':\n            interpolatesv = fake_data\n        elif type == \'mixed\':\n            alpha = torch.rand(real_data.shape[0], 1)\n            alpha = alpha.expand(real_data.shape[0], real_data.nelement() // real_data.shape[0]).contiguous().view(*real_data.shape)\n            alpha = alpha.to(device)\n            interpolatesv = alpha * real_data + ((1 - alpha) * fake_data)\n        else:\n            raise NotImplementedError(\'{} not implemented\'.format(type))\n        interpolatesv.requires_grad_(True)\n        disc_interpolates = netD(interpolatesv)\n        gradients = torch.autograd.grad(outputs=disc_interpolates, inputs=interpolatesv,\n                                        grad_outputs=torch.ones(disc_interpolates.size()).to(device),\n                                        create_graph=True, retain_graph=True, only_inputs=True)\n        gradients = gradients[0].view(real_data.size(0), -1)  # flat the data\n        gradient_penalty = (((gradients + 1e-16).norm(2, dim=1) - constant) ** 2).mean() * lambda_gp        # added eps\n        return gradient_penalty, gradients\n    else:\n        return 0.0, None\n\n# Defines the Unet generator.\n# |num_downs|: number of downsamplings in UNet. For example,\n# if |num_downs| == 7, image of size 128x128 will become of size 1x1\n# at the bottleneck\n\n\nclass G_Unet_add_input(nn.Module):\n    def __init__(self, input_nc, output_nc, nz, num_downs, ngf=64,\n                 norm_layer=None, nl_layer=None, use_dropout=False,\n                 upsample=\'basic\'):\n        super(G_Unet_add_input, self).__init__()\n        self.nz = nz\n        max_nchn = 8\n        # construct unet structure\n        unet_block = UnetBlock(ngf * max_nchn, ngf * max_nchn, ngf * max_nchn,\n                               innermost=True, norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        for i in range(num_downs - 5):\n            unet_block = UnetBlock(ngf * max_nchn, ngf * max_nchn, ngf * max_nchn, unet_block,\n                                   norm_layer=norm_layer, nl_layer=nl_layer, use_dropout=use_dropout, upsample=upsample)\n        unet_block = UnetBlock(ngf * 4, ngf * 4, ngf * max_nchn, unet_block,\n                               norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock(ngf * 2, ngf * 2, ngf * 4, unet_block,\n                               norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock(ngf, ngf, ngf * 2, unet_block,\n                               norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock(input_nc + nz, output_nc, ngf, unet_block,\n                               outermost=True, norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n\n        self.model = unet_block\n\n    def forward(self, x, z=None):\n        if self.nz > 0:\n            z_img = z.view(z.size(0), z.size(1), 1, 1).expand(\n                z.size(0), z.size(1), x.size(2), x.size(3))\n            x_with_z = torch.cat([x, z_img], 1)\n        else:\n            x_with_z = x  # no z\n\n        return self.model(x_with_z)\n\n\ndef upsampleLayer(inplanes, outplanes, upsample=\'basic\', padding_type=\'zero\'):\n    # padding_type = \'zero\'\n    if upsample == \'basic\':\n        upconv = [nn.ConvTranspose2d(\n            inplanes, outplanes, kernel_size=4, stride=2, padding=1)]\n    elif upsample == \'bilinear\':\n        upconv = [nn.Upsample(scale_factor=2, mode=\'bilinear\'),\n                  nn.ReflectionPad2d(1),\n                  nn.Conv2d(inplanes, outplanes, kernel_size=3, stride=1, padding=0)]\n    else:\n        raise NotImplementedError(\n            \'upsample layer [%s] not implemented\' % upsample)\n    return upconv\n\n\n# Defines the submodule with skip connection.\n# X -------------------identity---------------------- X\n#   |-- downsampling -- |submodule| -- upsampling --|\nclass UnetBlock(nn.Module):\n    def __init__(self, input_nc, outer_nc, inner_nc,\n                 submodule=None, outermost=False, innermost=False,\n                 norm_layer=None, nl_layer=None, use_dropout=False, upsample=\'basic\', padding_type=\'zero\'):\n        super(UnetBlock, self).__init__()\n        self.outermost = outermost\n        p = 0\n        downconv = []\n        if padding_type == \'reflect\':\n            downconv += [nn.ReflectionPad2d(1)]\n        elif padding_type == \'replicate\':\n            downconv += [nn.ReplicationPad2d(1)]\n        elif padding_type == \'zero\':\n            p = 1\n        else:\n            raise NotImplementedError(\n                \'padding [%s] is not implemented\' % padding_type)\n        downconv += [nn.Conv2d(input_nc, inner_nc,\n                               kernel_size=4, stride=2, padding=p)]\n        # downsample is different from upsample\n        downrelu = nn.LeakyReLU(0.2, True)\n        downnorm = norm_layer(inner_nc) if norm_layer is not None else None\n        uprelu = nl_layer()\n        upnorm = norm_layer(outer_nc) if norm_layer is not None else None\n\n        if outermost:\n            upconv = upsampleLayer(\n                inner_nc * 2, outer_nc, upsample=upsample, padding_type=padding_type)\n            down = downconv\n            up = [uprelu] + upconv + [nn.Tanh()]\n            model = down + [submodule] + up\n        elif innermost:\n            upconv = upsampleLayer(\n                inner_nc, outer_nc, upsample=upsample, padding_type=padding_type)\n            down = [downrelu] + downconv\n            up = [uprelu] + upconv\n            if upnorm is not None:\n                up += [upnorm]\n            model = down + up\n        else:\n            upconv = upsampleLayer(\n                inner_nc * 2, outer_nc, upsample=upsample, padding_type=padding_type)\n            down = [downrelu] + downconv\n            if downnorm is not None:\n                down += [downnorm]\n            up = [uprelu] + upconv\n            if upnorm is not None:\n                up += [upnorm]\n\n            if use_dropout:\n                model = down + [submodule] + up + [nn.Dropout(0.5)]\n            else:\n                model = down + [submodule] + up\n\n        self.model = nn.Sequential(*model)\n\n    def forward(self, x):\n        if self.outermost:\n            return self.model(x)\n        else:\n            return torch.cat([self.model(x), x], 1)\n\n\ndef conv3x3(in_planes, out_planes):\n    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=1,\n                     padding=1, bias=True)\n\n\n# two usage cases, depend on kw and padw\ndef upsampleConv(inplanes, outplanes, kw, padw):\n    sequence = []\n    sequence += [nn.Upsample(scale_factor=2, mode=\'nearest\')]\n    sequence += [nn.Conv2d(inplanes, outplanes, kernel_size=kw,\n                           stride=1, padding=padw, bias=True)]\n    return nn.Sequential(*sequence)\n\n\ndef meanpoolConv(inplanes, outplanes):\n    sequence = []\n    sequence += [nn.AvgPool2d(kernel_size=2, stride=2)]\n    sequence += [nn.Conv2d(inplanes, outplanes,\n                           kernel_size=1, stride=1, padding=0, bias=True)]\n    return nn.Sequential(*sequence)\n\n\ndef convMeanpool(inplanes, outplanes):\n    sequence = []\n    sequence += [conv3x3(inplanes, outplanes)]\n    sequence += [nn.AvgPool2d(kernel_size=2, stride=2)]\n    return nn.Sequential(*sequence)\n\n\nclass BasicBlockUp(nn.Module):\n    def __init__(self, inplanes, outplanes, norm_layer=None, nl_layer=None):\n        super(BasicBlockUp, self).__init__()\n        layers = []\n        if norm_layer is not None:\n            layers += [norm_layer(inplanes)]\n        layers += [nl_layer()]\n        layers += [upsampleConv(inplanes, outplanes, kw=3, padw=1)]\n        if norm_layer is not None:\n            layers += [norm_layer(outplanes)]\n        layers += [conv3x3(outplanes, outplanes)]\n        self.conv = nn.Sequential(*layers)\n        self.shortcut = upsampleConv(inplanes, outplanes, kw=1, padw=0)\n\n    def forward(self, x):\n        out = self.conv(x) + self.shortcut(x)\n        return out\n\n\nclass BasicBlock(nn.Module):\n    def __init__(self, inplanes, outplanes, norm_layer=None, nl_layer=None):\n        super(BasicBlock, self).__init__()\n        layers = []\n        if norm_layer is not None:\n            layers += [norm_layer(inplanes)]\n        layers += [nl_layer()]\n        layers += [conv3x3(inplanes, inplanes)]\n        if norm_layer is not None:\n            layers += [norm_layer(inplanes)]\n        layers += [nl_layer()]\n        layers += [convMeanpool(inplanes, outplanes)]\n        self.conv = nn.Sequential(*layers)\n        self.shortcut = meanpoolConv(inplanes, outplanes)\n\n    def forward(self, x):\n        out = self.conv(x) + self.shortcut(x)\n        return out\n\n\nclass E_ResNet(nn.Module):\n    def __init__(self, input_nc=3, output_nc=1, ndf=64, n_blocks=4,\n                 norm_layer=None, nl_layer=None, vaeLike=False):\n        super(E_ResNet, self).__init__()\n        self.vaeLike = vaeLike\n        max_ndf = 4\n        conv_layers = [\n            nn.Conv2d(input_nc, ndf, kernel_size=4, stride=2, padding=1, bias=True)]\n        for n in range(1, n_blocks):\n            input_ndf = ndf * min(max_ndf, n)\n            output_ndf = ndf * min(max_ndf, n + 1)\n            conv_layers += [BasicBlock(input_ndf,\n                                       output_ndf, norm_layer, nl_layer)]\n        conv_layers += [nl_layer(), nn.AvgPool2d(8)]\n        if vaeLike:\n            self.fc = nn.Sequential(*[nn.Linear(output_ndf, output_nc)])\n            self.fcVar = nn.Sequential(*[nn.Linear(output_ndf, output_nc)])\n        else:\n            self.fc = nn.Sequential(*[nn.Linear(output_ndf, output_nc)])\n        self.conv = nn.Sequential(*conv_layers)\n\n    def forward(self, x):\n        x_conv = self.conv(x)\n        conv_flat = x_conv.view(x.size(0), -1)\n        output = self.fc(conv_flat)\n        if self.vaeLike:\n            outputVar = self.fcVar(conv_flat)\n            return output, outputVar\n        else:\n            return output\n        return output\n\n\n# Defines the Unet generator.\n# |num_downs|: number of downsamplings in UNet. For example,\n# if |num_downs| == 7, image of size 128x128 will become of size 1x1\n# at the bottleneck\nclass G_Unet_add_all(nn.Module):\n    def __init__(self, input_nc, output_nc, nz, num_downs, ngf=64,\n                 norm_layer=None, nl_layer=None, use_dropout=False, upsample=\'basic\'):\n        super(G_Unet_add_all, self).__init__()\n        self.nz = nz\n        # construct unet structure\n        unet_block = UnetBlock_with_z(ngf * 8, ngf * 8, ngf * 8, nz, None, innermost=True,\n                                      norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock_with_z(ngf * 8, ngf * 8, ngf * 8, nz, unet_block,\n                                      norm_layer=norm_layer, nl_layer=nl_layer, use_dropout=use_dropout, upsample=upsample)\n        for i in range(num_downs - 6):\n            unet_block = UnetBlock_with_z(ngf * 8, ngf * 8, ngf * 8, nz, unet_block,\n                                          norm_layer=norm_layer, nl_layer=nl_layer, use_dropout=use_dropout, upsample=upsample)\n        unet_block = UnetBlock_with_z(ngf * 4, ngf * 4, ngf * 8, nz, unet_block,\n                                      norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock_with_z(ngf * 2, ngf * 2, ngf * 4, nz, unet_block,\n                                      norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock_with_z(\n            ngf, ngf, ngf * 2, nz, unet_block, norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        unet_block = UnetBlock_with_z(input_nc, output_nc, ngf, nz, unet_block,\n                                      outermost=True, norm_layer=norm_layer, nl_layer=nl_layer, upsample=upsample)\n        self.model = unet_block\n\n    def forward(self, x, z):\n        return self.model(x, z)\n\n\nclass UnetBlock_with_z(nn.Module):\n    def __init__(self, input_nc, outer_nc, inner_nc, nz=0,\n                 submodule=None, outermost=False, innermost=False,\n                 norm_layer=None, nl_layer=None, use_dropout=False, upsample=\'basic\', padding_type=\'zero\'):\n        super(UnetBlock_with_z, self).__init__()\n        p = 0\n        downconv = []\n        if padding_type == \'reflect\':\n            downconv += [nn.ReflectionPad2d(1)]\n        elif padding_type == \'replicate\':\n            downconv += [nn.ReplicationPad2d(1)]\n        elif padding_type == \'zero\':\n            p = 1\n        else:\n            raise NotImplementedError(\n                \'padding [%s] is not implemented\' % padding_type)\n\n        self.outermost = outermost\n        self.innermost = innermost\n        self.nz = nz\n        input_nc = input_nc + nz\n        downconv += [nn.Conv2d(input_nc, inner_nc,\n                               kernel_size=4, stride=2, padding=p)]\n        # downsample is different from upsample\n        downrelu = nn.LeakyReLU(0.2, True)\n        uprelu = nl_layer()\n\n        if outermost:\n            upconv = upsampleLayer(\n                inner_nc * 2, outer_nc, upsample=upsample, padding_type=padding_type)\n            down = downconv\n            up = [uprelu] + upconv + [nn.Tanh()]\n        elif innermost:\n            upconv = upsampleLayer(\n                inner_nc, outer_nc, upsample=upsample, padding_type=padding_type)\n            down = [downrelu] + downconv\n            up = [uprelu] + upconv\n            if norm_layer is not None:\n                up += [norm_layer(outer_nc)]\n        else:\n            upconv = upsampleLayer(\n                inner_nc * 2, outer_nc, upsample=upsample, padding_type=padding_type)\n            down = [downrelu] + downconv\n            if norm_layer is not None:\n                down += [norm_layer(inner_nc)]\n            up = [uprelu] + upconv\n\n            if norm_layer is not None:\n                up += [norm_layer(outer_nc)]\n\n            if use_dropout:\n                up += [nn.Dropout(0.5)]\n        self.down = nn.Sequential(*down)\n        self.submodule = submodule\n        self.up = nn.Sequential(*up)\n\n    def forward(self, x, z):\n        # print(x.size())\n        if self.nz > 0:\n            z_img = z.view(z.size(0), z.size(1), 1, 1).expand(z.size(0), z.size(1), x.size(2), x.size(3))\n            x_and_z = torch.cat([x, z_img], 1)\n        else:\n            x_and_z = x\n\n        if self.outermost:\n            x1 = self.down(x_and_z)\n            x2 = self.submodule(x1, z)\n            return self.up(x2)\n        elif self.innermost:\n            x1 = self.up(self.down(x_and_z))\n            return torch.cat([x1, x], 1)\n        else:\n            x1 = self.down(x_and_z)\n            x2 = self.submodule(x1, z)\n            return torch.cat([self.up(x2), x], 1)\n\n\nclass E_NLayers(nn.Module):\n    def __init__(self, input_nc, output_nc=1, ndf=64, n_layers=3,\n                 norm_layer=None, nl_layer=None, vaeLike=False):\n        super(E_NLayers, self).__init__()\n        self.vaeLike = vaeLike\n\n        kw, padw = 4, 1\n        sequence = [nn.Conv2d(input_nc, ndf, kernel_size=kw,\n                              stride=2, padding=padw), nl_layer()]\n\n        nf_mult = 1\n        nf_mult_prev = 1\n        for n in range(1, n_layers):\n            nf_mult_prev = nf_mult\n            nf_mult = min(2**n, 4)\n            sequence += [\n                nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult,\n                          kernel_size=kw, stride=2, padding=padw)]\n            if norm_layer is not None:\n                sequence += [norm_layer(ndf * nf_mult)]\n            sequence += [nl_layer()]\n        sequence += [nn.AvgPool2d(8)]\n        self.conv = nn.Sequential(*sequence)\n        self.fc = nn.Sequential(*[nn.Linear(ndf * nf_mult, output_nc)])\n        if vaeLike:\n            self.fcVar = nn.Sequential(*[nn.Linear(ndf * nf_mult, output_nc)])\n\n    def forward(self, x):\n        x_conv = self.conv(x)\n        conv_flat = x_conv.view(x.size(0), -1)\n        output = self.fc(conv_flat)\n        if self.vaeLike:\n            outputVar = self.fcVar(conv_flat)\n            return output, outputVar\n        return output\n'"
models/pix2pix_model.py,6,"b'import torch\nfrom .base_model import BaseModel\nfrom . import networks\n\n\nclass Pix2PixModel(BaseModel):\n    """""" This class implements the pix2pix model, for learning a mapping from input images to output images given paired data.\n\n    The model training requires \'--dataset_mode aligned\' dataset.\n    By default, it uses a \'--netG unet256\' U-Net generator,\n    a \'--netD basic\' discriminator (PatchGAN),\n    and a \'--gan_mode\' vanilla GAN loss (the cross-entropy objective used in the orignal GAN paper).\n\n    pix2pix paper: https://arxiv.org/pdf/1611.07004.pdf\n    """"""\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n\n        For pix2pix, we do not use image buffer\n        The training objective is: GAN Loss + lambda_L1 * ||G(A)-B||_1\n        By default, we use vanilla GAN loss, UNet with batchnorm, and aligned datasets.\n        """"""\n        # changing the default values to match the pix2pix paper (https://phillipi.github.io/pix2pix/)\n        parser.set_defaults(norm=\'batch\', netG=\'unet_256\', dataset_mode=\'aligned\')\n        parser.set_defaults(where_add=\'input\', nz=0)\n        if is_train:\n            parser.set_defaults(gan_mode=\'vanilla\', lambda_l1=100.0)\n\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize the pix2pix class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseModel.__init__(self, opt)\n        # specify the training losses you want to print out. The training/test scripts will call <BaseModel.get_current_losses>\n        self.loss_names = [\'G_GAN\', \'G_L1\', \'D_real\', \'D_fake\']\n        # specify the images you want to save/display. The training/test scripts will call <BaseModel.get_current_visuals>\n        self.visual_names = [\'real_A\', \'fake_B\', \'real_B\']\n        # specify the models you want to save to the disk. The training/test scripts will call <BaseModel.save_networks> and <BaseModel.load_networks>\n        if self.isTrain:\n            self.model_names = [\'G\', \'D\']\n        else:  # during test time, only load G\n            self.model_names = [\'G\']\n        # define networks (both generator and discriminator)\n        self.netG = networks.define_G(opt.input_nc, opt.output_nc, opt.nz, opt.ngf, netG=opt.netG,\n                                      norm=opt.norm, nl=opt.nl, use_dropout=opt.use_dropout, init_type=opt.init_type, init_gain=opt.init_gain,\n                                      gpu_ids=self.gpu_ids, where_add=opt.where_add, upsample=opt.upsample)\n\n        if self.isTrain:  # define a discriminator; conditional GANs need to take both input and output images; Therefore, #channels for D is input_nc + output_nc\n            self.netD = networks.define_D(opt.input_nc + opt.output_nc, opt.ndf, netD=opt.netD2, norm=opt.norm, nl=opt.nl,\n                                          init_type=opt.init_type, init_gain=opt.init_gain, num_Ds=opt.num_Ds, gpu_ids=self.gpu_ids)\n\n        if self.isTrain:\n            # define loss functions\n            self.criterionGAN = networks.GANLoss(opt.gan_mode).to(self.device)\n            self.criterionL1 = torch.nn.L1Loss()\n            # initialize optimizers; schedulers will be automatically created by function <BaseModel.setup>.\n            self.optimizer_G = torch.optim.Adam(self.netG.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizer_D = torch.optim.Adam(self.netD.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizers.append(self.optimizer_G)\n            self.optimizers.append(self.optimizer_D)\n\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input (dict): include the data itself and its metadata information.\n\n        The option \'direction\' can be used to swap images in domain A and domain B.\n        """"""\n        AtoB = self.opt.direction == \'AtoB\'\n        self.real_A = input[\'A\' if AtoB else \'B\'].to(self.device)\n        self.real_B = input[\'B\' if AtoB else \'A\'].to(self.device)\n        self.image_paths = input[\'A_paths\' if AtoB else \'B_paths\']\n\n    def forward(self):\n        """"""Run forward pass; called by both functions <optimize_parameters> and <test>.""""""\n        self.fake_B = self.netG(self.real_A)  # G(A)\n\n    def backward_D(self):\n        """"""Calculate GAN loss for the discriminator""""""\n        # Fake; stop backprop to the generator by detaching fake_B\n        fake_AB = torch.cat((self.real_A, self.fake_B), 1)  # we use conditional GANs; we need to feed both input and output to the discriminator\n        pred_fake = self.netD(fake_AB.detach())\n        self.loss_D_fake, _ = self.criterionGAN(pred_fake, False)\n        # Real\n        real_AB = torch.cat((self.real_A, self.real_B), 1)\n        pred_real = self.netD(real_AB)\n        self.loss_D_real, _ = self.criterionGAN(pred_real, True)\n        # combine loss and calculate gradients\n        self.loss_D = (self.loss_D_fake + self.loss_D_real) * 0.5\n        self.loss_D.backward()\n\n    def backward_G(self):\n        """"""Calculate GAN and L1 loss for the generator""""""\n        # First, G(A) should fake the discriminator\n        fake_AB = torch.cat((self.real_A, self.fake_B), 1)\n        pred_fake = self.netD(fake_AB)\n        self.loss_G_GAN, _ = self.criterionGAN(pred_fake, True)\n        # Second, G(A) = B\n        self.loss_G_L1 = self.criterionL1(self.fake_B, self.real_B) * self.opt.lambda_L1\n        # combine loss and calculate gradients\n        self.loss_G = self.loss_G_GAN + self.loss_G_L1\n        self.loss_G.backward()\n\n    def optimize_parameters(self):\n        self.forward()                   # compute fake images: G(A)\n        # update D\n        self.set_requires_grad(self.netD, True)  # enable backprop for D\n        self.optimizer_D.zero_grad()     # set D\'s gradients to zero\n        self.backward_D()                # calculate gradients for D\n        self.optimizer_D.step()          # update D\'s weights\n        # update G\n        self.set_requires_grad(self.netD, False)  # D requires no gradients when optimizing G\n        self.optimizer_G.zero_grad()        # set G\'s gradients to zero\n        self.backward_G()                   # calculate graidents for G\n        self.optimizer_G.step()             # udpate G\'s weights\n'"
models/template_model.py,3,"b'""""""Model class template\n\nThis module provides a template for users to implement custom models.\nYou can specify \'--model template\' to use this model.\nThe class name should be consistent with both the filename and its model option.\nThe filename should be <model>_dataset.py\nThe class name should be <Model>Dataset.py\nIt implements a simple image-to-image translation baseline based on regression loss.\nGiven input-output pairs (data_A, data_B), it learns a network netG that can minimize the following L1 loss:\n    min_<netG> ||netG(data_A) - data_B||_1\nYou need to implement the following functions:\n    <modify_commandline_options>:\xe3\x80\x80Add model-specific options and rewrite default values for existing options.\n    <__init__>: Initialize this model class.\n    <set_input>: Unpack input data and perform data pre-processing.\n    <forward>: Run forward pass. This will be called by both <optimize_parameters> and <test>.\n    <optimize_parameters>: Update network weights; it will be called in every training iteration.\n""""""\nimport torch\nfrom .base_model import BaseModel\nfrom . import networks\n\n\nclass TemplateModel(BaseModel):\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new model-specific options and rewrite default values for existing options.\n\n        Parameters:\n            parser -- the option parser\n            is_train -- if it is training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        parser.set_defaults(dataset_mode=\'aligned\', netG=\'unet_256\', where_add=\'input\', nz=0)  # You can rewrite default values for this model. For example, this model usually uses aligned dataset as its dataset.\n        if is_train:\n            parser.add_argument(\'--lambda_regression\', type=float, default=1.0, help=\'weight for the regression loss\')  # You can define new arguments for this model.\n\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize this model class.\n\n        Parameters:\n            opt -- training/test options\n\n        A few things can be done here.\n        - (required) call the initialization function of BaseModel\n        - define loss function, visualization images, model names, and optimizers\n        """"""\n        BaseModel.__init__(self, opt)  # call the initialization method of BaseModel\n        # specify the training losses you want to print out. The program will call base_model.get_current_losses to plot the losses to the console and save them to the disk.\n        self.loss_names = [\'loss_G\']\n        # specify the images you want to save and display. The program will call base_model.get_current_visuals to save and display these images.\n        self.visual_names = [\'data_A\', \'data_B\', \'output\']\n        # specify the models you want to save to the disk. The program will call base_model.save_networks and base_model.load_networks to save and load networks.\n        # you can use opt.isTrain to specify different behaviors for training and test. For example, some networks will not be used during test, and you don\'t need to load them.\n        self.model_names = [\'G\']\n        # define networks; you can use opt.isTrain to specify different behaviors for training and test.\n        self.netG = networks.define_G(opt.input_nc, opt.output_nc, opt.nz, opt.ngf, netG=opt.netG, gpu_ids=self.gpu_ids, where_add=opt.where_add)\n        if self.isTrain:  # only defined during training time\n            # define your loss functions. You can use losses provided by torch.nn such as torch.nn.L1Loss.\n            # We also provide a GANLoss class ""networks.GANLoss"". self.criterionGAN = networks.GANLoss().to(self.device)\n            self.criterionLoss = torch.nn.L1Loss()\n            # define and initialize optimizers. You can define one optimizer for each network.\n            # If two networks are updated at the same time, you can use itertools.chain to group them. See bicycle_gan_model.py for an example.\n            self.optimizer = torch.optim.Adam(self.netG.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizers = [self.optimizer]\n\n        # Our program will automatically call <model.setup> to define schedulers, load networks, and print networks\n\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input: a dictionary that contains the data itself and its metadata information.\n        """"""\n        AtoB = self.opt.direction == \'AtoB\'  # use <direction> to swap data_A and data_B\n        self.data_A = input[\'A\' if AtoB else \'B\'].to(self.device)  # get image data A\n        self.data_B = input[\'B\' if AtoB else \'A\'].to(self.device)  # get image data B\n        self.image_paths = input[\'A_paths\' if AtoB else \'B_paths\']  # get image paths\n\n    def forward(self):\n        """"""Run forward pass. This will be called by both functions <optimize_parameters> and <test>.""""""\n        self.output = self.netG(self.data_A)  # generate output image given the input data_A\n\n    def backward(self):\n        """"""Calculate losses, gradients, and update network weights; called in every training iteration""""""\n        # caculate the intermediate results if necessary; here self.output has been computed during function <forward>\n        # calculate loss given the input and intermediate results\n        self.loss_G = self.criterionLoss(self.output, self.data_B) * self.opt.lambda_regression\n        self.loss_G.backward()       # calculate gradients of network G w.r.t. loss_G\n\n    def optimize_parameters(self):\n        """"""Update network weights; it will be called in every training iteration.""""""\n        self.forward()               # first call forward to calculate intermediate results\n        self.optimizer.zero_grad()   # clear network G\'s existing gradients\n        self.backward()              # calculate gradients for network G\n        self.optimizer.step()        # update gradients for network G\n'"
options/__init__.py,0,b''
options/base_options.py,1,"b'import argparse\nimport os\nfrom util import util\nimport torch\nimport models\nimport data\n\n\nclass BaseOptions():\n    def __init__(self):\n        self.initialized = False\n\n    def initialize(self, parser):\n        """"""This class defines options used during both training and test time.\n\n        It also implements several helper functions such as parsing, printing, and saving the options.\n        It also gathers additional options defined in <modify_commandline_options> functions in both dataset class and model class.\n        """"""\n        parser.add_argument(\'--dataroot\', required=True, help=\'path to images (should have subfolders trainA, trainB, valA, valB, etc)\')\n        parser.add_argument(\'--batch_size\', type=int, default=2, help=\'input batch size\')\n        parser.add_argument(\'--load_size\', type=int, default=286, help=\'scale images to this size\')\n        parser.add_argument(\'--crop_size\', type=int, default=256, help=\'then crop to this size\')\n        parser.add_argument(\'--input_nc\', type=int, default=3, help=\'# of input image channels\')\n        parser.add_argument(\'--output_nc\', type=int, default=3, help=\'# of output image channels\')\n        parser.add_argument(\'--nz\', type=int, default=8, help=\'#latent vector\')\n        parser.add_argument(\'--gpu_ids\', type=str, default=\'0\', help=\'gpu ids: e.g. 0  0,1,2, 0,2, -1 for CPU mode\')\n        parser.add_argument(\'--name\', type=str, default=\'\', help=\'name of the experiment. It decides where to store samples and models\')\n        parser.add_argument(\'--preprocess\', type=str, default=\'resize_and_crop\', help=\'not implemented\')\n        parser.add_argument(\'--dataset_mode\', type=str, default=\'aligned\', help=\'aligned,single\')\n        parser.add_argument(\'--model\', type=str, default=\'bicycle_gan\', help=\'chooses which model to use. bicycle,, ...\')\n        parser.add_argument(\'--direction\', type=str, default=\'AtoB\', help=\'AtoB or BtoA\')\n        parser.add_argument(\'--epoch\', type=str, default=\'latest\', help=\'which epoch to load? set to latest to use latest cached model\')\n        parser.add_argument(\'--num_threads\', default=4, type=int, help=\'# sthreads for loading data\')\n        parser.add_argument(\'--checkpoints_dir\', type=str, default=\'./checkpoints\', help=\'models are saved here\')\n        parser.add_argument(\'--serial_batches\', action=\'store_true\', help=\'if true, takes images in order to make batches, otherwise takes them randomly\')\n        parser.add_argument(\'--use_dropout\', action=\'store_true\', help=\'use dropout for the generator\')\n        parser.add_argument(\'--max_dataset_size\', type=int, default=float(""inf""), help=\'Maximum number of samples allowed per dataset. If the dataset directory contains more than max_dataset_size, only a subset is loaded.\')\n        parser.add_argument(\'--no_flip\', action=\'store_true\', help=\'if specified, do not flip the images for data argumentation\')\n\n        # model parameters\n        parser.add_argument(\'--num_Ds\', type=int, default=2, help=\'number of Discrminators\')\n        parser.add_argument(\'--netD\', type=str, default=\'basic_256_multi\', help=\'selects model to use for netD\')\n        parser.add_argument(\'--netD2\', type=str, default=\'basic_256_multi\', help=\'selects model to use for netD2\')\n        parser.add_argument(\'--netG\', type=str, default=\'unet_256\', help=\'selects model to use for netG\')\n        parser.add_argument(\'--netE\', type=str, default=\'resnet_256\', help=\'selects model to use for netE\')\n        parser.add_argument(\'--nef\', type=int, default=64, help=\'# of encoder filters in the first conv layer\')\n        parser.add_argument(\'--ngf\', type=int, default=64, help=\'# of gen filters in the last conv layer\')\n        parser.add_argument(\'--ndf\', type=int, default=64, help=\'# of discrim filters in the first conv layer\')\n        parser.add_argument(\'--norm\', type=str, default=\'instance\', help=\'instance normalization or batch normalization\')\n        parser.add_argument(\'--upsample\', type=str, default=\'basic\', help=\'basic | bilinear\')\n        parser.add_argument(\'--nl\', type=str, default=\'relu\', help=\'non-linearity activation: relu | lrelu | elu\')\n\n        # extra parameters\n        parser.add_argument(\'--where_add\', type=str, default=\'all\', help=\'input|all|middle; where to add z in the network G\')\n        parser.add_argument(\'--conditional_D\', action=\'store_true\', help=\'if use conditional GAN for D\')\n        parser.add_argument(\'--init_type\', type=str, default=\'xavier\', help=\'network initialization [normal | xavier | kaiming | orthogonal]\')\n        parser.add_argument(\'--init_gain\', type=float, default=0.02, help=\'scaling factor for normal, xavier and orthogonal.\')\n        parser.add_argument(\'--center_crop\', action=\'store_true\', help=\'if apply for center cropping for the test\')\n        parser.add_argument(\'--verbose\', action=\'store_true\', help=\'if specified, print more debugging information\')\n        parser.add_argument(\'--suffix\', default=\'\', type=str, help=\'customized suffix: opt.name = opt.name + suffix: e.g., {model}_{netG}_size{load_size}\')\n        parser.add_argument(\'--display_winsize\', type=int, default=256, help=\'display window size\')\n\n        # special tasks\n        self.initialized = True\n        return parser\n\n    def gather_options(self):\n        """"""Initialize our parser with basic options(only once).\n        Add additional model-specific and dataset-specific options.\n        These options are difined in the <modify_commandline_options> function\n        in model and dataset classes.\n        """"""\n        if not self.initialized:  # check if it has been initialized\n            parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n            parser = self.initialize(parser)\n\n        # get the basic options\n        opt, _ = parser.parse_known_args()\n\n        # modify model-related parser options\n        model_name = opt.model\n        model_option_setter = models.get_option_setter(model_name)\n        parser = model_option_setter(parser, self.isTrain)\n        opt, _ = parser.parse_known_args()  # parse again with new defaults\n\n        # modify dataset-related parser options\n        dataset_name = opt.dataset_mode\n        dataset_option_setter = data.get_option_setter(dataset_name)\n        parser = dataset_option_setter(parser, self.isTrain)\n\n        # save and return the parser\n        self.parser = parser\n        return parser.parse_args()\n\n    def print_options(self, opt):\n        """"""Print and save options\n\n        It will print both current options and default values(if different).\n        It will save options into a text file / [checkpoints_dir] / opt.txt\n        """"""\n        message = \'\'\n        message += \'----------------- Options ---------------\\n\'\n        for k, v in sorted(vars(opt).items()):\n            comment = \'\'\n            default = self.parser.get_default(k)\n            if v != default:\n                comment = \'\\t[default: %s]\' % str(default)\n            message += \'{:>25}: {:<30}{}\\n\'.format(str(k), str(v), comment)\n        message += \'----------------- End -------------------\'\n        print(message)\n\n        # save to the disk\n        expr_dir = os.path.join(opt.checkpoints_dir, opt.name)\n        util.mkdirs(expr_dir)\n        file_name = os.path.join(expr_dir, \'opt.txt\')\n        with open(file_name, \'wt\') as opt_file:\n            opt_file.write(message)\n            opt_file.write(\'\\n\')\n\n    def parse(self):\n        """"""Parse our options, create checkpoints directory suffix, and set up gpu device.""""""\n        opt = self.gather_options()\n        opt.isTrain = self.isTrain   # train or test\n\n        # process opt.suffix\n        if opt.suffix:\n            suffix = (\'_\' + opt.suffix.format(**vars(opt))) if opt.suffix != \'\' else \'\'\n            opt.name = opt.name + suffix\n\n        self.print_options(opt)\n\n        # set gpu ids\n        str_ids = opt.gpu_ids.split(\',\')\n        opt.gpu_ids = []\n        for str_id in str_ids:\n            id = int(str_id)\n            if id >= 0:\n                opt.gpu_ids.append(id)\n        if len(opt.gpu_ids) > 0:\n            torch.cuda.set_device(opt.gpu_ids[0])\n\n        self.opt = opt\n        return self.opt\n'"
options/test_options.py,0,"b""from .base_options import BaseOptions\n\n\nclass TestOptions(BaseOptions):\n    def initialize(self, parser):\n        BaseOptions.initialize(self, parser)\n        parser.add_argument('--results_dir', type=str, default='../results/', help='saves results here.')\n        parser.add_argument('--phase', type=str, default='val', help='train, val, test, etc')\n        parser.add_argument('--num_test', type=int, default=50, help='how many test images to run')\n        parser.add_argument('--n_samples', type=int, default=5, help='#samples')\n        parser.add_argument('--no_encode', action='store_true', help='do not produce encoded image')\n        parser.add_argument('--sync', action='store_true', help='use the same latent code for different input images')\n        parser.add_argument('--aspect_ratio', type=float, default=1.0, help='aspect ratio for the results')\n        parser.add_argument('--eval', action='store_true', help='use eval mode during test time.')\n\n        self.isTrain = False\n        return parser\n"""
options/train_options.py,0,"b'from .base_options import BaseOptions\n\n\nclass TrainOptions(BaseOptions):\n    def initialize(self, parser):\n        BaseOptions.initialize(self, parser)\n        parser.add_argument(\'--display_freq\', type=int, default=400, help=\'frequency of showing training results on screen\')\n        parser.add_argument(\'--display_ncols\', type=int, default=4, help=\'if positive, display all images in a single visdom web panel with certain number of images per row.\')\n        parser.add_argument(\'--display_id\', type=int, default=1, help=\'window id of the web display\')\n        parser.add_argument(\'--display_port\', type=int, default=8097, help=\'visdom display port\')\n        parser.add_argument(\'--display_env\', type=str, default=\'main\', help=\'visdom display environment name (default is ""main"")\')\n        parser.add_argument(\'--display_server\', type=str, default=""http://localhost"", help=\'visdom server of the web display\')\n        parser.add_argument(\'--update_html_freq\', type=int, default=4000, help=\'frequency of saving training results to html\')\n        parser.add_argument(\'--print_freq\', type=int, default=100, help=\'frequency of showing training results on console\')\n        parser.add_argument(\'--save_latest_freq\', type=int, default=10000, help=\'frequency of saving the latest results\')\n        parser.add_argument(\'--save_epoch_freq\', type=int, default=5, help=\'frequency of saving checkpoints at the end of epochs\')\n        parser.add_argument(\'--phase\', type=str, default=\'train\', help=\'train, val, test, etc\')\n        parser.add_argument(\'--no_html\', action=\'store_true\', help=\'do not save intermediate training results to [opt.checkpoints_dir]/[opt.name]/web/\')\n        parser.add_argument(\'--gan_mode\', type=str, default=\'lsgan\', help=\'the type of GAN objective. [vanilla | lsgan \xef\xbd\x9c wgangp]. vanilla GAN loss is the cross-entropy objective used in the original GAN paper.\')\n        # training parameters\n        parser.add_argument(\'--niter\', type=int, default=100, help=\'# of iter at starting learning rate\')\n        parser.add_argument(\'--niter_decay\', type=int, default=100, help=\'# of iter to linearly decay learning rate to zero\')\n        parser.add_argument(\'--continue_train\', action=\'store_true\', help=\'continue training: load the latest model\')\n        parser.add_argument(\'--epoch_count\', type=int, default=1, help=\'the starting epoch count, we save the model by <epoch_count>, <epoch_count>+<save_latest_freq>, ...\')\n        parser.add_argument(\'--lr\', type=float, default=0.0002, help=\'initial learning rate for adam\')\n        parser.add_argument(\'--lr_policy\', type=str, default=\'linear\', help=\'learning rate policy: linear | step | plateau | cosine\')\n        parser.add_argument(\'--beta1\', type=float, default=0.5, help=\'momentum term of adam\')\n        parser.add_argument(\'--lr_decay_iters\', type=int, default=100, help=\'multiply by a gamma every lr_decay_iters iterations\')\n        # lambda parameters\n        parser.add_argument(\'--lambda_L1\', type=float, default=10.0, help=\'weight for |B-G(A, E(B))|\')\n        parser.add_argument(\'--lambda_GAN\', type=float, default=1.0, help=\'weight on D loss. D(G(A, E(B)))\')\n        parser.add_argument(\'--lambda_GAN2\', type=float, default=1.0, help=\'weight on D2 loss, D(G(A, random_z))\')\n        parser.add_argument(\'--lambda_z\', type=float, default=0.5, help=\'weight for ||E(G(random_z)) - random_z||\')\n        parser.add_argument(\'--lambda_kl\', type=float, default=0.01, help=\'weight for KL loss\')\n        parser.add_argument(\'--use_same_D\', action=\'store_true\', help=\'if two Ds share the weights or not\')\n        self.isTrain = True\n        return parser\n'"
options/video_options.py,0,"b""from .base_options import BaseOptions\n\n\nclass VideoOptions(BaseOptions):\n    def initialize(self, parser):\n        BaseOptions.initialize(self, parser)\n        parser.add_argument('--results_dir', type=str, default='../video/', help='saves results here.')\n        parser.add_argument('--phase', type=str, default='val', help='train, val, test, etc')\n        parser.add_argument('--num_test', type=int, default=50, help='how many test images to run')\n        parser.add_argument('--n_samples', type=int, default=5, help='#samples')\n        parser.add_argument('--num_frames', type=int, default=4, help='number of the frames used in the morphing sequence')\n        parser.add_argument('--align_mode', type=str, default='horizontal', help='ways of aligning the input images')\n        parser.add_argument('--border', type=int, default='0', help='border between results')\n        parser.add_argument('--seed', type=int, default=50, help='random seed for latent vectors')\n        parser.add_argument('--fps', type=int, default=8, help='speed of the generated video')\n        self.isTrain = False\n        return parser\n"""
scripts/test_before_push.py,0,"b'""""""Simple script to make sure basic usage such as training, testing, saving and loading runs without errors.""""""\nimport os\n\n\ndef run(command):\n    print(command)\n    exit_status = os.system(command)\n    if exit_status > 0:\n        exit(1)\n\n\nif __name__ == \'__main__\':\n    if not os.path.exists(\'./datasets/mini_pix2pix\'):\n        run(\'bash ./datasets/download_cyclegan_dataset.sh mini_pix2pix\')\n\n    # pix2pix train/test\n    run(\'python train.py --model pix2pix --name temp_pix2pix --dataroot ./datasets/mini_pix2pix --niter 1 --niter_decay 0 --save_latest_freq 10 --display_id -1\')\n\n    # template train/test\n    run(\'python train.py --model template --name temp2 --dataroot ./datasets/mini_pix2pix --niter 1 --niter_decay 0 --save_latest_freq 10 --display_id -1\')\n\n    run(\'bash ./scripts/test_edges2shoes.sh\')\n    run(\'bash ./scripts/test_edges2shoes.sh --sync\')\n    run(\'bash ./scripts/video_edges2shoes.sh\')\n    # run(\'bash ./scripts/train_facades.sh\')\n'"
util/__init__.py,0,b''
util/html.py,0,"b'import dominate\nfrom dominate.tags import meta, h3, table, tr, td, p, a, img, br\nimport os\n\n\nclass HTML:\n    """"""This HTML class allows us to save images and write texts into a single HTML file.\n\n     It consists of functions such as <add_header> (add a text header to the HTML file),\n     <add_images> (add a row of images to the HTML file), and <save> (save the HTML to the disk).\n     It is based on Python library \'dominate\', a Python library for creating and manipulating HTML documents using a DOM API.\n    """"""\n\n    def __init__(self, web_dir, title, refresh=0):\n        """"""Initialize the HTML classes\n\n        Parameters:\n            web_dir (str) -- a directory that stores the webpage. HTML file will be created at <web_dir>/index.html; images will be saved at <web_dir/images/\n            title (str)   -- the webpage name\n            reflect (int) -- how often the website refresh itself; if 0; no refreshing\n        """"""\n        self.title = title\n        self.web_dir = web_dir\n        self.img_dir = os.path.join(self.web_dir, \'images\')\n        if not os.path.exists(self.web_dir):\n            os.makedirs(self.web_dir)\n        if not os.path.exists(self.img_dir):\n            os.makedirs(self.img_dir)\n\n        self.doc = dominate.document(title=title)\n        if refresh > 0:\n            with self.doc.head:\n                meta(http_equiv=""refresh"", content=str(refresh))\n\n    def get_image_dir(self):\n        """"""Return the directory that stores images""""""\n        return self.img_dir\n\n    def add_header(self, text):\n        """"""Insert a header to the HTML file\n\n        Parameters:\n            text (str) -- the header text\n        """"""\n        with self.doc:\n            h3(text)\n\n    def add_images(self, ims, txts, links, width=400):\n        """"""add images to the HTML file\n\n        Parameters:\n            ims (str list)   -- a list of image paths\n            txts (str list)  -- a list of image names shown on the website\n            links (str list) --  a list of hyperref links; when you click an image, it will redirect you to a new page\n        """"""\n        self.t = table(border=1, style=""table-layout: fixed;"")  # Insert a table\n        self.doc.add(self.t)\n        with self.t:\n            with tr():\n                for im, txt, link in zip(ims, txts, links):\n                    with td(style=""word-wrap: break-word;"", halign=""center"", valign=""top""):\n                        with p():\n                            with a(href=os.path.join(\'images\', link)):\n                                img(style=""width:%dpx"" % width, src=os.path.join(\'images\', im))\n                            br()\n                            p(txt)\n\n    def save(self):\n        """"""save the current content to the HMTL file""""""\n        html_file = \'%s/index.html\' % self.web_dir\n        f = open(html_file, \'wt\')\n        f.write(self.doc.render())\n        f.close()\n\n\nif __name__ == \'__main__\':  # we show an example usage here.\n    html = HTML(\'web/\', \'test_html\')\n    html.add_header(\'hello world\')\n\n    ims, txts, links = [], [], []\n    for n in range(4):\n        ims.append(\'image_%d.png\' % n)\n        txts.append(\'text_%d\' % n)\n        links.append(\'image_%d.png\' % n)\n    html.add_images(ims, txts, links)\n    html.save()\n'"
util/util.py,2,"b'from __future__ import print_function\nimport torch\nimport numpy as np\nfrom PIL import Image\nimport os\nimport pickle\n\n\ndef tensor2im(input_image, imtype=np.uint8):\n    """"""""Convert a Tensor array into a numpy image array.\n    Parameters:\n        input_image (tensor) --  the input image tensor array\n        imtype (type)        --  the desired type of the converted numpy array\n    """"""\n    if not isinstance(input_image, np.ndarray):\n        if isinstance(input_image, torch.Tensor):  # get the data from a variable\n            image_tensor = input_image.data\n        else:\n            return input_image\n        image_numpy = image_tensor[0].cpu().float().numpy()  # convert it into a numpy array\n        if image_numpy.shape[0] == 1:  # grayscale to RGB\n            image_numpy = np.tile(image_numpy, (3, 1, 1))\n        image_numpy = (np.transpose(image_numpy, (1, 2, 0)) + 1) / 2.0 * 255.0  # post-processing: tranpose and scaling\n    else:  # if it is a numpy array, do nothing\n        image_numpy = input_image\n    return image_numpy.astype(imtype)\n\n\ndef tensor2vec(vector_tensor):\n    numpy_vec = vector_tensor.data.cpu().numpy()\n    if numpy_vec.ndim == 4:\n        return numpy_vec[:, :, 0, 0]\n    else:\n        return numpy_vec\n\n\ndef pickle_load(file_name):\n    data = None\n    with open(file_name, \'rb\') as f:\n        data = pickle.load(f)\n    return data\n\n\ndef pickle_save(file_name, data):\n    with open(file_name, \'wb\') as f:\n        pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL)\n\n\ndef diagnose_network(net, name=\'network\'):\n    """"""Calculate and print the mean of average absolute(gradients)\n    Parameters:\n        net (torch network) -- Torch network\n        name (str) -- the name of the network\n    """"""\n    mean = 0.0\n    count = 0\n    for param in net.parameters():\n        if param.grad is not None:\n            mean += torch.mean(torch.abs(param.grad.data))\n            count += 1\n    if count > 0:\n        mean = mean / count\n    print(name)\n    print(mean)\n\n\ndef interp_z(z0, z1, num_frames, interp_mode=\'linear\'):\n    zs = []\n    if interp_mode == \'linear\':\n        for n in range(num_frames):\n            ratio = n / float(num_frames - 1)\n            z_t = (1 - ratio) * z0 + ratio * z1\n            zs.append(z_t[np.newaxis, :])\n        zs = np.concatenate(zs, axis=0).astype(np.float32)\n\n    if interp_mode == \'slerp\':\n        z0_n = z0 / (np.linalg.norm(z0) + 1e-10)\n        z1_n = z1 / (np.linalg.norm(z1) + 1e-10)\n        omega = np.arccos(np.dot(z0_n, z1_n))\n        sin_omega = np.sin(omega)\n        if sin_omega < 1e-10 and sin_omega > -1e-10:\n            zs = interp_z(z0, z1, num_frames, interp_mode=\'linear\')\n        else:\n            for n in range(num_frames):\n                ratio = n / float(num_frames - 1)\n                z_t = np.sin((1 - ratio) * omega) / sin_omega * z0 + np.sin(ratio * omega) / sin_omega * z1\n                zs.append(z_t[np.newaxis, :])\n        zs = np.concatenate(zs, axis=0).astype(np.float32)\n\n    return zs\n\n\ndef save_image(image_numpy, image_path):\n    """"""Save a numpy image to the disk\n    Parameters:\n        image_numpy (numpy array) -- input numpy array\n        image_path (str)          -- the path of the image\n    """"""\n    image_pil = Image.fromarray(image_numpy)\n    image_pil.save(image_path)\n\n\ndef print_numpy(x, val=True, shp=False):\n    """"""Print the mean, min, max, median, std, and size of a numpy array\n    Parameters:\n        val (bool) -- if print the values of the numpy array\n        shp (bool) -- if print the shape of the numpy array\n    """"""\n    x = x.astype(np.float64)\n    if shp:\n        print(\'shape,\', x.shape)\n    if val:\n        x = x.flatten()\n        print(\'mean = %3.3f, min = %3.3f, max = %3.3f, median = %3.3f, std=%3.3f\' % (\n            np.mean(x), np.min(x), np.max(x), np.median(x), np.std(x)))\n\n\ndef mkdirs(paths):\n    """"""create empty directories if they don\'t exist\n    Parameters:\n        paths (str list) -- a list of directory paths\n    """"""\n    if isinstance(paths, list) and not isinstance(paths, str):\n        for path in paths:\n            mkdir(path)\n    else:\n        mkdir(paths)\n\n\ndef mkdir(path):\n    """"""create a single empty directory if it didn\'t exist\n    Parameters:\n        path (str) -- a single directory path\n    """"""\n    if not os.path.exists(path):\n        os.makedirs(path)\n'"
util/visualizer.py,0,"b'import numpy as np\nimport os\nimport sys\nimport ntpath\nimport time\nfrom . import util\nfrom . import html\nfrom subprocess import Popen, PIPE\nfrom scipy.misc import imresize\n\n\nif sys.version_info[0] == 2:\n    VisdomExceptionBase = Exception\nelse:\n    VisdomExceptionBase = ConnectionError\n\n\ndef save_images(webpage, images, names, image_path, aspect_ratio=1.0, width=256):\n    """"""Save images to the disk.\n    Parameters:\n        webpage (the HTML class)  -- the HTML webpage class that stores these imaegs (see html.py for more details)\n        images (numpy array list) -- a list of numpy array that stores images\n        names (str list)          -- a str list stores the names of the images above\n        image_path (str)         -- the string is used to create image paths\n        aspect_ratio (float)     -- the aspect ratio of saved images\n        width (int)              -- the images will be resized to width x width\n    This function will save images stored in \'visuals\' to the HTML file specified by \'webpage\'.\n    """"""\n    image_dir = webpage.get_image_dir()\n    name = ntpath.basename(image_path)\n\n    webpage.add_header(name)\n    ims, txts, links = [], [], []\n\n    for label, im_data in zip(names, images):\n        im = util.tensor2im(im_data)\n        image_name = \'%s_%s.png\' % (name, label)\n        save_path = os.path.join(image_dir, image_name)\n        h, w, _ = im.shape\n        if aspect_ratio > 1.0:\n            im = imresize(im, (h, int(w * aspect_ratio)), interp=\'bicubic\')\n        if aspect_ratio < 1.0:\n            im = imresize(im, (int(h / aspect_ratio), w), interp=\'bicubic\')\n        util.save_image(im, save_path)\n\n        ims.append(image_name)\n        txts.append(label)\n        links.append(image_name)\n    webpage.add_images(ims, txts, links, width=width)\n\n\nclass Visualizer():\n    """"""This class includes several functions that can display/save images and print/save logging information.\n    It uses a Python library \'visdom\' for display, and a Python library \'dominate\' (wrapped in \'HTML\') for creating HTML files with images.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize the Visualizer class\n        Parameters:\n            opt -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        Step 1: Cache the training/test options\n        Step 2: connect to a visdom server\n        Step 3: create an HTML object for saveing HTML filters\n        Step 4: create a logging file to store training losses\n        """"""\n        self.opt = opt  # cache the option\n        self.display_id = opt.display_id\n        self.use_html = opt.isTrain and not opt.no_html\n        self.win_size = opt.display_winsize\n        self.name = opt.name\n        self.port = opt.display_port\n        self.saved = False\n        if self.display_id > 0:  # connect to a visdom server given <display_port> and <display_server>\n            import visdom\n            self.ncols = opt.display_ncols\n            self.vis = visdom.Visdom(server=opt.display_server, port=opt.display_port, env=opt.display_env)\n            if not self.vis.check_connection():\n                self.create_visdom_connections()\n        if self.use_html:  # create an HTML object at <checkpoints_dir>/web/; images will be saved under <checkpoints_dir>/web/images/\n            self.web_dir = os.path.join(opt.checkpoints_dir, opt.name, \'web\')\n            self.img_dir = os.path.join(self.web_dir, \'images\')\n            print(\'create web directory %s...\' % self.web_dir)\n            util.mkdirs([self.web_dir, self.img_dir])\n        # create a logging file to store training losses\n        self.log_name = os.path.join(opt.checkpoints_dir, opt.name, \'loss_log.txt\')\n        with open(self.log_name, ""a"") as log_file:\n            now = time.strftime(""%c"")\n            log_file.write(\'================ Training Loss (%s) ================\\n\' % now)\n\n    def reset(self):\n        """"""Reset the self.saved status""""""\n        self.saved = False\n\n    def create_visdom_connections(self):\n        """"""If the program could not connect to Visdom server, this function will start a new server at port < self.port > """"""\n        cmd = sys.executable + \' -m visdom.server -p %d &>/dev/null &\' % self.port\n        print(\'\\n\\nCould not connect to Visdom server. \\n Trying to start a server....\')\n        print(\'Command: %s\' % cmd)\n        Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE)\n\n    def display_current_results(self, visuals, epoch, save_result):\n        """"""Display current results on visdom; save current results to an HTML file.\n        Parameters:\n            visuals (OrderedDict) - - dictionary of images to display or save\n            epoch (int) - - the current epoch\n            save_result (bool) - - if save the current results to an HTML file\n        """"""\n        if self.display_id > 0:  # show images in the browser using visdom\n            ncols = self.ncols\n            if ncols > 0:        # show all the images in one visdom panel\n                ncols = min(ncols, len(visuals))\n                h, w = next(iter(visuals.values())).shape[:2]\n                table_css = """"""<style>\n                        table {border-collapse: separate; border-spacing: 4px; white-space: nowrap; text-align: center}\n                        table td {width: % dpx; height: % dpx; padding: 4px; outline: 4px solid black}\n                        </style>"""""" % (w, h)  # create a table css\n                # create a table of images.\n                title = self.name\n                label_html = \'\'\n                label_html_row = \'\'\n                images = []\n                idx = 0\n                for label, image in visuals.items():\n                    image_numpy = util.tensor2im(image)\n                    label_html_row += \'<td>%s</td>\' % label\n                    images.append(image_numpy.transpose([2, 0, 1]))\n                    idx += 1\n                    if idx % ncols == 0:\n                        label_html += \'<tr>%s</tr>\' % label_html_row\n                        label_html_row = \'\'\n                white_image = np.ones_like(image_numpy.transpose([2, 0, 1])) * 255\n                while idx % ncols != 0:\n                    images.append(white_image)\n                    label_html_row += \'<td></td>\'\n                    idx += 1\n                if label_html_row != \'\':\n                    label_html += \'<tr>%s</tr>\' % label_html_row\n                try:\n                    self.vis.images(images, nrow=ncols, win=self.display_id + 1,\n                                    padding=2, opts=dict(title=title + \' images\'))\n                    label_html = \'<table>%s</table>\' % label_html\n                    self.vis.text(table_css + label_html, win=self.display_id + 2,\n                                  opts=dict(title=title + \' labels\'))\n                except VisdomExceptionBase:\n                    self.create_visdom_connections()\n\n            else:     # show each image in a separate visdom panel;\n                idx = 1\n                try:\n                    for label, image in visuals.items():\n                        image_numpy = util.tensor2im(image)\n                        self.vis.image(image_numpy.transpose([2, 0, 1]), opts=dict(title=label),\n                                       win=self.display_id + idx)\n                        idx += 1\n                except VisdomExceptionBase:\n                    self.create_visdom_connections()\n\n        if self.use_html and (save_result or not self.saved):  # save images to an HTML file if they haven\'t been saved.\n            self.saved = True\n            # save images to the disk\n            for label, image in visuals.items():\n                image_numpy = util.tensor2im(image)\n                img_path = os.path.join(self.img_dir, \'epoch%.3d_%s.png\' % (epoch, label))\n                util.save_image(image_numpy, img_path)\n\n            # update website\n            webpage = html.HTML(self.web_dir, \'Experiment name = %s\' % self.name, refresh=1)\n            for n in range(epoch, 0, -1):\n                webpage.add_header(\'epoch [%d]\' % n)\n                ims, txts, links = [], [], []\n\n                for label, image_numpy in visuals.items():\n                    image_numpy = util.tensor2im(image)\n                    img_path = \'epoch%.3d_%s.png\' % (n, label)\n                    ims.append(img_path)\n                    txts.append(label)\n                    links.append(img_path)\n                webpage.add_images(ims, txts, links, width=self.win_size)\n            webpage.save()\n\n    def plot_current_losses(self, epoch, counter_ratio, losses):\n        """"""display the current losses on visdom display: dictionary of error labels and values\n        Parameters:\n            epoch (int)           -- current epoch\n            counter_ratio (float) -- progress (percentage) in the current epoch, between 0 to 1\n            losses (OrderedDict)  -- training losses stored in the format of (name, float) pairs\n        """"""\n        if not hasattr(self, \'plot_data\'):\n            self.plot_data = {\'X\': [], \'Y\': [], \'legend\': list(losses.keys())}\n        self.plot_data[\'X\'].append(epoch + counter_ratio)\n        self.plot_data[\'Y\'].append([losses[k] for k in self.plot_data[\'legend\']])\n        try:\n            self.vis.line(\n                X=np.stack([np.array(self.plot_data[\'X\'])] * len(self.plot_data[\'legend\']), 1),\n                Y=np.array(self.plot_data[\'Y\']),\n                opts={\n                    \'title\': self.name + \' loss over time\',\n                    \'legend\': self.plot_data[\'legend\'],\n                    \'xlabel\': \'epoch\',\n                    \'ylabel\': \'loss\'},\n                win=self.display_id)\n        except VisdomExceptionBase:\n            self.create_visdom_connections()\n\n    # losses: same format as |losses| of plot_current_losses\n    def print_current_losses(self, epoch, iters, losses, t_comp, t_data):\n        """"""print current losses on console; also save the losses to the disk\n        Parameters:\n            epoch (int) -- current epoch\n            iters (int) -- current training iteration during this epoch (reset to 0 at the end of every epoch)\n            losses (OrderedDict) -- training losses stored in the format of (name, float) pairs\n            t_comp (float) -- computational time per data point (normalized by batch_size)\n            t_data (float) -- data loading time per data point (normalized by batch_size)\n        """"""\n        message = \'(epoch: %d, iters: %d, time: %.3f, data: %.3f) \' % (epoch, iters, t_comp, t_data)\n        for k, v in losses.items():\n            message += \'%s: %.3f \' % (k, v)\n\n        print(message)  # print the message\n        with open(self.log_name, ""a"") as log_file:\n            log_file.write(\'%s\\n\' % message)  # save the message\n'"
