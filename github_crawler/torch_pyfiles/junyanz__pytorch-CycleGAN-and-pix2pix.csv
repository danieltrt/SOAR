file_path,api_count,code
test.py,0,"b'""""""General-purpose test script for image-to-image translation.\n\nOnce you have trained your model with train.py, you can use this script to test the model.\nIt will load a saved model from \'--checkpoints_dir\' and save the results to \'--results_dir\'.\n\nIt first creates model and dataset given the option. It will hard-code some parameters.\nIt then runs inference for \'--num_test\' images and save results to an HTML file.\n\nExample (You need to train models first or download pre-trained models from our website):\n    Test a CycleGAN model (both sides):\n        python test.py --dataroot ./datasets/maps --name maps_cyclegan --model cycle_gan\n\n    Test a CycleGAN model (one side only):\n        python test.py --dataroot datasets/horse2zebra/testA --name horse2zebra_pretrained --model test --no_dropout\n\n    The option \'--model test\' is used for generating CycleGAN results only for one side.\n    This option will automatically set \'--dataset_mode single\', which only loads the images from one set.\n    On the contrary, using \'--model cycle_gan\' requires loading and generating results in both directions,\n    which is sometimes unnecessary. The results will be saved at ./results/.\n    Use \'--results_dir <directory_path_to_save_result>\' to specify the results directory.\n\n    Test a pix2pix model:\n        python test.py --dataroot ./datasets/facades --name facades_pix2pix --model pix2pix --direction BtoA\n\nSee options/base_options.py and options/test_options.py for more test options.\nSee training and test tips at: https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/blob/master/docs/tips.md\nSee frequently asked questions at: https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/blob/master/docs/qa.md\n""""""\nimport os\nfrom options.test_options import TestOptions\nfrom data import create_dataset\nfrom models import create_model\nfrom util.visualizer import save_images\nfrom util import html\n\n\nif __name__ == \'__main__\':\n    opt = TestOptions().parse()  # get test options\n    # hard-code some parameters for test\n    opt.num_threads = 0   # test code only supports num_threads = 1\n    opt.batch_size = 1    # test code only supports batch_size = 1\n    opt.serial_batches = True  # disable data shuffling; comment this line if results on randomly chosen images are needed.\n    opt.no_flip = True    # no flip; comment this line if results on flipped images are needed.\n    opt.display_id = -1   # no visdom display; the test code saves the results to a HTML file.\n    dataset = create_dataset(opt)  # create a dataset given opt.dataset_mode and other options\n    model = create_model(opt)      # create a model given opt.model and other options\n    model.setup(opt)               # regular setup: load and print networks; create schedulers\n    # create a website\n    web_dir = os.path.join(opt.results_dir, opt.name, \'{}_{}\'.format(opt.phase, opt.epoch))  # define the website directory\n    if opt.load_iter > 0:  # load_iter is 0 by default\n        web_dir = \'{:s}_iter{:d}\'.format(web_dir, opt.load_iter)\n    print(\'creating web directory\', web_dir)\n    webpage = html.HTML(web_dir, \'Experiment = %s, Phase = %s, Epoch = %s\' % (opt.name, opt.phase, opt.epoch))\n    # test with eval mode. This only affects layers like batchnorm and dropout.\n    # For [pix2pix]: we use batchnorm and dropout in the original pix2pix. You can experiment it with and without eval() mode.\n    # For [CycleGAN]: It should not affect CycleGAN as CycleGAN uses instancenorm without dropout.\n    if opt.eval:\n        model.eval()\n    for i, data in enumerate(dataset):\n        if i >= opt.num_test:  # only apply our model to opt.num_test images.\n            break\n        model.set_input(data)  # unpack data from data loader\n        model.test()           # run inference\n        visuals = model.get_current_visuals()  # get image results\n        img_path = model.get_image_paths()     # get image paths\n        if i % 5 == 0:  # save images to an HTML file\n            print(\'processing (%04d)-th image... %s\' % (i, img_path))\n        save_images(webpage, visuals, img_path, aspect_ratio=opt.aspect_ratio, width=opt.display_winsize)\n    webpage.save()  # save the HTML\n'"
train.py,0,"b'""""""General-purpose training script for image-to-image translation.\n\nThis script works for various models (with option \'--model\': e.g., pix2pix, cyclegan, colorization) and\ndifferent datasets (with option \'--dataset_mode\': e.g., aligned, unaligned, single, colorization).\nYou need to specify the dataset (\'--dataroot\'), experiment name (\'--name\'), and model (\'--model\').\n\nIt first creates model, dataset, and visualizer given the option.\nIt then does standard network training. During the training, it also visualize/save the images, print/save the loss plot, and save models.\nThe script supports continue/resume training. Use \'--continue_train\' to resume your previous training.\n\nExample:\n    Train a CycleGAN model:\n        python train.py --dataroot ./datasets/maps --name maps_cyclegan --model cycle_gan\n    Train a pix2pix model:\n        python train.py --dataroot ./datasets/facades --name facades_pix2pix --model pix2pix --direction BtoA\n\nSee options/base_options.py and options/train_options.py for more training options.\nSee training and test tips at: https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/blob/master/docs/tips.md\nSee frequently asked questions at: https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/blob/master/docs/qa.md\n""""""\nimport time\nfrom options.train_options import TrainOptions\nfrom data import create_dataset\nfrom models import create_model\nfrom util.visualizer import Visualizer\n\nif __name__ == \'__main__\':\n    opt = TrainOptions().parse()   # get training options\n    dataset = create_dataset(opt)  # create a dataset given opt.dataset_mode and other options\n    dataset_size = len(dataset)    # get the number of images in the dataset.\n    print(\'The number of training images = %d\' % dataset_size)\n\n    model = create_model(opt)      # create a model given opt.model and other options\n    model.setup(opt)               # regular setup: load and print networks; create schedulers\n    visualizer = Visualizer(opt)   # create a visualizer that display/save images and plots\n    total_iters = 0                # the total number of training iterations\n\n    for epoch in range(opt.epoch_count, opt.n_epochs + opt.n_epochs_decay + 1):    # outer loop for different epochs; we save the model by <epoch_count>, <epoch_count>+<save_latest_freq>\n        epoch_start_time = time.time()  # timer for entire epoch\n        iter_data_time = time.time()    # timer for data loading per iteration\n        epoch_iter = 0                  # the number of training iterations in current epoch, reset to 0 every epoch\n        visualizer.reset()              # reset the visualizer: make sure it saves the results to HTML at least once every epoch\n\n        for i, data in enumerate(dataset):  # inner loop within one epoch\n            iter_start_time = time.time()  # timer for computation per iteration\n            if total_iters % opt.print_freq == 0:\n                t_data = iter_start_time - iter_data_time\n\n            total_iters += opt.batch_size\n            epoch_iter += opt.batch_size\n            model.set_input(data)         # unpack data from dataset and apply preprocessing\n            model.optimize_parameters()   # calculate loss functions, get gradients, update network weights\n\n            if total_iters % opt.display_freq == 0:   # display images on visdom and save images to a HTML file\n                save_result = total_iters % opt.update_html_freq == 0\n                model.compute_visuals()\n                visualizer.display_current_results(model.get_current_visuals(), epoch, save_result)\n\n            if total_iters % opt.print_freq == 0:    # print training losses and save logging information to the disk\n                losses = model.get_current_losses()\n                t_comp = (time.time() - iter_start_time) / opt.batch_size\n                visualizer.print_current_losses(epoch, epoch_iter, losses, t_comp, t_data)\n                if opt.display_id > 0:\n                    visualizer.plot_current_losses(epoch, float(epoch_iter) / dataset_size, losses)\n\n            if total_iters % opt.save_latest_freq == 0:   # cache our latest model every <save_latest_freq> iterations\n                print(\'saving the latest model (epoch %d, total_iters %d)\' % (epoch, total_iters))\n                save_suffix = \'iter_%d\' % total_iters if opt.save_by_iter else \'latest\'\n                model.save_networks(save_suffix)\n\n            iter_data_time = time.time()\n        if epoch % opt.save_epoch_freq == 0:              # cache our model every <save_epoch_freq> epochs\n            print(\'saving the model at the end of epoch %d, iters %d\' % (epoch, total_iters))\n            model.save_networks(\'latest\')\n            model.save_networks(epoch)\n\n        print(\'End of epoch %d / %d \\t Time Taken: %d sec\' % (epoch, opt.n_epochs + opt.n_epochs_decay, time.time() - epoch_start_time))\n        model.update_learning_rate()                     # update learning rates at the end of every epoch.\n'"
data/__init__.py,2,"b'""""""This package includes all the modules related to data loading and preprocessing\n\n To add a custom dataset class called \'dummy\', you need to add a file called \'dummy_dataset.py\' and define a subclass \'DummyDataset\' inherited from BaseDataset.\n You need to implement four functions:\n    -- <__init__>:                      initialize the class, first call BaseDataset.__init__(self, opt).\n    -- <__len__>:                       return the size of dataset.\n    -- <__getitem__>:                   get a data point from data loader.\n    -- <modify_commandline_options>:    (optionally) add dataset-specific options and set default options.\n\nNow you can use the dataset class by specifying flag \'--dataset_mode dummy\'.\nSee our template dataset class \'template_dataset.py\' for more details.\n""""""\nimport importlib\nimport torch.utils.data\nfrom data.base_dataset import BaseDataset\n\n\ndef find_dataset_using_name(dataset_name):\n    """"""Import the module ""data/[dataset_name]_dataset.py"".\n\n    In the file, the class called DatasetNameDataset() will\n    be instantiated. It has to be a subclass of BaseDataset,\n    and it is case-insensitive.\n    """"""\n    dataset_filename = ""data."" + dataset_name + ""_dataset""\n    datasetlib = importlib.import_module(dataset_filename)\n\n    dataset = None\n    target_dataset_name = dataset_name.replace(\'_\', \'\') + \'dataset\'\n    for name, cls in datasetlib.__dict__.items():\n        if name.lower() == target_dataset_name.lower() \\\n           and issubclass(cls, BaseDataset):\n            dataset = cls\n\n    if dataset is None:\n        raise NotImplementedError(""In %s.py, there should be a subclass of BaseDataset with class name that matches %s in lowercase."" % (dataset_filename, target_dataset_name))\n\n    return dataset\n\n\ndef get_option_setter(dataset_name):\n    """"""Return the static method <modify_commandline_options> of the dataset class.""""""\n    dataset_class = find_dataset_using_name(dataset_name)\n    return dataset_class.modify_commandline_options\n\n\ndef create_dataset(opt):\n    """"""Create a dataset given the option.\n\n    This function wraps the class CustomDatasetDataLoader.\n        This is the main interface between this package and \'train.py\'/\'test.py\'\n\n    Example:\n        >>> from data import create_dataset\n        >>> dataset = create_dataset(opt)\n    """"""\n    data_loader = CustomDatasetDataLoader(opt)\n    dataset = data_loader.load_data()\n    return dataset\n\n\nclass CustomDatasetDataLoader():\n    """"""Wrapper class of Dataset class that performs multi-threaded data loading""""""\n\n    def __init__(self, opt):\n        """"""Initialize this class\n\n        Step 1: create a dataset instance given the name [dataset_mode]\n        Step 2: create a multi-threaded data loader.\n        """"""\n        self.opt = opt\n        dataset_class = find_dataset_using_name(opt.dataset_mode)\n        self.dataset = dataset_class(opt)\n        print(""dataset [%s] was created"" % type(self.dataset).__name__)\n        self.dataloader = torch.utils.data.DataLoader(\n            self.dataset,\n            batch_size=opt.batch_size,\n            shuffle=not opt.serial_batches,\n            num_workers=int(opt.num_threads))\n\n    def load_data(self):\n        return self\n\n    def __len__(self):\n        """"""Return the number of data in the dataset""""""\n        return min(len(self.dataset), self.opt.max_dataset_size)\n\n    def __iter__(self):\n        """"""Return a batch of data""""""\n        for i, data in enumerate(self.dataloader):\n            if i * self.opt.batch_size >= self.opt.max_dataset_size:\n                break\n            yield data\n'"
data/aligned_dataset.py,0,"b'import os.path\nfrom data.base_dataset import BaseDataset, get_params, get_transform\nfrom data.image_folder import make_dataset\nfrom PIL import Image\n\n\nclass AlignedDataset(BaseDataset):\n    """"""A dataset class for paired image dataset.\n\n    It assumes that the directory \'/path/to/data/train\' contains image pairs in the form of {A,B}.\n    During test time, you need to prepare a directory \'/path/to/data/test\'.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseDataset.__init__(self, opt)\n        self.dir_AB = os.path.join(opt.dataroot, opt.phase)  # get the image directory\n        self.AB_paths = sorted(make_dataset(self.dir_AB, opt.max_dataset_size))  # get image paths\n        assert(self.opt.load_size >= self.opt.crop_size)   # crop_size should be smaller than the size of loaded image\n        self.input_nc = self.opt.output_nc if self.opt.direction == \'BtoA\' else self.opt.input_nc\n        self.output_nc = self.opt.input_nc if self.opt.direction == \'BtoA\' else self.opt.output_nc\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns a dictionary that contains A, B, A_paths and B_paths\n            A (tensor) - - an image in the input domain\n            B (tensor) - - its corresponding image in the target domain\n            A_paths (str) - - image paths\n            B_paths (str) - - image paths (same as A_paths)\n        """"""\n        # read a image given a random integer index\n        AB_path = self.AB_paths[index]\n        AB = Image.open(AB_path).convert(\'RGB\')\n        # split AB image into A and B\n        w, h = AB.size\n        w2 = int(w / 2)\n        A = AB.crop((0, 0, w2, h))\n        B = AB.crop((w2, 0, w, h))\n\n        # apply the same transform to both A and B\n        transform_params = get_params(self.opt, A.size)\n        A_transform = get_transform(self.opt, transform_params, grayscale=(self.input_nc == 1))\n        B_transform = get_transform(self.opt, transform_params, grayscale=(self.output_nc == 1))\n\n        A = A_transform(A)\n        B = B_transform(B)\n\n        return {\'A\': A, \'B\': B, \'A_paths\': AB_path, \'B_paths\': AB_path}\n\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return len(self.AB_paths)\n'"
data/base_dataset.py,1,"b'""""""This module implements an abstract base class (ABC) \'BaseDataset\' for datasets.\n\nIt also includes common transformation functions (e.g., get_transform, __scale_width), which can be later used in subclasses.\n""""""\nimport random\nimport numpy as np\nimport torch.utils.data as data\nfrom PIL import Image\nimport torchvision.transforms as transforms\nfrom abc import ABC, abstractmethod\n\n\nclass BaseDataset(data.Dataset, ABC):\n    """"""This class is an abstract base class (ABC) for datasets.\n\n    To create a subclass, you need to implement the following four functions:\n    -- <__init__>:                      initialize the class, first call BaseDataset.__init__(self, opt).\n    -- <__len__>:                       return the size of dataset.\n    -- <__getitem__>:                   get a data point.\n    -- <modify_commandline_options>:    (optionally) add dataset-specific options and set default options.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize the class; save the options in the class\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        self.opt = opt\n        self.root = opt.dataroot\n\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        return parser\n\n    @abstractmethod\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return 0\n\n    @abstractmethod\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns:\n            a dictionary of data with their names. It ususally contains the data itself and its metadata information.\n        """"""\n        pass\n\n\ndef get_params(opt, size):\n    w, h = size\n    new_h = h\n    new_w = w\n    if opt.preprocess == \'resize_and_crop\':\n        new_h = new_w = opt.load_size\n    elif opt.preprocess == \'scale_width_and_crop\':\n        new_w = opt.load_size\n        new_h = opt.load_size * h // w\n\n    x = random.randint(0, np.maximum(0, new_w - opt.crop_size))\n    y = random.randint(0, np.maximum(0, new_h - opt.crop_size))\n\n    flip = random.random() > 0.5\n\n    return {\'crop_pos\': (x, y), \'flip\': flip}\n\n\ndef get_transform(opt, params=None, grayscale=False, method=Image.BICUBIC, convert=True):\n    transform_list = []\n    if grayscale:\n        transform_list.append(transforms.Grayscale(1))\n    if \'resize\' in opt.preprocess:\n        osize = [opt.load_size, opt.load_size]\n        transform_list.append(transforms.Resize(osize, method))\n    elif \'scale_width\' in opt.preprocess:\n        transform_list.append(transforms.Lambda(lambda img: __scale_width(img, opt.load_size, opt.crop_size, method)))\n\n    if \'crop\' in opt.preprocess:\n        if params is None:\n            transform_list.append(transforms.RandomCrop(opt.crop_size))\n        else:\n            transform_list.append(transforms.Lambda(lambda img: __crop(img, params[\'crop_pos\'], opt.crop_size)))\n\n    if opt.preprocess == \'none\':\n        transform_list.append(transforms.Lambda(lambda img: __make_power_2(img, base=4, method=method)))\n\n    if not opt.no_flip:\n        if params is None:\n            transform_list.append(transforms.RandomHorizontalFlip())\n        elif params[\'flip\']:\n            transform_list.append(transforms.Lambda(lambda img: __flip(img, params[\'flip\'])))\n\n    if convert:\n        transform_list += [transforms.ToTensor()]\n        if grayscale:\n            transform_list += [transforms.Normalize((0.5,), (0.5,))]\n        else:\n            transform_list += [transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]\n    return transforms.Compose(transform_list)\n\n\ndef __make_power_2(img, base, method=Image.BICUBIC):\n    ow, oh = img.size\n    h = int(round(oh / base) * base)\n    w = int(round(ow / base) * base)\n    if h == oh and w == ow:\n        return img\n\n    __print_size_warning(ow, oh, w, h)\n    return img.resize((w, h), method)\n\n\ndef __scale_width(img, target_size, crop_size, method=Image.BICUBIC):\n    ow, oh = img.size\n    if ow == target_size and oh >= crop_size:\n        return img\n    w = target_size\n    h = int(max(target_size * oh / ow, crop_size))\n    return img.resize((w, h), method)\n\n\ndef __crop(img, pos, size):\n    ow, oh = img.size\n    x1, y1 = pos\n    tw = th = size\n    if (ow > tw or oh > th):\n        return img.crop((x1, y1, x1 + tw, y1 + th))\n    return img\n\n\ndef __flip(img, flip):\n    if flip:\n        return img.transpose(Image.FLIP_LEFT_RIGHT)\n    return img\n\n\ndef __print_size_warning(ow, oh, w, h):\n    """"""Print warning information about image size(only print once)""""""\n    if not hasattr(__print_size_warning, \'has_printed\'):\n        print(""The image size needs to be a multiple of 4. ""\n              ""The loaded image size was (%d, %d), so it was adjusted to ""\n              ""(%d, %d). This adjustment will be done to all images ""\n              ""whose sizes are not multiples of 4"" % (ow, oh, w, h))\n        __print_size_warning.has_printed = True\n'"
data/colorization_dataset.py,0,"b'import os.path\nfrom data.base_dataset import BaseDataset, get_transform\nfrom data.image_folder import make_dataset\nfrom skimage import color  # require skimage\nfrom PIL import Image\nimport numpy as np\nimport torchvision.transforms as transforms\n\n\nclass ColorizationDataset(BaseDataset):\n    """"""This dataset class can load a set of natural images in RGB, and convert RGB format into (L, ab) pairs in Lab color space.\n\n    This dataset is required by pix2pix-based colorization model (\'--model colorization\')\n    """"""\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n\n        By default, the number of channels for input image  is 1 (L) and\n        the number of channels for output image is 2 (ab). The direction is from A to B\n        """"""\n        parser.set_defaults(input_nc=1, output_nc=2, direction=\'AtoB\')\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseDataset.__init__(self, opt)\n        self.dir = os.path.join(opt.dataroot, opt.phase)\n        self.AB_paths = sorted(make_dataset(self.dir, opt.max_dataset_size))\n        assert(opt.input_nc == 1 and opt.output_nc == 2 and opt.direction == \'AtoB\')\n        self.transform = get_transform(self.opt, convert=False)\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns a dictionary that contains A, B, A_paths and B_paths\n            A (tensor) - - the L channel of an image\n            B (tensor) - - the ab channels of the same image\n            A_paths (str) - - image paths\n            B_paths (str) - - image paths (same as A_paths)\n        """"""\n        path = self.AB_paths[index]\n        im = Image.open(path).convert(\'RGB\')\n        im = self.transform(im)\n        im = np.array(im)\n        lab = color.rgb2lab(im).astype(np.float32)\n        lab_t = transforms.ToTensor()(lab)\n        A = lab_t[[0], ...] / 50.0 - 1.0\n        B = lab_t[[1, 2], ...] / 110.0\n        return {\'A\': A, \'B\': B, \'A_paths\': path, \'B_paths\': path}\n\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return len(self.AB_paths)\n'"
data/image_folder.py,1,"b'""""""A modified image folder class\n\nWe modify the official PyTorch image folder (https://github.com/pytorch/vision/blob/master/torchvision/datasets/folder.py)\nso that this class can load images from both current directory and its subdirectories.\n""""""\n\nimport torch.utils.data as data\n\nfrom PIL import Image\nimport os\nimport os.path\n\nIMG_EXTENSIONS = [\n    \'.jpg\', \'.JPG\', \'.jpeg\', \'.JPEG\',\n    \'.png\', \'.PNG\', \'.ppm\', \'.PPM\', \'.bmp\', \'.BMP\',\n    \'.tif\', \'.TIF\', \'.tiff\', \'.TIFF\',\n]\n\n\ndef is_image_file(filename):\n    return any(filename.endswith(extension) for extension in IMG_EXTENSIONS)\n\n\ndef make_dataset(dir, max_dataset_size=float(""inf"")):\n    images = []\n    assert os.path.isdir(dir), \'%s is not a valid directory\' % dir\n\n    for root, _, fnames in sorted(os.walk(dir)):\n        for fname in fnames:\n            if is_image_file(fname):\n                path = os.path.join(root, fname)\n                images.append(path)\n    return images[:min(max_dataset_size, len(images))]\n\n\ndef default_loader(path):\n    return Image.open(path).convert(\'RGB\')\n\n\nclass ImageFolder(data.Dataset):\n\n    def __init__(self, root, transform=None, return_paths=False,\n                 loader=default_loader):\n        imgs = make_dataset(root)\n        if len(imgs) == 0:\n            raise(RuntimeError(""Found 0 images in: "" + root + ""\\n""\n                               ""Supported image extensions are: "" +\n                               "","".join(IMG_EXTENSIONS)))\n\n        self.root = root\n        self.imgs = imgs\n        self.transform = transform\n        self.return_paths = return_paths\n        self.loader = loader\n\n    def __getitem__(self, index):\n        path = self.imgs[index]\n        img = self.loader(path)\n        if self.transform is not None:\n            img = self.transform(img)\n        if self.return_paths:\n            return img, path\n        else:\n            return img\n\n    def __len__(self):\n        return len(self.imgs)\n'"
data/single_dataset.py,0,"b'from data.base_dataset import BaseDataset, get_transform\nfrom data.image_folder import make_dataset\nfrom PIL import Image\n\n\nclass SingleDataset(BaseDataset):\n    """"""This dataset class can load a set of images specified by the path --dataroot /path/to/data.\n\n    It can be used for generating CycleGAN results only for one side with the model option \'-model test\'.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseDataset.__init__(self, opt)\n        self.A_paths = sorted(make_dataset(opt.dataroot, opt.max_dataset_size))\n        input_nc = self.opt.output_nc if self.opt.direction == \'BtoA\' else self.opt.input_nc\n        self.transform = get_transform(opt, grayscale=(input_nc == 1))\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index - - a random integer for data indexing\n\n        Returns a dictionary that contains A and A_paths\n            A(tensor) - - an image in one domain\n            A_paths(str) - - the path of the image\n        """"""\n        A_path = self.A_paths[index]\n        A_img = Image.open(A_path).convert(\'RGB\')\n        A = self.transform(A_img)\n        return {\'A\': A, \'A_paths\': A_path}\n\n    def __len__(self):\n        """"""Return the total number of images in the dataset.""""""\n        return len(self.A_paths)\n'"
data/template_dataset.py,0,"b'""""""Dataset class template\n\nThis module provides a template for users to implement custom datasets.\nYou can specify \'--dataset_mode template\' to use this dataset.\nThe class name should be consistent with both the filename and its dataset_mode option.\nThe filename should be <dataset_mode>_dataset.py\nThe class name should be <Dataset_mode>Dataset.py\nYou need to implement the following functions:\n    -- <modify_commandline_options>:\xe3\x80\x80Add dataset-specific options and rewrite default values for existing options.\n    -- <__init__>: Initialize this dataset class.\n    -- <__getitem__>: Return a data point and its metadata information.\n    -- <__len__>: Return the number of images.\n""""""\nfrom data.base_dataset import BaseDataset, get_transform\n# from data.image_folder import make_dataset\n# from PIL import Image\n\n\nclass TemplateDataset(BaseDataset):\n    """"""A template dataset class for you to implement custom datasets.""""""\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        parser.add_argument(\'--new_dataset_option\', type=float, default=1.0, help=\'new dataset option\')\n        parser.set_defaults(max_dataset_size=10, new_dataset_option=2.0)  # specify dataset-specific default values\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n\n        A few things can be done here.\n        - save the options (have been done in BaseDataset)\n        - get image paths and meta information of the dataset.\n        - define the image transformation.\n        """"""\n        # save the option and dataset root\n        BaseDataset.__init__(self, opt)\n        # get the image paths of your dataset;\n        self.image_paths = []  # You can call sorted(make_dataset(self.root, opt.max_dataset_size)) to get all the image paths under the directory self.root\n        # define the default transform function. You can use <base_dataset.get_transform>; You can also define your custom transform function\n        self.transform = get_transform(opt)\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index -- a random integer for data indexing\n\n        Returns:\n            a dictionary of data with their names. It usually contains the data itself and its metadata information.\n\n        Step 1: get a random image path: e.g., path = self.image_paths[index]\n        Step 2: load your data from the disk: e.g., image = Image.open(path).convert(\'RGB\').\n        Step 3: convert your data to a PyTorch tensor. You can use helpder functions such as self.transform. e.g., data = self.transform(image)\n        Step 4: return a data point as a dictionary.\n        """"""\n        path = \'temp\'    # needs to be a string\n        data_A = None    # needs to be a tensor\n        data_B = None    # needs to be a tensor\n        return {\'data_A\': data_A, \'data_B\': data_B, \'path\': path}\n\n    def __len__(self):\n        """"""Return the total number of images.""""""\n        return len(self.image_paths)\n'"
data/unaligned_dataset.py,0,"b'import os.path\nfrom data.base_dataset import BaseDataset, get_transform\nfrom data.image_folder import make_dataset\nfrom PIL import Image\nimport random\n\n\nclass UnalignedDataset(BaseDataset):\n    """"""\n    This dataset class can load unaligned/unpaired datasets.\n\n    It requires two directories to host training images from domain A \'/path/to/data/trainA\'\n    and from domain B \'/path/to/data/trainB\' respectively.\n    You can train the model with the dataset flag \'--dataroot /path/to/data\'.\n    Similarly, you need to prepare two directories:\n    \'/path/to/data/testA\' and \'/path/to/data/testB\' during test time.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize this dataset class.\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseDataset.__init__(self, opt)\n        self.dir_A = os.path.join(opt.dataroot, opt.phase + \'A\')  # create a path \'/path/to/data/trainA\'\n        self.dir_B = os.path.join(opt.dataroot, opt.phase + \'B\')  # create a path \'/path/to/data/trainB\'\n\n        self.A_paths = sorted(make_dataset(self.dir_A, opt.max_dataset_size))   # load images from \'/path/to/data/trainA\'\n        self.B_paths = sorted(make_dataset(self.dir_B, opt.max_dataset_size))    # load images from \'/path/to/data/trainB\'\n        self.A_size = len(self.A_paths)  # get the size of dataset A\n        self.B_size = len(self.B_paths)  # get the size of dataset B\n        btoA = self.opt.direction == \'BtoA\'\n        input_nc = self.opt.output_nc if btoA else self.opt.input_nc       # get the number of channels of input image\n        output_nc = self.opt.input_nc if btoA else self.opt.output_nc      # get the number of channels of output image\n        self.transform_A = get_transform(self.opt, grayscale=(input_nc == 1))\n        self.transform_B = get_transform(self.opt, grayscale=(output_nc == 1))\n\n    def __getitem__(self, index):\n        """"""Return a data point and its metadata information.\n\n        Parameters:\n            index (int)      -- a random integer for data indexing\n\n        Returns a dictionary that contains A, B, A_paths and B_paths\n            A (tensor)       -- an image in the input domain\n            B (tensor)       -- its corresponding image in the target domain\n            A_paths (str)    -- image paths\n            B_paths (str)    -- image paths\n        """"""\n        A_path = self.A_paths[index % self.A_size]  # make sure index is within then range\n        if self.opt.serial_batches:   # make sure index is within then range\n            index_B = index % self.B_size\n        else:   # randomize the index for domain B to avoid fixed pairs.\n            index_B = random.randint(0, self.B_size - 1)\n        B_path = self.B_paths[index_B]\n        A_img = Image.open(A_path).convert(\'RGB\')\n        B_img = Image.open(B_path).convert(\'RGB\')\n        # apply image transformation\n        A = self.transform_A(A_img)\n        B = self.transform_B(B_img)\n\n        return {\'A\': A, \'B\': B, \'A_paths\': A_path, \'B_paths\': B_path}\n\n    def __len__(self):\n        """"""Return the total number of images in the dataset.\n\n        As we have two datasets with potentially different number of images,\n        we take a maximum of\n        """"""\n        return max(self.A_size, self.B_size)\n'"
datasets/combine_A_and_B.py,0,"b""import os\nimport numpy as np\nimport cv2\nimport argparse\n\nparser = argparse.ArgumentParser('create image pairs')\nparser.add_argument('--fold_A', dest='fold_A', help='input directory for image A', type=str, default='../dataset/50kshoes_edges')\nparser.add_argument('--fold_B', dest='fold_B', help='input directory for image B', type=str, default='../dataset/50kshoes_jpg')\nparser.add_argument('--fold_AB', dest='fold_AB', help='output directory', type=str, default='../dataset/test_AB')\nparser.add_argument('--num_imgs', dest='num_imgs', help='number of images', type=int, default=1000000)\nparser.add_argument('--use_AB', dest='use_AB', help='if true: (0001_A, 0001_B) to (0001_AB)', action='store_true')\nargs = parser.parse_args()\n\nfor arg in vars(args):\n    print('[%s] = ' % arg, getattr(args, arg))\n\nsplits = os.listdir(args.fold_A)\n\nfor sp in splits:\n    img_fold_A = os.path.join(args.fold_A, sp)\n    img_fold_B = os.path.join(args.fold_B, sp)\n    img_list = os.listdir(img_fold_A)\n    if args.use_AB:\n        img_list = [img_path for img_path in img_list if '_A.' in img_path]\n\n    num_imgs = min(args.num_imgs, len(img_list))\n    print('split = %s, use %d/%d images' % (sp, num_imgs, len(img_list)))\n    img_fold_AB = os.path.join(args.fold_AB, sp)\n    if not os.path.isdir(img_fold_AB):\n        os.makedirs(img_fold_AB)\n    print('split = %s, number of images = %d' % (sp, num_imgs))\n    for n in range(num_imgs):\n        name_A = img_list[n]\n        path_A = os.path.join(img_fold_A, name_A)\n        if args.use_AB:\n            name_B = name_A.replace('_A.', '_B.')\n        else:\n            name_B = name_A\n        path_B = os.path.join(img_fold_B, name_B)\n        if os.path.isfile(path_A) and os.path.isfile(path_B):\n            name_AB = name_A\n            if args.use_AB:\n                name_AB = name_AB.replace('_A.', '.')  # remove _A\n            path_AB = os.path.join(img_fold_AB, name_AB)\n            im_A = cv2.imread(path_A, 1) # python2: cv2.CV_LOAD_IMAGE_COLOR; python3: cv2.IMREAD_COLOR\n            im_B = cv2.imread(path_B, 1) # python2: cv2.CV_LOAD_IMAGE_COLOR; python3: cv2.IMREAD_COLOR\n            im_AB = np.concatenate([im_A, im_B], 1)\n            cv2.imwrite(path_AB, im_AB)\n"""
datasets/make_dataset_aligned.py,0,"b'import os\n\nfrom PIL import Image\n\n\ndef get_file_paths(folder):\n    image_file_paths = []\n    for root, dirs, filenames in os.walk(folder):\n        filenames = sorted(filenames)\n        for filename in filenames:\n            input_path = os.path.abspath(root)\n            file_path = os.path.join(input_path, filename)\n            if filename.endswith(\'.png\') or filename.endswith(\'.jpg\'):\n                image_file_paths.append(file_path)\n\n        break  # prevent descending into subfolders\n    return image_file_paths\n\n\ndef align_images(a_file_paths, b_file_paths, target_path):\n    if not os.path.exists(target_path):\n        os.makedirs(target_path)\n\n    for i in range(len(a_file_paths)):\n        img_a = Image.open(a_file_paths[i])\n        img_b = Image.open(b_file_paths[i])\n        assert(img_a.size == img_b.size)\n\n        aligned_image = Image.new(""RGB"", (img_a.size[0] * 2, img_a.size[1]))\n        aligned_image.paste(img_a, (0, 0))\n        aligned_image.paste(img_b, (img_a.size[0], 0))\n        aligned_image.save(os.path.join(target_path, \'{:04d}.jpg\'.format(i)))\n\n\nif __name__ == \'__main__\':\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \'--dataset-path\',\n        dest=\'dataset_path\',\n        help=\'Which folder to process (it should have subfolders testA, testB, trainA and trainB\'\n    )\n    args = parser.parse_args()\n\n    dataset_folder = args.dataset_path\n    print(dataset_folder)\n\n    test_a_path = os.path.join(dataset_folder, \'testA\')\n    test_b_path = os.path.join(dataset_folder, \'testB\')\n    test_a_file_paths = get_file_paths(test_a_path)\n    test_b_file_paths = get_file_paths(test_b_path)\n    assert(len(test_a_file_paths) == len(test_b_file_paths))\n    test_path = os.path.join(dataset_folder, \'test\')\n\n    train_a_path = os.path.join(dataset_folder, \'trainA\')\n    train_b_path = os.path.join(dataset_folder, \'trainB\')\n    train_a_file_paths = get_file_paths(train_a_path)\n    train_b_file_paths = get_file_paths(train_b_path)\n    assert(len(train_a_file_paths) == len(train_b_file_paths))\n    train_path = os.path.join(dataset_folder, \'train\')\n\n    align_images(test_a_file_paths, test_b_file_paths, test_path)\n    align_images(train_a_file_paths, train_b_file_paths, train_path)\n'"
datasets/prepare_cityscapes_dataset.py,0,"b'import os\nimport glob\nfrom PIL import Image\n\nhelp_msg = """"""\nThe dataset can be downloaded from https://cityscapes-dataset.com.\nPlease download the datasets [gtFine_trainvaltest.zip] and [leftImg8bit_trainvaltest.zip] and unzip them.\ngtFine contains the semantics segmentations. Use --gtFine_dir to specify the path to the unzipped gtFine_trainvaltest directory. \nleftImg8bit contains the dashcam photographs. Use --leftImg8bit_dir to specify the path to the unzipped leftImg8bit_trainvaltest directory. \nThe processed images will be placed at --output_dir.\n\nExample usage:\n\npython prepare_cityscapes_dataset.py --gitFine_dir ./gtFine/ --leftImg8bit_dir ./leftImg8bit --output_dir ./datasets/cityscapes/\n""""""\n\ndef load_resized_img(path):\n    return Image.open(path).convert(\'RGB\').resize((256, 256))\n\ndef check_matching_pair(segmap_path, photo_path):\n    segmap_identifier = os.path.basename(segmap_path).replace(\'_gtFine_color\', \'\')\n    photo_identifier = os.path.basename(photo_path).replace(\'_leftImg8bit\', \'\')\n        \n    assert segmap_identifier == photo_identifier, \\\n        ""[%s] and [%s] don\'t seem to be matching. Aborting."" % (segmap_path, photo_path)\n    \n\ndef process_cityscapes(gtFine_dir, leftImg8bit_dir, output_dir, phase):\n    save_phase = \'test\' if phase == \'val\' else \'train\'\n    savedir = os.path.join(output_dir, save_phase)\n    os.makedirs(savedir, exist_ok=True)\n    os.makedirs(savedir + \'A\', exist_ok=True)\n    os.makedirs(savedir + \'B\', exist_ok=True)\n    print(""Directory structure prepared at %s"" % output_dir)\n    \n    segmap_expr = os.path.join(gtFine_dir, phase) + ""/*/*_color.png""\n    segmap_paths = glob.glob(segmap_expr)\n    segmap_paths = sorted(segmap_paths)\n\n    photo_expr = os.path.join(leftImg8bit_dir, phase) + ""/*/*_leftImg8bit.png""\n    photo_paths = glob.glob(photo_expr)\n    photo_paths = sorted(photo_paths)\n\n    assert len(segmap_paths) == len(photo_paths), \\\n        ""%d images that match [%s], and %d images that match [%s]. Aborting."" % (len(segmap_paths), segmap_expr, len(photo_paths), photo_expr)\n\n    for i, (segmap_path, photo_path) in enumerate(zip(segmap_paths, photo_paths)):\n        check_matching_pair(segmap_path, photo_path)\n        segmap = load_resized_img(segmap_path)\n        photo = load_resized_img(photo_path)\n\n        # data for pix2pix where the two images are placed side-by-side\n        sidebyside = Image.new(\'RGB\', (512, 256))\n        sidebyside.paste(segmap, (256, 0))\n        sidebyside.paste(photo, (0, 0))\n        savepath = os.path.join(savedir, ""%d.jpg"" % i)\n        sidebyside.save(savepath, format=\'JPEG\', subsampling=0, quality=100)\n\n        # data for cyclegan where the two images are stored at two distinct directories\n        savepath = os.path.join(savedir + \'A\', ""%d_A.jpg"" % i)\n        photo.save(savepath, format=\'JPEG\', subsampling=0, quality=100)\n        savepath = os.path.join(savedir + \'B\', ""%d_B.jpg"" % i)\n        segmap.save(savepath, format=\'JPEG\', subsampling=0, quality=100)\n        \n        if i % (len(segmap_paths) // 10) == 0:\n            print(""%d / %d: last image saved at %s, "" % (i, len(segmap_paths), savepath))\n\n\n        \n        \n        \n        \n        \n    \n\n\nif __name__ == \'__main__\':\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--gtFine_dir\', type=str, required=True,\n                        help=\'Path to the Cityscapes gtFine directory.\')\n    parser.add_argument(\'--leftImg8bit_dir\', type=str, required=True,\n                        help=\'Path to the Cityscapes leftImg8bit_trainvaltest directory.\')\n    parser.add_argument(\'--output_dir\', type=str, required=True,\n                        default=\'./datasets/cityscapes\',\n                        help=\'Directory the output images will be written to.\')\n    opt = parser.parse_args()\n\n    print(help_msg)\n    \n    print(\'Preparing Cityscapes Dataset for val phase\')\n    process_cityscapes(opt.gtFine_dir, opt.leftImg8bit_dir, opt.output_dir, ""val"")\n    print(\'Preparing Cityscapes Dataset for train phase\')\n    process_cityscapes(opt.gtFine_dir, opt.leftImg8bit_dir, opt.output_dir, ""train"")\n\n    print(\'Done\')\n\n    \n\n'"
models/__init__.py,0,"b'""""""This package contains modules related to objective functions, optimizations, and network architectures.\n\nTo add a custom model class called \'dummy\', you need to add a file called \'dummy_model.py\' and define a subclass DummyModel inherited from BaseModel.\nYou need to implement the following five functions:\n    -- <__init__>:                      initialize the class; first call BaseModel.__init__(self, opt).\n    -- <set_input>:                     unpack data from dataset and apply preprocessing.\n    -- <forward>:                       produce intermediate results.\n    -- <optimize_parameters>:           calculate loss, gradients, and update network weights.\n    -- <modify_commandline_options>:    (optionally) add model-specific options and set default options.\n\nIn the function <__init__>, you need to define four lists:\n    -- self.loss_names (str list):          specify the training losses that you want to plot and save.\n    -- self.model_names (str list):         define networks used in our training.\n    -- self.visual_names (str list):        specify the images that you want to display and save.\n    -- self.optimizers (optimizer list):    define and initialize optimizers. You can define one optimizer for each network. If two networks are updated at the same time, you can use itertools.chain to group them. See cycle_gan_model.py for an usage.\n\nNow you can use the model class by specifying flag \'--model dummy\'.\nSee our template model class \'template_model.py\' for more details.\n""""""\n\nimport importlib\nfrom models.base_model import BaseModel\n\n\ndef find_model_using_name(model_name):\n    """"""Import the module ""models/[model_name]_model.py"".\n\n    In the file, the class called DatasetNameModel() will\n    be instantiated. It has to be a subclass of BaseModel,\n    and it is case-insensitive.\n    """"""\n    model_filename = ""models."" + model_name + ""_model""\n    modellib = importlib.import_module(model_filename)\n    model = None\n    target_model_name = model_name.replace(\'_\', \'\') + \'model\'\n    for name, cls in modellib.__dict__.items():\n        if name.lower() == target_model_name.lower() \\\n           and issubclass(cls, BaseModel):\n            model = cls\n\n    if model is None:\n        print(""In %s.py, there should be a subclass of BaseModel with class name that matches %s in lowercase."" % (model_filename, target_model_name))\n        exit(0)\n\n    return model\n\n\ndef get_option_setter(model_name):\n    """"""Return the static method <modify_commandline_options> of the model class.""""""\n    model_class = find_model_using_name(model_name)\n    return model_class.modify_commandline_options\n\n\ndef create_model(opt):\n    """"""Create a model given the option.\n\n    This function warps the class CustomDatasetDataLoader.\n    This is the main interface between this package and \'train.py\'/\'test.py\'\n\n    Example:\n        >>> from models import create_model\n        >>> model = create_model(opt)\n    """"""\n    model = find_model_using_name(opt.model)\n    instance = model(opt)\n    print(""model [%s] was created"" % type(instance).__name__)\n    return instance\n'"
models/base_model.py,8,"b'import os\nimport torch\nfrom collections import OrderedDict\nfrom abc import ABC, abstractmethod\nfrom . import networks\n\n\nclass BaseModel(ABC):\n    """"""This class is an abstract base class (ABC) for models.\n    To create a subclass, you need to implement the following five functions:\n        -- <__init__>:                      initialize the class; first call BaseModel.__init__(self, opt).\n        -- <set_input>:                     unpack data from dataset and apply preprocessing.\n        -- <forward>:                       produce intermediate results.\n        -- <optimize_parameters>:           calculate losses, gradients, and update network weights.\n        -- <modify_commandline_options>:    (optionally) add model-specific options and set default options.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize the BaseModel class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n\n        When creating your custom class, you need to implement your own initialization.\n        In this function, you should first call <BaseModel.__init__(self, opt)>\n        Then, you need to define four lists:\n            -- self.loss_names (str list):          specify the training losses that you want to plot and save.\n            -- self.model_names (str list):         define networks used in our training.\n            -- self.visual_names (str list):        specify the images that you want to display and save.\n            -- self.optimizers (optimizer list):    define and initialize optimizers. You can define one optimizer for each network. If two networks are updated at the same time, you can use itertools.chain to group them. See cycle_gan_model.py for an example.\n        """"""\n        self.opt = opt\n        self.gpu_ids = opt.gpu_ids\n        self.isTrain = opt.isTrain\n        self.device = torch.device(\'cuda:{}\'.format(self.gpu_ids[0])) if self.gpu_ids else torch.device(\'cpu\')  # get device name: CPU or GPU\n        self.save_dir = os.path.join(opt.checkpoints_dir, opt.name)  # save all the checkpoints to save_dir\n        if opt.preprocess != \'scale_width\':  # with [scale_width], input images might have different sizes, which hurts the performance of cudnn.benchmark.\n            torch.backends.cudnn.benchmark = True\n        self.loss_names = []\n        self.model_names = []\n        self.visual_names = []\n        self.optimizers = []\n        self.image_paths = []\n        self.metric = 0  # used for learning rate policy \'plateau\'\n\n    @staticmethod\n    def modify_commandline_options(parser, is_train):\n        """"""Add new model-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        return parser\n\n    @abstractmethod\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input (dict): includes the data itself and its metadata information.\n        """"""\n        pass\n\n    @abstractmethod\n    def forward(self):\n        """"""Run forward pass; called by both functions <optimize_parameters> and <test>.""""""\n        pass\n\n    @abstractmethod\n    def optimize_parameters(self):\n        """"""Calculate losses, gradients, and update network weights; called in every training iteration""""""\n        pass\n\n    def setup(self, opt):\n        """"""Load and print networks; create schedulers\n\n        Parameters:\n            opt (Option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        if self.isTrain:\n            self.schedulers = [networks.get_scheduler(optimizer, opt) for optimizer in self.optimizers]\n        if not self.isTrain or opt.continue_train:\n            load_suffix = \'iter_%d\' % opt.load_iter if opt.load_iter > 0 else opt.epoch\n            self.load_networks(load_suffix)\n        self.print_networks(opt.verbose)\n\n    def eval(self):\n        """"""Make models eval mode during test time""""""\n        for name in self.model_names:\n            if isinstance(name, str):\n                net = getattr(self, \'net\' + name)\n                net.eval()\n\n    def test(self):\n        """"""Forward function used in test time.\n\n        This function wraps <forward> function in no_grad() so we don\'t save intermediate steps for backprop\n        It also calls <compute_visuals> to produce additional visualization results\n        """"""\n        with torch.no_grad():\n            self.forward()\n            self.compute_visuals()\n\n    def compute_visuals(self):\n        """"""Calculate additional output images for visdom and HTML visualization""""""\n        pass\n\n    def get_image_paths(self):\n        """""" Return image paths that are used to load current data""""""\n        return self.image_paths\n\n    def update_learning_rate(self):\n        """"""Update learning rates for all the networks; called at the end of every epoch""""""\n        for scheduler in self.schedulers:\n            if self.opt.lr_policy == \'plateau\':\n                scheduler.step(self.metric)\n            else:\n                scheduler.step()\n\n        lr = self.optimizers[0].param_groups[0][\'lr\']\n        print(\'learning rate = %.7f\' % lr)\n\n    def get_current_visuals(self):\n        """"""Return visualization images. train.py will display these images with visdom, and save the images to a HTML""""""\n        visual_ret = OrderedDict()\n        for name in self.visual_names:\n            if isinstance(name, str):\n                visual_ret[name] = getattr(self, name)\n        return visual_ret\n\n    def get_current_losses(self):\n        """"""Return traning losses / errors. train.py will print out these errors on console, and save them to a file""""""\n        errors_ret = OrderedDict()\n        for name in self.loss_names:\n            if isinstance(name, str):\n                errors_ret[name] = float(getattr(self, \'loss_\' + name))  # float(...) works for both scalar tensor and float number\n        return errors_ret\n\n    def save_networks(self, epoch):\n        """"""Save all the networks to the disk.\n\n        Parameters:\n            epoch (int) -- current epoch; used in the file name \'%s_net_%s.pth\' % (epoch, name)\n        """"""\n        for name in self.model_names:\n            if isinstance(name, str):\n                save_filename = \'%s_net_%s.pth\' % (epoch, name)\n                save_path = os.path.join(self.save_dir, save_filename)\n                net = getattr(self, \'net\' + name)\n\n                if len(self.gpu_ids) > 0 and torch.cuda.is_available():\n                    torch.save(net.module.cpu().state_dict(), save_path)\n                    net.cuda(self.gpu_ids[0])\n                else:\n                    torch.save(net.cpu().state_dict(), save_path)\n\n    def __patch_instance_norm_state_dict(self, state_dict, module, keys, i=0):\n        """"""Fix InstanceNorm checkpoints incompatibility (prior to 0.4)""""""\n        key = keys[i]\n        if i + 1 == len(keys):  # at the end, pointing to a parameter/buffer\n            if module.__class__.__name__.startswith(\'InstanceNorm\') and \\\n                    (key == \'running_mean\' or key == \'running_var\'):\n                if getattr(module, key) is None:\n                    state_dict.pop(\'.\'.join(keys))\n            if module.__class__.__name__.startswith(\'InstanceNorm\') and \\\n               (key == \'num_batches_tracked\'):\n                state_dict.pop(\'.\'.join(keys))\n        else:\n            self.__patch_instance_norm_state_dict(state_dict, getattr(module, key), keys, i + 1)\n\n    def load_networks(self, epoch):\n        """"""Load all the networks from the disk.\n\n        Parameters:\n            epoch (int) -- current epoch; used in the file name \'%s_net_%s.pth\' % (epoch, name)\n        """"""\n        for name in self.model_names:\n            if isinstance(name, str):\n                load_filename = \'%s_net_%s.pth\' % (epoch, name)\n                load_path = os.path.join(self.save_dir, load_filename)\n                net = getattr(self, \'net\' + name)\n                if isinstance(net, torch.nn.DataParallel):\n                    net = net.module\n                print(\'loading the model from %s\' % load_path)\n                # if you are using PyTorch newer than 0.4 (e.g., built from\n                # GitHub source), you can remove str() on self.device\n                state_dict = torch.load(load_path, map_location=str(self.device))\n                if hasattr(state_dict, \'_metadata\'):\n                    del state_dict._metadata\n\n                # patch InstanceNorm checkpoints prior to 0.4\n                for key in list(state_dict.keys()):  # need to copy keys here because we mutate in loop\n                    self.__patch_instance_norm_state_dict(state_dict, net, key.split(\'.\'))\n                net.load_state_dict(state_dict)\n\n    def print_networks(self, verbose):\n        """"""Print the total number of parameters in the network and (if verbose) network architecture\n\n        Parameters:\n            verbose (bool) -- if verbose: print the network architecture\n        """"""\n        print(\'---------- Networks initialized -------------\')\n        for name in self.model_names:\n            if isinstance(name, str):\n                net = getattr(self, \'net\' + name)\n                num_params = 0\n                for param in net.parameters():\n                    num_params += param.numel()\n                if verbose:\n                    print(net)\n                print(\'[Network %s] Total number of parameters : %.3f M\' % (name, num_params / 1e6))\n        print(\'-----------------------------------------------\')\n\n    def set_requires_grad(self, nets, requires_grad=False):\n        """"""Set requies_grad=Fasle for all the networks to avoid unnecessary computations\n        Parameters:\n            nets (network list)   -- a list of networks\n            requires_grad (bool)  -- whether the networks require gradients or not\n        """"""\n        if not isinstance(nets, list):\n            nets = [nets]\n        for net in nets:\n            if net is not None:\n                for param in net.parameters():\n                    param.requires_grad = requires_grad\n'"
models/colorization_model.py,1,"b'from .pix2pix_model import Pix2PixModel\nimport torch\nfrom skimage import color  # used for lab2rgb\nimport numpy as np\n\n\nclass ColorizationModel(Pix2PixModel):\n    """"""This is a subclass of Pix2PixModel for image colorization (black & white image -> colorful images).\n\n    The model training requires \'-dataset_model colorization\' dataset.\n    It trains a pix2pix model, mapping from L channel to ab channels in Lab color space.\n    By default, the colorization dataset will automatically set \'--input_nc 1\' and \'--output_nc 2\'.\n    """"""\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n\n        By default, we use \'colorization\' dataset for this model.\n        See the original pix2pix paper (https://arxiv.org/pdf/1611.07004.pdf) and colorization results (Figure 9 in the paper)\n        """"""\n        Pix2PixModel.modify_commandline_options(parser, is_train)\n        parser.set_defaults(dataset_mode=\'colorization\')\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize the class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n\n        For visualization, we set \'visual_names\' as \'real_A\' (input real image),\n        \'real_B_rgb\' (ground truth RGB image), and \'fake_B_rgb\' (predicted RGB image)\n        We convert the Lab image \'real_B\' (inherited from Pix2pixModel) to a RGB image \'real_B_rgb\'.\n        we convert the Lab image \'fake_B\' (inherited from Pix2pixModel) to a RGB image \'fake_B_rgb\'.\n        """"""\n        # reuse the pix2pix model\n        Pix2PixModel.__init__(self, opt)\n        # specify the images to be visualized.\n        self.visual_names = [\'real_A\', \'real_B_rgb\', \'fake_B_rgb\']\n\n    def lab2rgb(self, L, AB):\n        """"""Convert an Lab tensor image to a RGB numpy output\n        Parameters:\n            L  (1-channel tensor array): L channel images (range: [-1, 1], torch tensor array)\n            AB (2-channel tensor array):  ab channel images (range: [-1, 1], torch tensor array)\n\n        Returns:\n            rgb (RGB numpy image): rgb output images  (range: [0, 255], numpy array)\n        """"""\n        AB2 = AB * 110.0\n        L2 = (L + 1.0) * 50.0\n        Lab = torch.cat([L2, AB2], dim=1)\n        Lab = Lab[0].data.cpu().float().numpy()\n        Lab = np.transpose(Lab.astype(np.float64), (1, 2, 0))\n        rgb = color.lab2rgb(Lab) * 255\n        return rgb\n\n    def compute_visuals(self):\n        """"""Calculate additional output images for visdom and HTML visualization""""""\n        self.real_B_rgb = self.lab2rgb(self.real_A, self.real_B)\n        self.fake_B_rgb = self.lab2rgb(self.real_A, self.fake_B)\n'"
models/cycle_gan_model.py,4,"b'import torch\nimport itertools\nfrom util.image_pool import ImagePool\nfrom .base_model import BaseModel\nfrom . import networks\n\n\nclass CycleGANModel(BaseModel):\n    """"""\n    This class implements the CycleGAN model, for learning image-to-image translation without paired data.\n\n    The model training requires \'--dataset_mode unaligned\' dataset.\n    By default, it uses a \'--netG resnet_9blocks\' ResNet generator,\n    a \'--netD basic\' discriminator (PatchGAN introduced by pix2pix),\n    and a least-square GANs objective (\'--gan_mode lsgan\').\n\n    CycleGAN paper: https://arxiv.org/pdf/1703.10593.pdf\n    """"""\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n\n        For CycleGAN, in addition to GAN losses, we introduce lambda_A, lambda_B, and lambda_identity for the following losses.\n        A (source domain), B (target domain).\n        Generators: G_A: A -> B; G_B: B -> A.\n        Discriminators: D_A: G_A(A) vs. B; D_B: G_B(B) vs. A.\n        Forward cycle loss:  lambda_A * ||G_B(G_A(A)) - A|| (Eqn. (2) in the paper)\n        Backward cycle loss: lambda_B * ||G_A(G_B(B)) - B|| (Eqn. (2) in the paper)\n        Identity loss (optional): lambda_identity * (||G_A(B) - B|| * lambda_B + ||G_B(A) - A|| * lambda_A) (Sec 5.2 ""Photo generation from paintings"" in the paper)\n        Dropout is not used in the original CycleGAN paper.\n        """"""\n        parser.set_defaults(no_dropout=True)  # default CycleGAN did not use dropout\n        if is_train:\n            parser.add_argument(\'--lambda_A\', type=float, default=10.0, help=\'weight for cycle loss (A -> B -> A)\')\n            parser.add_argument(\'--lambda_B\', type=float, default=10.0, help=\'weight for cycle loss (B -> A -> B)\')\n            parser.add_argument(\'--lambda_identity\', type=float, default=0.5, help=\'use identity mapping. Setting lambda_identity other than 0 has an effect of scaling the weight of the identity mapping loss. For example, if the weight of the identity loss should be 10 times smaller than the weight of the reconstruction loss, please set lambda_identity = 0.1\')\n\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize the CycleGAN class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseModel.__init__(self, opt)\n        # specify the training losses you want to print out. The training/test scripts will call <BaseModel.get_current_losses>\n        self.loss_names = [\'D_A\', \'G_A\', \'cycle_A\', \'idt_A\', \'D_B\', \'G_B\', \'cycle_B\', \'idt_B\']\n        # specify the images you want to save/display. The training/test scripts will call <BaseModel.get_current_visuals>\n        visual_names_A = [\'real_A\', \'fake_B\', \'rec_A\']\n        visual_names_B = [\'real_B\', \'fake_A\', \'rec_B\']\n        if self.isTrain and self.opt.lambda_identity > 0.0:  # if identity loss is used, we also visualize idt_B=G_A(B) ad idt_A=G_A(B)\n            visual_names_A.append(\'idt_B\')\n            visual_names_B.append(\'idt_A\')\n\n        self.visual_names = visual_names_A + visual_names_B  # combine visualizations for A and B\n        # specify the models you want to save to the disk. The training/test scripts will call <BaseModel.save_networks> and <BaseModel.load_networks>.\n        if self.isTrain:\n            self.model_names = [\'G_A\', \'G_B\', \'D_A\', \'D_B\']\n        else:  # during test time, only load Gs\n            self.model_names = [\'G_A\', \'G_B\']\n\n        # define networks (both Generators and discriminators)\n        # The naming is different from those used in the paper.\n        # Code (vs. paper): G_A (G), G_B (F), D_A (D_Y), D_B (D_X)\n        self.netG_A = networks.define_G(opt.input_nc, opt.output_nc, opt.ngf, opt.netG, opt.norm,\n                                        not opt.no_dropout, opt.init_type, opt.init_gain, self.gpu_ids)\n        self.netG_B = networks.define_G(opt.output_nc, opt.input_nc, opt.ngf, opt.netG, opt.norm,\n                                        not opt.no_dropout, opt.init_type, opt.init_gain, self.gpu_ids)\n\n        if self.isTrain:  # define discriminators\n            self.netD_A = networks.define_D(opt.output_nc, opt.ndf, opt.netD,\n                                            opt.n_layers_D, opt.norm, opt.init_type, opt.init_gain, self.gpu_ids)\n            self.netD_B = networks.define_D(opt.input_nc, opt.ndf, opt.netD,\n                                            opt.n_layers_D, opt.norm, opt.init_type, opt.init_gain, self.gpu_ids)\n\n        if self.isTrain:\n            if opt.lambda_identity > 0.0:  # only works when input and output images have the same number of channels\n                assert(opt.input_nc == opt.output_nc)\n            self.fake_A_pool = ImagePool(opt.pool_size)  # create image buffer to store previously generated images\n            self.fake_B_pool = ImagePool(opt.pool_size)  # create image buffer to store previously generated images\n            # define loss functions\n            self.criterionGAN = networks.GANLoss(opt.gan_mode).to(self.device)  # define GAN loss.\n            self.criterionCycle = torch.nn.L1Loss()\n            self.criterionIdt = torch.nn.L1Loss()\n            # initialize optimizers; schedulers will be automatically created by function <BaseModel.setup>.\n            self.optimizer_G = torch.optim.Adam(itertools.chain(self.netG_A.parameters(), self.netG_B.parameters()), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizer_D = torch.optim.Adam(itertools.chain(self.netD_A.parameters(), self.netD_B.parameters()), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizers.append(self.optimizer_G)\n            self.optimizers.append(self.optimizer_D)\n\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input (dict): include the data itself and its metadata information.\n\n        The option \'direction\' can be used to swap domain A and domain B.\n        """"""\n        AtoB = self.opt.direction == \'AtoB\'\n        self.real_A = input[\'A\' if AtoB else \'B\'].to(self.device)\n        self.real_B = input[\'B\' if AtoB else \'A\'].to(self.device)\n        self.image_paths = input[\'A_paths\' if AtoB else \'B_paths\']\n\n    def forward(self):\n        """"""Run forward pass; called by both functions <optimize_parameters> and <test>.""""""\n        self.fake_B = self.netG_A(self.real_A)  # G_A(A)\n        self.rec_A = self.netG_B(self.fake_B)   # G_B(G_A(A))\n        self.fake_A = self.netG_B(self.real_B)  # G_B(B)\n        self.rec_B = self.netG_A(self.fake_A)   # G_A(G_B(B))\n\n    def backward_D_basic(self, netD, real, fake):\n        """"""Calculate GAN loss for the discriminator\n\n        Parameters:\n            netD (network)      -- the discriminator D\n            real (tensor array) -- real images\n            fake (tensor array) -- images generated by a generator\n\n        Return the discriminator loss.\n        We also call loss_D.backward() to calculate the gradients.\n        """"""\n        # Real\n        pred_real = netD(real)\n        loss_D_real = self.criterionGAN(pred_real, True)\n        # Fake\n        pred_fake = netD(fake.detach())\n        loss_D_fake = self.criterionGAN(pred_fake, False)\n        # Combined loss and calculate gradients\n        loss_D = (loss_D_real + loss_D_fake) * 0.5\n        loss_D.backward()\n        return loss_D\n\n    def backward_D_A(self):\n        """"""Calculate GAN loss for discriminator D_A""""""\n        fake_B = self.fake_B_pool.query(self.fake_B)\n        self.loss_D_A = self.backward_D_basic(self.netD_A, self.real_B, fake_B)\n\n    def backward_D_B(self):\n        """"""Calculate GAN loss for discriminator D_B""""""\n        fake_A = self.fake_A_pool.query(self.fake_A)\n        self.loss_D_B = self.backward_D_basic(self.netD_B, self.real_A, fake_A)\n\n    def backward_G(self):\n        """"""Calculate the loss for generators G_A and G_B""""""\n        lambda_idt = self.opt.lambda_identity\n        lambda_A = self.opt.lambda_A\n        lambda_B = self.opt.lambda_B\n        # Identity loss\n        if lambda_idt > 0:\n            # G_A should be identity if real_B is fed: ||G_A(B) - B||\n            self.idt_A = self.netG_A(self.real_B)\n            self.loss_idt_A = self.criterionIdt(self.idt_A, self.real_B) * lambda_B * lambda_idt\n            # G_B should be identity if real_A is fed: ||G_B(A) - A||\n            self.idt_B = self.netG_B(self.real_A)\n            self.loss_idt_B = self.criterionIdt(self.idt_B, self.real_A) * lambda_A * lambda_idt\n        else:\n            self.loss_idt_A = 0\n            self.loss_idt_B = 0\n\n        # GAN loss D_A(G_A(A))\n        self.loss_G_A = self.criterionGAN(self.netD_A(self.fake_B), True)\n        # GAN loss D_B(G_B(B))\n        self.loss_G_B = self.criterionGAN(self.netD_B(self.fake_A), True)\n        # Forward cycle loss || G_B(G_A(A)) - A||\n        self.loss_cycle_A = self.criterionCycle(self.rec_A, self.real_A) * lambda_A\n        # Backward cycle loss || G_A(G_B(B)) - B||\n        self.loss_cycle_B = self.criterionCycle(self.rec_B, self.real_B) * lambda_B\n        # combined loss and calculate gradients\n        self.loss_G = self.loss_G_A + self.loss_G_B + self.loss_cycle_A + self.loss_cycle_B + self.loss_idt_A + self.loss_idt_B\n        self.loss_G.backward()\n\n    def optimize_parameters(self):\n        """"""Calculate losses, gradients, and update network weights; called in every training iteration""""""\n        # forward\n        self.forward()      # compute fake images and reconstruction images.\n        # G_A and G_B\n        self.set_requires_grad([self.netD_A, self.netD_B], False)  # Ds require no gradients when optimizing Gs\n        self.optimizer_G.zero_grad()  # set G_A and G_B\'s gradients to zero\n        self.backward_G()             # calculate gradients for G_A and G_B\n        self.optimizer_G.step()       # update G_A and G_B\'s weights\n        # D_A and D_B\n        self.set_requires_grad([self.netD_A, self.netD_B], True)\n        self.optimizer_D.zero_grad()   # set D_A and D_B\'s gradients to zero\n        self.backward_D_A()      # calculate gradients for D_A\n        self.backward_D_B()      # calculate graidents for D_B\n        self.optimizer_D.step()  # update D_A and D_B\'s weights\n'"
models/networks.py,13,"b'import torch\nimport torch.nn as nn\nfrom torch.nn import init\nimport functools\nfrom torch.optim import lr_scheduler\n\n\n###############################################################################\n# Helper Functions\n###############################################################################\n\n\nclass Identity(nn.Module):\n    def forward(self, x):\n        return x\n\n\ndef get_norm_layer(norm_type=\'instance\'):\n    """"""Return a normalization layer\n\n    Parameters:\n        norm_type (str) -- the name of the normalization layer: batch | instance | none\n\n    For BatchNorm, we use learnable affine parameters and track running statistics (mean/stddev).\n    For InstanceNorm, we do not use learnable affine parameters. We do not track running statistics.\n    """"""\n    if norm_type == \'batch\':\n        norm_layer = functools.partial(nn.BatchNorm2d, affine=True, track_running_stats=True)\n    elif norm_type == \'instance\':\n        norm_layer = functools.partial(nn.InstanceNorm2d, affine=False, track_running_stats=False)\n    elif norm_type == \'none\':\n        def norm_layer(x): return Identity()\n    else:\n        raise NotImplementedError(\'normalization layer [%s] is not found\' % norm_type)\n    return norm_layer\n\n\ndef get_scheduler(optimizer, opt):\n    """"""Return a learning rate scheduler\n\n    Parameters:\n        optimizer          -- the optimizer of the network\n        opt (option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\xef\xbc\x8e\xe3\x80\x80\n                              opt.lr_policy is the name of learning rate policy: linear | step | plateau | cosine\n\n    For \'linear\', we keep the same learning rate for the first <opt.n_epochs> epochs\n    and linearly decay the rate to zero over the next <opt.n_epochs_decay> epochs.\n    For other schedulers (step, plateau, and cosine), we use the default PyTorch schedulers.\n    See https://pytorch.org/docs/stable/optim.html for more details.\n    """"""\n    if opt.lr_policy == \'linear\':\n        def lambda_rule(epoch):\n            lr_l = 1.0 - max(0, epoch + opt.epoch_count - opt.n_epochs) / float(opt.n_epochs_decay + 1)\n            return lr_l\n        scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda_rule)\n    elif opt.lr_policy == \'step\':\n        scheduler = lr_scheduler.StepLR(optimizer, step_size=opt.lr_decay_iters, gamma=0.1)\n    elif opt.lr_policy == \'plateau\':\n        scheduler = lr_scheduler.ReduceLROnPlateau(optimizer, mode=\'min\', factor=0.2, threshold=0.01, patience=5)\n    elif opt.lr_policy == \'cosine\':\n        scheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=opt.n_epochs, eta_min=0)\n    else:\n        return NotImplementedError(\'learning rate policy [%s] is not implemented\', opt.lr_policy)\n    return scheduler\n\n\ndef init_weights(net, init_type=\'normal\', init_gain=0.02):\n    """"""Initialize network weights.\n\n    Parameters:\n        net (network)   -- network to be initialized\n        init_type (str) -- the name of an initialization method: normal | xavier | kaiming | orthogonal\n        init_gain (float)    -- scaling factor for normal, xavier and orthogonal.\n\n    We use \'normal\' in the original pix2pix and CycleGAN paper. But xavier and kaiming might\n    work better for some applications. Feel free to try yourself.\n    """"""\n    def init_func(m):  # define the initialization function\n        classname = m.__class__.__name__\n        if hasattr(m, \'weight\') and (classname.find(\'Conv\') != -1 or classname.find(\'Linear\') != -1):\n            if init_type == \'normal\':\n                init.normal_(m.weight.data, 0.0, init_gain)\n            elif init_type == \'xavier\':\n                init.xavier_normal_(m.weight.data, gain=init_gain)\n            elif init_type == \'kaiming\':\n                init.kaiming_normal_(m.weight.data, a=0, mode=\'fan_in\')\n            elif init_type == \'orthogonal\':\n                init.orthogonal_(m.weight.data, gain=init_gain)\n            else:\n                raise NotImplementedError(\'initialization method [%s] is not implemented\' % init_type)\n            if hasattr(m, \'bias\') and m.bias is not None:\n                init.constant_(m.bias.data, 0.0)\n        elif classname.find(\'BatchNorm2d\') != -1:  # BatchNorm Layer\'s weight is not a matrix; only normal distribution applies.\n            init.normal_(m.weight.data, 1.0, init_gain)\n            init.constant_(m.bias.data, 0.0)\n\n    print(\'initialize network with %s\' % init_type)\n    net.apply(init_func)  # apply the initialization function <init_func>\n\n\ndef init_net(net, init_type=\'normal\', init_gain=0.02, gpu_ids=[]):\n    """"""Initialize a network: 1. register CPU/GPU device (with multi-GPU support); 2. initialize the network weights\n    Parameters:\n        net (network)      -- the network to be initialized\n        init_type (str)    -- the name of an initialization method: normal | xavier | kaiming | orthogonal\n        gain (float)       -- scaling factor for normal, xavier and orthogonal.\n        gpu_ids (int list) -- which GPUs the network runs on: e.g., 0,1,2\n\n    Return an initialized network.\n    """"""\n    if len(gpu_ids) > 0:\n        assert(torch.cuda.is_available())\n        net.to(gpu_ids[0])\n        net = torch.nn.DataParallel(net, gpu_ids)  # multi-GPUs\n    init_weights(net, init_type, init_gain=init_gain)\n    return net\n\n\ndef define_G(input_nc, output_nc, ngf, netG, norm=\'batch\', use_dropout=False, init_type=\'normal\', init_gain=0.02, gpu_ids=[]):\n    """"""Create a generator\n\n    Parameters:\n        input_nc (int) -- the number of channels in input images\n        output_nc (int) -- the number of channels in output images\n        ngf (int) -- the number of filters in the last conv layer\n        netG (str) -- the architecture\'s name: resnet_9blocks | resnet_6blocks | unet_256 | unet_128\n        norm (str) -- the name of normalization layers used in the network: batch | instance | none\n        use_dropout (bool) -- if use dropout layers.\n        init_type (str)    -- the name of our initialization method.\n        init_gain (float)  -- scaling factor for normal, xavier and orthogonal.\n        gpu_ids (int list) -- which GPUs the network runs on: e.g., 0,1,2\n\n    Returns a generator\n\n    Our current implementation provides two types of generators:\n        U-Net: [unet_128] (for 128x128 input images) and [unet_256] (for 256x256 input images)\n        The original U-Net paper: https://arxiv.org/abs/1505.04597\n\n        Resnet-based generator: [resnet_6blocks] (with 6 Resnet blocks) and [resnet_9blocks] (with 9 Resnet blocks)\n        Resnet-based generator consists of several Resnet blocks between a few downsampling/upsampling operations.\n        We adapt Torch code from Justin Johnson\'s neural style transfer project (https://github.com/jcjohnson/fast-neural-style).\n\n\n    The generator has been initialized by <init_net>. It uses RELU for non-linearity.\n    """"""\n    net = None\n    norm_layer = get_norm_layer(norm_type=norm)\n\n    if netG == \'resnet_9blocks\':\n        net = ResnetGenerator(input_nc, output_nc, ngf, norm_layer=norm_layer, use_dropout=use_dropout, n_blocks=9)\n    elif netG == \'resnet_6blocks\':\n        net = ResnetGenerator(input_nc, output_nc, ngf, norm_layer=norm_layer, use_dropout=use_dropout, n_blocks=6)\n    elif netG == \'unet_128\':\n        net = UnetGenerator(input_nc, output_nc, 7, ngf, norm_layer=norm_layer, use_dropout=use_dropout)\n    elif netG == \'unet_256\':\n        net = UnetGenerator(input_nc, output_nc, 8, ngf, norm_layer=norm_layer, use_dropout=use_dropout)\n    else:\n        raise NotImplementedError(\'Generator model name [%s] is not recognized\' % netG)\n    return init_net(net, init_type, init_gain, gpu_ids)\n\n\ndef define_D(input_nc, ndf, netD, n_layers_D=3, norm=\'batch\', init_type=\'normal\', init_gain=0.02, gpu_ids=[]):\n    """"""Create a discriminator\n\n    Parameters:\n        input_nc (int)     -- the number of channels in input images\n        ndf (int)          -- the number of filters in the first conv layer\n        netD (str)         -- the architecture\'s name: basic | n_layers | pixel\n        n_layers_D (int)   -- the number of conv layers in the discriminator; effective when netD==\'n_layers\'\n        norm (str)         -- the type of normalization layers used in the network.\n        init_type (str)    -- the name of the initialization method.\n        init_gain (float)  -- scaling factor for normal, xavier and orthogonal.\n        gpu_ids (int list) -- which GPUs the network runs on: e.g., 0,1,2\n\n    Returns a discriminator\n\n    Our current implementation provides three types of discriminators:\n        [basic]: \'PatchGAN\' classifier described in the original pix2pix paper.\n        It can classify whether 70\xc3\x9770 overlapping patches are real or fake.\n        Such a patch-level discriminator architecture has fewer parameters\n        than a full-image discriminator and can work on arbitrarily-sized images\n        in a fully convolutional fashion.\n\n        [n_layers]: With this mode, you can specify the number of conv layers in the discriminator\n        with the parameter <n_layers_D> (default=3 as used in [basic] (PatchGAN).)\n\n        [pixel]: 1x1 PixelGAN discriminator can classify whether a pixel is real or not.\n        It encourages greater color diversity but has no effect on spatial statistics.\n\n    The discriminator has been initialized by <init_net>. It uses Leakly RELU for non-linearity.\n    """"""\n    net = None\n    norm_layer = get_norm_layer(norm_type=norm)\n\n    if netD == \'basic\':  # default PatchGAN classifier\n        net = NLayerDiscriminator(input_nc, ndf, n_layers=3, norm_layer=norm_layer)\n    elif netD == \'n_layers\':  # more options\n        net = NLayerDiscriminator(input_nc, ndf, n_layers_D, norm_layer=norm_layer)\n    elif netD == \'pixel\':     # classify if each pixel is real or fake\n        net = PixelDiscriminator(input_nc, ndf, norm_layer=norm_layer)\n    else:\n        raise NotImplementedError(\'Discriminator model name [%s] is not recognized\' % netD)\n    return init_net(net, init_type, init_gain, gpu_ids)\n\n\n##############################################################################\n# Classes\n##############################################################################\nclass GANLoss(nn.Module):\n    """"""Define different GAN objectives.\n\n    The GANLoss class abstracts away the need to create the target label tensor\n    that has the same size as the input.\n    """"""\n\n    def __init__(self, gan_mode, target_real_label=1.0, target_fake_label=0.0):\n        """""" Initialize the GANLoss class.\n\n        Parameters:\n            gan_mode (str) - - the type of GAN objective. It currently supports vanilla, lsgan, and wgangp.\n            target_real_label (bool) - - label for a real image\n            target_fake_label (bool) - - label of a fake image\n\n        Note: Do not use sigmoid as the last layer of Discriminator.\n        LSGAN needs no sigmoid. vanilla GANs will handle it with BCEWithLogitsLoss.\n        """"""\n        super(GANLoss, self).__init__()\n        self.register_buffer(\'real_label\', torch.tensor(target_real_label))\n        self.register_buffer(\'fake_label\', torch.tensor(target_fake_label))\n        self.gan_mode = gan_mode\n        if gan_mode == \'lsgan\':\n            self.loss = nn.MSELoss()\n        elif gan_mode == \'vanilla\':\n            self.loss = nn.BCEWithLogitsLoss()\n        elif gan_mode in [\'wgangp\']:\n            self.loss = None\n        else:\n            raise NotImplementedError(\'gan mode %s not implemented\' % gan_mode)\n\n    def get_target_tensor(self, prediction, target_is_real):\n        """"""Create label tensors with the same size as the input.\n\n        Parameters:\n            prediction (tensor) - - tpyically the prediction from a discriminator\n            target_is_real (bool) - - if the ground truth label is for real images or fake images\n\n        Returns:\n            A label tensor filled with ground truth label, and with the size of the input\n        """"""\n\n        if target_is_real:\n            target_tensor = self.real_label\n        else:\n            target_tensor = self.fake_label\n        return target_tensor.expand_as(prediction)\n\n    def __call__(self, prediction, target_is_real):\n        """"""Calculate loss given Discriminator\'s output and grount truth labels.\n\n        Parameters:\n            prediction (tensor) - - tpyically the prediction output from a discriminator\n            target_is_real (bool) - - if the ground truth label is for real images or fake images\n\n        Returns:\n            the calculated loss.\n        """"""\n        if self.gan_mode in [\'lsgan\', \'vanilla\']:\n            target_tensor = self.get_target_tensor(prediction, target_is_real)\n            loss = self.loss(prediction, target_tensor)\n        elif self.gan_mode == \'wgangp\':\n            if target_is_real:\n                loss = -prediction.mean()\n            else:\n                loss = prediction.mean()\n        return loss\n\n\ndef cal_gradient_penalty(netD, real_data, fake_data, device, type=\'mixed\', constant=1.0, lambda_gp=10.0):\n    """"""Calculate the gradient penalty loss, used in WGAN-GP paper https://arxiv.org/abs/1704.00028\n\n    Arguments:\n        netD (network)              -- discriminator network\n        real_data (tensor array)    -- real images\n        fake_data (tensor array)    -- generated images from the generator\n        device (str)                -- GPU / CPU: from torch.device(\'cuda:{}\'.format(self.gpu_ids[0])) if self.gpu_ids else torch.device(\'cpu\')\n        type (str)                  -- if we mix real and fake data or not [real | fake | mixed].\n        constant (float)            -- the constant used in formula ( | |gradient||_2 - constant)^2\n        lambda_gp (float)           -- weight for this loss\n\n    Returns the gradient penalty loss\n    """"""\n    if lambda_gp > 0.0:\n        if type == \'real\':   # either use real images, fake images, or a linear interpolation of two.\n            interpolatesv = real_data\n        elif type == \'fake\':\n            interpolatesv = fake_data\n        elif type == \'mixed\':\n            alpha = torch.rand(real_data.shape[0], 1, device=device)\n            alpha = alpha.expand(real_data.shape[0], real_data.nelement() // real_data.shape[0]).contiguous().view(*real_data.shape)\n            interpolatesv = alpha * real_data + ((1 - alpha) * fake_data)\n        else:\n            raise NotImplementedError(\'{} not implemented\'.format(type))\n        interpolatesv.requires_grad_(True)\n        disc_interpolates = netD(interpolatesv)\n        gradients = torch.autograd.grad(outputs=disc_interpolates, inputs=interpolatesv,\n                                        grad_outputs=torch.ones(disc_interpolates.size()).to(device),\n                                        create_graph=True, retain_graph=True, only_inputs=True)\n        gradients = gradients[0].view(real_data.size(0), -1)  # flat the data\n        gradient_penalty = (((gradients + 1e-16).norm(2, dim=1) - constant) ** 2).mean() * lambda_gp        # added eps\n        return gradient_penalty, gradients\n    else:\n        return 0.0, None\n\n\nclass ResnetGenerator(nn.Module):\n    """"""Resnet-based generator that consists of Resnet blocks between a few downsampling/upsampling operations.\n\n    We adapt Torch code and idea from Justin Johnson\'s neural style transfer project(https://github.com/jcjohnson/fast-neural-style)\n    """"""\n\n    def __init__(self, input_nc, output_nc, ngf=64, norm_layer=nn.BatchNorm2d, use_dropout=False, n_blocks=6, padding_type=\'reflect\'):\n        """"""Construct a Resnet-based generator\n\n        Parameters:\n            input_nc (int)      -- the number of channels in input images\n            output_nc (int)     -- the number of channels in output images\n            ngf (int)           -- the number of filters in the last conv layer\n            norm_layer          -- normalization layer\n            use_dropout (bool)  -- if use dropout layers\n            n_blocks (int)      -- the number of ResNet blocks\n            padding_type (str)  -- the name of padding layer in conv layers: reflect | replicate | zero\n        """"""\n        assert(n_blocks >= 0)\n        super(ResnetGenerator, self).__init__()\n        if type(norm_layer) == functools.partial:\n            use_bias = norm_layer.func == nn.InstanceNorm2d\n        else:\n            use_bias = norm_layer == nn.InstanceNorm2d\n\n        model = [nn.ReflectionPad2d(3),\n                 nn.Conv2d(input_nc, ngf, kernel_size=7, padding=0, bias=use_bias),\n                 norm_layer(ngf),\n                 nn.ReLU(True)]\n\n        n_downsampling = 2\n        for i in range(n_downsampling):  # add downsampling layers\n            mult = 2 ** i\n            model += [nn.Conv2d(ngf * mult, ngf * mult * 2, kernel_size=3, stride=2, padding=1, bias=use_bias),\n                      norm_layer(ngf * mult * 2),\n                      nn.ReLU(True)]\n\n        mult = 2 ** n_downsampling\n        for i in range(n_blocks):       # add ResNet blocks\n\n            model += [ResnetBlock(ngf * mult, padding_type=padding_type, norm_layer=norm_layer, use_dropout=use_dropout, use_bias=use_bias)]\n\n        for i in range(n_downsampling):  # add upsampling layers\n            mult = 2 ** (n_downsampling - i)\n            model += [nn.ConvTranspose2d(ngf * mult, int(ngf * mult / 2),\n                                         kernel_size=3, stride=2,\n                                         padding=1, output_padding=1,\n                                         bias=use_bias),\n                      norm_layer(int(ngf * mult / 2)),\n                      nn.ReLU(True)]\n        model += [nn.ReflectionPad2d(3)]\n        model += [nn.Conv2d(ngf, output_nc, kernel_size=7, padding=0)]\n        model += [nn.Tanh()]\n\n        self.model = nn.Sequential(*model)\n\n    def forward(self, input):\n        """"""Standard forward""""""\n        return self.model(input)\n\n\nclass ResnetBlock(nn.Module):\n    """"""Define a Resnet block""""""\n\n    def __init__(self, dim, padding_type, norm_layer, use_dropout, use_bias):\n        """"""Initialize the Resnet block\n\n        A resnet block is a conv block with skip connections\n        We construct a conv block with build_conv_block function,\n        and implement skip connections in <forward> function.\n        Original Resnet paper: https://arxiv.org/pdf/1512.03385.pdf\n        """"""\n        super(ResnetBlock, self).__init__()\n        self.conv_block = self.build_conv_block(dim, padding_type, norm_layer, use_dropout, use_bias)\n\n    def build_conv_block(self, dim, padding_type, norm_layer, use_dropout, use_bias):\n        """"""Construct a convolutional block.\n\n        Parameters:\n            dim (int)           -- the number of channels in the conv layer.\n            padding_type (str)  -- the name of padding layer: reflect | replicate | zero\n            norm_layer          -- normalization layer\n            use_dropout (bool)  -- if use dropout layers.\n            use_bias (bool)     -- if the conv layer uses bias or not\n\n        Returns a conv block (with a conv layer, a normalization layer, and a non-linearity layer (ReLU))\n        """"""\n        conv_block = []\n        p = 0\n        if padding_type == \'reflect\':\n            conv_block += [nn.ReflectionPad2d(1)]\n        elif padding_type == \'replicate\':\n            conv_block += [nn.ReplicationPad2d(1)]\n        elif padding_type == \'zero\':\n            p = 1\n        else:\n            raise NotImplementedError(\'padding [%s] is not implemented\' % padding_type)\n\n        conv_block += [nn.Conv2d(dim, dim, kernel_size=3, padding=p, bias=use_bias), norm_layer(dim), nn.ReLU(True)]\n        if use_dropout:\n            conv_block += [nn.Dropout(0.5)]\n\n        p = 0\n        if padding_type == \'reflect\':\n            conv_block += [nn.ReflectionPad2d(1)]\n        elif padding_type == \'replicate\':\n            conv_block += [nn.ReplicationPad2d(1)]\n        elif padding_type == \'zero\':\n            p = 1\n        else:\n            raise NotImplementedError(\'padding [%s] is not implemented\' % padding_type)\n        conv_block += [nn.Conv2d(dim, dim, kernel_size=3, padding=p, bias=use_bias), norm_layer(dim)]\n\n        return nn.Sequential(*conv_block)\n\n    def forward(self, x):\n        """"""Forward function (with skip connections)""""""\n        out = x + self.conv_block(x)  # add skip connections\n        return out\n\n\nclass UnetGenerator(nn.Module):\n    """"""Create a Unet-based generator""""""\n\n    def __init__(self, input_nc, output_nc, num_downs, ngf=64, norm_layer=nn.BatchNorm2d, use_dropout=False):\n        """"""Construct a Unet generator\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            output_nc (int) -- the number of channels in output images\n            num_downs (int) -- the number of downsamplings in UNet. For example, # if |num_downs| == 7,\n                                image of size 128x128 will become of size 1x1 # at the bottleneck\n            ngf (int)       -- the number of filters in the last conv layer\n            norm_layer      -- normalization layer\n\n        We construct the U-Net from the innermost layer to the outermost layer.\n        It is a recursive process.\n        """"""\n        super(UnetGenerator, self).__init__()\n        # construct unet structure\n        unet_block = UnetSkipConnectionBlock(ngf * 8, ngf * 8, input_nc=None, submodule=None, norm_layer=norm_layer, innermost=True)  # add the innermost layer\n        for i in range(num_downs - 5):          # add intermediate layers with ngf * 8 filters\n            unet_block = UnetSkipConnectionBlock(ngf * 8, ngf * 8, input_nc=None, submodule=unet_block, norm_layer=norm_layer, use_dropout=use_dropout)\n        # gradually reduce the number of filters from ngf * 8 to ngf\n        unet_block = UnetSkipConnectionBlock(ngf * 4, ngf * 8, input_nc=None, submodule=unet_block, norm_layer=norm_layer)\n        unet_block = UnetSkipConnectionBlock(ngf * 2, ngf * 4, input_nc=None, submodule=unet_block, norm_layer=norm_layer)\n        unet_block = UnetSkipConnectionBlock(ngf, ngf * 2, input_nc=None, submodule=unet_block, norm_layer=norm_layer)\n        self.model = UnetSkipConnectionBlock(output_nc, ngf, input_nc=input_nc, submodule=unet_block, outermost=True, norm_layer=norm_layer)  # add the outermost layer\n\n    def forward(self, input):\n        """"""Standard forward""""""\n        return self.model(input)\n\n\nclass UnetSkipConnectionBlock(nn.Module):\n    """"""Defines the Unet submodule with skip connection.\n        X -------------------identity----------------------\n        |-- downsampling -- |submodule| -- upsampling --|\n    """"""\n\n    def __init__(self, outer_nc, inner_nc, input_nc=None,\n                 submodule=None, outermost=False, innermost=False, norm_layer=nn.BatchNorm2d, use_dropout=False):\n        """"""Construct a Unet submodule with skip connections.\n\n        Parameters:\n            outer_nc (int) -- the number of filters in the outer conv layer\n            inner_nc (int) -- the number of filters in the inner conv layer\n            input_nc (int) -- the number of channels in input images/features\n            submodule (UnetSkipConnectionBlock) -- previously defined submodules\n            outermost (bool)    -- if this module is the outermost module\n            innermost (bool)    -- if this module is the innermost module\n            norm_layer          -- normalization layer\n            use_dropout (bool)  -- if use dropout layers.\n        """"""\n        super(UnetSkipConnectionBlock, self).__init__()\n        self.outermost = outermost\n        if type(norm_layer) == functools.partial:\n            use_bias = norm_layer.func == nn.InstanceNorm2d\n        else:\n            use_bias = norm_layer == nn.InstanceNorm2d\n        if input_nc is None:\n            input_nc = outer_nc\n        downconv = nn.Conv2d(input_nc, inner_nc, kernel_size=4,\n                             stride=2, padding=1, bias=use_bias)\n        downrelu = nn.LeakyReLU(0.2, True)\n        downnorm = norm_layer(inner_nc)\n        uprelu = nn.ReLU(True)\n        upnorm = norm_layer(outer_nc)\n\n        if outermost:\n            upconv = nn.ConvTranspose2d(inner_nc * 2, outer_nc,\n                                        kernel_size=4, stride=2,\n                                        padding=1)\n            down = [downconv]\n            up = [uprelu, upconv, nn.Tanh()]\n            model = down + [submodule] + up\n        elif innermost:\n            upconv = nn.ConvTranspose2d(inner_nc, outer_nc,\n                                        kernel_size=4, stride=2,\n                                        padding=1, bias=use_bias)\n            down = [downrelu, downconv]\n            up = [uprelu, upconv, upnorm]\n            model = down + up\n        else:\n            upconv = nn.ConvTranspose2d(inner_nc * 2, outer_nc,\n                                        kernel_size=4, stride=2,\n                                        padding=1, bias=use_bias)\n            down = [downrelu, downconv, downnorm]\n            up = [uprelu, upconv, upnorm]\n\n            if use_dropout:\n                model = down + [submodule] + up + [nn.Dropout(0.5)]\n            else:\n                model = down + [submodule] + up\n\n        self.model = nn.Sequential(*model)\n\n    def forward(self, x):\n        if self.outermost:\n            return self.model(x)\n        else:   # add skip connections\n            return torch.cat([x, self.model(x)], 1)\n\n\nclass NLayerDiscriminator(nn.Module):\n    """"""Defines a PatchGAN discriminator""""""\n\n    def __init__(self, input_nc, ndf=64, n_layers=3, norm_layer=nn.BatchNorm2d):\n        """"""Construct a PatchGAN discriminator\n\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            ndf (int)       -- the number of filters in the last conv layer\n            n_layers (int)  -- the number of conv layers in the discriminator\n            norm_layer      -- normalization layer\n        """"""\n        super(NLayerDiscriminator, self).__init__()\n        if type(norm_layer) == functools.partial:  # no need to use bias as BatchNorm2d has affine parameters\n            use_bias = norm_layer.func == nn.InstanceNorm2d\n        else:\n            use_bias = norm_layer == nn.InstanceNorm2d\n\n        kw = 4\n        padw = 1\n        sequence = [nn.Conv2d(input_nc, ndf, kernel_size=kw, stride=2, padding=padw), nn.LeakyReLU(0.2, True)]\n        nf_mult = 1\n        nf_mult_prev = 1\n        for n in range(1, n_layers):  # gradually increase the number of filters\n            nf_mult_prev = nf_mult\n            nf_mult = min(2 ** n, 8)\n            sequence += [\n                nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult, kernel_size=kw, stride=2, padding=padw, bias=use_bias),\n                norm_layer(ndf * nf_mult),\n                nn.LeakyReLU(0.2, True)\n            ]\n\n        nf_mult_prev = nf_mult\n        nf_mult = min(2 ** n_layers, 8)\n        sequence += [\n            nn.Conv2d(ndf * nf_mult_prev, ndf * nf_mult, kernel_size=kw, stride=1, padding=padw, bias=use_bias),\n            norm_layer(ndf * nf_mult),\n            nn.LeakyReLU(0.2, True)\n        ]\n\n        sequence += [nn.Conv2d(ndf * nf_mult, 1, kernel_size=kw, stride=1, padding=padw)]  # output 1 channel prediction map\n        self.model = nn.Sequential(*sequence)\n\n    def forward(self, input):\n        """"""Standard forward.""""""\n        return self.model(input)\n\n\nclass PixelDiscriminator(nn.Module):\n    """"""Defines a 1x1 PatchGAN discriminator (pixelGAN)""""""\n\n    def __init__(self, input_nc, ndf=64, norm_layer=nn.BatchNorm2d):\n        """"""Construct a 1x1 PatchGAN discriminator\n\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            ndf (int)       -- the number of filters in the last conv layer\n            norm_layer      -- normalization layer\n        """"""\n        super(PixelDiscriminator, self).__init__()\n        if type(norm_layer) == functools.partial:  # no need to use bias as BatchNorm2d has affine parameters\n            use_bias = norm_layer.func == nn.InstanceNorm2d\n        else:\n            use_bias = norm_layer == nn.InstanceNorm2d\n\n        self.net = [\n            nn.Conv2d(input_nc, ndf, kernel_size=1, stride=1, padding=0),\n            nn.LeakyReLU(0.2, True),\n            nn.Conv2d(ndf, ndf * 2, kernel_size=1, stride=1, padding=0, bias=use_bias),\n            norm_layer(ndf * 2),\n            nn.LeakyReLU(0.2, True),\n            nn.Conv2d(ndf * 2, 1, kernel_size=1, stride=1, padding=0, bias=use_bias)]\n\n        self.net = nn.Sequential(*self.net)\n\n    def forward(self, input):\n        """"""Standard forward.""""""\n        return self.net(input)\n'"
models/pix2pix_model.py,6,"b'import torch\nfrom .base_model import BaseModel\nfrom . import networks\n\n\nclass Pix2PixModel(BaseModel):\n    """""" This class implements the pix2pix model, for learning a mapping from input images to output images given paired data.\n\n    The model training requires \'--dataset_mode aligned\' dataset.\n    By default, it uses a \'--netG unet256\' U-Net generator,\n    a \'--netD basic\' discriminator (PatchGAN),\n    and a \'--gan_mode\' vanilla GAN loss (the cross-entropy objective used in the orignal GAN paper).\n\n    pix2pix paper: https://arxiv.org/pdf/1611.07004.pdf\n    """"""\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n\n        For pix2pix, we do not use image buffer\n        The training objective is: GAN Loss + lambda_L1 * ||G(A)-B||_1\n        By default, we use vanilla GAN loss, UNet with batchnorm, and aligned datasets.\n        """"""\n        # changing the default values to match the pix2pix paper (https://phillipi.github.io/pix2pix/)\n        parser.set_defaults(norm=\'batch\', netG=\'unet_256\', dataset_mode=\'aligned\')\n        if is_train:\n            parser.set_defaults(pool_size=0, gan_mode=\'vanilla\')\n            parser.add_argument(\'--lambda_L1\', type=float, default=100.0, help=\'weight for L1 loss\')\n\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize the pix2pix class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        BaseModel.__init__(self, opt)\n        # specify the training losses you want to print out. The training/test scripts will call <BaseModel.get_current_losses>\n        self.loss_names = [\'G_GAN\', \'G_L1\', \'D_real\', \'D_fake\']\n        # specify the images you want to save/display. The training/test scripts will call <BaseModel.get_current_visuals>\n        self.visual_names = [\'real_A\', \'fake_B\', \'real_B\']\n        # specify the models you want to save to the disk. The training/test scripts will call <BaseModel.save_networks> and <BaseModel.load_networks>\n        if self.isTrain:\n            self.model_names = [\'G\', \'D\']\n        else:  # during test time, only load G\n            self.model_names = [\'G\']\n        # define networks (both generator and discriminator)\n        self.netG = networks.define_G(opt.input_nc, opt.output_nc, opt.ngf, opt.netG, opt.norm,\n                                      not opt.no_dropout, opt.init_type, opt.init_gain, self.gpu_ids)\n\n        if self.isTrain:  # define a discriminator; conditional GANs need to take both input and output images; Therefore, #channels for D is input_nc + output_nc\n            self.netD = networks.define_D(opt.input_nc + opt.output_nc, opt.ndf, opt.netD,\n                                          opt.n_layers_D, opt.norm, opt.init_type, opt.init_gain, self.gpu_ids)\n\n        if self.isTrain:\n            # define loss functions\n            self.criterionGAN = networks.GANLoss(opt.gan_mode).to(self.device)\n            self.criterionL1 = torch.nn.L1Loss()\n            # initialize optimizers; schedulers will be automatically created by function <BaseModel.setup>.\n            self.optimizer_G = torch.optim.Adam(self.netG.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizer_D = torch.optim.Adam(self.netD.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizers.append(self.optimizer_G)\n            self.optimizers.append(self.optimizer_D)\n\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input (dict): include the data itself and its metadata information.\n\n        The option \'direction\' can be used to swap images in domain A and domain B.\n        """"""\n        AtoB = self.opt.direction == \'AtoB\'\n        self.real_A = input[\'A\' if AtoB else \'B\'].to(self.device)\n        self.real_B = input[\'B\' if AtoB else \'A\'].to(self.device)\n        self.image_paths = input[\'A_paths\' if AtoB else \'B_paths\']\n\n    def forward(self):\n        """"""Run forward pass; called by both functions <optimize_parameters> and <test>.""""""\n        self.fake_B = self.netG(self.real_A)  # G(A)\n\n    def backward_D(self):\n        """"""Calculate GAN loss for the discriminator""""""\n        # Fake; stop backprop to the generator by detaching fake_B\n        fake_AB = torch.cat((self.real_A, self.fake_B), 1)  # we use conditional GANs; we need to feed both input and output to the discriminator\n        pred_fake = self.netD(fake_AB.detach())\n        self.loss_D_fake = self.criterionGAN(pred_fake, False)\n        # Real\n        real_AB = torch.cat((self.real_A, self.real_B), 1)\n        pred_real = self.netD(real_AB)\n        self.loss_D_real = self.criterionGAN(pred_real, True)\n        # combine loss and calculate gradients\n        self.loss_D = (self.loss_D_fake + self.loss_D_real) * 0.5\n        self.loss_D.backward()\n\n    def backward_G(self):\n        """"""Calculate GAN and L1 loss for the generator""""""\n        # First, G(A) should fake the discriminator\n        fake_AB = torch.cat((self.real_A, self.fake_B), 1)\n        pred_fake = self.netD(fake_AB)\n        self.loss_G_GAN = self.criterionGAN(pred_fake, True)\n        # Second, G(A) = B\n        self.loss_G_L1 = self.criterionL1(self.fake_B, self.real_B) * self.opt.lambda_L1\n        # combine loss and calculate gradients\n        self.loss_G = self.loss_G_GAN + self.loss_G_L1\n        self.loss_G.backward()\n\n    def optimize_parameters(self):\n        self.forward()                   # compute fake images: G(A)\n        # update D\n        self.set_requires_grad(self.netD, True)  # enable backprop for D\n        self.optimizer_D.zero_grad()     # set D\'s gradients to zero\n        self.backward_D()                # calculate gradients for D\n        self.optimizer_D.step()          # update D\'s weights\n        # update G\n        self.set_requires_grad(self.netD, False)  # D requires no gradients when optimizing G\n        self.optimizer_G.zero_grad()        # set G\'s gradients to zero\n        self.backward_G()                   # calculate graidents for G\n        self.optimizer_G.step()             # udpate G\'s weights\n'"
models/template_model.py,3,"b'""""""Model class template\n\nThis module provides a template for users to implement custom models.\nYou can specify \'--model template\' to use this model.\nThe class name should be consistent with both the filename and its model option.\nThe filename should be <model>_dataset.py\nThe class name should be <Model>Dataset.py\nIt implements a simple image-to-image translation baseline based on regression loss.\nGiven input-output pairs (data_A, data_B), it learns a network netG that can minimize the following L1 loss:\n    min_<netG> ||netG(data_A) - data_B||_1\nYou need to implement the following functions:\n    <modify_commandline_options>:\xe3\x80\x80Add model-specific options and rewrite default values for existing options.\n    <__init__>: Initialize this model class.\n    <set_input>: Unpack input data and perform data pre-processing.\n    <forward>: Run forward pass. This will be called by both <optimize_parameters> and <test>.\n    <optimize_parameters>: Update network weights; it will be called in every training iteration.\n""""""\nimport torch\nfrom .base_model import BaseModel\nfrom . import networks\n\n\nclass TemplateModel(BaseModel):\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new model-specific options and rewrite default values for existing options.\n\n        Parameters:\n            parser -- the option parser\n            is_train -- if it is training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n        """"""\n        parser.set_defaults(dataset_mode=\'aligned\')  # You can rewrite default values for this model. For example, this model usually uses aligned dataset as its dataset.\n        if is_train:\n            parser.add_argument(\'--lambda_regression\', type=float, default=1.0, help=\'weight for the regression loss\')  # You can define new arguments for this model.\n\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize this model class.\n\n        Parameters:\n            opt -- training/test options\n\n        A few things can be done here.\n        - (required) call the initialization function of BaseModel\n        - define loss function, visualization images, model names, and optimizers\n        """"""\n        BaseModel.__init__(self, opt)  # call the initialization method of BaseModel\n        # specify the training losses you want to print out. The program will call base_model.get_current_losses to plot the losses to the console and save them to the disk.\n        self.loss_names = [\'loss_G\']\n        # specify the images you want to save and display. The program will call base_model.get_current_visuals to save and display these images.\n        self.visual_names = [\'data_A\', \'data_B\', \'output\']\n        # specify the models you want to save to the disk. The program will call base_model.save_networks and base_model.load_networks to save and load networks.\n        # you can use opt.isTrain to specify different behaviors for training and test. For example, some networks will not be used during test, and you don\'t need to load them.\n        self.model_names = [\'G\']\n        # define networks; you can use opt.isTrain to specify different behaviors for training and test.\n        self.netG = networks.define_G(opt.input_nc, opt.output_nc, opt.ngf, opt.netG, gpu_ids=self.gpu_ids)\n        if self.isTrain:  # only defined during training time\n            # define your loss functions. You can use losses provided by torch.nn such as torch.nn.L1Loss.\n            # We also provide a GANLoss class ""networks.GANLoss"". self.criterionGAN = networks.GANLoss().to(self.device)\n            self.criterionLoss = torch.nn.L1Loss()\n            # define and initialize optimizers. You can define one optimizer for each network.\n            # If two networks are updated at the same time, you can use itertools.chain to group them. See cycle_gan_model.py for an example.\n            self.optimizer = torch.optim.Adam(self.netG.parameters(), lr=opt.lr, betas=(opt.beta1, 0.999))\n            self.optimizers = [self.optimizer]\n\n        # Our program will automatically call <model.setup> to define schedulers, load networks, and print networks\n\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input: a dictionary that contains the data itself and its metadata information.\n        """"""\n        AtoB = self.opt.direction == \'AtoB\'  # use <direction> to swap data_A and data_B\n        self.data_A = input[\'A\' if AtoB else \'B\'].to(self.device)  # get image data A\n        self.data_B = input[\'B\' if AtoB else \'A\'].to(self.device)  # get image data B\n        self.image_paths = input[\'A_paths\' if AtoB else \'B_paths\']  # get image paths\n\n    def forward(self):\n        """"""Run forward pass. This will be called by both functions <optimize_parameters> and <test>.""""""\n        self.output = self.netG(self.data_A)  # generate output image given the input data_A\n\n    def backward(self):\n        """"""Calculate losses, gradients, and update network weights; called in every training iteration""""""\n        # caculate the intermediate results if necessary; here self.output has been computed during function <forward>\n        # calculate loss given the input and intermediate results\n        self.loss_G = self.criterionLoss(self.output, self.data_B) * self.opt.lambda_regression\n        self.loss_G.backward()       # calculate gradients of network G w.r.t. loss_G\n\n    def optimize_parameters(self):\n        """"""Update network weights; it will be called in every training iteration.""""""\n        self.forward()               # first call forward to calculate intermediate results\n        self.optimizer.zero_grad()   # clear network G\'s existing gradients\n        self.backward()              # calculate gradients for network G\n        self.optimizer.step()        # update gradients for network G\n'"
models/test_model.py,0,"b'from .base_model import BaseModel\nfrom . import networks\n\n\nclass TestModel(BaseModel):\n    """""" This TesteModel can be used to generate CycleGAN results for only one direction.\n    This model will automatically set \'--dataset_mode single\', which only loads the images from one collection.\n\n    See the test instruction for more details.\n    """"""\n    @staticmethod\n    def modify_commandline_options(parser, is_train=True):\n        """"""Add new dataset-specific options, and rewrite default values for existing options.\n\n        Parameters:\n            parser          -- original option parser\n            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.\n\n        Returns:\n            the modified parser.\n\n        The model can only be used during test time. It requires \'--dataset_mode single\'.\n        You need to specify the network using the option \'--model_suffix\'.\n        """"""\n        assert not is_train, \'TestModel cannot be used during training time\'\n        parser.set_defaults(dataset_mode=\'single\')\n        parser.add_argument(\'--model_suffix\', type=str, default=\'\', help=\'In checkpoints_dir, [epoch]_net_G[model_suffix].pth will be loaded as the generator.\')\n\n        return parser\n\n    def __init__(self, opt):\n        """"""Initialize the pix2pix class.\n\n        Parameters:\n            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions\n        """"""\n        assert(not opt.isTrain)\n        BaseModel.__init__(self, opt)\n        # specify the training losses you want to print out. The training/test scripts  will call <BaseModel.get_current_losses>\n        self.loss_names = []\n        # specify the images you want to save/display. The training/test scripts  will call <BaseModel.get_current_visuals>\n        self.visual_names = [\'real\', \'fake\']\n        # specify the models you want to save to the disk. The training/test scripts will call <BaseModel.save_networks> and <BaseModel.load_networks>\n        self.model_names = [\'G\' + opt.model_suffix]  # only generator is needed.\n        self.netG = networks.define_G(opt.input_nc, opt.output_nc, opt.ngf, opt.netG,\n                                      opt.norm, not opt.no_dropout, opt.init_type, opt.init_gain, self.gpu_ids)\n\n        # assigns the model to self.netG_[suffix] so that it can be loaded\n        # please see <BaseModel.load_networks>\n        setattr(self, \'netG\' + opt.model_suffix, self.netG)  # store netG in self.\n\n    def set_input(self, input):\n        """"""Unpack input data from the dataloader and perform necessary pre-processing steps.\n\n        Parameters:\n            input: a dictionary that contains the data itself and its metadata information.\n\n        We need to use \'single_dataset\' dataset mode. It only load images from one domain.\n        """"""\n        self.real = input[\'A\'].to(self.device)\n        self.image_paths = input[\'A_paths\']\n\n    def forward(self):\n        """"""Run forward pass.""""""\n        self.fake = self.netG(self.real)  # G(real)\n\n    def optimize_parameters(self):\n        """"""No optimization for test model.""""""\n        pass\n'"
options/__init__.py,0,"b'""""""This package options includes option modules: training options, test options, and basic options (used in both training and test).""""""\n'"
options/base_options.py,1,"b'import argparse\nimport os\nfrom util import util\nimport torch\nimport models\nimport data\n\n\nclass BaseOptions():\n    """"""This class defines options used during both training and test time.\n\n    It also implements several helper functions such as parsing, printing, and saving the options.\n    It also gathers additional options defined in <modify_commandline_options> functions in both dataset class and model class.\n    """"""\n\n    def __init__(self):\n        """"""Reset the class; indicates the class hasn\'t been initailized""""""\n        self.initialized = False\n\n    def initialize(self, parser):\n        """"""Define the common options that are used in both training and test.""""""\n        # basic parameters\n        parser.add_argument(\'--dataroot\', required=True, help=\'path to images (should have subfolders trainA, trainB, valA, valB, etc)\')\n        parser.add_argument(\'--name\', type=str, default=\'experiment_name\', help=\'name of the experiment. It decides where to store samples and models\')\n        parser.add_argument(\'--gpu_ids\', type=str, default=\'0\', help=\'gpu ids: e.g. 0  0,1,2, 0,2. use -1 for CPU\')\n        parser.add_argument(\'--checkpoints_dir\', type=str, default=\'./checkpoints\', help=\'models are saved here\')\n        # model parameters\n        parser.add_argument(\'--model\', type=str, default=\'cycle_gan\', help=\'chooses which model to use. [cycle_gan | pix2pix | test | colorization]\')\n        parser.add_argument(\'--input_nc\', type=int, default=3, help=\'# of input image channels: 3 for RGB and 1 for grayscale\')\n        parser.add_argument(\'--output_nc\', type=int, default=3, help=\'# of output image channels: 3 for RGB and 1 for grayscale\')\n        parser.add_argument(\'--ngf\', type=int, default=64, help=\'# of gen filters in the last conv layer\')\n        parser.add_argument(\'--ndf\', type=int, default=64, help=\'# of discrim filters in the first conv layer\')\n        parser.add_argument(\'--netD\', type=str, default=\'basic\', help=\'specify discriminator architecture [basic | n_layers | pixel]. The basic model is a 70x70 PatchGAN. n_layers allows you to specify the layers in the discriminator\')\n        parser.add_argument(\'--netG\', type=str, default=\'resnet_9blocks\', help=\'specify generator architecture [resnet_9blocks | resnet_6blocks | unet_256 | unet_128]\')\n        parser.add_argument(\'--n_layers_D\', type=int, default=3, help=\'only used if netD==n_layers\')\n        parser.add_argument(\'--norm\', type=str, default=\'instance\', help=\'instance normalization or batch normalization [instance | batch | none]\')\n        parser.add_argument(\'--init_type\', type=str, default=\'normal\', help=\'network initialization [normal | xavier | kaiming | orthogonal]\')\n        parser.add_argument(\'--init_gain\', type=float, default=0.02, help=\'scaling factor for normal, xavier and orthogonal.\')\n        parser.add_argument(\'--no_dropout\', action=\'store_true\', help=\'no dropout for the generator\')\n        # dataset parameters\n        parser.add_argument(\'--dataset_mode\', type=str, default=\'unaligned\', help=\'chooses how datasets are loaded. [unaligned | aligned | single | colorization]\')\n        parser.add_argument(\'--direction\', type=str, default=\'AtoB\', help=\'AtoB or BtoA\')\n        parser.add_argument(\'--serial_batches\', action=\'store_true\', help=\'if true, takes images in order to make batches, otherwise takes them randomly\')\n        parser.add_argument(\'--num_threads\', default=4, type=int, help=\'# threads for loading data\')\n        parser.add_argument(\'--batch_size\', type=int, default=1, help=\'input batch size\')\n        parser.add_argument(\'--load_size\', type=int, default=286, help=\'scale images to this size\')\n        parser.add_argument(\'--crop_size\', type=int, default=256, help=\'then crop to this size\')\n        parser.add_argument(\'--max_dataset_size\', type=int, default=float(""inf""), help=\'Maximum number of samples allowed per dataset. If the dataset directory contains more than max_dataset_size, only a subset is loaded.\')\n        parser.add_argument(\'--preprocess\', type=str, default=\'resize_and_crop\', help=\'scaling and cropping of images at load time [resize_and_crop | crop | scale_width | scale_width_and_crop | none]\')\n        parser.add_argument(\'--no_flip\', action=\'store_true\', help=\'if specified, do not flip the images for data augmentation\')\n        parser.add_argument(\'--display_winsize\', type=int, default=256, help=\'display window size for both visdom and HTML\')\n        # additional parameters\n        parser.add_argument(\'--epoch\', type=str, default=\'latest\', help=\'which epoch to load? set to latest to use latest cached model\')\n        parser.add_argument(\'--load_iter\', type=int, default=\'0\', help=\'which iteration to load? if load_iter > 0, the code will load models by iter_[load_iter]; otherwise, the code will load models by [epoch]\')\n        parser.add_argument(\'--verbose\', action=\'store_true\', help=\'if specified, print more debugging information\')\n        parser.add_argument(\'--suffix\', default=\'\', type=str, help=\'customized suffix: opt.name = opt.name + suffix: e.g., {model}_{netG}_size{load_size}\')\n        self.initialized = True\n        return parser\n\n    def gather_options(self):\n        """"""Initialize our parser with basic options(only once).\n        Add additional model-specific and dataset-specific options.\n        These options are defined in the <modify_commandline_options> function\n        in model and dataset classes.\n        """"""\n        if not self.initialized:  # check if it has been initialized\n            parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n            parser = self.initialize(parser)\n\n        # get the basic options\n        opt, _ = parser.parse_known_args()\n\n        # modify model-related parser options\n        model_name = opt.model\n        model_option_setter = models.get_option_setter(model_name)\n        parser = model_option_setter(parser, self.isTrain)\n        opt, _ = parser.parse_known_args()  # parse again with new defaults\n\n        # modify dataset-related parser options\n        dataset_name = opt.dataset_mode\n        dataset_option_setter = data.get_option_setter(dataset_name)\n        parser = dataset_option_setter(parser, self.isTrain)\n\n        # save and return the parser\n        self.parser = parser\n        return parser.parse_args()\n\n    def print_options(self, opt):\n        """"""Print and save options\n\n        It will print both current options and default values(if different).\n        It will save options into a text file / [checkpoints_dir] / opt.txt\n        """"""\n        message = \'\'\n        message += \'----------------- Options ---------------\\n\'\n        for k, v in sorted(vars(opt).items()):\n            comment = \'\'\n            default = self.parser.get_default(k)\n            if v != default:\n                comment = \'\\t[default: %s]\' % str(default)\n            message += \'{:>25}: {:<30}{}\\n\'.format(str(k), str(v), comment)\n        message += \'----------------- End -------------------\'\n        print(message)\n\n        # save to the disk\n        expr_dir = os.path.join(opt.checkpoints_dir, opt.name)\n        util.mkdirs(expr_dir)\n        file_name = os.path.join(expr_dir, \'{}_opt.txt\'.format(opt.phase))\n        with open(file_name, \'wt\') as opt_file:\n            opt_file.write(message)\n            opt_file.write(\'\\n\')\n\n    def parse(self):\n        """"""Parse our options, create checkpoints directory suffix, and set up gpu device.""""""\n        opt = self.gather_options()\n        opt.isTrain = self.isTrain   # train or test\n\n        # process opt.suffix\n        if opt.suffix:\n            suffix = (\'_\' + opt.suffix.format(**vars(opt))) if opt.suffix != \'\' else \'\'\n            opt.name = opt.name + suffix\n\n        self.print_options(opt)\n\n        # set gpu ids\n        str_ids = opt.gpu_ids.split(\',\')\n        opt.gpu_ids = []\n        for str_id in str_ids:\n            id = int(str_id)\n            if id >= 0:\n                opt.gpu_ids.append(id)\n        if len(opt.gpu_ids) > 0:\n            torch.cuda.set_device(opt.gpu_ids[0])\n\n        self.opt = opt\n        return self.opt\n'"
options/test_options.py,0,"b'from .base_options import BaseOptions\n\n\nclass TestOptions(BaseOptions):\n    """"""This class includes test options.\n\n    It also includes shared options defined in BaseOptions.\n    """"""\n\n    def initialize(self, parser):\n        parser = BaseOptions.initialize(self, parser)  # define shared options\n        parser.add_argument(\'--results_dir\', type=str, default=\'./results/\', help=\'saves results here.\')\n        parser.add_argument(\'--aspect_ratio\', type=float, default=1.0, help=\'aspect ratio of result images\')\n        parser.add_argument(\'--phase\', type=str, default=\'test\', help=\'train, val, test, etc\')\n        # Dropout and Batchnorm has different behavioir during training and test.\n        parser.add_argument(\'--eval\', action=\'store_true\', help=\'use eval mode during test time.\')\n        parser.add_argument(\'--num_test\', type=int, default=50, help=\'how many test images to run\')\n        # rewrite devalue values\n        parser.set_defaults(model=\'test\')\n        # To avoid cropping, the load_size should be the same as crop_size\n        parser.set_defaults(load_size=parser.get_default(\'crop_size\'))\n        self.isTrain = False\n        return parser\n'"
options/train_options.py,0,"b'from .base_options import BaseOptions\n\n\nclass TrainOptions(BaseOptions):\n    """"""This class includes training options.\n\n    It also includes shared options defined in BaseOptions.\n    """"""\n\n    def initialize(self, parser):\n        parser = BaseOptions.initialize(self, parser)\n        # visdom and HTML visualization parameters\n        parser.add_argument(\'--display_freq\', type=int, default=400, help=\'frequency of showing training results on screen\')\n        parser.add_argument(\'--display_ncols\', type=int, default=4, help=\'if positive, display all images in a single visdom web panel with certain number of images per row.\')\n        parser.add_argument(\'--display_id\', type=int, default=1, help=\'window id of the web display\')\n        parser.add_argument(\'--display_server\', type=str, default=""http://localhost"", help=\'visdom server of the web display\')\n        parser.add_argument(\'--display_env\', type=str, default=\'main\', help=\'visdom display environment name (default is ""main"")\')\n        parser.add_argument(\'--display_port\', type=int, default=8097, help=\'visdom port of the web display\')\n        parser.add_argument(\'--update_html_freq\', type=int, default=1000, help=\'frequency of saving training results to html\')\n        parser.add_argument(\'--print_freq\', type=int, default=100, help=\'frequency of showing training results on console\')\n        parser.add_argument(\'--no_html\', action=\'store_true\', help=\'do not save intermediate training results to [opt.checkpoints_dir]/[opt.name]/web/\')\n        # network saving and loading parameters\n        parser.add_argument(\'--save_latest_freq\', type=int, default=5000, help=\'frequency of saving the latest results\')\n        parser.add_argument(\'--save_epoch_freq\', type=int, default=5, help=\'frequency of saving checkpoints at the end of epochs\')\n        parser.add_argument(\'--save_by_iter\', action=\'store_true\', help=\'whether saves model by iteration\')\n        parser.add_argument(\'--continue_train\', action=\'store_true\', help=\'continue training: load the latest model\')\n        parser.add_argument(\'--epoch_count\', type=int, default=1, help=\'the starting epoch count, we save the model by <epoch_count>, <epoch_count>+<save_latest_freq>, ...\')\n        parser.add_argument(\'--phase\', type=str, default=\'train\', help=\'train, val, test, etc\')\n        # training parameters\n        parser.add_argument(\'--n_epochs\', type=int, default=100, help=\'number of epochs with the initial learning rate\')\n        parser.add_argument(\'--n_epochs_decay\', type=int, default=100, help=\'number of epochs to linearly decay learning rate to zero\')\n        parser.add_argument(\'--beta1\', type=float, default=0.5, help=\'momentum term of adam\')\n        parser.add_argument(\'--lr\', type=float, default=0.0002, help=\'initial learning rate for adam\')\n        parser.add_argument(\'--gan_mode\', type=str, default=\'lsgan\', help=\'the type of GAN objective. [vanilla| lsgan | wgangp]. vanilla GAN loss is the cross-entropy objective used in the original GAN paper.\')\n        parser.add_argument(\'--pool_size\', type=int, default=50, help=\'the size of image buffer that stores previously generated images\')\n        parser.add_argument(\'--lr_policy\', type=str, default=\'linear\', help=\'learning rate policy. [linear | step | plateau | cosine]\')\n        parser.add_argument(\'--lr_decay_iters\', type=int, default=50, help=\'multiply by a gamma every lr_decay_iters iterations\')\n\n        self.isTrain = True\n        return parser\n'"
scripts/test_before_push.py,0,"b'# Simple script to make sure basic usage\n# such as training, testing, saving and loading\n# runs without errors.\nimport os\n\n\ndef run(command):\n    print(command)\n    exit_status = os.system(command)\n    if exit_status > 0:\n        exit(1)\n\n\nif __name__ == \'__main__\':\n    # download mini datasets\n    if not os.path.exists(\'./datasets/mini\'):\n        run(\'bash ./datasets/download_cyclegan_dataset.sh mini\')\n\n    if not os.path.exists(\'./datasets/mini_pix2pix\'):\n        run(\'bash ./datasets/download_cyclegan_dataset.sh mini_pix2pix\')\n\n    # pretrained cyclegan model\n    if not os.path.exists(\'./checkpoints/horse2zebra_pretrained/latest_net_G.pth\'):\n        run(\'bash ./scripts/download_cyclegan_model.sh horse2zebra\')\n    run(\'python test.py --model test --dataroot ./datasets/mini --name horse2zebra_pretrained --no_dropout --num_test 1 --no_dropout\')\n\n    # pretrained pix2pix model\n    if not os.path.exists(\'./checkpoints/facades_label2photo_pretrained/latest_net_G.pth\'):\n        run(\'bash ./scripts/download_pix2pix_model.sh facades_label2photo\')\n    if not os.path.exists(\'./datasets/facades\'):\n        run(\'bash ./datasets/download_pix2pix_dataset.sh facades\')\n    run(\'python test.py --dataroot ./datasets/facades/ --direction BtoA --model pix2pix --name facades_label2photo_pretrained --num_test 1\')\n\n    # cyclegan train/test\n    run(\'python train.py --model cycle_gan --name temp_cyclegan --dataroot ./datasets/mini --n_epochs 1 --n_epochs_decay 0 --save_latest_freq 10  --print_freq 1 --display_id -1\')\n    run(\'python test.py --model test --name temp_cyclegan --dataroot ./datasets/mini --num_test 1 --model_suffix ""_A"" --no_dropout\')\n\n    # pix2pix train/test\n    run(\'python train.py --model pix2pix --name temp_pix2pix --dataroot ./datasets/mini_pix2pix --n_epochs 1 --n_epochs_decay 5 --save_latest_freq 10 --display_id -1\')\n    run(\'python test.py --model pix2pix --name temp_pix2pix --dataroot ./datasets/mini_pix2pix --num_test 1\')\n\n    # template train/test\n    run(\'python train.py --model template --name temp2 --dataroot ./datasets/mini_pix2pix --n_epochs 1 --n_epochs_decay 0 --save_latest_freq 10 --display_id -1\')\n    run(\'python test.py --model template --name temp2 --dataroot ./datasets/mini_pix2pix --num_test 1\')\n\n    # colorization train/test (optional)\n    if not os.path.exists(\'./datasets/mini_colorization\'):\n        run(\'bash ./datasets/download_cyclegan_dataset.sh mini_colorization\')\n\n    run(\'python train.py --model colorization --name temp_color --dataroot ./datasets/mini_colorization --n_epochs 1 --n_epochs_decay 0 --save_latest_freq 5 --display_id -1\')\n    run(\'python test.py --model colorization --name temp_color --dataroot ./datasets/mini_colorization --num_test 1\')\n'"
util/__init__.py,0,"b'""""""This package includes a miscellaneous collection of useful helper functions.""""""\n'"
util/get_data.py,0,"b'from __future__ import print_function\nimport os\nimport tarfile\nimport requests\nfrom warnings import warn\nfrom zipfile import ZipFile\nfrom bs4 import BeautifulSoup\nfrom os.path import abspath, isdir, join, basename\n\n\nclass GetData(object):\n    """"""A Python script for downloading CycleGAN or pix2pix datasets.\n\n    Parameters:\n        technique (str) -- One of: \'cyclegan\' or \'pix2pix\'.\n        verbose (bool)  -- If True, print additional information.\n\n    Examples:\n        >>> from util.get_data import GetData\n        >>> gd = GetData(technique=\'cyclegan\')\n        >>> new_data_path = gd.get(save_path=\'./datasets\')  # options will be displayed.\n\n    Alternatively, You can use bash scripts: \'scripts/download_pix2pix_model.sh\'\n    and \'scripts/download_cyclegan_model.sh\'.\n    """"""\n\n    def __init__(self, technique=\'cyclegan\', verbose=True):\n        url_dict = {\n            \'pix2pix\': \'http://efrosgans.eecs.berkeley.edu/pix2pix/datasets/\',\n            \'cyclegan\': \'https://people.eecs.berkeley.edu/~taesung_park/CycleGAN/datasets\'\n        }\n        self.url = url_dict.get(technique.lower())\n        self._verbose = verbose\n\n    def _print(self, text):\n        if self._verbose:\n            print(text)\n\n    @staticmethod\n    def _get_options(r):\n        soup = BeautifulSoup(r.text, \'lxml\')\n        options = [h.text for h in soup.find_all(\'a\', href=True)\n                   if h.text.endswith((\'.zip\', \'tar.gz\'))]\n        return options\n\n    def _present_options(self):\n        r = requests.get(self.url)\n        options = self._get_options(r)\n        print(\'Options:\\n\')\n        for i, o in enumerate(options):\n            print(""{0}: {1}"".format(i, o))\n        choice = input(""\\nPlease enter the number of the ""\n                       ""dataset above you wish to download:"")\n        return options[int(choice)]\n\n    def _download_data(self, dataset_url, save_path):\n        if not isdir(save_path):\n            os.makedirs(save_path)\n\n        base = basename(dataset_url)\n        temp_save_path = join(save_path, base)\n\n        with open(temp_save_path, ""wb"") as f:\n            r = requests.get(dataset_url)\n            f.write(r.content)\n\n        if base.endswith(\'.tar.gz\'):\n            obj = tarfile.open(temp_save_path)\n        elif base.endswith(\'.zip\'):\n            obj = ZipFile(temp_save_path, \'r\')\n        else:\n            raise ValueError(""Unknown File Type: {0}."".format(base))\n\n        self._print(""Unpacking Data..."")\n        obj.extractall(save_path)\n        obj.close()\n        os.remove(temp_save_path)\n\n    def get(self, save_path, dataset=None):\n        """"""\n\n        Download a dataset.\n\n        Parameters:\n            save_path (str) -- A directory to save the data to.\n            dataset (str)   -- (optional). A specific dataset to download.\n                            Note: this must include the file extension.\n                            If None, options will be presented for you\n                            to choose from.\n\n        Returns:\n            save_path_full (str) -- the absolute path to the downloaded data.\n\n        """"""\n        if dataset is None:\n            selected_dataset = self._present_options()\n        else:\n            selected_dataset = dataset\n\n        save_path_full = join(save_path, selected_dataset.split(\'.\')[0])\n\n        if isdir(save_path_full):\n            warn(""\\n\'{0}\' already exists. Voiding Download."".format(\n                save_path_full))\n        else:\n            self._print(\'Downloading Data...\')\n            url = ""{0}/{1}"".format(self.url, selected_dataset)\n            self._download_data(url, save_path=save_path)\n\n        return abspath(save_path_full)\n'"
util/html.py,0,"b'import dominate\nfrom dominate.tags import meta, h3, table, tr, td, p, a, img, br\nimport os\n\n\nclass HTML:\n    """"""This HTML class allows us to save images and write texts into a single HTML file.\n\n     It consists of functions such as <add_header> (add a text header to the HTML file),\n     <add_images> (add a row of images to the HTML file), and <save> (save the HTML to the disk).\n     It is based on Python library \'dominate\', a Python library for creating and manipulating HTML documents using a DOM API.\n    """"""\n\n    def __init__(self, web_dir, title, refresh=0):\n        """"""Initialize the HTML classes\n\n        Parameters:\n            web_dir (str) -- a directory that stores the webpage. HTML file will be created at <web_dir>/index.html; images will be saved at <web_dir/images/\n            title (str)   -- the webpage name\n            refresh (int) -- how often the website refresh itself; if 0; no refreshing\n        """"""\n        self.title = title\n        self.web_dir = web_dir\n        self.img_dir = os.path.join(self.web_dir, \'images\')\n        if not os.path.exists(self.web_dir):\n            os.makedirs(self.web_dir)\n        if not os.path.exists(self.img_dir):\n            os.makedirs(self.img_dir)\n\n        self.doc = dominate.document(title=title)\n        if refresh > 0:\n            with self.doc.head:\n                meta(http_equiv=""refresh"", content=str(refresh))\n\n    def get_image_dir(self):\n        """"""Return the directory that stores images""""""\n        return self.img_dir\n\n    def add_header(self, text):\n        """"""Insert a header to the HTML file\n\n        Parameters:\n            text (str) -- the header text\n        """"""\n        with self.doc:\n            h3(text)\n\n    def add_images(self, ims, txts, links, width=400):\n        """"""add images to the HTML file\n\n        Parameters:\n            ims (str list)   -- a list of image paths\n            txts (str list)  -- a list of image names shown on the website\n            links (str list) --  a list of hyperref links; when you click an image, it will redirect you to a new page\n        """"""\n        self.t = table(border=1, style=""table-layout: fixed;"")  # Insert a table\n        self.doc.add(self.t)\n        with self.t:\n            with tr():\n                for im, txt, link in zip(ims, txts, links):\n                    with td(style=""word-wrap: break-word;"", halign=""center"", valign=""top""):\n                        with p():\n                            with a(href=os.path.join(\'images\', link)):\n                                img(style=""width:%dpx"" % width, src=os.path.join(\'images\', im))\n                            br()\n                            p(txt)\n\n    def save(self):\n        """"""save the current content to the HMTL file""""""\n        html_file = \'%s/index.html\' % self.web_dir\n        f = open(html_file, \'wt\')\n        f.write(self.doc.render())\n        f.close()\n\n\nif __name__ == \'__main__\':  # we show an example usage here.\n    html = HTML(\'web/\', \'test_html\')\n    html.add_header(\'hello world\')\n\n    ims, txts, links = [], [], []\n    for n in range(4):\n        ims.append(\'image_%d.png\' % n)\n        txts.append(\'text_%d\' % n)\n        links.append(\'image_%d.png\' % n)\n    html.add_images(ims, txts, links)\n    html.save()\n'"
util/image_pool.py,2,"b'import random\nimport torch\n\n\nclass ImagePool():\n    """"""This class implements an image buffer that stores previously generated images.\n\n    This buffer enables us to update discriminators using a history of generated images\n    rather than the ones produced by the latest generators.\n    """"""\n\n    def __init__(self, pool_size):\n        """"""Initialize the ImagePool class\n\n        Parameters:\n            pool_size (int) -- the size of image buffer, if pool_size=0, no buffer will be created\n        """"""\n        self.pool_size = pool_size\n        if self.pool_size > 0:  # create an empty pool\n            self.num_imgs = 0\n            self.images = []\n\n    def query(self, images):\n        """"""Return an image from the pool.\n\n        Parameters:\n            images: the latest generated images from the generator\n\n        Returns images from the buffer.\n\n        By 50/100, the buffer will return input images.\n        By 50/100, the buffer will return images previously stored in the buffer,\n        and insert the current images to the buffer.\n        """"""\n        if self.pool_size == 0:  # if the buffer size is 0, do nothing\n            return images\n        return_images = []\n        for image in images:\n            image = torch.unsqueeze(image.data, 0)\n            if self.num_imgs < self.pool_size:   # if the buffer is not full; keep inserting current images to the buffer\n                self.num_imgs = self.num_imgs + 1\n                self.images.append(image)\n                return_images.append(image)\n            else:\n                p = random.uniform(0, 1)\n                if p > 0.5:  # by 50% chance, the buffer will return a previously stored image, and insert the current image into the buffer\n                    random_id = random.randint(0, self.pool_size - 1)  # randint is inclusive\n                    tmp = self.images[random_id].clone()\n                    self.images[random_id] = image\n                    return_images.append(tmp)\n                else:       # by another 50% chance, the buffer will return the current image\n                    return_images.append(image)\n        return_images = torch.cat(return_images, 0)   # collect all the images and return\n        return return_images\n'"
util/util.py,2,"b'""""""This module contains simple helper functions """"""\nfrom __future__ import print_function\nimport torch\nimport numpy as np\nfrom PIL import Image\nimport os\n\n\ndef tensor2im(input_image, imtype=np.uint8):\n    """"""""Converts a Tensor array into a numpy image array.\n\n    Parameters:\n        input_image (tensor) --  the input image tensor array\n        imtype (type)        --  the desired type of the converted numpy array\n    """"""\n    if not isinstance(input_image, np.ndarray):\n        if isinstance(input_image, torch.Tensor):  # get the data from a variable\n            image_tensor = input_image.data\n        else:\n            return input_image\n        image_numpy = image_tensor[0].cpu().float().numpy()  # convert it into a numpy array\n        if image_numpy.shape[0] == 1:  # grayscale to RGB\n            image_numpy = np.tile(image_numpy, (3, 1, 1))\n        image_numpy = (np.transpose(image_numpy, (1, 2, 0)) + 1) / 2.0 * 255.0  # post-processing: tranpose and scaling\n    else:  # if it is a numpy array, do nothing\n        image_numpy = input_image\n    return image_numpy.astype(imtype)\n\n\ndef diagnose_network(net, name=\'network\'):\n    """"""Calculate and print the mean of average absolute(gradients)\n\n    Parameters:\n        net (torch network) -- Torch network\n        name (str) -- the name of the network\n    """"""\n    mean = 0.0\n    count = 0\n    for param in net.parameters():\n        if param.grad is not None:\n            mean += torch.mean(torch.abs(param.grad.data))\n            count += 1\n    if count > 0:\n        mean = mean / count\n    print(name)\n    print(mean)\n\n\ndef save_image(image_numpy, image_path, aspect_ratio=1.0):\n    """"""Save a numpy image to the disk\n\n    Parameters:\n        image_numpy (numpy array) -- input numpy array\n        image_path (str)          -- the path of the image\n    """"""\n\n    image_pil = Image.fromarray(image_numpy)\n    h, w, _ = image_numpy.shape\n\n    if aspect_ratio > 1.0:\n        image_pil = image_pil.resize((h, int(w * aspect_ratio)), Image.BICUBIC)\n    if aspect_ratio < 1.0:\n        image_pil = image_pil.resize((int(h / aspect_ratio), w), Image.BICUBIC)\n    image_pil.save(image_path)\n\n\ndef print_numpy(x, val=True, shp=False):\n    """"""Print the mean, min, max, median, std, and size of a numpy array\n\n    Parameters:\n        val (bool) -- if print the values of the numpy array\n        shp (bool) -- if print the shape of the numpy array\n    """"""\n    x = x.astype(np.float64)\n    if shp:\n        print(\'shape,\', x.shape)\n    if val:\n        x = x.flatten()\n        print(\'mean = %3.3f, min = %3.3f, max = %3.3f, median = %3.3f, std=%3.3f\' % (\n            np.mean(x), np.min(x), np.max(x), np.median(x), np.std(x)))\n\n\ndef mkdirs(paths):\n    """"""create empty directories if they don\'t exist\n\n    Parameters:\n        paths (str list) -- a list of directory paths\n    """"""\n    if isinstance(paths, list) and not isinstance(paths, str):\n        for path in paths:\n            mkdir(path)\n    else:\n        mkdir(paths)\n\n\ndef mkdir(path):\n    """"""create a single empty directory if it didn\'t exist\n\n    Parameters:\n        path (str) -- a single directory path\n    """"""\n    if not os.path.exists(path):\n        os.makedirs(path)\n'"
util/visualizer.py,0,"b'import numpy as np\nimport os\nimport sys\nimport ntpath\nimport time\nfrom . import util, html\nfrom subprocess import Popen, PIPE\n\n\nif sys.version_info[0] == 2:\n    VisdomExceptionBase = Exception\nelse:\n    VisdomExceptionBase = ConnectionError\n\n\ndef save_images(webpage, visuals, image_path, aspect_ratio=1.0, width=256):\n    """"""Save images to the disk.\n\n    Parameters:\n        webpage (the HTML class) -- the HTML webpage class that stores these imaegs (see html.py for more details)\n        visuals (OrderedDict)    -- an ordered dictionary that stores (name, images (either tensor or numpy) ) pairs\n        image_path (str)         -- the string is used to create image paths\n        aspect_ratio (float)     -- the aspect ratio of saved images\n        width (int)              -- the images will be resized to width x width\n\n    This function will save images stored in \'visuals\' to the HTML file specified by \'webpage\'.\n    """"""\n    image_dir = webpage.get_image_dir()\n    short_path = ntpath.basename(image_path[0])\n    name = os.path.splitext(short_path)[0]\n\n    webpage.add_header(name)\n    ims, txts, links = [], [], []\n\n    for label, im_data in visuals.items():\n        im = util.tensor2im(im_data)\n        image_name = \'%s_%s.png\' % (name, label)\n        save_path = os.path.join(image_dir, image_name)\n        util.save_image(im, save_path, aspect_ratio=aspect_ratio)\n        ims.append(image_name)\n        txts.append(label)\n        links.append(image_name)\n    webpage.add_images(ims, txts, links, width=width)\n\n\nclass Visualizer():\n    """"""This class includes several functions that can display/save images and print/save logging information.\n\n    It uses a Python library \'visdom\' for display, and a Python library \'dominate\' (wrapped in \'HTML\') for creating HTML files with images.\n    """"""\n\n    def __init__(self, opt):\n        """"""Initialize the Visualizer class\n\n        Parameters:\n            opt -- stores all the experiment flags; needs to be a subclass of BaseOptions\n        Step 1: Cache the training/test options\n        Step 2: connect to a visdom server\n        Step 3: create an HTML object for saveing HTML filters\n        Step 4: create a logging file to store training losses\n        """"""\n        self.opt = opt  # cache the option\n        self.display_id = opt.display_id\n        self.use_html = opt.isTrain and not opt.no_html\n        self.win_size = opt.display_winsize\n        self.name = opt.name\n        self.port = opt.display_port\n        self.saved = False\n        if self.display_id > 0:  # connect to a visdom server given <display_port> and <display_server>\n            import visdom\n            self.ncols = opt.display_ncols\n            self.vis = visdom.Visdom(server=opt.display_server, port=opt.display_port, env=opt.display_env)\n            if not self.vis.check_connection():\n                self.create_visdom_connections()\n\n        if self.use_html:  # create an HTML object at <checkpoints_dir>/web/; images will be saved under <checkpoints_dir>/web/images/\n            self.web_dir = os.path.join(opt.checkpoints_dir, opt.name, \'web\')\n            self.img_dir = os.path.join(self.web_dir, \'images\')\n            print(\'create web directory %s...\' % self.web_dir)\n            util.mkdirs([self.web_dir, self.img_dir])\n        # create a logging file to store training losses\n        self.log_name = os.path.join(opt.checkpoints_dir, opt.name, \'loss_log.txt\')\n        with open(self.log_name, ""a"") as log_file:\n            now = time.strftime(""%c"")\n            log_file.write(\'================ Training Loss (%s) ================\\n\' % now)\n\n    def reset(self):\n        """"""Reset the self.saved status""""""\n        self.saved = False\n\n    def create_visdom_connections(self):\n        """"""If the program could not connect to Visdom server, this function will start a new server at port < self.port > """"""\n        cmd = sys.executable + \' -m visdom.server -p %d &>/dev/null &\' % self.port\n        print(\'\\n\\nCould not connect to Visdom server. \\n Trying to start a server....\')\n        print(\'Command: %s\' % cmd)\n        Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE)\n\n    def display_current_results(self, visuals, epoch, save_result):\n        """"""Display current results on visdom; save current results to an HTML file.\n\n        Parameters:\n            visuals (OrderedDict) - - dictionary of images to display or save\n            epoch (int) - - the current epoch\n            save_result (bool) - - if save the current results to an HTML file\n        """"""\n        if self.display_id > 0:  # show images in the browser using visdom\n            ncols = self.ncols\n            if ncols > 0:        # show all the images in one visdom panel\n                ncols = min(ncols, len(visuals))\n                h, w = next(iter(visuals.values())).shape[:2]\n                table_css = """"""<style>\n                        table {border-collapse: separate; border-spacing: 4px; white-space: nowrap; text-align: center}\n                        table td {width: % dpx; height: % dpx; padding: 4px; outline: 4px solid black}\n                        </style>"""""" % (w, h)  # create a table css\n                # create a table of images.\n                title = self.name\n                label_html = \'\'\n                label_html_row = \'\'\n                images = []\n                idx = 0\n                for label, image in visuals.items():\n                    image_numpy = util.tensor2im(image)\n                    label_html_row += \'<td>%s</td>\' % label\n                    images.append(image_numpy.transpose([2, 0, 1]))\n                    idx += 1\n                    if idx % ncols == 0:\n                        label_html += \'<tr>%s</tr>\' % label_html_row\n                        label_html_row = \'\'\n                white_image = np.ones_like(image_numpy.transpose([2, 0, 1])) * 255\n                while idx % ncols != 0:\n                    images.append(white_image)\n                    label_html_row += \'<td></td>\'\n                    idx += 1\n                if label_html_row != \'\':\n                    label_html += \'<tr>%s</tr>\' % label_html_row\n                try:\n                    self.vis.images(images, nrow=ncols, win=self.display_id + 1,\n                                    padding=2, opts=dict(title=title + \' images\'))\n                    label_html = \'<table>%s</table>\' % label_html\n                    self.vis.text(table_css + label_html, win=self.display_id + 2,\n                                  opts=dict(title=title + \' labels\'))\n                except VisdomExceptionBase:\n                    self.create_visdom_connections()\n\n            else:     # show each image in a separate visdom panel;\n                idx = 1\n                try:\n                    for label, image in visuals.items():\n                        image_numpy = util.tensor2im(image)\n                        self.vis.image(image_numpy.transpose([2, 0, 1]), opts=dict(title=label),\n                                       win=self.display_id + idx)\n                        idx += 1\n                except VisdomExceptionBase:\n                    self.create_visdom_connections()\n\n        if self.use_html and (save_result or not self.saved):  # save images to an HTML file if they haven\'t been saved.\n            self.saved = True\n            # save images to the disk\n            for label, image in visuals.items():\n                image_numpy = util.tensor2im(image)\n                img_path = os.path.join(self.img_dir, \'epoch%.3d_%s.png\' % (epoch, label))\n                util.save_image(image_numpy, img_path)\n\n            # update website\n            webpage = html.HTML(self.web_dir, \'Experiment name = %s\' % self.name, refresh=1)\n            for n in range(epoch, 0, -1):\n                webpage.add_header(\'epoch [%d]\' % n)\n                ims, txts, links = [], [], []\n\n                for label, image_numpy in visuals.items():\n                    image_numpy = util.tensor2im(image)\n                    img_path = \'epoch%.3d_%s.png\' % (n, label)\n                    ims.append(img_path)\n                    txts.append(label)\n                    links.append(img_path)\n                webpage.add_images(ims, txts, links, width=self.win_size)\n            webpage.save()\n\n    def plot_current_losses(self, epoch, counter_ratio, losses):\n        """"""display the current losses on visdom display: dictionary of error labels and values\n\n        Parameters:\n            epoch (int)           -- current epoch\n            counter_ratio (float) -- progress (percentage) in the current epoch, between 0 to 1\n            losses (OrderedDict)  -- training losses stored in the format of (name, float) pairs\n        """"""\n        if not hasattr(self, \'plot_data\'):\n            self.plot_data = {\'X\': [], \'Y\': [], \'legend\': list(losses.keys())}\n        self.plot_data[\'X\'].append(epoch + counter_ratio)\n        self.plot_data[\'Y\'].append([losses[k] for k in self.plot_data[\'legend\']])\n        try:\n            self.vis.line(\n                X=np.stack([np.array(self.plot_data[\'X\'])] * len(self.plot_data[\'legend\']), 1),\n                Y=np.array(self.plot_data[\'Y\']),\n                opts={\n                    \'title\': self.name + \' loss over time\',\n                    \'legend\': self.plot_data[\'legend\'],\n                    \'xlabel\': \'epoch\',\n                    \'ylabel\': \'loss\'},\n                win=self.display_id)\n        except VisdomExceptionBase:\n            self.create_visdom_connections()\n\n    # losses: same format as |losses| of plot_current_losses\n    def print_current_losses(self, epoch, iters, losses, t_comp, t_data):\n        """"""print current losses on console; also save the losses to the disk\n\n        Parameters:\n            epoch (int) -- current epoch\n            iters (int) -- current training iteration during this epoch (reset to 0 at the end of every epoch)\n            losses (OrderedDict) -- training losses stored in the format of (name, float) pairs\n            t_comp (float) -- computational time per data point (normalized by batch_size)\n            t_data (float) -- data loading time per data point (normalized by batch_size)\n        """"""\n        message = \'(epoch: %d, iters: %d, time: %.3f, data: %.3f) \' % (epoch, iters, t_comp, t_data)\n        for k, v in losses.items():\n            message += \'%s: %.3f \' % (k, v)\n\n        print(message)  # print the message\n        with open(self.log_name, ""a"") as log_file:\n            log_file.write(\'%s\\n\' % message)  # save the message\n'"
scripts/edges/batch_hed.py,0,"b'# HED batch processing script; modified from https://github.com/s9xie/hed/blob/master/examples/hed/HED-tutorial.ipynb\n# Step 1: download the hed repo: https://github.com/s9xie/hed\n# Step 2: download the models and protoxt, and put them under {caffe_root}/examples/hed/\n# Step 3: put this script under {caffe_root}/examples/hed/\n# Step 4: run the following script:\n#       python batch_hed.py --images_dir=/data/to/path/photos/ --hed_mat_dir=/data/to/path/hed_mat_files/\n# The code sometimes crashes after computation is done. Error looks like ""Check failed: ... driver shutting down"". You can just kill the job.\n# For large images, it will produce gpu memory issue. Therefore, you better resize the images before running this script.\n# Step 5: run the MATLAB post-processing script ""PostprocessHED.m""\n\n\nimport caffe\nimport numpy as np\nfrom PIL import Image\nimport os\nimport argparse\nimport sys\nimport scipy.io as sio\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\'batch proccesing: photos->edges\')\n    parser.add_argument(\'--caffe_root\', dest=\'caffe_root\', help=\'caffe root\', default=\'../../\', type=str)\n    parser.add_argument(\'--caffemodel\', dest=\'caffemodel\', help=\'caffemodel\', default=\'./hed_pretrained_bsds.caffemodel\', type=str)\n    parser.add_argument(\'--prototxt\', dest=\'prototxt\', help=\'caffe prototxt file\', default=\'./deploy.prototxt\', type=str)\n    parser.add_argument(\'--images_dir\', dest=\'images_dir\', help=\'directory to store input photos\', type=str)\n    parser.add_argument(\'--hed_mat_dir\', dest=\'hed_mat_dir\', help=\'directory to store output hed edges in mat file\', type=str)\n    parser.add_argument(\'--border\', dest=\'border\', help=\'padding border\', type=int, default=128)\n    parser.add_argument(\'--gpu_id\', dest=\'gpu_id\', help=\'gpu id\', type=int, default=1)\n    args = parser.parse_args()\n    return args\n\n\nargs = parse_args()\nfor arg in vars(args):\n    print(\'[%s] =\' % arg, getattr(args, arg))\n# Make sure that caffe is on the python path:\ncaffe_root = args.caffe_root   # this file is expected to be in {caffe_root}/examples/hed/\nsys.path.insert(0, caffe_root + \'python\')\n\n\nif not os.path.exists(args.hed_mat_dir):\n    print(\'create output directory %s\' % args.hed_mat_dir)\n    os.makedirs(args.hed_mat_dir)\n\nimgList = os.listdir(args.images_dir)\nnImgs = len(imgList)\nprint(\'#images = %d\' % nImgs)\n\ncaffe.set_mode_gpu()\ncaffe.set_device(args.gpu_id)\n# load net\nnet = caffe.Net(args.prototxt, args.caffemodel, caffe.TEST)\n# pad border\nborder = args.border\n\nfor i in range(nImgs):\n    if i % 500 == 0:\n        print(\'processing image %d/%d\' % (i, nImgs))\n    im = Image.open(os.path.join(args.images_dir, imgList[i]))\n\n    in_ = np.array(im, dtype=np.float32)\n    in_ = np.pad(in_, ((border, border), (border, border), (0, 0)), \'reflect\')\n\n    in_ = in_[:, :, 0:3]\n    in_ = in_[:, :, ::-1]\n    in_ -= np.array((104.00698793, 116.66876762, 122.67891434))\n    in_ = in_.transpose((2, 0, 1))\n    # remove the following two lines if testing with cpu\n\n    # shape for input (data blob is N x C x H x W), set data\n    net.blobs[\'data\'].reshape(1, *in_.shape)\n    net.blobs[\'data\'].data[...] = in_\n    # run net and take argmax for prediction\n    net.forward()\n    fuse = net.blobs[\'sigmoid-fuse\'].data[0][0, :, :]\n    # get rid of the border\n    fuse = fuse[(border+35):(-border+35), (border+35):(-border+35)]\n    # save hed file to the disk\n    name, ext = os.path.splitext(imgList[i])\n    sio.savemat(os.path.join(args.hed_mat_dir, name + \'.mat\'), {\'edge_predict\': fuse})\n'"
scripts/eval_cityscapes/cityscapes.py,0,"b'# The following code is modified from https://github.com/shelhamer/clockwork-fcn\nimport sys\nimport os\nimport glob\nimport numpy as np\nfrom PIL import Image\n\n\nclass cityscapes:\n    def __init__(self, data_path):\n        # data_path something like /data2/cityscapes\n        self.dir = data_path\n        self.classes = [\'road\', \'sidewalk\', \'building\', \'wall\', \'fence\',\n                        \'pole\', \'traffic light\', \'traffic sign\', \'vegetation\', \'terrain\',\n                        \'sky\', \'person\', \'rider\', \'car\', \'truck\',\n                        \'bus\', \'train\', \'motorcycle\', \'bicycle\']\n        self.mean = np.array((72.78044, 83.21195, 73.45286), dtype=np.float32)\n        # import cityscapes label helper and set up label mappings\n        sys.path.insert(0, \'{}/scripts/helpers/\'.format(self.dir))\n        labels = __import__(\'labels\')\n        self.id2trainId = {label.id: label.trainId for label in labels.labels}  # dictionary mapping from raw IDs to train IDs\n        self.trainId2color = {label.trainId: label.color for label in labels.labels}  # dictionary mapping train IDs to colors as 3-tuples\n\n    def get_dset(self, split):\n        \'\'\'\n        List images as (city, id) for the specified split\n\n        TODO(shelhamer) generate splits from cityscapes itself, instead of\n        relying on these separately made text files.\n        \'\'\'\n        if split == \'train\':\n            dataset = open(\'{}/ImageSets/segFine/train.txt\'.format(self.dir)).read().splitlines()\n        else:\n            dataset = open(\'{}/ImageSets/segFine/val.txt\'.format(self.dir)).read().splitlines()\n        return [(item.split(\'/\')[0], item.split(\'/\')[1]) for item in dataset]\n\n    def load_image(self, split, city, idx):\n        im = Image.open(\'{}/leftImg8bit_sequence/{}/{}/{}_leftImg8bit.png\'.format(self.dir, split, city, idx))\n        return im\n\n    def assign_trainIds(self, label):\n        """"""\n        Map the given label IDs to the train IDs appropriate for training\n        Use the label mapping provided in labels.py from the cityscapes scripts\n        """"""\n        label = np.array(label, dtype=np.float32)\n        if sys.version_info[0] < 3:\n            for k, v in self.id2trainId.iteritems():\n                label[label == k] = v\n        else:\n            for k, v in self.id2trainId.items():\n                label[label == k] = v\n        return label\n\n    def load_label(self, split, city, idx):\n        """"""\n        Load label image as 1 x height x width integer array of label indices.\n        The leading singleton dimension is required by the loss.\n        """"""\n        label = Image.open(\'{}/gtFine/{}/{}/{}_gtFine_labelIds.png\'.format(self.dir, split, city, idx))\n        label = self.assign_trainIds(label)  # get proper labels for eval\n        label = np.array(label, dtype=np.uint8)\n        label = label[np.newaxis, ...]\n        return label\n\n    def preprocess(self, im):\n        """"""\n        Preprocess loaded image (by load_image) for Caffe:\n        - cast to float\n        - switch channels RGB -> BGR\n        - subtract mean\n        - transpose to channel x height x width order\n        """"""\n        in_ = np.array(im, dtype=np.float32)\n        in_ = in_[:, :, ::-1]\n        in_ -= self.mean\n        in_ = in_.transpose((2, 0, 1))\n        return in_\n\n    def palette(self, label):\n        \'\'\'\n        Map trainIds to colors as specified in labels.py\n        \'\'\'\n        if label.ndim == 3:\n            label = label[0]\n        color = np.empty((label.shape[0], label.shape[1], 3))\n        if sys.version_info[0] < 3:\n            for k, v in self.trainId2color.iteritems():\n                color[label == k, :] = v\n        else:\n            for k, v in self.trainId2color.items():\n                color[label == k, :] = v\n        return color\n\n    def make_boundaries(label, thickness=None):\n        """"""\n        Input is an image label, output is a numpy array mask encoding the boundaries of the objects\n        Extract pixels at the true boundary by dilation - erosion of label.\n        Don\'t just pick the void label as it is not exclusive to the boundaries.\n        """"""\n        assert(thickness is not None)\n        import skimage.morphology as skm\n        void = 255\n        mask = np.logical_and(label > 0, label != void)[0]\n        selem = skm.disk(thickness)\n        boundaries = np.logical_xor(skm.dilation(mask, selem),\n                                    skm.erosion(mask, selem))\n        return boundaries\n\n    def list_label_frames(self, split):\n        """"""\n        Select labeled frames from a split for evaluation\n        collected as (city, shot, idx) tuples\n        """"""\n        def file2idx(f):\n            """"""Helper to convert file path into frame ID""""""\n            city, shot, frame = (os.path.basename(f).split(\'_\')[:3])\n            return ""_"".join([city, shot, frame])\n        frames = []\n        cities = [os.path.basename(f) for f in glob.glob(\'{}/gtFine/{}/*\'.format(self.dir, split))]\n        for c in cities:\n            files = sorted(glob.glob(\'{}/gtFine/{}/{}/*labelIds.png\'.format(self.dir, split, c)))\n            frames.extend([file2idx(f) for f in files])\n        return frames\n\n    def collect_frame_sequence(self, split, idx, length):\n        """"""\n        Collect sequence of frames preceding (and including) a labeled frame\n        as a list of Images.\n\n        Note: 19 preceding frames are provided for each labeled frame.\n        """"""\n        SEQ_LEN = length\n        city, shot, frame = idx.split(\'_\')\n        frame = int(frame)\n        frame_seq = []\n        for i in range(frame - SEQ_LEN, frame + 1):\n            frame_path = \'{0}/leftImg8bit_sequence/val/{1}/{1}_{2}_{3:0>6d}_leftImg8bit.png\'.format(\n                self.dir, city, shot, i)\n            frame_seq.append(Image.open(frame_path))\n        return frame_seq\n'"
scripts/eval_cityscapes/evaluate.py,0,"b'import os\nimport caffe\nimport argparse\nimport numpy as np\nimport scipy.misc\nfrom PIL import Image\nfrom util import segrun, fast_hist, get_scores\nfrom cityscapes import cityscapes\n\nparser = argparse.ArgumentParser()\nparser.add_argument(""--cityscapes_dir"", type=str, required=True, help=""Path to the original cityscapes dataset"")\nparser.add_argument(""--result_dir"", type=str, required=True, help=""Path to the generated images to be evaluated"")\nparser.add_argument(""--output_dir"", type=str, required=True, help=""Where to save the evaluation results"")\nparser.add_argument(""--caffemodel_dir"", type=str, default=\'./scripts/eval_cityscapes/caffemodel/\', help=""Where the FCN-8s caffemodel stored"")\nparser.add_argument(""--gpu_id"", type=int, default=0, help=""Which gpu id to use"")\nparser.add_argument(""--split"", type=str, default=\'val\', help=""Data split to be evaluated"")\nparser.add_argument(""--save_output_images"", type=int, default=0, help=""Whether to save the FCN output images"")\nargs = parser.parse_args()\n\n\ndef main():\n    if not os.path.isdir(args.output_dir):\n        os.makedirs(args.output_dir)\n    if args.save_output_images > 0:\n        output_image_dir = args.output_dir + \'image_outputs/\'\n        if not os.path.isdir(output_image_dir):\n            os.makedirs(output_image_dir)\n    CS = cityscapes(args.cityscapes_dir)\n    n_cl = len(CS.classes)\n    label_frames = CS.list_label_frames(args.split)\n    caffe.set_device(args.gpu_id)\n    caffe.set_mode_gpu()\n    net = caffe.Net(args.caffemodel_dir + \'/deploy.prototxt\',\n                    args.caffemodel_dir + \'fcn-8s-cityscapes.caffemodel\',\n                    caffe.TEST)\n\n    hist_perframe = np.zeros((n_cl, n_cl))\n    for i, idx in enumerate(label_frames):\n        if i % 10 == 0:\n            print(\'Evaluating: %d/%d\' % (i, len(label_frames)))\n        city = idx.split(\'_\')[0]\n        # idx is city_shot_frame\n        label = CS.load_label(args.split, city, idx)\n        im_file = args.result_dir + \'/\' + idx + \'_leftImg8bit.png\'\n        im = np.array(Image.open(im_file))\n        im = scipy.misc.imresize(im, (label.shape[1], label.shape[2]))\n        out = segrun(net, CS.preprocess(im))\n        hist_perframe += fast_hist(label.flatten(), out.flatten(), n_cl)\n        if args.save_output_images > 0:\n            label_im = CS.palette(label)\n            pred_im = CS.palette(out)\n            scipy.misc.imsave(output_image_dir + \'/\' + str(i) + \'_pred.jpg\', pred_im)\n            scipy.misc.imsave(output_image_dir + \'/\' + str(i) + \'_gt.jpg\', label_im)\n            scipy.misc.imsave(output_image_dir + \'/\' + str(i) + \'_input.jpg\', im)\n\n    mean_pixel_acc, mean_class_acc, mean_class_iou, per_class_acc, per_class_iou = get_scores(hist_perframe)\n    with open(args.output_dir + \'/evaluation_results.txt\', \'w\') as f:\n        f.write(\'Mean pixel accuracy: %f\\n\' % mean_pixel_acc)\n        f.write(\'Mean class accuracy: %f\\n\' % mean_class_acc)\n        f.write(\'Mean class IoU: %f\\n\' % mean_class_iou)\n        f.write(\'************ Per class numbers below ************\\n\')\n        for i, cl in enumerate(CS.classes):\n            while len(cl) < 15:\n                cl = cl + \' \'\n            f.write(\'%s: acc = %f, iou = %f\\n\' % (cl, per_class_acc[i], per_class_iou[i]))\n\n\nmain()\n'"
scripts/eval_cityscapes/util.py,0,"b'# The following code is modified from https://github.com/shelhamer/clockwork-fcn\nimport numpy as np\n\n\ndef get_out_scoremap(net):\n    return net.blobs[\'score\'].data[0].argmax(axis=0).astype(np.uint8)\n\n\ndef feed_net(net, in_):\n    """"""\n    Load prepared input into net.\n    """"""\n    net.blobs[\'data\'].reshape(1, *in_.shape)\n    net.blobs[\'data\'].data[...] = in_\n\n\ndef segrun(net, in_):\n    feed_net(net, in_)\n    net.forward()\n    return get_out_scoremap(net)\n\n\ndef fast_hist(a, b, n):\n    k = np.where((a >= 0) & (a < n))[0]\n    bc = np.bincount(n * a[k].astype(int) + b[k], minlength=n**2)\n    if len(bc) != n**2:\n        # ignore this example if dimension mismatch\n        return 0\n    return bc.reshape(n, n)\n\n\ndef get_scores(hist):\n    # Mean pixel accuracy\n    acc = np.diag(hist).sum() / (hist.sum() + 1e-12)\n\n    # Per class accuracy\n    cl_acc = np.diag(hist) / (hist.sum(1) + 1e-12)\n\n    # Per class IoU\n    iu = np.diag(hist) / (hist.sum(1) + hist.sum(0) - np.diag(hist) + 1e-12)\n\n    return acc, np.nanmean(cl_acc), np.nanmean(iu), cl_acc, iu\n'"
