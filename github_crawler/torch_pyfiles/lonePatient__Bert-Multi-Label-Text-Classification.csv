file_path,api_count,code
__init__.py,0,b'#encoding:utf-8'
predict_one.py,1,"b'import torch\nfrom pybert.configs.basic_config import config\nfrom pybert.io.bert_processor import BertProcessor\nfrom pybert.model.bert_for_multi_label import BertForMultiLable\n\ndef main(text,arch,max_seq_length,do_lower_case):\n    processor = BertProcessor(vocab_path=config[\'bert_vocab_path\'], do_lower_case=do_lower_case)\n    label_list = processor.get_labels()\n    id2label = {i: label for i, label in enumerate(label_list)}\n    model = BertForMultiLable.from_pretrained(config[\'checkpoint_dir\'] /f\'{arch}\', num_labels=len(label_list))\n    tokens = processor.tokenizer.tokenize(text)\n    if len(tokens) > max_seq_length - 2:\n        tokens = tokens[:max_seq_length - 2]\n    tokens = [\'[CLS]\'] + tokens + [\'[SEP]\']\n    input_ids = processor.tokenizer.convert_tokens_to_ids(tokens)\n    input_ids = torch.tensor(input_ids).unsqueeze(0)  # Batch size 1, 2 choices\n    logits = model(input_ids)\n    probs = logits.sigmoid()\n    return probs.cpu().detach().numpy()[0]\n\nif __name__ == ""__main__"":\n    text = \'\'\'\'""FUCK YOUR FILTHY MOTHER IN THE ASS, DRY!""\'\'\'\n    max_seq_length = 256\n    do_loer_case = True\n    arch = \'bert\'\n    probs = main(text,arch,max_seq_length,do_loer_case)\n    print(probs)\n    \n  \'\'\'\n  #output\n  [0.98304486 0.40958735 0.9851305  0.04566246 0.8630512  0.07316463]\n  \'\'\'\n'"
run_albert.py,4,"b'import torch\nimport time\nimport warnings\nfrom pathlib import Path\nfrom argparse import ArgumentParser\nfrom pybert.train.losses import BCEWithLogLoss\nfrom pybert.train.trainer import Trainer\nfrom torch.utils.data import DataLoader\n\nfrom pybert.common.tools import init_logger, logger\nfrom pybert.common.tools import seed_everything\nfrom pybert.configs.basic_config import config\nfrom pybert.io.albert_processor import AlbertProcessor\nfrom pybert.io.utils import collate_fn\nfrom pybert.model.albert_for_multi_label import AlbertForMultiLable\nfrom pybert.preprocessing.preprocessor import EnglishPreProcessor\nfrom pybert.callback.modelcheckpoint import ModelCheckpoint\nfrom pybert.callback.trainingmonitor import TrainingMonitor\nfrom pybert.train.metrics import AUC, AccuracyThresh, MultiLabelReport\nfrom pybert.callback.optimizater.adamw import AdamW\nfrom pybert.callback.lr_schedulers import get_linear_schedule_with_warmup\nfrom torch.utils.data import RandomSampler, SequentialSampler\nwarnings.filterwarnings(""ignore"")\n\ndef run_train(args):\n    # --------- data\n    processor = AlbertProcessor(spm_model_file=config[\'albert_vocab_path\'], do_lower_case=args.do_lower_case,\n                                vocab_file=None)\n    label_list = processor.get_labels()\n    label2id = {label: i for i, label in enumerate(label_list)}\n    id2label = {i: label for i, label in enumerate(label_list)}\n\n    train_data = processor.get_train(config[\'data_dir\'] / f""{args.data_name}.train.pkl"")\n    train_examples = processor.create_examples(lines=train_data,\n                                               example_type=\'train\',\n                                               cached_examples_file=config[\n                                                    \'data_dir\'] / f""cached_train_examples_{args.arch}"")\n    train_features = processor.create_features(examples=train_examples,\n                                               max_seq_len=args.train_max_seq_len,\n                                               cached_features_file=config[\n                                                    \'data_dir\'] / ""cached_train_features_{}_{}"".format(\n                                                   args.train_max_seq_len, args.arch\n                                               ))\n    train_dataset = processor.create_dataset(train_features, is_sorted=args.sorted)\n    if args.sorted:\n        train_sampler = SequentialSampler(train_dataset)\n    else:\n        train_sampler = RandomSampler(train_dataset)\n    train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,\n                                  collate_fn=collate_fn)\n    valid_data = processor.get_dev(config[\'data_dir\'] / f""{args.data_name}.valid.pkl"")\n    valid_examples = processor.create_examples(lines=valid_data,\n                                               example_type=\'valid\',\n                                               cached_examples_file=config[\n                                                \'data_dir\'] / f""cached_valid_examples_{args.arch}"")\n\n    valid_features = processor.create_features(examples=valid_examples,\n                                               max_seq_len=args.eval_max_seq_len,\n                                               cached_features_file=config[\n                                                \'data_dir\'] / ""cached_valid_features_{}_{}"".format(\n                                                   args.eval_max_seq_len, args.arch\n                                               ))\n    valid_dataset = processor.create_dataset(valid_features)\n    valid_sampler = SequentialSampler(valid_dataset)\n    valid_dataloader = DataLoader(valid_dataset, sampler=valid_sampler, batch_size=args.eval_batch_size,\n                                  collate_fn=collate_fn)\n\n    # ------- model\n    logger.info(""initializing model"")\n    if args.resume_path:\n        args.resume_path = Path(args.resume_path)\n        model = AlbertForMultiLable.from_pretrained(args.resume_path, num_labels=len(label_list))\n    else:\n        model = AlbertForMultiLable.from_pretrained(config[\'albert_model_dir\'], num_labels=len(label_list))\n    t_total = int(len(train_dataloader) / args.gradient_accumulation_steps * args.epochs)\n\n    param_optimizer = list(model.named_parameters())\n    no_decay = [\'bias\', \'LayerNorm.weight\']\n    optimizer_grouped_parameters = [\n        {\'params\': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)],\'weight_decay\': args.weight_decay},\n        {\'params\': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)], \'weight_decay\': 0.0}\n    ]\n    warmup_steps = int(t_total * args.warmup_proportion)\n    optimizer = AdamW(optimizer_grouped_parameters, lr=args.learning_rate, eps=args.adam_epsilon)\n    scheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=warmup_steps,\n                                                num_training_steps=t_total)\n    if args.fp16:\n        try:\n            from apex import amp\n        except ImportError:\n            raise ImportError(""Please install apex from https://www.github.com/nvidia/apex to use fp16 training."")\n        model, optimizer = amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)\n    # ---- callbacks\n    logger.info(""initializing callbacks"")\n    train_monitor = TrainingMonitor(file_dir=config[\'figure_dir\'], arch=args.arch)\n    model_checkpoint = ModelCheckpoint(checkpoint_dir=config[\'checkpoint_dir\'],mode=args.mode,\n                                       monitor=args.monitor,arch=args.arch,\n                                       save_best_only=args.save_best)\n\n    # **************************** training model ***********************\n    logger.info(""***** Running training *****"")\n    logger.info(""  Num examples = %d"", len(train_examples))\n    logger.info(""  Num Epochs = %d"", args.epochs)\n    logger.info(""  Total train batch size (w. parallel, distributed & accumulation) = %d"",\n                args.train_batch_size * args.gradient_accumulation_steps * (\n                    torch.distributed.get_world_size() if args.local_rank != -1 else 1))\n    logger.info(""  Gradient Accumulation steps = %d"", args.gradient_accumulation_steps)\n    logger.info(""  Total optimization steps = %d"", t_total)\n\n    trainer = Trainer(args= args,model=model,logger=logger,criterion=BCEWithLogLoss(),optimizer=optimizer,\n                      scheduler=scheduler,early_stopping=None,training_monitor=train_monitor,\n                      model_checkpoint=model_checkpoint,\n                      batch_metrics=[AccuracyThresh(thresh=0.5)],\n                      epoch_metrics=[AUC(average=\'micro\', task_type=\'binary\'),\n                                     MultiLabelReport(id2label=id2label)])\n    trainer.train(train_data=train_dataloader, valid_data=valid_dataloader)\n\ndef run_test(args):\n    from pybert.io.task_data import TaskData\n    from pybert.test.predictor import Predictor\n    data = TaskData()\n    targets, sentences = data.read_data(raw_data_path=config[\'test_path\'],\n                                        preprocessor=EnglishPreProcessor(),\n                                        is_train=False)\n    lines = list(zip(sentences, targets))\n    processor = AlbertProcessor(spm_model_file=config[\'albert_vocab_path\'], do_lower_case=args.do_lower_case,\n                                vocab_file=None)\n    label_list = processor.get_labels()\n    id2label = {i: label for i, label in enumerate(label_list)}\n\n    test_data = processor.get_test(lines=lines)\n    test_examples = processor.create_examples(lines=test_data,\n                                              example_type=\'test\',\n                                              cached_examples_file=config[\n                                             \'data_dir\'] / f""cached_test_examples_{args.arch}"")\n    test_features = processor.create_features(examples=test_examples,\n                                              max_seq_len=args.eval_max_seq_len,\n                                              cached_features_file=config[\n                                              \'data_dir\'] / ""cached_test_features_{}_{}"".format(\n                                                  args.eval_max_seq_len, args.arch\n                                              ))\n    test_dataset = processor.create_dataset(test_features)\n    test_sampler = SequentialSampler(test_dataset)\n    test_dataloader = DataLoader(test_dataset, sampler=test_sampler, batch_size=args.train_batch_size,\n                                 collate_fn=collate_fn)\n    model = AlbertForMultiLable.from_pretrained(config[\'checkpoint_dir\'], num_labels=len(label_list))\n\n    # ----------- predicting\n    logger.info(\'model predicting....\')\n    predictor = Predictor(model=model,logger=logger,n_gpu=args.n_gpu)\n    result = predictor.predict(data=test_dataloader)\n    print(result)\n\n\ndef main():\n    parser = ArgumentParser()\n    parser.add_argument(""--arch"", default=\'albert\', type=str)\n    parser.add_argument(""--do_data"", action=\'store_true\')\n    parser.add_argument(""--do_train"", action=\'store_true\')\n    parser.add_argument(""--do_test"", action=\'store_true\')\n    parser.add_argument(""--save_best"", action=\'store_true\')\n    parser.add_argument(""--do_lower_case"", action=\'store_true\')\n    parser.add_argument(\'--data_name\', default=\'kaggle\', type=str)\n    parser.add_argument(""--mode"", default=\'min\', type=str)\n    parser.add_argument(""--monitor"", default=\'valid_loss\', type=str)\n\n    parser.add_argument(""--epochs"", default=6, type=int)\n    parser.add_argument(""--resume_path"", default=\'\', type=str)\n    parser.add_argument(""--valid_size"", default=0.2, type=float)\n    parser.add_argument(""--local_rank"", type=int, default=-1)\n    parser.add_argument(""--sorted"", default=1, type=int, help=\'1 : True  0:False \')\n    parser.add_argument(""--n_gpu"", type=str, default=\'0\', help=\'""0,1,.."" or ""0"" or """" \')\n    parser.add_argument(\'--gradient_accumulation_steps\', type=int, default=1)\n    parser.add_argument(""--train_batch_size"", default=16, type=int)\n    parser.add_argument(\'--eval_batch_size\', default=16, type=int)\n    parser.add_argument(""--train_max_seq_len"", default=256, type=int)\n    parser.add_argument(""--eval_max_seq_len"", default=256, type=int)\n    parser.add_argument(\'--loss_scale\', type=float, default=0)\n    parser.add_argument(""--warmup_proportion"", default=0.1, type=float)\n    parser.add_argument(""--weight_decay"", default=0.01, type=float)\n    parser.add_argument(""--adam_epsilon"", default=1e-8, type=float)\n    parser.add_argument(""--grad_clip"", default=1.0, type=float)\n    parser.add_argument(""--learning_rate"", default=1e-5, type=float)\n    parser.add_argument(\'--seed\', type=int, default=42)\n    parser.add_argument(\'--fp16\', action=\'store_true\')\n    parser.add_argument(\'--fp16_opt_level\', type=str, default=\'O1\')\n    args = parser.parse_args()\n\n    init_logger(log_file=config[\'log_dir\'] / f\'{args.arch}-{time.strftime(""%Y-%m-%d-%H:%M:%S"", time.localtime())}.log\')\n    config[\'checkpoint_dir\'] = config[\'checkpoint_dir\'] / args.arch\n    config[\'checkpoint_dir\'].mkdir(exist_ok=True)\n    # Good practice: save your training arguments together with the trained model\n    torch.save(args, config[\'checkpoint_dir\'] / \'training_args.bin\')\n    seed_everything(args.seed)\n    logger.info(""Training/evaluation parameters %s"", args)\n    if args.do_data:\n        from pybert.io.task_data import TaskData\n        data = TaskData()\n        targets, sentences = data.read_data(raw_data_path=config[\'raw_data_path\'],\n                                            preprocessor=EnglishPreProcessor(),\n                                            is_train=True)\n        data.train_val_split(X=sentences, y=targets, shuffle=True, stratify=False,\n                             valid_size=args.valid_size, data_dir=config[\'data_dir\'],\n                             data_name=args.data_name)\n    if args.do_train:\n        run_train(args)\n\n    if args.do_test:\n        run_test(args)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
run_bert.py,4,"b'import torch\r\nimport time\r\nimport warnings\r\nfrom pathlib import Path\r\nfrom argparse import ArgumentParser\r\nfrom pybert.train.losses import BCEWithLogLoss\r\nfrom pybert.train.trainer import Trainer\r\nfrom torch.utils.data import DataLoader\r\nfrom pybert.io.utils import collate_fn\r\nfrom pybert.io.bert_processor import BertProcessor\r\nfrom pybert.common.tools import init_logger, logger\r\nfrom pybert.common.tools import seed_everything\r\nfrom pybert.configs.basic_config import config\r\nfrom pybert.model.bert_for_multi_label import BertForMultiLable\r\nfrom pybert.preprocessing.preprocessor import EnglishPreProcessor\r\nfrom pybert.callback.modelcheckpoint import ModelCheckpoint\r\nfrom pybert.callback.trainingmonitor import TrainingMonitor\r\nfrom pybert.train.metrics import AUC, AccuracyThresh, MultiLabelReport\r\nfrom pybert.callback.optimizater.adamw import AdamW\r\nfrom pybert.callback.lr_schedulers import get_linear_schedule_with_warmup\r\nfrom torch.utils.data import RandomSampler, SequentialSampler\r\n\r\nwarnings.filterwarnings(""ignore"")\r\n\r\n\r\ndef run_train(args):\r\n    # --------- data\r\n    processor = BertProcessor(vocab_path=config[\'bert_vocab_path\'], do_lower_case=args.do_lower_case)\r\n    label_list = processor.get_labels()\r\n    label2id = {label: i for i, label in enumerate(label_list)}\r\n    id2label = {i: label for i, label in enumerate(label_list)}\r\n\r\n    train_data = processor.get_train(config[\'data_dir\'] / f""{args.data_name}.train.pkl"")\r\n    train_examples = processor.create_examples(lines=train_data,\r\n                                               example_type=\'train\',\r\n                                               cached_examples_file=config[\r\n                                                    \'data_dir\'] / f""cached_train_examples_{args.arch}"")\r\n    train_features = processor.create_features(examples=train_examples,\r\n                                               max_seq_len=args.train_max_seq_len,\r\n                                               cached_features_file=config[\r\n                                                    \'data_dir\'] / ""cached_train_features_{}_{}"".format(\r\n                                                   args.train_max_seq_len, args.arch\r\n                                               ))\r\n    train_dataset = processor.create_dataset(train_features, is_sorted=args.sorted)\r\n    if args.sorted:\r\n        train_sampler = SequentialSampler(train_dataset)\r\n    else:\r\n        train_sampler = RandomSampler(train_dataset)\r\n    train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,\r\n                                  collate_fn=collate_fn)\r\n\r\n    valid_data = processor.get_dev(config[\'data_dir\'] / f""{args.data_name}.valid.pkl"")\r\n    valid_examples = processor.create_examples(lines=valid_data,\r\n                                               example_type=\'valid\',\r\n                                               cached_examples_file=config[\r\n                                                \'data_dir\'] / f""cached_valid_examples_{args.arch}"")\r\n\r\n    valid_features = processor.create_features(examples=valid_examples,\r\n                                               max_seq_len=args.eval_max_seq_len,\r\n                                               cached_features_file=config[\r\n                                                \'data_dir\'] / ""cached_valid_features_{}_{}"".format(\r\n                                                   args.eval_max_seq_len, args.arch\r\n                                               ))\r\n    valid_dataset = processor.create_dataset(valid_features)\r\n    valid_sampler = SequentialSampler(valid_dataset)\r\n    valid_dataloader = DataLoader(valid_dataset, sampler=valid_sampler, batch_size=args.eval_batch_size,\r\n                                  collate_fn=collate_fn)\r\n\r\n    # ------- model\r\n    logger.info(""initializing model"")\r\n    if args.resume_path:\r\n        args.resume_path = Path(args.resume_path)\r\n        model = BertForMultiLable.from_pretrained(args.resume_path, num_labels=len(label_list))\r\n    else:\r\n        model = BertForMultiLable.from_pretrained(config[\'bert_model_dir\'], num_labels=len(label_list))\r\n    t_total = int(len(train_dataloader) / args.gradient_accumulation_steps * args.epochs)\r\n\r\n    param_optimizer = list(model.named_parameters())\r\n    no_decay = [\'bias\', \'LayerNorm.weight\']\r\n    optimizer_grouped_parameters = [\r\n        {\'params\': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)],\'weight_decay\': args.weight_decay},\r\n        {\'params\': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)], \'weight_decay\': 0.0}\r\n    ]\r\n    warmup_steps = int(t_total * args.warmup_proportion)\r\n    optimizer = AdamW(optimizer_grouped_parameters, lr=args.learning_rate, eps=args.adam_epsilon)\r\n    scheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=warmup_steps,\r\n                                                num_training_steps=t_total)\r\n    if args.fp16:\r\n        try:\r\n            from apex import amp\r\n        except ImportError:\r\n            raise ImportError(""Please install apex from https://www.github.com/nvidia/apex to use fp16 training."")\r\n        model, optimizer = amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)\r\n    # ---- callbacks\r\n    logger.info(""initializing callbacks"")\r\n    train_monitor = TrainingMonitor(file_dir=config[\'figure_dir\'], arch=args.arch)\r\n    model_checkpoint = ModelCheckpoint(checkpoint_dir=config[\'checkpoint_dir\'],mode=args.mode,\r\n                                       monitor=args.monitor,arch=args.arch,\r\n                                       save_best_only=args.save_best)\r\n\r\n    # **************************** training model ***********************\r\n    logger.info(""***** Running training *****"")\r\n    logger.info(""  Num examples = %d"", len(train_examples))\r\n    logger.info(""  Num Epochs = %d"", args.epochs)\r\n    logger.info(""  Total train batch size (w. parallel, distributed & accumulation) = %d"",\r\n                args.train_batch_size * args.gradient_accumulation_steps * (\r\n                    torch.distributed.get_world_size() if args.local_rank != -1 else 1))\r\n    logger.info(""  Gradient Accumulation steps = %d"", args.gradient_accumulation_steps)\r\n    logger.info(""  Total optimization steps = %d"", t_total)\r\n\r\n    trainer = Trainer(args= args,model=model,logger=logger,criterion=BCEWithLogLoss(),optimizer=optimizer,\r\n                      scheduler=scheduler,early_stopping=None,training_monitor=train_monitor,\r\n                      model_checkpoint=model_checkpoint,\r\n                      batch_metrics=[AccuracyThresh(thresh=0.5)],\r\n                      epoch_metrics=[AUC(average=\'micro\', task_type=\'binary\'),\r\n                                     MultiLabelReport(id2label=id2label)])\r\n    trainer.train(train_data=train_dataloader, valid_data=valid_dataloader)\r\n\r\ndef run_test(args):\r\n    from pybert.io.task_data import TaskData\r\n    from pybert.test.predictor import Predictor\r\n    data = TaskData()\r\n    targets, sentences = data.read_data(raw_data_path=config[\'test_path\'],\r\n                                        preprocessor=EnglishPreProcessor(),\r\n                                        is_train=False)\r\n    lines = list(zip(sentences, targets))\r\n    processor = BertProcessor(vocab_path=config[\'bert_vocab_path\'], do_lower_case=args.do_lower_case)\r\n    label_list = processor.get_labels()\r\n    id2label = {i: label for i, label in enumerate(label_list)}\r\n\r\n    test_data = processor.get_test(lines=lines)\r\n    test_examples = processor.create_examples(lines=test_data,\r\n                                              example_type=\'test\',\r\n                                              cached_examples_file=config[\r\n                                            \'data_dir\'] / f""cached_test_examples_{args.arch}"")\r\n    test_features = processor.create_features(examples=test_examples,\r\n                                              max_seq_len=args.eval_max_seq_len,\r\n                                              cached_features_file=config[\r\n                                            \'data_dir\'] / ""cached_test_features_{}_{}"".format(\r\n                                                  args.eval_max_seq_len, args.arch\r\n                                              ))\r\n    test_dataset = processor.create_dataset(test_features)\r\n    test_sampler = SequentialSampler(test_dataset)\r\n    test_dataloader = DataLoader(test_dataset, sampler=test_sampler, batch_size=args.train_batch_size,\r\n                                 collate_fn=collate_fn)\r\n    model = BertForMultiLable.from_pretrained(config[\'checkpoint_dir\'], num_labels=len(label_list))\r\n\r\n    # ----------- predicting\r\n    logger.info(\'model predicting....\')\r\n    predictor = Predictor(model=model,\r\n                          logger=logger,\r\n                          n_gpu=args.n_gpu)\r\n    result = predictor.predict(data=test_dataloader)\r\n    print(result)\r\n\r\n\r\ndef main():\r\n    parser = ArgumentParser()\r\n    parser.add_argument(""--arch"", default=\'bert\', type=str)\r\n    parser.add_argument(""--do_data"", action=\'store_true\')\r\n    parser.add_argument(""--do_train"", action=\'store_true\')\r\n    parser.add_argument(""--do_test"", action=\'store_true\')\r\n    parser.add_argument(""--save_best"", action=\'store_true\')\r\n    parser.add_argument(""--do_lower_case"", action=\'store_true\')\r\n    parser.add_argument(\'--data_name\', default=\'kaggle\', type=str)\r\n    parser.add_argument(""--mode"", default=\'min\', type=str)\r\n    parser.add_argument(""--monitor"", default=\'valid_loss\', type=str)\r\n\r\n    parser.add_argument(""--epochs"", default=6, type=int)\r\n    parser.add_argument(""--resume_path"", default=\'\', type=str)\r\n    parser.add_argument(""--predict_checkpoints"", type=int, default=0)\r\n    parser.add_argument(""--valid_size"", default=0.2, type=float)\r\n    parser.add_argument(""--local_rank"", type=int, default=-1)\r\n    parser.add_argument(""--sorted"", default=1, type=int, help=\'1 : True  0:False \')\r\n    parser.add_argument(""--n_gpu"", type=str, default=\'0\', help=\'""0,1,.."" or ""0"" or """" \')\r\n    parser.add_argument(\'--gradient_accumulation_steps\', type=int, default=1)\r\n    parser.add_argument(""--train_batch_size"", default=8, type=int)\r\n    parser.add_argument(\'--eval_batch_size\', default=8, type=int)\r\n    parser.add_argument(""--train_max_seq_len"", default=256, type=int)\r\n    parser.add_argument(""--eval_max_seq_len"", default=256, type=int)\r\n    parser.add_argument(\'--loss_scale\', type=float, default=0)\r\n    parser.add_argument(""--warmup_proportion"", default=0.1, type=float)\r\n    parser.add_argument(""--weight_decay"", default=0.01, type=float)\r\n    parser.add_argument(""--adam_epsilon"", default=1e-8, type=float)\r\n    parser.add_argument(""--grad_clip"", default=1.0, type=float)\r\n    parser.add_argument(""--learning_rate"", default=2e-5, type=float)\r\n    parser.add_argument(\'--seed\', type=int, default=42)\r\n    parser.add_argument(\'--fp16\', action=\'store_true\')\r\n    parser.add_argument(\'--fp16_opt_level\', type=str, default=\'O1\')\r\n    args = parser.parse_args()\r\n\r\n    init_logger(log_file=config[\'log_dir\'] / f\'{args.arch}-{time.strftime(""%Y-%m-%d-%H:%M:%S"", time.localtime())}.log\')\r\n    config[\'checkpoint_dir\'] = config[\'checkpoint_dir\'] / args.arch\r\n    config[\'checkpoint_dir\'].mkdir(exist_ok=True)\r\n    # Good practice: save your training arguments together with the trained model\r\n    torch.save(args, config[\'checkpoint_dir\'] / \'training_args.bin\')\r\n    seed_everything(args.seed)\r\n    logger.info(""Training/evaluation parameters %s"", args)\r\n    if args.do_data:\r\n        from pybert.io.task_data import TaskData\r\n        data = TaskData()\r\n        targets, sentences = data.read_data(raw_data_path=config[\'raw_data_path\'],\r\n                                            preprocessor=EnglishPreProcessor(),\r\n                                            is_train=True)\r\n        data.train_val_split(X=sentences, y=targets, shuffle=True, stratify=False,\r\n                             valid_size=args.valid_size, data_dir=config[\'data_dir\'],\r\n                             data_name=args.data_name)\r\n    if args.do_train:\r\n        run_train(args)\r\n\r\n    if args.do_test:\r\n        run_test(args)\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\r\n'"
run_xlnet.py,4,"b'import torch\nimport time\nimport warnings\nfrom pathlib import Path\nfrom argparse import ArgumentParser\nfrom pybert.train.losses import BCEWithLogLoss\nfrom pybert.train.trainer import Trainer\nfrom torch.utils.data import DataLoader\nfrom pybert.io.utils import xlnet_collate_fn as collate_fn\nfrom pybert.io.xlnet_processor import  XlnetProcessor\nfrom pybert.common.tools import init_logger, logger\nfrom pybert.common.tools import seed_everything\nfrom pybert.configs.basic_config import config\nfrom pybert.model.xlnet_for_multi_label import XlnetForMultiLable\nfrom pybert.preprocessing.preprocessor import EnglishPreProcessor\nfrom pybert.callback.modelcheckpoint import ModelCheckpoint\nfrom pybert.callback.trainingmonitor import TrainingMonitor\nfrom pybert.train.metrics import AUC, AccuracyThresh, MultiLabelReport\nfrom pybert.callback.optimizater.adamw import AdamW\nfrom pybert.callback.lr_schedulers import get_linear_schedule_with_warmup\nfrom torch.utils.data import RandomSampler, SequentialSampler\nwarnings.filterwarnings(""ignore"")\n\n\ndef run_train(args):\n    # --------- data\n    processor = XlnetProcessor(vocab_path=str(config[\'xlnet_vocab_path\']), do_lower_case=args.do_lower_case)\n    label_list = processor.get_labels()\n    label2id = {label: i for i, label in enumerate(label_list)}\n    id2label = {i: label for i, label in enumerate(label_list)}\n\n    train_data = processor.get_train(config[\'data_dir\'] / f""{args.data_name}.train.pkl"")\n    train_examples = processor.create_examples(lines=train_data,\n                                               example_type=\'train\',\n                                               cached_examples_file=config[\n                                                    \'data_dir\'] / f""cached_train_examples_{args.arch}"")\n    train_features = processor.create_features(examples=train_examples,\n                                               max_seq_len=args.train_max_seq_len,\n                                               cached_features_file=config[\n                                                    \'data_dir\'] / ""cached_train_features_{}_{}"".format(\n                                                   args.train_max_seq_len, args.arch\n                                               ))\n    train_dataset = processor.create_dataset(train_features, is_sorted=args.sorted)\n    if args.sorted:\n        train_sampler = SequentialSampler(train_dataset)\n    else:\n        train_sampler = RandomSampler(train_dataset)\n    train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,\n                                  collate_fn=collate_fn)\n\n    valid_data = processor.get_dev(config[\'data_dir\'] / f""{args.data_name}.valid.pkl"")\n    valid_examples = processor.create_examples(lines=valid_data,\n                                               example_type=\'valid\',\n                                               cached_examples_file=config[\n                                                    \'data_dir\'] / f""cached_valid_examples_{args.arch}"")\n\n    valid_features = processor.create_features(examples=valid_examples,\n                                               max_seq_len=args.eval_max_seq_len,\n                                               cached_features_file=config[\n                                                    \'data_dir\'] / ""cached_valid_features_{}_{}"".format(\n                                                   args.eval_max_seq_len, args.arch\n                                               ))\n    valid_dataset = processor.create_dataset(valid_features)\n    valid_sampler = SequentialSampler(valid_dataset)\n    valid_dataloader = DataLoader(valid_dataset, sampler=valid_sampler, batch_size=args.eval_batch_size,\n                                  collate_fn=collate_fn)\n\n    # ------- model\n    logger.info(""initializing model"")\n    if args.resume_path:\n        args.resume_path = Path(args.resume_path)\n        model = XlnetForMultiLable.from_pretrained(args.resume_path, num_labels=len(label_list))\n    else:\n        model = XlnetForMultiLable.from_pretrained(config[\'xlnet_model_dir\'], num_labels=len(label_list))\n    t_total = int(len(train_dataloader) / args.gradient_accumulation_steps * args.epochs)\n\n    # Prepare optimizer and schedule (linear warmup and decay)\n    param_optimizer = list(model.named_parameters())\n    no_decay = [\'bias\', \'LayerNorm.weight\']\n    optimizer_grouped_parameters = [\n        {\'params\': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)],\n         \'weight_decay\': args.weight_decay},\n        {\'params\': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)], \'weight_decay\': 0.0}\n    ]\n    warmup_steps = int(t_total * args.warmup_proportion)\n    optimizer = AdamW(optimizer_grouped_parameters, lr=args.learning_rate, eps=args.adam_epsilon)\n    scheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=warmup_steps,\n                                                num_training_steps=t_total)\n\n    if args.fp16:\n        try:\n            from apex import amp\n        except ImportError:\n            raise ImportError(""Please install apex from https://www.github.com/nvidia/apex to use fp16 training."")\n        model, optimizer = amp.initialize(model, optimizer, opt_level=args.fp16_opt_level)\n\n    # ---- callbacks\n    logger.info(""initializing callbacks"")\n    train_monitor = TrainingMonitor(file_dir=config[\'figure_dir\'], arch=args.arch)\n    model_checkpoint = ModelCheckpoint(checkpoint_dir=config[\'checkpoint_dir\'],\n                                       mode=args.mode,\n                                       monitor=args.monitor,\n                                       arch=args.arch,\n                                       save_best_only=args.save_best)\n\n    # **************************** training model ***********************\n    logger.info(""***** Running training *****"")\n    logger.info(""  Num examples = %d"", len(train_examples))\n    logger.info(""  Num Epochs = %d"", args.epochs)\n    logger.info(""  Total train batch size (w. parallel, distributed & accumulation) = %d"",\n                args.train_batch_size * args.gradient_accumulation_steps * (\n                    torch.distributed.get_world_size() if args.local_rank != -1 else 1))\n    logger.info(""  Gradient Accumulation steps = %d"", args.gradient_accumulation_steps)\n    logger.info(""  Total optimization steps = %d"", t_total)\n\n    trainer = Trainer(args= args,model=model,logger=logger,criterion=BCEWithLogLoss(),optimizer=optimizer,\n                      scheduler=scheduler,early_stopping=None,training_monitor=train_monitor,\n                      model_checkpoint=model_checkpoint,\n                      batch_metrics=[AccuracyThresh(thresh=0.5)],\n                      epoch_metrics=[AUC(average=\'micro\', task_type=\'binary\'),\n                                     MultiLabelReport(id2label=id2label)])\n    trainer.train(train_data=train_dataloader, valid_data=valid_dataloader)\n\n\ndef run_test(args):\n    from pybert.io.task_data import TaskData\n    from pybert.test.predictor import Predictor\n    data = TaskData()\n    targets, sentences = data.read_data(raw_data_path=config[\'test_path\'],\n                                        preprocessor=EnglishPreProcessor(),\n                                        is_train=True)\n    lines = zip(sentences, targets)\n    processor = XlnetProcessor(vocab_path=config[\'xlnet_vocab_path\'], do_lower_case=args.do_lower_case)\n    label_list = processor.get_labels()\n    id2label = {i: label for i, label in enumerate(label_list)}\n\n    test_data = processor.get_test(lines=lines)\n    test_examples = processor.create_examples(lines=test_data,\n                                              example_type=\'test\',\n                                              cached_examples_file=config[\n                                                    \'data_dir\'] / f""cached_test_examples_{args.arch}"")\n    test_features = processor.create_features(examples=test_examples,\n                                              max_seq_len=args.eval_max_seq_len,\n                                              cached_features_file=config[\n                                                        \'data_dir\'] / ""cached_test_features_{}_{}"".format(\n                                                  args.eval_max_seq_len, args.arch\n                                              ))\n    test_dataset = processor.create_dataset(test_features)\n    test_sampler = SequentialSampler(test_dataset)\n    test_dataloader = DataLoader(test_dataset, sampler=test_sampler, batch_size=args.train_batch_size,\n                                 collate_fn=collate_fn)\n    model = XlnetForMultiLable.from_pretrained(config[\'checkpoint_dir\'], num_labels=len(label_list))\n    # ----------- predicting\n    logger.info(\'model predicting....\')\n    predictor = Predictor(model=model,logger=logger,n_gpu=args.n_gpu)\n    result = predictor.predict(data=test_dataloader)\n    print(result)\n\ndef main():\n    parser = ArgumentParser()\n    parser.add_argument(""--arch"", default=\'xlnet\', type=str)\n    parser.add_argument(""--do_data"", action=\'store_true\')\n    parser.add_argument(""--do_train"", action=\'store_true\')\n    parser.add_argument(""--do_test"", action=\'store_true\')\n    parser.add_argument(""--save_best"", action=\'store_true\')\n    parser.add_argument(""--do_lower_case"", action=\'store_true\')\n    parser.add_argument(\'--data_name\', default=\'kaggle\', type=str)\n    parser.add_argument(""--epochs"", default=6, type=int)\n    parser.add_argument(""--resume_path"", default=\'\', type=str)\n    parser.add_argument(""--mode"", default=\'min\', type=str)\n    parser.add_argument(""--monitor"", default=\'valid_loss\', type=str)\n    parser.add_argument(""--valid_size"", default=0.2, type=float)\n    parser.add_argument(""--local_rank"", type=int, default=-1)\n    parser.add_argument(""--sorted"", default=1, type=int, help=\'1 : True  0:False \')\n    parser.add_argument(""--n_gpu"", type=str, default=\'0\', help=\'""0,1,.."" or ""0"" or """" \')\n    parser.add_argument(\'--gradient_accumulation_steps\', type=int, default=1)\n    parser.add_argument(""--train_batch_size"", default=8, type=int)\n    parser.add_argument(\'--eval_batch_size\', default=8, type=int)\n    parser.add_argument(""--train_max_seq_len"", default=256, type=int)\n    parser.add_argument(""--eval_max_seq_len"", default=256, type=int)\n    parser.add_argument(\'--loss_scale\', type=float, default=0)\n    parser.add_argument(""--warmup_proportion"", default=0.1, type=int, )\n    parser.add_argument(""--weight_decay"", default=0.01, type=float)\n    parser.add_argument(""--adam_epsilon"", default=1e-8, type=float)\n    parser.add_argument(""--grad_clip"", default=1.0, type=float)\n    parser.add_argument(""--learning_rate"", default=2e-5, type=float)\n    parser.add_argument(\'--seed\', type=int, default=42)\n    parser.add_argument(\'--fp16\', action=\'store_true\')\n    parser.add_argument(\'--fp16_opt_level\', type=str, default=\'O1\')\n    args = parser.parse_args()\n    init_logger(log_file=config[\'log_dir\'] / f\'{args.arch}-{time.strftime(""%Y-%m-%d-%H:%M:%S"", time.localtime())}.log\')\n    config[\'checkpoint_dir\'] = config[\'checkpoint_dir\'] / args.arch\n    config[\'checkpoint_dir\'].mkdir(exist_ok=True)\n    # Good practice: save your training arguments together with the trained model\n    torch.save(args, config[\'checkpoint_dir\'] / \'training_args.bin\')\n    seed_everything(args.seed)\n    logger.info(""Training/evaluation parameters %s"", args)\n    if args.do_data:\n        from pybert.io.task_data import TaskData\n        data = TaskData()\n        targets, sentences = data.read_data(raw_data_path=config[\'raw_data_path\'],\n                                            preprocessor=EnglishPreProcessor(),\n                                            is_train=True)\n        data.train_val_split(X=sentences, y=targets, shuffle=True, stratify=False,\n                             valid_size=args.valid_size, data_dir=config[\'data_dir\'],\n                             data_name=args.data_name)\n    if args.do_train:\n        run_train(args)\n\n    if args.do_test:\n        run_test(args)\n\nif __name__ == \'__main__\':\n    main()\n'"
pybert/__init__.py,0,b'#encoding:utf-8'
pybert/callback/__init__.py,0,b'#encoding:utf-8'
pybert/callback/earlystopping.py,0,"b'import numpy as np\r\nfrom ..common.tools import logger\r\nclass EarlyStopping(object):\r\n    \'\'\'\r\n        """"""Stop training when a monitored quantity has stopped improving.\r\n    # Arguments\r\n        monitor: quantity to be monitored.\r\n        min_delta: minimum change in the monitored quantity\r\n            to qualify as an improvement, i.e. an absolute\r\n            change of less than min_delta, will count as no\r\n            improvement.\r\n        patience: number of epochs with no improvement\r\n            after which training will be stopped.\r\n        verbose: verbosity mode.\r\n        mode: one of {auto, min, max}. In `min` mode,\r\n            training will stop when the quantity\r\n            monitored has stopped decreasing; in `max`\r\n            mode it will stop when the quantity\r\n            monitored has stopped increasing; in `auto`\r\n            mode, the direction is automatically inferred\r\n            from the name of the monitored quantity.\r\n        baseline: Baseline value for the monitored quantity to reach.\r\n            Training will stop if the model doesn\'t show improvement\r\n            over the baseline.\r\n        restore_best_weights: whether to restore model weights from\r\n            the epoch with the best value of the monitored quantity.\r\n            If False, the model weights obtained at the last step of\r\n            training are used.\r\n\r\n    # Arguments\r\n        min_delta: \xe6\x9c\x80\xe5\xb0\x8f\xe5\x8f\x98\xe5\x8c\x96\r\n        patience: \xe5\xa4\x9a\xe5\xb0\x91\xe4\xb8\xaaepoch\xe6\x9c\xaa\xe6\x8f\x90\xe9\xab\x98\xef\xbc\x8c\xe5\xb0\xb1\xe5\x81\x9c\xe6\xad\xa2\xe8\xae\xad\xe7\xbb\x83\r\n        verbose: \xe4\xbf\xa1\xe6\x81\xaf\xe5\xa4\xa7\xe4\xba\x8e\xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe6\x89\x93\xe5\x8d\xb0\xe4\xbf\xa1\xe6\x81\xaf\r\n        mode: \xe8\xae\xa1\xe7\xae\x97\xe6\xa8\xa1\xe5\xbc\x8f\r\n        monitor: \xe8\xae\xa1\xe7\xae\x97\xe6\x8c\x87\xe6\xa0\x87\r\n        baseline: \xe5\x9f\xba\xe7\xba\xbf\r\n    \'\'\'\r\n    def __init__(self,\r\n                 min_delta = 0,\r\n                 patience  = 10,\r\n                 verbose   = 1,\r\n                 mode      = \'min\',\r\n                 monitor   = \'loss\',\r\n                 baseline  = None):\r\n\r\n        self.baseline = baseline\r\n        self.patience = patience\r\n        self.verbose = verbose\r\n        self.min_delta = min_delta\r\n        self.monitor = monitor\r\n\r\n        assert mode in [\'min\',\'max\']\r\n\r\n        if mode == \'min\':\r\n            self.monitor_op = np.less\r\n        elif mode == \'max\':\r\n            self.monitor_op = np.greater\r\n        if self.monitor_op == np.greater:\r\n            self.min_delta *= 1\r\n        else:\r\n            self.min_delta *= -1\r\n        self.reset()\r\n\r\n    def reset(self):\r\n        # Allow instances to be re-used\r\n        self.wait = 0\r\n        self.stop_training = False\r\n        if self.baseline is not None:\r\n            self.best = self.baseline\r\n        else:\r\n            self.best = np.Inf if self.monitor_op == np.less else -np.Inf\r\n\r\n    def epoch_step(self,current):\r\n        if self.monitor_op(current - self.min_delta, self.best):\r\n            self.best = current\r\n            self.wait = 0\r\n        else:\r\n            self.wait += 1\r\n            if self.wait >= self.patience:\r\n                if self.verbose >0:\r\n                    logger.info(f""{self.patience} epochs with no improvement after which training will be stopped"")\r\n                self.stop_training = True\r\n'"
pybert/callback/lr_schedulers.py,3,"b'import math\r\nimport numpy as np\r\nimport warnings\r\nfrom torch.optim.optimizer import Optimizer\r\nfrom torch.optim.lr_scheduler import LambdaLR\r\n\r\n__all__ = [\'CustomDecayLR\',\r\n           \'BertLR\',\r\n           \'CyclicLR\',\r\n           \'ReduceLROnPlateau\',\r\n           \'ReduceLRWDOnPlateau\',\r\n           \'CosineLRWithRestarts\',\r\n           \'get_constant_schedule\',\r\n           \'get_constant_schedule_with_warmup\',\r\n           \'get_linear_schedule_with_warmup\',\r\n           \'get_cosine_schedule_with_warmup\',\r\n           \'get_cosine_with_hard_restarts_schedule_with_warmup\'\r\n           ]\r\n\r\ndef get_constant_schedule(optimizer, last_epoch=-1):\r\n    """""" Create a schedule with a constant learning rate.\r\n    """"""\r\n    return LambdaLR(optimizer, lambda _: 1, last_epoch=last_epoch)\r\n\r\n\r\ndef get_constant_schedule_with_warmup(optimizer, num_warmup_steps, last_epoch=-1):\r\n    """""" Create a schedule with a constant learning rate preceded by a warmup\r\n    period during which the learning rate increases linearly between 0 and 1.\r\n    """"""\r\n    def lr_lambda(current_step):\r\n        if current_step < num_warmup_steps:\r\n            return float(current_step) / float(max(1.0, num_warmup_steps))\r\n        return 1.\r\n\r\n    return LambdaLR(optimizer, lr_lambda, last_epoch=last_epoch)\r\n\r\n\r\ndef get_linear_schedule_with_warmup(optimizer, num_warmup_steps, num_training_steps, last_epoch=-1):\r\n    """""" Create a schedule with a learning rate that decreases linearly after\r\n    linearly increasing during a warmup period.\r\n    """"""\r\n    def lr_lambda(current_step):\r\n        if current_step < num_warmup_steps:\r\n            return float(current_step) / float(max(1, num_warmup_steps))\r\n        return max(0.0, float(num_training_steps - current_step) / float(max(1, num_training_steps - num_warmup_steps)))\r\n\r\n    return LambdaLR(optimizer, lr_lambda, last_epoch)\r\n\r\n\r\ndef get_cosine_schedule_with_warmup(optimizer, num_warmup_steps, num_training_steps, num_cycles=.5, last_epoch=-1):\r\n    """""" Create a schedule with a learning rate that decreases following the\r\n    values of the cosine function between 0 and `pi * cycles` after a warmup\r\n    period during which it increases linearly between 0 and 1.\r\n    """"""\r\n    def lr_lambda(current_step):\r\n        if current_step < num_warmup_steps:\r\n            return float(current_step) / float(max(1, num_warmup_steps))\r\n        progress = float(current_step - num_warmup_steps) / float(max(1, num_training_steps - num_warmup_steps))\r\n        return max(0., 0.5 * (1. + math.cos(math.pi * float(num_cycles) * 2. * progress)))\r\n\r\n    return LambdaLR(optimizer, lr_lambda, last_epoch)\r\n\r\n\r\ndef get_cosine_with_hard_restarts_schedule_with_warmup(optimizer, num_warmup_steps, num_training_steps, num_cycles=1., last_epoch=-1):\r\n    """""" Create a schedule with a learning rate that decreases following the\r\n    values of the cosine function with several hard restarts, after a warmup\r\n    period during which it increases linearly between 0 and 1.\r\n    """"""\r\n    def lr_lambda(current_step):\r\n        if current_step < num_warmup_steps:\r\n            return float(current_step) / float(max(1, num_warmup_steps))\r\n        progress = float(current_step - num_warmup_steps) / float(max(1, num_training_steps - num_warmup_steps))\r\n        if progress >= 1.:\r\n            return 0.\r\n        return max(0., 0.5 * (1. + math.cos(math.pi * ((float(num_cycles) * progress) % 1.))))\r\n\r\n    return LambdaLR(optimizer, lr_lambda, last_epoch)\r\n\r\n\r\nclass CustomDecayLR(object):\r\n    \'\'\'\r\n    \xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe5\xad\xa6\xe4\xb9\xa0\xe7\x8e\x87\xe5\x8f\x98\xe5\x8c\x96\xe6\x9c\xba\xe5\x88\xb6\r\n        Example:\r\n        >>> scheduler = CustomDecayLR(optimizer)\r\n        >>> for epoch in range(100):\r\n        >>>     scheduler.epoch_step()\r\n        >>>     train(...)\r\n        >>>         ...\r\n        >>>         optimizer.zero_grad()\r\n        >>>         loss.backward()\r\n        >>>         optimizer.step()\r\n        >>>     validate(...)\r\n    \'\'\'\r\n    def __init__(self,optimizer,lr):\r\n        self.optimizer = optimizer\r\n        self.lr = lr\r\n\r\n    def epoch_step(self,epoch):\r\n        lr = self.lr\r\n        if epoch > 12:\r\n            lr = lr / 1000\r\n        elif epoch > 8:\r\n            lr = lr / 100\r\n        elif epoch > 4:\r\n            lr = lr / 10\r\n        for param_group in self.optimizer.param_groups:\r\n            param_group[\'lr\'] = lr\r\n\r\nclass BertLR(object):\r\n    \'\'\'\r\n    Bert\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x86\x85\xe5\xae\x9a\xe7\x9a\x84\xe5\xad\xa6\xe4\xb9\xa0\xe7\x8e\x87\xe5\x8f\x98\xe5\x8c\x96\xe6\x9c\xba\xe5\x88\xb6\r\n    Example:\r\n        >>> scheduler = BertLR(optimizer)\r\n        >>> for epoch in range(100):\r\n        >>>     scheduler.step()\r\n        >>>     train(...)\r\n        >>>         ...\r\n        >>>         optimizer.zero_grad()\r\n        >>>         loss.backward()\r\n        >>>         optimizer.step()\r\n        >>>         scheduler.batch_step()\r\n        >>>     validate(...)\r\n    \'\'\'\r\n    def __init__(self,optimizer,learning_rate,t_total,warmup):\r\n        self.learning_rate = learning_rate\r\n        self.optimizer = optimizer\r\n        self.t_total = t_total\r\n        self.warmup = warmup\r\n\r\n    # \xe7\xba\xbf\xe6\x80\xa7\xe9\xa2\x84\xe7\x83\xad\xe6\x96\xb9\xe5\xbc\x8f\r\n    def warmup_linear(self,x, warmup=0.002):\r\n        if x < warmup:\r\n            return x / warmup\r\n        return 1.0 - x\r\n\r\n    def batch_step(self,training_step):\r\n        lr_this_step = self.learning_rate * self.warmup_linear(training_step / self.t_total,self.warmup)\r\n        for param_group in self.optimizer.param_groups:\r\n            param_group[\'lr\'] = lr_this_step\r\n\r\nclass CyclicLR(object):\r\n    \'\'\'\r\n    Cyclical learning rates for training neural networks\r\n    Example:\r\n        >>> scheduler = CyclicLR(optimizer)\r\n        >>> for epoch in range(100):\r\n        >>>     scheduler.step()\r\n        >>>     train(...)\r\n        >>>         ...\r\n        >>>         optimizer.zero_grad()\r\n        >>>         loss.backward()\r\n        >>>         optimizer.step()\r\n        >>>         scheduler.batch_step()\r\n        >>>     validate(...)\r\n    \'\'\'\r\n    def __init__(self, optimizer, base_lr=1e-3, max_lr=6e-3,\r\n                 step_size=2000, mode=\'triangular\', gamma=1.,\r\n                 scale_fn=None, scale_mode=\'cycle\', last_batch_iteration=-1):\r\n\r\n        if not isinstance(optimizer, Optimizer):\r\n            raise TypeError(\'{} is not an Optimizer\'.format(\r\n                type(optimizer).__name__))\r\n\r\n        self.optimizer = optimizer\r\n\r\n        if isinstance(base_lr, list) or isinstance(base_lr, tuple):\r\n            if len(base_lr) != len(optimizer.param_groups):\r\n                raise ValueError(""expected {} base_lr, got {}"".format(\r\n                    len(optimizer.param_groups), len(base_lr)))\r\n            self.base_lrs = list(base_lr)\r\n        else:\r\n            self.base_lrs = [base_lr] * len(optimizer.param_groups)\r\n\r\n        if isinstance(max_lr, list) or isinstance(max_lr, tuple):\r\n            if len(max_lr) != len(optimizer.param_groups):\r\n                raise ValueError(""expected {} max_lr, got {}"".format(\r\n                    len(optimizer.param_groups), len(max_lr)))\r\n            self.max_lrs = list(max_lr)\r\n        else:\r\n            self.max_lrs = [max_lr] * len(optimizer.param_groups)\r\n\r\n        self.step_size = step_size\r\n\r\n        if mode not in [\'triangular\', \'triangular2\', \'exp_range\'] \\\r\n                and scale_fn is None:\r\n            raise ValueError(\'mode is invalid and scale_fn is None\')\r\n\r\n        self.mode = mode\r\n        self.gamma = gamma\r\n\r\n        if scale_fn is None:\r\n            if self.mode == \'triangular\':\r\n                self.scale_fn = self._triangular_scale_fn\r\n                self.scale_mode = \'cycle\'\r\n            elif self.mode == \'triangular2\':\r\n                self.scale_fn = self._triangular2_scale_fn\r\n                self.scale_mode = \'cycle\'\r\n            elif self.mode == \'exp_range\':\r\n                self.scale_fn = self._exp_range_scale_fn\r\n                self.scale_mode = \'iterations\'\r\n        else:\r\n            self.scale_fn = scale_fn\r\n            self.scale_mode = scale_mode\r\n\r\n        self.batch_step(last_batch_iteration + 1)\r\n        self.last_batch_iteration = last_batch_iteration\r\n\r\n    def _triangular_scale_fn(self, x):\r\n        return 1.\r\n\r\n    def _triangular2_scale_fn(self, x):\r\n        return 1 / (2. ** (x - 1))\r\n\r\n    def _exp_range_scale_fn(self, x):\r\n        return self.gamma**(x)\r\n\r\n    def get_lr(self):\r\n        step_size = float(self.step_size)\r\n        cycle = np.floor(1 + self.last_batch_iteration / (2 * step_size))\r\n        x = np.abs(self.last_batch_iteration / step_size - 2 * cycle + 1)\r\n\r\n        lrs = []\r\n        param_lrs = zip(self.optimizer.param_groups, self.base_lrs, self.max_lrs)\r\n        for param_group, base_lr, max_lr in param_lrs:\r\n            base_height = (max_lr - base_lr) * np.maximum(0, (1 - x))\r\n            if self.scale_mode == \'cycle\':\r\n                lr = base_lr + base_height * self.scale_fn(cycle)\r\n            else:\r\n                lr = base_lr + base_height * self.scale_fn(self.last_batch_iteration)\r\n            lrs.append(lr)\r\n        return lrs\r\n\r\n    def batch_step(self, batch_iteration=None):\r\n        if batch_iteration is None:\r\n            batch_iteration = self.last_batch_iteration + 1\r\n        self.last_batch_iteration = batch_iteration\r\n        for param_group, lr in zip(self.optimizer.param_groups, self.get_lr()):\r\n            param_group[\'lr\'] = lr\r\n\r\nclass ReduceLROnPlateau(object):\r\n    """"""Reduce learning rate when a metric has stopped improving.\r\n    Models often benefit from reducing the learning rate by a factor\r\n    of 2-10 once learning stagnates. This scheduler reads a metrics\r\n    quantity and if no improvement is seen for a \'patience\' number\r\n    of epochs, the learning rate is reduced.\r\n\r\n    Args:\r\n        factor: factor by which the learning rate will\r\n            be reduced. new_lr = lr * factor\r\n        patience: number of epochs with no improvement\r\n            after which learning rate will be reduced.\r\n        verbose: int. 0: quiet, 1: update messages.\r\n        mode: one of {min, max}. In `min` mode,\r\n            lr will be reduced when the quantity\r\n            monitored has stopped decreasing; in `max`\r\n            mode it will be reduced when the quantity\r\n            monitored has stopped increasing.\r\n        epsilon: threshold for measuring the new optimum,\r\n            to only focus on significant changes.\r\n        cooldown: number of epochs to wait before resuming\r\n            normal operation after lr has been reduced.\r\n        min_lr: lower bound on the learning rate.\r\n\r\n\r\n    Example:\r\n        >>> optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)\r\n        >>> scheduler = ReduceLROnPlateau(optimizer, \'min\')\r\n        >>> for epoch in range(10):\r\n        >>>     train(...)\r\n        >>>     val_acc, val_loss = validate(...)\r\n        >>>     scheduler.epoch_step(val_loss, epoch)\r\n    """"""\r\n\r\n    def __init__(self, optimizer, mode=\'min\', factor=0.1, patience=10,\r\n                 verbose=0, epsilon=1e-4, cooldown=0, min_lr=0,eps=1e-8):\r\n\r\n        super(ReduceLROnPlateau, self).__init__()\r\n        assert isinstance(optimizer, Optimizer)\r\n        if factor >= 1.0:\r\n            raise ValueError(\'ReduceLROnPlateau \'\r\n                             \'does not support a factor >= 1.0.\')\r\n        self.factor = factor\r\n        self.min_lr = min_lr\r\n        self.epsilon = epsilon\r\n        self.patience = patience\r\n        self.verbose = verbose\r\n        self.cooldown = cooldown\r\n        self.cooldown_counter = 0  # Cooldown counter.\r\n        self.monitor_op = None\r\n        self.wait = 0\r\n        self.best = 0\r\n        self.mode = mode\r\n        self.optimizer = optimizer\r\n        self.eps = eps\r\n        self._reset()\r\n\r\n    def _reset(self):\r\n        """"""Resets wait counter and cooldown counter.\r\n        """"""\r\n        if self.mode not in [\'min\', \'max\']:\r\n            raise RuntimeError(\'Learning Rate Plateau Reducing mode %s is unknown!\')\r\n        if self.mode == \'min\':\r\n            self.monitor_op = lambda a, b: np.less(a, b - self.epsilon)\r\n            self.best = np.Inf\r\n        else:\r\n            self.monitor_op = lambda a, b: np.greater(a, b + self.epsilon)\r\n            self.best = -np.Inf\r\n        self.cooldown_counter = 0\r\n        self.wait = 0\r\n\r\n    def reset(self):\r\n        self._reset()\r\n\r\n    def epoch_step(self, metrics, epoch):\r\n        current = metrics\r\n        if current is None:\r\n            warnings.warn(\'Learning Rate Plateau Reducing requires metrics available!\', RuntimeWarning)\r\n        else:\r\n            if self.in_cooldown():\r\n                self.cooldown_counter -= 1\r\n                self.wait = 0\r\n\r\n            if self.monitor_op(current, self.best):\r\n                self.best = current\r\n                self.wait = 0\r\n            elif not self.in_cooldown():\r\n                if self.wait >= self.patience:\r\n                    for param_group in self.optimizer.param_groups:\r\n                        old_lr = float(param_group[\'lr\'])\r\n                        if old_lr > self.min_lr + self.eps:\r\n                            new_lr = old_lr * self.factor\r\n                            new_lr = max(new_lr, self.min_lr)\r\n                            param_group[\'lr\'] = new_lr\r\n                            if self.verbose > 0:\r\n                                print(\'\\nEpoch %05d: reducing learning rate to %s.\' % (epoch, new_lr))\r\n                            self.cooldown_counter = self.cooldown\r\n                            self.wait = 0\r\n                self.wait += 1\r\n\r\n    def in_cooldown(self):\r\n        return self.cooldown_counter > 0\r\n\r\nclass ReduceLRWDOnPlateau(ReduceLROnPlateau):\r\n    """"""Reduce learning rate and weight decay when a metric has stopped\r\n    improving. Models often benefit from reducing the learning rate by\r\n    a factor of 2-10 once learning stagnates. This scheduler reads a metric\r\n    quantity and if no improvement is seen for a \'patience\' number\r\n    of epochs, the learning rate and weight decay factor is reduced for\r\n    optimizers that implement the the weight decay method from the paper\r\n    `Fixing Weight Decay Regularization in Adam`_.\r\n\r\n    .. _Fixing Weight Decay Regularization in Adam:\r\n        https://arxiv.org/abs/1711.05101\r\n    for AdamW or SGDW\r\n    Example:\r\n        >>> optimizer = AdamW(model.parameters(), lr=0.1, weight_decay=1e-3)\r\n        >>> scheduler = ReduceLRWDOnPlateau(optimizer, \'min\')\r\n        >>> for epoch in range(10):\r\n        >>>     train(...)\r\n        >>>     val_loss = validate(...)\r\n        >>>     # Note that step should be called after validate()\r\n        >>>     scheduler.epoch_step(val_loss)\r\n    """"""\r\n    def epoch_step(self, metrics, epoch):\r\n        current = metrics\r\n        if current is None:\r\n            warnings.warn(\'Learning Rate Plateau Reducing requires metrics available!\', RuntimeWarning)\r\n        else:\r\n            if self.in_cooldown():\r\n                self.cooldown_counter -= 1\r\n                self.wait = 0\r\n\r\n            if self.monitor_op(current, self.best):\r\n                self.best = current\r\n                self.wait = 0\r\n            elif not self.in_cooldown():\r\n                if self.wait >= self.patience:\r\n                    for param_group in self.optimizer.param_groups:\r\n                        old_lr = float(param_group[\'lr\'])\r\n                        if old_lr > self.min_lr + self.eps:\r\n                            new_lr = old_lr * self.factor\r\n                            new_lr = max(new_lr, self.min_lr)\r\n                            param_group[\'lr\'] = new_lr\r\n                            if self.verbose > 0:\r\n                                print(\'\\nEpoch %d: reducing learning rate to %s.\' % (epoch, new_lr))\r\n                        if param_group[\'weight_decay\'] != 0:\r\n                            old_weight_decay = float(param_group[\'weight_decay\'])\r\n                            new_weight_decay = max(old_weight_decay * self.factor, self.min_lr)\r\n                            if old_weight_decay > new_weight_decay + self.eps:\r\n                                param_group[\'weight_decay\'] = new_weight_decay\r\n                                if self.verbose:\r\n                                    print(\'\\nEpoch {epoch}: reducing weight decay factor of group {i} to {new_weight_decay:.4e}.\')\r\n                    self.cooldown_counter = self.cooldown\r\n                    self.wait = 0\r\n                self.wait += 1\r\n\r\nclass CosineLRWithRestarts(object):\r\n    """"""Decays learning rate with cosine annealing, normalizes weight decay\r\n    hyperparameter value, implements restarts.\r\n    https://arxiv.org/abs/1711.05101\r\n\r\n    Args:\r\n        optimizer (Optimizer): Wrapped optimizer.\r\n        batch_size: minibatch size\r\n        epoch_size: training samples per epoch\r\n        restart_period: epoch count in the first restart period\r\n        t_mult: multiplication factor by which the next restart period will extend/shrink\r\n\r\n    Example:\r\n        >>> scheduler = CosineLRWithRestarts(optimizer, 32, 1024, restart_period=5, t_mult=1.2)\r\n        >>> for epoch in range(100):\r\n        >>>     scheduler.step()\r\n        >>>     train(...)\r\n        >>>         ...\r\n        >>>         optimizer.zero_grad()\r\n        >>>         loss.backward()\r\n        >>>         optimizer.step()\r\n        >>>         scheduler.batch_step()\r\n        >>>     validate(...)\r\n    """"""\r\n\r\n    def __init__(self, optimizer, batch_size, epoch_size, restart_period=100,\r\n                 t_mult=2, last_epoch=-1, eta_threshold=1000, verbose=False):\r\n        if not isinstance(optimizer, Optimizer):\r\n            raise TypeError(\'{} is not an Optimizer\'.format(\r\n                type(optimizer).__name__))\r\n        self.optimizer = optimizer\r\n        if last_epoch == -1:\r\n            for group in optimizer.param_groups:\r\n                group.setdefault(\'initial_lr\', group[\'lr\'])\r\n        else:\r\n            for i, group in enumerate(optimizer.param_groups):\r\n                if \'initial_lr\' not in group:\r\n                    raise KeyError(""param \'initial_lr\' is not specified ""\r\n                                   ""in param_groups[{}] when resuming an""\r\n                                   "" optimizer"".format(i))\r\n        self.base_lrs = list(map(lambda group: group[\'initial_lr\'],\r\n                                 optimizer.param_groups))\r\n\r\n        self.last_epoch = last_epoch\r\n        self.batch_size = batch_size\r\n        self.iteration = 0\r\n        self.epoch_size = epoch_size\r\n        self.eta_threshold = eta_threshold\r\n        self.t_mult = t_mult\r\n        self.verbose = verbose\r\n        self.base_weight_decays = list(map(lambda group: group[\'weight_decay\'],\r\n                                           optimizer.param_groups))\r\n        self.restart_period = restart_period\r\n        self.restarts = 0\r\n        self.t_epoch = -1\r\n        self.batch_increments = []\r\n        self._set_batch_increment()\r\n\r\n    def _schedule_eta(self):\r\n        """"""\r\n        Threshold value could be adjusted to shrink eta_min and eta_max values.\r\n        """"""\r\n        eta_min = 0\r\n        eta_max = 1\r\n        if self.restarts <= self.eta_threshold:\r\n            return eta_min, eta_max\r\n        else:\r\n            d = self.restarts - self.eta_threshold\r\n            k = d * 0.09\r\n            return (eta_min + k, eta_max - k)\r\n\r\n    def get_lr(self, t_cur):\r\n        eta_min, eta_max = self._schedule_eta()\r\n\r\n        eta_t = (eta_min + 0.5 * (eta_max - eta_min)\r\n                 * (1. + math.cos(math.pi *\r\n                                  (t_cur / self.restart_period))))\r\n\r\n        weight_decay_norm_multi = math.sqrt(self.batch_size /\r\n                                            (self.epoch_size *\r\n                                             self.restart_period))\r\n        lrs = [base_lr * eta_t for base_lr in self.base_lrs]\r\n        weight_decays = [base_weight_decay * eta_t * weight_decay_norm_multi\r\n                         for base_weight_decay in self.base_weight_decays]\r\n\r\n        if self.t_epoch % self.restart_period < self.t_epoch:\r\n            if self.verbose:\r\n                print(""Restart at epoch {}"".format(self.last_epoch))\r\n            self.restart_period *= self.t_mult\r\n            self.restarts += 1\r\n            self.t_epoch = 0\r\n\r\n        return zip(lrs, weight_decays)\r\n\r\n    def _set_batch_increment(self):\r\n        d, r = divmod(self.epoch_size, self.batch_size)\r\n        batches_in_epoch = d + 2 if r > 0 else d + 1\r\n        self.iteration = 0\r\n        self.batch_increments = list(np.linspace(0, 1, batches_in_epoch))\r\n\r\n    def batch_step(self):\r\n        self.last_epoch += 1\r\n        self.t_epoch += 1\r\n        self._set_batch_increment()\r\n        try:\r\n            t_cur = self.t_epoch + self.batch_increments[self.iteration]\r\n            self.iteration += 1\r\n        except (IndexError):\r\n            raise RuntimeError(""Epoch size and batch size used in the ""\r\n                               ""training loop and while initializing ""\r\n                               ""scheduler should be the same."")\r\n\r\n        for param_group, (lr, weight_decay) in zip(self.optimizer.param_groups,self.get_lr(t_cur)):\r\n            param_group[\'lr\'] = lr\r\n            param_group[\'weight_decay\'] = weight_decay\r\n\r\n\r\nclass NoamLR(object):\r\n    \'\'\'\r\n    \xe4\xb8\xbb\xe8\xa6\x81\xe5\x8f\x82\xe8\x80\x83\xe8\xae\xba\xe6\x96\x87<< Attention Is All You Need>>\xe4\xb8\xad\xe7\x9a\x84\xe5\xad\xa6\xe4\xb9\xa0\xe6\x9b\xb4\xe6\x96\xb0\xe6\x96\xb9\xe5\xbc\x8f\r\n    Example:\r\n        >>> scheduler = NoamLR(d_model,factor,warm_up,optimizer)\r\n        >>> for epoch in range(100):\r\n        >>>     scheduler.step()\r\n        >>>     train(...)\r\n        >>>         ...\r\n        >>>         glopab_step += 1\r\n        >>>         optimizer.zero_grad()\r\n        >>>         loss.backward()\r\n        >>>         optimizer.step()\r\n        >>>         scheduler.batch_step(global_step)\r\n        >>>     validate(...)\r\n    \'\'\'\r\n    def __init__(self,d_model,factor,warm_up,optimizer):\r\n        self.optimizer = optimizer\r\n        self.warm_up = warm_up\r\n        self.factor = factor\r\n        self.d_model = d_model\r\n        self._lr = 0\r\n\r\n    def get_lr(self,step):\r\n        lr = self.factor * (self.d_model ** (-0.5) * min(step ** (-0.5),step * self.warm_up ** (-1.5)))\r\n        return lr\r\n\r\n    def batch_step(self,step):\r\n        \'\'\'\r\n        update parameters and rate\r\n        :return:\r\n        \'\'\'\r\n        lr = self.get_lr(step)\r\n        for p in self.optimizer.param_groups:\r\n            p[\'lr\'] = lr\r\n        self._lr = lr\r\n'"
pybert/callback/modelcheckpoint.py,4,"b'from pathlib import Path\r\nimport numpy as np\r\nimport torch\r\nfrom ..common.tools import logger\r\n\r\nclass ModelCheckpoint(object):\r\n    """"""Save the model after every epoch.\r\n    # Arguments\r\n        checkpoint_dir: string, path to save the model file.\r\n        monitor: quantity to monitor.\r\n        verbose: verbosity mode, 0 or 1.\r\n        save_best_only: if `save_best_only=True`,\r\n            the latest best model according to\r\n            the quantity monitored will not be overwritten.\r\n        mode: one of {auto, min, max}.\r\n            If `save_best_only=True`, the decision\r\n            to overwrite the current save file is made\r\n            based on either the maximization or the\r\n            minimization of the monitored quantity. For `val_acc`,\r\n            this should be `max`, for `val_loss` this should\r\n            be `min`, etc. In `auto` mode, the direction is\r\n            automatically inferred from the name of the monitored quantity.\r\n    """"""\r\n    def __init__(self, checkpoint_dir,\r\n                 monitor,\r\n                 arch,\r\n                 mode=\'min\',\r\n                 epoch_freq=1,\r\n                 best = None,\r\n                 save_best_only = True):\r\n        if isinstance(checkpoint_dir,Path):\r\n            checkpoint_dir = checkpoint_dir\r\n        else:\r\n            checkpoint_dir = Path(checkpoint_dir)\r\n        assert checkpoint_dir.is_dir()\r\n        checkpoint_dir.mkdir(exist_ok=True)\r\n        self.base_path = checkpoint_dir\r\n        self.arch = arch\r\n        self.monitor = monitor\r\n        self.epoch_freq = epoch_freq\r\n        self.save_best_only = save_best_only\r\n\r\n        # \xe8\xae\xa1\xe7\xae\x97\xe6\xa8\xa1\xe5\xbc\x8f\r\n        if mode == \'min\':\r\n            self.monitor_op = np.less\r\n            self.best = np.Inf\r\n\r\n        elif mode == \'max\':\r\n            self.monitor_op = np.greater\r\n            self.best = -np.Inf\r\n        # \xe8\xbf\x99\xe9\x87\x8c\xe4\xb8\xbb\xe8\xa6\x81\xe9\x87\x8d\xe6\x96\xb0\xe5\x8a\xa0\xe8\xbd\xbd\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x97\xb6\xe5\x80\x99\r\n        #\xe5\xaf\xb9best\xe9\x87\x8d\xe6\x96\xb0\xe8\xb5\x8b\xe5\x80\xbc\r\n        if best:\r\n            self.best = best\r\n\r\n        if save_best_only:\r\n            self.model_name = f""BEST_{arch}_MODEL.pth""\r\n\r\n    def epoch_step(self, state,current):\r\n        \'\'\'\r\n        :param state: \xe9\x9c\x80\xe8\xa6\x81\xe4\xbf\x9d\xe5\xad\x98\xe7\x9a\x84\xe4\xbf\xa1\xe6\x81\xaf\r\n        :param current: \xe5\xbd\x93\xe5\x89\x8d\xe5\x88\xa4\xe6\x96\xad\xe6\x8c\x87\xe6\xa0\x87\r\n        :return:\r\n        \'\'\'\r\n        if self.save_best_only:\r\n            if self.monitor_op(current, self.best):\r\n                logger.info(f""\\nEpoch {state[\'epoch\']}: {self.monitor} improved from {self.best:.5f} to {current:.5f}"")\r\n                self.best = current\r\n                state[\'best\'] = self.best\r\n                best_path = self.base_path/ self.model_name\r\n                torch.save(state, str(best_path))\r\n\r\n        else:\r\n            filename = self.base_path / f""epoch_{state[\'epoch\']}_{state[self.monitor]}_{self.arch}_model.bin""\r\n            if state[\'epoch\'] % self.epoch_freq == 0:\r\n                logger.info(f""\\nEpoch {state[\'epoch\']}: save model to disk."")\r\n                torch.save(state, str(filename))\r\n\r\n    def bert_epoch_step(self, state,current):\r\n        model_to_save = state[\'model\']\r\n        if self.save_best_only:\r\n            if self.monitor_op(current, self.best):\r\n                logger.info(f""\\nEpoch {state[\'epoch\']}: {self.monitor} improved from {self.best:.5f} to {current:.5f}"")\r\n                self.best = current\r\n                state[\'best\'] = self.best\r\n                model_to_save.save_pretrained(str(self.base_path))\r\n                output_config_file = self.base_path / \'config.json\'\r\n                with open(str(output_config_file), \'w\') as f:\r\n                    f.write(model_to_save.config.to_json_string())\r\n                state.pop(""model"")\r\n                torch.save(state,self.base_path / \'checkpoint_info.bin\')\r\n\r\n        else:\r\n            if state[\'epoch\'] % self.epoch_freq == 0:\r\n                save_path = self.base_path / f""checkpoint-epoch-{state[\'epoch\']}""\r\n                save_path.mkdir(exist_ok=True)\r\n                logger.info(f""\\nEpoch {state[\'epoch\']}: save model to disk."")\r\n                model_to_save.save_pretrained(save_path)\r\n                output_config_file = save_path / \'config.json\'\r\n                with open(str(output_config_file), \'w\') as f:\r\n                    f.write(model_to_save.config.to_json_string())\r\n                state.pop(""model"")\r\n                torch.save(state, save_path / \'checkpoint_info.bin\')\r\n'"
pybert/callback/progressbar.py,0,"b'import time\r\nclass ProgressBar(object):\r\n    \'\'\'\r\n    custom progress bar\r\n    Example:\r\n        >>> pbar = ProgressBar(n_total=30,desc=\'training\')\r\n        >>> step = 2\r\n        >>> pbar(step=step)\r\n    \'\'\'\r\n    def __init__(self, n_total,width=30,desc = \'Training\'):\r\n        self.width = width\r\n        self.n_total = n_total\r\n        self.start_time = time.time()\r\n        self.desc = desc\r\n\r\n    def __call__(self, step, info={}):\r\n        now = time.time()\r\n        current = step + 1\r\n        recv_per = current / self.n_total\r\n        bar = f\'[{self.desc}] {current}/{self.n_total} [\'\r\n        if recv_per >= 1:\r\n            recv_per = 1\r\n        prog_width = int(self.width * recv_per)\r\n        if prog_width > 0:\r\n            bar += \'=\' * (prog_width - 1)\r\n            if current< self.n_total:\r\n                bar += "">""\r\n            else:\r\n                bar += \'=\'\r\n        bar += \'.\' * (self.width - prog_width)\r\n        bar += \']\'\r\n        show_bar = f""\\r{bar}""\r\n        time_per_unit = (now - self.start_time) / current\r\n        if current < self.n_total:\r\n            eta = time_per_unit * (self.n_total - current)\r\n            if eta > 3600:\r\n                eta_format = (\'%d:%02d:%02d\' %\r\n                              (eta // 3600, (eta % 3600) // 60, eta % 60))\r\n            elif eta > 60:\r\n                eta_format = \'%d:%02d\' % (eta // 60, eta % 60)\r\n            else:\r\n                eta_format = \'%ds\' % eta\r\n            time_info = f\' - ETA: {eta_format}\'\r\n        else:\r\n            if time_per_unit >= 1:\r\n                time_info = f\' {time_per_unit:.1f}s/step\'\r\n            elif time_per_unit >= 1e-3:\r\n                time_info = f\' {time_per_unit * 1e3:.1f}ms/step\'\r\n            else:\r\n                time_info = f\' {time_per_unit * 1e6:.1f}us/step\'\r\n\r\n        show_bar += time_info\r\n        if len(info) != 0:\r\n            show_info = f\'{show_bar} \' + \\\r\n                        ""-"".join([f\' {key}: {value:.4f} \' for key, value in info.items()])\r\n            print(show_info, end=\'\')\r\n        else:\r\n            print(show_bar, end=\'\')\r\n'"
pybert/callback/trainingmonitor.py,0,"b'# encoding:utf-8\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom ..common.tools import load_json\nfrom ..common.tools import save_json\nplt.switch_backend(\'agg\')\n\n\nclass TrainingMonitor():\n    def __init__(self, file_dir, arch, add_test=False):\n        \'\'\'\n        :param startAt: \xe9\x87\x8d\xe6\x96\xb0\xe5\xbc\x80\xe5\xa7\x8b\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84epoch\xe7\x82\xb9\n        \'\'\'\n        if isinstance(file_dir, Path):\n            pass\n        else:\n            file_dir = Path(file_dir)\n        file_dir.mkdir(parents=True, exist_ok=True)\n\n        self.arch = arch\n        self.file_dir = file_dir\n        self.H = {}\n        self.add_test = add_test\n        self.json_path = file_dir / (arch + ""_training_monitor.json"")\n\n    def reset(self,start_at):\n        if start_at > 0:\n            if self.json_path is not None:\n                if self.json_path.exists():\n                    self.H = load_json(self.json_path)\n                    for k in self.H.keys():\n                        self.H[k] = self.H[k][:start_at]\n\n    def epoch_step(self, logs={}):\n        for (k, v) in logs.items():\n            l = self.H.get(k, [])\n            # np.float32\xe4\xbc\x9a\xe6\x8a\xa5\xe9\x94\x99\n            if not isinstance(v, np.float):\n                v = round(float(v), 4)\n            l.append(v)\n            self.H[k] = l\n\n        # \xe5\x86\x99\xe5\x85\xa5\xe6\x96\x87\xe4\xbb\xb6\n        if self.json_path is not None:\n            save_json(data = self.H,file_path=self.json_path)\n\n        # \xe4\xbf\x9d\xe5\xad\x98train\xe5\x9b\xbe\xe5\x83\x8f\n        if len(self.H[""loss""]) == 1:\n            self.paths = {key: self.file_dir / (self.arch + f\'_{key.upper()}\') for key in self.H.keys()}\n\n        if len(self.H[""loss""]) > 1:\n            # \xe6\x8c\x87\xe6\xa0\x87\xe5\x8f\x98\xe5\x8c\x96\n            # \xe6\x9b\xb2\xe7\xba\xbf\n            # \xe9\x9c\x80\xe8\xa6\x81\xe6\x88\x90\xe5\xaf\xb9\xe5\x87\xba\xe7\x8e\xb0\n            keys = [key for key, _ in self.H.items() if \'_\' not in key]\n            for key in keys:\n                N = np.arange(0, len(self.H[key]))\n                plt.style.use(""ggplot"")\n                plt.figure()\n                plt.plot(N, self.H[key], label=f""train_{key}"")\n                plt.plot(N, self.H[f""valid_{key}""], label=f""valid_{key}"")\n                if self.add_test:\n                    plt.plot(N, self.H[f""test_{key}""], label=f""test_{key}"")\n                plt.legend()\n                plt.xlabel(""Epoch #"")\n                plt.ylabel(key)\n                plt.title(f""Training {key} [Epoch {len(self.H[key])}]"")\n                plt.savefig(str(self.paths[key]))\n                plt.close()\n'"
pybert/common/tools.py,14,"b'import os\nimport random\nimport torch\nimport numpy as np\nimport json\nimport pickle\nimport torch.nn as nn\nfrom collections import OrderedDict\nfrom pathlib import Path\nimport logging\n\nlogger = logging.getLogger()\n\ndef print_config(config):\n    info = ""Running with the following configs:\\n""\n    for k, v in config.items():\n        info += f""\\t{k} : {str(v)}\\n""\n    print(""\\n"" + info + ""\\n"")\n    return\n\ndef init_logger(log_file=None, log_file_level=logging.NOTSET):\n    \'\'\'\n    Example:\n        >>> init_logger(log_file)\n        >>> logger.info(""abc\'"")\n    \'\'\'\n    if isinstance(log_file,Path):\n        log_file = str(log_file)\n    log_format = logging.Formatter(fmt=\'%(asctime)s - %(levelname)s - %(name)s -   %(message)s\',\n                                   datefmt=\'%m/%d/%Y %H:%M:%S\')\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(log_format)\n    logger.handlers = [console_handler]\n    if log_file and log_file != \'\':\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setLevel(log_file_level)\n        # file_handler.setFormatter(log_format)\n        logger.addHandler(file_handler)\n    return logger\n\ndef seed_everything(seed=1029):\n    \'\'\'\n    \xe8\xae\xbe\xe7\xbd\xae\xe6\x95\xb4\xe4\xb8\xaa\xe5\xbc\x80\xe5\x8f\x91\xe7\x8e\xaf\xe5\xa2\x83\xe7\x9a\x84seed\n    :param seed:\n    :param device:\n    :return:\n    \'\'\'\n    random.seed(seed)\n    os.environ[\'PYTHONHASHSEED\'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    # some cudnn methods can be random even after fixing the seed\n    # unless you tell it to be deterministic\n    torch.backends.cudnn.deterministic = True\n\ndef prepare_device(use_gpu):\n    """"""\n    setup GPU device if available, move model into configured device\n    # \xe5\xa6\x82\xe6\x9e\x9cn_gpu_use\xe4\xb8\xba\xe6\x95\xb0\xe5\xad\x97\xef\xbc\x8c\xe5\x88\x99\xe4\xbd\xbf\xe7\x94\xa8range\xe7\x94\x9f\xe6\x88\x90list\n    # \xe5\xa6\x82\xe6\x9e\x9c\xe8\xbe\x93\xe5\x85\xa5\xe7\x9a\x84\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaalist\xef\xbc\x8c\xe5\x88\x99\xe9\xbb\x98\xe8\xae\xa4\xe4\xbd\xbf\xe7\x94\xa8list[0]\xe4\xbd\x9c\xe4\xb8\xbacontroller\n    Example:\n        use_gpu = \'\' : cpu\n        use_gpu = \'0\': cuda:0\n        use_gpu = \'0,1\' : cuda:0 and cuda:1\n     """"""\n    n_gpu_use = [int(x) for x in use_gpu.split("","")]\n    if not use_gpu:\n        device_type = \'cpu\'\n    else:\n        device_type = f""cuda:{n_gpu_use[0]}""\n    n_gpu = torch.cuda.device_count()\n    if len(n_gpu_use) > 0 and n_gpu == 0:\n        logger.warning(""Warning: There\\\'s no GPU available on this machine, training will be performed on CPU."")\n        device_type = \'cpu\'\n    if len(n_gpu_use) > n_gpu:\n        msg = f""Warning: The number of GPU\\\'s configured to use is {n_gpu}, but only {n_gpu} are available on this machine.""\n        logger.warning(msg)\n        n_gpu_use = range(n_gpu)\n    device = torch.device(device_type)\n    list_ids = n_gpu_use\n    return device, list_ids\n\n\ndef model_device(n_gpu, model):\n    \'\'\'\n    :param n_gpu:\n    :param model:\n    :return:\n    \'\'\'\n    device, device_ids = prepare_device(n_gpu)\n    if len(device_ids) > 1:\n        logger.info(f""current {len(device_ids)} GPUs"")\n        model = torch.nn.DataParallel(model, device_ids=device_ids)\n    if len(device_ids) == 1:\n        os.environ[\'CUDA_VISIBLE_DEVICES\'] = str(device_ids[0])\n    model = model.to(device)\n    return model, device\n\ndef restore_checkpoint(resume_path, model=None):\n    \'\'\'\n    \xe5\x8a\xa0\xe8\xbd\xbd\xe6\xa8\xa1\xe5\x9e\x8b\n    :param resume_path:\n    :param model:\n    :param optimizer:\n    :return:\n    \xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x9a \xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe5\x8a\xa0\xe8\xbd\xbdBert\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\x81\xe8\xb0\x83\xe6\x95\xb4\xef\xbc\x8c\xe4\xb8\x8d\xe8\x83\xbd\xe4\xbd\xbf\xe7\x94\xa8\xe8\xaf\xa5\xe6\xa8\xa1\xe5\xbc\x8f\n    \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8\xe6\xa8\xa1\xe5\x9d\x97\xe8\x87\xaa\xe5\xb8\xa6\xe7\x9a\x84Bert_model.from_pretrained(state_dict = your save state_dict)\n    \'\'\'\n    if isinstance(resume_path, Path):\n        resume_path = str(resume_path)\n    checkpoint = torch.load(resume_path)\n    best = checkpoint[\'best\']\n    start_epoch = checkpoint[\'epoch\'] + 1\n    states = checkpoint[\'state_dict\']\n    if isinstance(model, nn.DataParallel):\n        model.module.load_state_dict(states)\n    else:\n        model.load_state_dict(states)\n    return [model,best,start_epoch]\n\ndef save_pickle(data, file_path):\n    \'\'\'\n    \xe4\xbf\x9d\xe5\xad\x98\xe6\x88\x90pickle\xe6\x96\x87\xe4\xbb\xb6\n    :param data:\n    :param file_name:\n    :param pickle_path:\n    :return:\n    \'\'\'\n    if isinstance(file_path, Path):\n        file_path = str(file_path)\n    with open(file_path, \'wb\') as f:\n        pickle.dump(data, f)\n\n\ndef load_pickle(input_file):\n    \'\'\'\n    \xe8\xaf\xbb\xe5\x8f\x96pickle\xe6\x96\x87\xe4\xbb\xb6\n    :param pickle_path:\n    :param file_name:\n    :return:\n    \'\'\'\n    with open(str(input_file), \'rb\') as f:\n        data = pickle.load(f)\n    return data\n\n\ndef save_json(data, file_path):\n    \'\'\'\n    \xe4\xbf\x9d\xe5\xad\x98\xe6\x88\x90json\xe6\x96\x87\xe4\xbb\xb6\n    :param data:\n    :param json_path:\n    :param file_name:\n    :return:\n    \'\'\'\n    if not isinstance(file_path, Path):\n        file_path = Path(file_path)\n    # if isinstance(data,dict):\n    #     data = json.dumps(data)\n    with open(str(file_path), \'w\') as f:\n        json.dump(data, f)\n\n\ndef load_json(file_path):\n    \'\'\'\n    \xe5\x8a\xa0\xe8\xbd\xbdjson\xe6\x96\x87\xe4\xbb\xb6\n    :param json_path:\n    :param file_name:\n    :return:\n    \'\'\'\n    if not isinstance(file_path, Path):\n        file_path = Path(file_path)\n    with open(str(file_path), \'r\') as f:\n        data = json.load(f)\n    return data\n\ndef json_to_text(file_path,data):\n    \'\'\'\n    chinese\n    \xe5\xb0\x86json list\xe5\x86\x99\xe5\x85\xa5text\xe6\x96\x87\xe4\xbb\xb6\xe4\xb8\xad\n    :param file_path:\n    :param data:\n    :return:\n    \'\'\'\n    if not isinstance(file_path, Path):\n        file_path = Path(file_path)\n    with open(str(file_path), \'w\') as fw:\n        for line in data:\n            line = json.dumps(line, ensure_ascii=False)\n            fw.write(line + \'\\n\')\n\ndef save_model(model, model_path):\n    """""" \xe5\xad\x98\xe5\x82\xa8\xe4\xb8\x8d\xe5\x90\xab\xe6\x9c\x89\xe6\x98\xbe\xe5\x8d\xa1\xe4\xbf\xa1\xe6\x81\xaf\xe7\x9a\x84state_dict\xe6\x88\x96model\n    :param model:\n    :param model_name:\n    :param only_param:\n    :return:\n    """"""\n    if isinstance(model_path, Path):\n        model_path = str(model_path)\n    if isinstance(model, nn.DataParallel):\n        model = model.module\n    state_dict = model.state_dict()\n    for key in state_dict:\n        state_dict[key] = state_dict[key].cpu()\n    torch.save(state_dict, model_path)\n\ndef load_model(model, model_path):\n    \'\'\'\n    \xe5\x8a\xa0\xe8\xbd\xbd\xe6\xa8\xa1\xe5\x9e\x8b\n    :param model:\n    :param model_name:\n    :param model_path:\n    :param only_param:\n    :return:\n    \'\'\'\n    if isinstance(model_path, Path):\n        model_path = str(model_path)\n    logging.info(f""loading model from {str(model_path)} ."")\n    states = torch.load(model_path)\n    state = states[\'state_dict\']\n    if isinstance(model, nn.DataParallel):\n        model.module.load_state_dict(state)\n    else:\n        model.load_state_dict(state)\n    return model\n\n\nclass AverageMeter(object):\n    \'\'\'\n    computes and stores the average and current value\n    Example:\n        >>> loss = AverageMeter()\n        >>> for step,batch in enumerate(train_data):\n        >>>     pred = self.model(batch)\n        >>>     raw_loss = self.metrics(pred,target)\n        >>>     loss.update(raw_loss.item(),n = 1)\n        >>> cur_loss = loss.avg\n    \'\'\'\n\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.val = 0\n        self.avg = 0\n        self.sum = 0\n        self.count = 0\n\n    def update(self, val, n=1):\n        self.val = val\n        self.sum += val * n\n        self.count += n\n        self.avg = self.sum / self.count\n\n\ndef summary(model, *inputs, batch_size=-1, show_input=True):\n    \'\'\'\n    \xe6\x89\x93\xe5\x8d\xb0\xe6\xa8\xa1\xe5\x9e\x8b\xe7\xbb\x93\xe6\x9e\x84\xe4\xbf\xa1\xe6\x81\xaf\n    :param model:\n    :param inputs:\n    :param batch_size:\n    :param show_input:\n    :return:\n    Example:\n        >>> print(""model summary info: "")\n        >>> for step,batch in enumerate(train_data):\n        >>>     summary(self.model,*batch,show_input=True)\n        >>>     break\n    \'\'\'\n\n    def register_hook(module):\n        def hook(module, input, output=None):\n            class_name = str(module.__class__).split(""."")[-1].split(""\'"")[0]\n            module_idx = len(summary)\n\n            m_key = f""{class_name}-{module_idx + 1}""\n            summary[m_key] = OrderedDict()\n            summary[m_key][""input_shape""] = list(input[0].size())\n            summary[m_key][""input_shape""][0] = batch_size\n\n            if show_input is False and output is not None:\n                if isinstance(output, (list, tuple)):\n                    for out in output:\n                        if isinstance(out, torch.Tensor):\n                            summary[m_key][""output_shape""] = [\n                                [-1] + list(out.size())[1:]\n                            ][0]\n                        else:\n                            summary[m_key][""output_shape""] = [\n                                [-1] + list(out[0].size())[1:]\n                            ][0]\n                else:\n                    summary[m_key][""output_shape""] = list(output.size())\n                    summary[m_key][""output_shape""][0] = batch_size\n\n            params = 0\n            if hasattr(module, ""weight"") and hasattr(module.weight, ""size""):\n                params += torch.prod(torch.LongTensor(list(module.weight.size())))\n                summary[m_key][""trainable""] = module.weight.requires_grad\n            if hasattr(module, ""bias"") and hasattr(module.bias, ""size""):\n                params += torch.prod(torch.LongTensor(list(module.bias.size())))\n            summary[m_key][""nb_params""] = params\n\n        if (not isinstance(module, nn.Sequential) and not isinstance(module, nn.ModuleList) and not (module == model)):\n            if show_input is True:\n                hooks.append(module.register_forward_pre_hook(hook))\n            else:\n                hooks.append(module.register_forward_hook(hook))\n\n    # create properties\n    summary = OrderedDict()\n    hooks = []\n\n    # register hook\n    model.apply(register_hook)\n    model(*inputs)\n\n    # remove these hooks\n    for h in hooks:\n        h.remove()\n\n    print(""-----------------------------------------------------------------------"")\n    if show_input is True:\n        line_new = f""{\'Layer (type)\':>25}  {\'Input Shape\':>25} {\'Param #\':>15}""\n    else:\n        line_new = f""{\'Layer (type)\':>25}  {\'Output Shape\':>25} {\'Param #\':>15}""\n    print(line_new)\n    print(""======================================================================="")\n\n    total_params = 0\n    total_output = 0\n    trainable_params = 0\n    for layer in summary:\n        # input_shape, output_shape, trainable, nb_params\n        if show_input is True:\n            line_new = ""{:>25}  {:>25} {:>15}"".format(\n                layer,\n                str(summary[layer][""input_shape""]),\n                ""{0:,}"".format(summary[layer][""nb_params""]),\n            )\n        else:\n            line_new = ""{:>25}  {:>25} {:>15}"".format(\n                layer,\n                str(summary[layer][""output_shape""]),\n                ""{0:,}"".format(summary[layer][""nb_params""]),\n            )\n\n        total_params += summary[layer][""nb_params""]\n        if show_input is True:\n            total_output += np.prod(summary[layer][""input_shape""])\n        else:\n            total_output += np.prod(summary[layer][""output_shape""])\n        if ""trainable"" in summary[layer]:\n            if summary[layer][""trainable""] == True:\n                trainable_params += summary[layer][""nb_params""]\n\n        print(line_new)\n\n    print(""======================================================================="")\n    print(f""Total params: {total_params:0,}"")\n    print(f""Trainable params: {trainable_params:0,}"")\n    print(f""Non-trainable params: {(total_params - trainable_params):0,}"")\n    print(""-----------------------------------------------------------------------"")\n'"
pybert/configs/__init__.py,0,b'#encoding:utf-8'
pybert/configs/basic_config.py,0,"b'\r\nfrom pathlib import Path\r\nBASE_DIR = Path(\'pybert\')\r\nconfig = {\r\n    \'raw_data_path\': BASE_DIR / \'dataset/train_sample.csv\',\r\n    \'test_path\': BASE_DIR / \'dataset/test.csv\',\r\n\r\n    \'data_dir\': BASE_DIR / \'dataset\',\r\n    \'log_dir\': BASE_DIR / \'output/log\',\r\n    \'writer_dir\': BASE_DIR / ""output/TSboard"",\r\n    \'figure_dir\': BASE_DIR / ""output/figure"",\r\n    \'checkpoint_dir\': BASE_DIR / ""output/checkpoints"",\r\n    \'cache_dir\': BASE_DIR / \'model/\',\r\n    \'result\': BASE_DIR / ""output/result"",\r\n\r\n    \'bert_vocab_path\': BASE_DIR / \'pretrain/bert/base-uncased/bert_vocab.txt\',\r\n    \'bert_config_file\': BASE_DIR / \'pretrain/bert/base-uncased/config.json\',\r\n    \'bert_model_dir\': BASE_DIR / \'pretrain/bert/base-uncased\',\r\n\r\n    \'xlnet_vocab_path\': BASE_DIR / \'pretrain/xlnet/base-cased/spiece.model\',\r\n    \'xlnet_config_file\': BASE_DIR / \'pretrain/xlnet/base-cased/config.json\',\r\n    \'xlnet_model_dir\': BASE_DIR / \'pretrain/xlnet/base-cased\',\r\n\r\n    \'albert_vocab_path\': BASE_DIR / \'pretrain/albert/albert-base/30k-clean.model\',\r\n    \'albert_config_file\': BASE_DIR / \'pretrain/albert/albert-base/config.json\',\r\n    \'albert_model_dir\': BASE_DIR / \'pretrain/albert/albert-base\'\r\n\r\n\r\n}\r\n\r\n'"
pybert/dataset/__init__.py,0,b'#encoding:utf-8'
pybert/io/__init__.py,0,b'#encoding:utf-8'
pybert/io/albert_processor.py,10,"b'import torch\nimport numpy as np\nfrom ..common.tools import load_pickle\nfrom ..common.tools import logger\nfrom ..callback.progressbar import ProgressBar\nfrom torch.utils.data import TensorDataset\nfrom pybert.model.albert.tokenization_albert import FullTokenizer\n\nclass InputExample(object):\n    def __init__(self, guid, text_a, text_b=None, label=None):\n        """"""Constructs a InputExample.\n        Args:\n            guid: Unique id for the example.\n            text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n            text_b: (Optional) string. The untokenized text of the second sequence.\n            Only must be specified for sequence pair tasks.\n            label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid   = guid\n        self.text_a = text_a\n        self.text_b = text_b\n        self.label  = label\n\nclass InputFeature(object):\n    \'\'\'\n    A single set of features of data.\n    \'\'\'\n    def __init__(self,input_ids,input_mask,segment_ids,label_id,input_len):\n        self.input_ids   = input_ids\n        self.input_mask  = input_mask\n        self.segment_ids = segment_ids\n        self.label_id    = label_id\n        self.input_len = input_len\n\nclass AlbertProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def __init__(self,vocab_file,spm_model_file,do_lower_case):\n        self.tokenizer = FullTokenizer(vocab_file=vocab_file,spm_model_file=spm_model_file,do_lower_case=do_lower_case)\n\n    def get_train(self, data_file):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        return self.read_data(data_file)\n\n    def get_dev(self, data_file):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        return self.read_data(data_file)\n\n    def get_test(self,lines):\n        return lines\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        return [""toxic"",""severe_toxic"",""obscene"",""threat"",""insult"",""identity_hate""]\n\n    @classmethod\n    def read_data(cls, input_file,quotechar = None):\n        """"""Reads a tab separated value file.""""""\n        if \'pkl\' in str(input_file):\n            lines = load_pickle(input_file)\n        else:\n            lines = input_file\n        return lines\n\n    def truncate_seq_pair(self,tokens_a,tokens_b,max_length):\n        # This is a simple heuristic which will always truncate the longer sequence\n        # one token at a time. This makes more sense than truncating an equal percent\n        # of tokens from each, since if one sequence is very short then each token\n        # that\'s truncated likely contains more information than a longer sequence.\n        while True:\n            total_length = len(tokens_a) + len(tokens_b)\n            if total_length <= max_length:\n                break\n            if len(tokens_a) > len(tokens_b):\n                tokens_a.pop()\n            else:\n                tokens_b.pop()\n\n    def create_examples(self,lines,example_type,cached_examples_file):\n        \'\'\'\n        Creates examples for data\n        \'\'\'\n        pbar = ProgressBar(n_total = len(lines),desc=\'create examples\')\n        if cached_examples_file.exists():\n            logger.info(""Loading examples from cached file %s"", cached_examples_file)\n            examples = torch.load(cached_examples_file)\n        else:\n            examples = []\n            for i,line in enumerate(lines):\n                guid = \'%s-%d\'%(example_type,i)\n                text_a = line[0]\n                label = line[1]\n                if isinstance(label,str):\n                    label = [np.float(x) for x in label.split("","")]\n                else:\n                    label = [np.float(x) for x in list(label)]\n                text_b = None\n                example = InputExample(guid = guid,text_a = text_a,text_b=text_b,label= label)\n                examples.append(example)\n                pbar(step=i)\n            logger.info(""Saving examples into cached file %s"", cached_examples_file)\n            torch.save(examples, cached_examples_file)\n        return examples\n\n    def create_features(self,examples,max_seq_len,cached_features_file):\n        \'\'\'\n        # The convention in BERT is:\n        # (a) For sequence pairs:\n        #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n        #  type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1\n        # (b) For single sequences:\n        #  tokens:   [CLS] the dog is hairy . [SEP]\n        #  type_ids:   0   0   0   0  0     0   0\n        \'\'\'\n        pbar = ProgressBar(n_total=len(examples),desc=\'create features\')\n        if cached_features_file.exists():\n            logger.info(""Loading features from cached file %s"", cached_features_file)\n            features = torch.load(cached_features_file)\n        else:\n            features = []\n            for ex_id,example in enumerate(examples):\n                tokens_a = self.tokenizer.tokenize(example.text_a)\n                tokens_b = None\n                label_id = example.label\n\n                if example.text_b:\n                    tokens_b = self.tokenizer.tokenize(example.text_b)\n                    # Modifies `tokens_a` and `tokens_b` in place so that the total\n                    # length is less than the specified length.\n                    # Account for [CLS], [SEP], [SEP] with ""- 3""\n                    self.truncate_seq_pair(tokens_a,tokens_b,max_length = max_seq_len - 3)\n                else:\n                    # Account for [CLS] and [SEP] with \'-2\'\n                    if len(tokens_a) > max_seq_len - 2:\n                        tokens_a = tokens_a[:max_seq_len - 2]\n                tokens = [\'[CLS]\'] + tokens_a + [\'[SEP]\']\n                segment_ids = [0] * len(tokens)\n                if tokens_b:\n                    tokens += tokens_b + [\'[SEP]\']\n                    segment_ids += [1] * (len(tokens_b) + 1)\n\n                input_ids = self.tokenizer.convert_tokens_to_ids(tokens)\n                input_mask = [1] * len(input_ids)\n                padding = [0] * (max_seq_len - len(input_ids))\n                input_len = len(input_ids)\n\n                input_ids   += padding\n                input_mask  += padding\n                segment_ids += padding\n\n                assert len(input_ids) == max_seq_len\n                assert len(input_mask) == max_seq_len\n                assert len(segment_ids) == max_seq_len\n\n                if ex_id < 2:\n                    logger.info(""*** Example ***"")\n                    logger.info(f""guid: {example.guid}"" % ())\n                    logger.info(f""tokens: {\' \'.join([str(x) for x in tokens])}"")\n                    logger.info(f""input_ids: {\' \'.join([str(x) for x in input_ids])}"")\n                    logger.info(f""input_mask: {\' \'.join([str(x) for x in input_mask])}"")\n                    logger.info(f""segment_ids: {\' \'.join([str(x) for x in segment_ids])}"")\n\n                feature = InputFeature(input_ids = input_ids,\n                                       input_mask = input_mask,\n                                       segment_ids = segment_ids,\n                                       label_id = label_id,\n                                       input_len = input_len)\n                features.append(feature)\n                pbar(step=ex_id)\n            logger.info(""Saving features into cached file %s"", cached_features_file)\n            torch.save(features, cached_features_file)\n        return features\n\n    def create_dataset(self,features,is_sorted = False):\n        # Convert to Tensors and build dataset\n        if is_sorted:\n            logger.info(""sorted data by th length of input"")\n            features = sorted(features,key=lambda x:x.input_len,reverse=True)\n        all_input_ids = torch.tensor([f.input_ids for f in features], dtype=torch.long)\n        all_input_mask = torch.tensor([f.input_mask for f in features], dtype=torch.long)\n        all_segment_ids = torch.tensor([f.segment_ids for f in features], dtype=torch.long)\n        all_label_ids = torch.tensor([f.label_id for f in features],dtype=torch.long)\n        all_input_lens = torch.tensor([f.input_len for f in features], dtype=torch.long)\n        dataset = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids,all_input_lens)\n        return dataset\n\n'"
pybert/io/bert_processor.py,10,"b'import csv\r\nimport torch\r\nimport numpy as np\r\nfrom ..common.tools import load_pickle\r\nfrom ..common.tools import logger\r\nfrom ..callback.progressbar import ProgressBar\r\nfrom torch.utils.data import TensorDataset\r\nfrom transformers import BertTokenizer\r\n\r\nclass InputExample(object):\r\n    def __init__(self, guid, text_a, text_b=None, label=None):\r\n        """"""Constructs a InputExample.\r\n        Args:\r\n            guid: Unique id for the example.\r\n            text_a: string. The untokenized text of the first sequence. For single\r\n            sequence tasks, only this sequence must be specified.\r\n            text_b: (Optional) string. The untokenized text of the second sequence.\r\n            Only must be specified for sequence pair tasks.\r\n            label: (Optional) string. The label of the example. This should be\r\n            specified for train and dev examples, but not for test examples.\r\n        """"""\r\n        self.guid   = guid\r\n        self.text_a = text_a\r\n        self.text_b = text_b\r\n        self.label  = label\r\n\r\nclass InputFeature(object):\r\n    \'\'\'\r\n    A single set of features of data.\r\n    \'\'\'\r\n    def __init__(self,input_ids,input_mask,segment_ids,label_id,input_len):\r\n        self.input_ids   = input_ids\r\n        self.input_mask  = input_mask\r\n        self.segment_ids = segment_ids\r\n        self.label_id    = label_id\r\n        self.input_len = input_len\r\n\r\nclass BertProcessor(object):\r\n    """"""Base class for data converters for sequence classification data sets.""""""\r\n\r\n    def __init__(self,vocab_path,do_lower_case):\r\n        self.tokenizer = BertTokenizer(vocab_path,do_lower_case)\r\n\r\n    def get_train(self, data_file):\r\n        """"""Gets a collection of `InputExample`s for the train set.""""""\r\n        return self.read_data(data_file)\r\n\r\n    def get_dev(self, data_file):\r\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\r\n        return self.read_data(data_file)\r\n\r\n    def get_test(self,lines):\r\n        return lines\r\n\r\n    def get_labels(self):\r\n        """"""Gets the list of labels for this data set.""""""\r\n        return [""toxic"",""severe_toxic"",""obscene"",""threat"",""insult"",""identity_hate""]\r\n\r\n    @classmethod\r\n    def read_data(cls, input_file,quotechar = None):\r\n        """"""Reads a tab separated value file.""""""\r\n        if \'pkl\' in str(input_file):\r\n            lines = load_pickle(input_file)\r\n        else:\r\n            lines = input_file\r\n        return lines\r\n\r\n    def truncate_seq_pair(self,tokens_a,tokens_b,max_length):\r\n        # This is a simple heuristic which will always truncate the longer sequence\r\n        # one token at a time. This makes more sense than truncating an equal percent\r\n        # of tokens from each, since if one sequence is very short then each token\r\n        # that\'s truncated likely contains more information than a longer sequence.\r\n        while True:\r\n            total_length = len(tokens_a) + len(tokens_b)\r\n            if total_length <= max_length:\r\n                break\r\n            if len(tokens_a) > len(tokens_b):\r\n                tokens_a.pop()\r\n            else:\r\n                tokens_b.pop()\r\n\r\n    def create_examples(self,lines,example_type,cached_examples_file):\r\n        \'\'\'\r\n        Creates examples for data\r\n        \'\'\'\r\n        pbar = ProgressBar(n_total = len(lines),desc=\'create examples\')\r\n        if cached_examples_file.exists():\r\n            logger.info(""Loading examples from cached file %s"", cached_examples_file)\r\n            examples = torch.load(cached_examples_file)\r\n        else:\r\n            examples = []\r\n            for i,line in enumerate(lines):\r\n                guid = \'%s-%d\'%(example_type,i)\r\n                text_a = line[0]\r\n                label = line[1]\r\n                if isinstance(label,str):\r\n                    label = [np.float(x) for x in label.split("","")]\r\n                else:\r\n                    label = [np.float(x) for x in list(label)]\r\n                text_b = None\r\n                example = InputExample(guid = guid,text_a = text_a,text_b=text_b,label= label)\r\n                examples.append(example)\r\n                pbar(step=i)\r\n            logger.info(""Saving examples into cached file %s"", cached_examples_file)\r\n            torch.save(examples, cached_examples_file)\r\n        return examples\r\n\r\n    def create_features(self,examples,max_seq_len,cached_features_file):\r\n        \'\'\'\r\n        # The convention in BERT is:\r\n        # (a) For sequence pairs:\r\n        #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\r\n        #  type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1\r\n        # (b) For single sequences:\r\n        #  tokens:   [CLS] the dog is hairy . [SEP]\r\n        #  type_ids:   0   0   0   0  0     0   0\r\n        \'\'\'\r\n        pbar = ProgressBar(n_total=len(examples),desc=\'create features\')\r\n        if cached_features_file.exists():\r\n            logger.info(""Loading features from cached file %s"", cached_features_file)\r\n            features = torch.load(cached_features_file)\r\n        else:\r\n            features = []\r\n            for ex_id,example in enumerate(examples):\r\n                tokens_a = self.tokenizer.tokenize(example.text_a)\r\n                tokens_b = None\r\n                label_id = example.label\r\n\r\n                if example.text_b:\r\n                    tokens_b = self.tokenizer.tokenize(example.text_b)\r\n                    # Modifies `tokens_a` and `tokens_b` in place so that the total\r\n                    # length is less than the specified length.\r\n                    # Account for [CLS], [SEP], [SEP] with ""- 3""\r\n                    self.truncate_seq_pair(tokens_a,tokens_b,max_length = max_seq_len - 3)\r\n                else:\r\n                    # Account for [CLS] and [SEP] with \'-2\'\r\n                    if len(tokens_a) > max_seq_len - 2:\r\n                        tokens_a = tokens_a[:max_seq_len - 2]\r\n                tokens = [\'[CLS]\'] + tokens_a + [\'[SEP]\']\r\n                segment_ids = [0] * len(tokens)\r\n                if tokens_b:\r\n                    tokens += tokens_b + [\'[SEP]\']\r\n                    segment_ids += [1] * (len(tokens_b) + 1)\r\n\r\n                input_ids = self.tokenizer.convert_tokens_to_ids(tokens)\r\n                input_mask = [1] * len(input_ids)\r\n                padding = [0] * (max_seq_len - len(input_ids))\r\n                input_len = len(input_ids)\r\n\r\n                input_ids   += padding\r\n                input_mask  += padding\r\n                segment_ids += padding\r\n\r\n                assert len(input_ids) == max_seq_len\r\n                assert len(input_mask) == max_seq_len\r\n                assert len(segment_ids) == max_seq_len\r\n\r\n                if ex_id < 2:\r\n                    logger.info(""*** Example ***"")\r\n                    logger.info(f""guid: {example.guid}"" % ())\r\n                    logger.info(f""tokens: {\' \'.join([str(x) for x in tokens])}"")\r\n                    logger.info(f""input_ids: {\' \'.join([str(x) for x in input_ids])}"")\r\n                    logger.info(f""input_mask: {\' \'.join([str(x) for x in input_mask])}"")\r\n                    logger.info(f""segment_ids: {\' \'.join([str(x) for x in segment_ids])}"")\r\n\r\n                feature = InputFeature(input_ids = input_ids,\r\n                                       input_mask = input_mask,\r\n                                       segment_ids = segment_ids,\r\n                                       label_id = label_id,\r\n                                       input_len = input_len)\r\n                features.append(feature)\r\n                pbar(step=ex_id)\r\n            logger.info(""Saving features into cached file %s"", cached_features_file)\r\n            torch.save(features, cached_features_file)\r\n        return features\r\n\r\n    def create_dataset(self,features,is_sorted = False):\r\n        # Convert to Tensors and build dataset\r\n        if is_sorted:\r\n            logger.info(""sorted data by th length of input"")\r\n            features = sorted(features,key=lambda x:x.input_len,reverse=True)\r\n        all_input_ids = torch.tensor([f.input_ids for f in features], dtype=torch.long)\r\n        all_input_mask = torch.tensor([f.input_mask for f in features], dtype=torch.long)\r\n        all_segment_ids = torch.tensor([f.segment_ids for f in features], dtype=torch.long)\r\n        all_label_ids = torch.tensor([f.label_id for f in features],dtype=torch.long)\r\n        all_input_lens = torch.tensor([f.input_len for f in features], dtype=torch.long)\r\n        dataset = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids,all_input_lens)\r\n        return dataset\r\n\r\n'"
pybert/io/task_data.py,0,"b'import random\r\nimport pandas as pd\r\nfrom tqdm import tqdm\r\nfrom ..common.tools import save_pickle\r\nfrom ..common.tools import logger\r\nfrom ..callback.progressbar import ProgressBar\r\n\r\nclass TaskData(object):\r\n    def __init__(self):\r\n        pass\r\n    def train_val_split(self,X, y,valid_size,stratify=False,shuffle=True,save = True,\r\n                        seed = None,data_name = None,data_dir = None):\r\n        pbar = ProgressBar(n_total=len(X),desc=\'bucket\')\r\n        logger.info(\'split raw data into train and valid\')\r\n        if stratify:\r\n            num_classes = len(list(set(y)))\r\n            train, valid = [], []\r\n            bucket = [[] for _ in range(num_classes)]\r\n            for step,(data_x, data_y) in enumerate(zip(X, y)):\r\n                bucket[int(data_y)].append((data_x, data_y))\r\n                pbar(step=step)\r\n            del X, y\r\n            for bt in tqdm(bucket, desc=\'split\'):\r\n                N = len(bt)\r\n                if N == 0:\r\n                    continue\r\n                test_size = int(N * valid_size)\r\n                if shuffle:\r\n                    random.seed(seed)\r\n                    random.shuffle(bt)\r\n                valid.extend(bt[:test_size])\r\n                train.extend(bt[test_size:])\r\n            if shuffle:\r\n                random.seed(seed)\r\n                random.shuffle(train)\r\n        else:\r\n            data = []\r\n            for step,(data_x, data_y) in enumerate(zip(X, y)):\r\n                data.append((data_x, data_y))\r\n                pbar(step=step)\r\n            del X, y\r\n            N = len(data)\r\n            test_size = int(N * valid_size)\r\n            if shuffle:\r\n                random.seed(seed)\r\n                random.shuffle(data)\r\n            valid = data[:test_size]\r\n            train = data[test_size:]\r\n            # \xe6\xb7\xb7\xe6\xb4\x97train\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\r\n            if shuffle:\r\n                random.seed(seed)\r\n                random.shuffle(train)\r\n        if save:\r\n            train_path = data_dir / f""{data_name}.train.pkl""\r\n            valid_path = data_dir / f""{data_name}.valid.pkl""\r\n            save_pickle(data=train,file_path=train_path)\r\n            save_pickle(data = valid,file_path=valid_path)\r\n        return train, valid\r\n\r\n    def read_data(self,raw_data_path,preprocessor = None,is_train=True):\r\n        \'\'\'\r\n        :param raw_data_path:\r\n        :param skip_header:\r\n        :param preprocessor:\r\n        :return:\r\n        \'\'\'\r\n        targets, sentences = [], []\r\n        data = pd.read_csv(raw_data_path)\r\n        for row in data.values:\r\n            if is_train:\r\n                target = row[2:]\r\n            else:\r\n                target = [-1,-1,-1,-1,-1,-1]\r\n            sentence = str(row[1])\r\n            if preprocessor:\r\n                sentence = preprocessor(sentence)\r\n            if sentence:\r\n                targets.append(target)\r\n                sentences.append(sentence)\r\n        return targets,sentences\r\n'"
pybert/io/utils.py,2,"b'import torch\ndef collate_fn(batch):\n    """"""\n    batch should be a list of (sequence, target, length) tuples...\n    Returns a padded tensor of sequences sorted from longest to shortest,\n    """"""\n    all_input_ids, all_input_mask, all_segment_ids, all_label_ids,all_input_lens = map(torch.stack, zip(*batch))\n    max_len = max(all_input_lens).item()\n    all_input_ids = all_input_ids[:, :max_len]\n    all_input_mask = all_input_mask[:, :max_len]\n    all_segment_ids = all_segment_ids[:, :max_len]\n    return all_input_ids, all_input_mask, all_segment_ids, all_label_ids\n\ndef xlnet_collate_fn(batch):\n    """"""\n    batch should be a list of (sequence, target, length) tuples...\n    Returns a padded tensor of sequences sorted from longest to shortest,\n    """"""\n    all_input_ids, all_input_mask, all_segment_ids, all_label_ids,all_input_lens = map(torch.stack, zip(*batch))\n    max_len = max(all_input_lens).item()\n    all_input_ids = all_input_ids[:, -max_len:]\n    all_input_mask = all_input_mask[:, -max_len:]\n    all_segment_ids = all_segment_ids[:, -max_len:]\n    return all_input_ids, all_input_mask, all_segment_ids, all_label_ids\n\n'"
pybert/io/vocabulary.py,0,"b'from collections import Counter\r\nfrom ..common.tools import save_pickle\r\nfrom ..common.tools import load_pickle\r\nfrom ..common.tools import logger\r\n\r\nclass Vocabulary(object):\r\n    def __init__(self, max_size=None,\r\n                 min_freq=None,\r\n                 pad_token=""[PAD]"",\r\n                 unk_token = ""[UNK]"",\r\n                 cls_token = ""[CLS]"",\r\n                 sep_token = ""[SEP]"",\r\n                 mask_token = ""[MASK]"",\r\n                 add_unused = False):\r\n        self.max_size = max_size\r\n        self.min_freq = min_freq\r\n        self.cls_token = cls_token\r\n        self.sep_token = sep_token\r\n        self.pad_token = pad_token\r\n        self.mask_token = mask_token\r\n        self.unk_token = unk_token\r\n        self.word2id = {}\r\n        self.id2word = None\r\n        self.rebuild = True\r\n        self.add_unused = add_unused\r\n        self.word_counter = Counter()\r\n        self.reset()\r\n\r\n    def reset(self):\r\n        ctrl_symbols = [self.pad_token,self.unk_token,self.cls_token,self.sep_token,self.mask_token]\r\n        for index,syb in enumerate(ctrl_symbols):\r\n            self.word2id[syb] = index\r\n\r\n        if self.add_unused:\r\n            for i in range(20):\r\n                self.word2id[f\'[UNUSED{i}]\'] = len(self.word2id)\r\n\r\n    def update(self, word_list):\r\n        \'\'\'\r\n        \xe4\xbe\x9d\xe6\xac\xa1\xe5\xa2\x9e\xe5\x8a\xa0\xe5\xba\x8f\xe5\x88\x97\xe4\xb8\xad\xe8\xaf\x8d\xe5\x9c\xa8\xe8\xaf\x8d\xe5\x85\xb8\xe4\xb8\xad\xe7\x9a\x84\xe5\x87\xba\xe7\x8e\xb0\xe9\xa2\x91\xe7\x8e\x87\r\n        :param word_list:\r\n        :return:\r\n        \'\'\'\r\n        self.word_counter.update(word_list)\r\n\r\n    def add(self, word):\r\n        \'\'\'\r\n        \xe5\xa2\x9e\xe5\x8a\xa0\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\xb0\xe8\xaf\x8d\xe5\x9c\xa8\xe8\xaf\x8d\xe5\x85\xb8\xe4\xb8\xad\xe7\x9a\x84\xe5\x87\xba\xe7\x8e\xb0\xe9\xa2\x91\xe7\x8e\x87\r\n        :param word:\r\n        :return:\r\n        \'\'\'\r\n        self.word_counter[word] += 1\r\n\r\n    def has_word(self, word):\r\n        \'\'\'\r\n        \xe6\xa3\x80\xe6\x9f\xa5\xe8\xaf\x8d\xe6\x98\xaf\xe5\x90\xa6\xe8\xa2\xab\xe8\xae\xb0\xe5\xbd\x95\r\n        :param word:\r\n        :return:\r\n        \'\'\'\r\n        return word in self.word2id\r\n\r\n    def to_index(self, word):\r\n        \'\'\'\r\n        \xe5\xb0\x86\xe8\xaf\x8d\xe8\xbd\xac\xe4\xb8\xba\xe6\x95\xb0\xe5\xad\x97. \xe8\x8b\xa5\xe8\xaf\x8d\xe4\xb8\x8d\xe5\x86\x8d\xe8\xaf\x8d\xe5\x85\xb8\xe4\xb8\xad\xe8\xa2\xab\xe8\xae\xb0\xe5\xbd\x95, \xe5\xb0\x86\xe8\xa7\x86\xe4\xb8\xba unknown, \xe8\x8b\xa5 ``unknown=None`` , \xe5\xb0\x86\xe6\x8a\x9b\xe5\x87\xba\r\n        :param word:\r\n        :return:\r\n        \'\'\'\r\n        if word in self.word2id:\r\n            return self.word2id[word]\r\n        if self.unk_token is not None:\r\n            return self.word2id[self.unk_token]\r\n        else:\r\n            raise ValueError(""word {} not in vocabulary"".format(word))\r\n\r\n    def unknown_idx(self):\r\n        """"""\r\n        unknown \xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe6\x95\xb0\xe5\xad\x97.\r\n        """"""\r\n        if self.unk_token is None:\r\n            return None\r\n        return self.word2id[self.unk_token]\r\n\r\n    def padding_idx(self):\r\n        """"""\r\n        padding \xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe6\x95\xb0\xe5\xad\x97\r\n        """"""\r\n        if self.pad_token is None:\r\n            return None\r\n        return self.word2id[self.pad_token]\r\n\r\n    def to_word(self, idx):\r\n        """"""\r\n        \xe7\xbb\x99\xe5\xae\x9a\xe4\xb8\x80\xe4\xb8\xaa\xe6\x95\xb0\xe5\xad\x97, \xe5\xb0\x86\xe5\x85\xb6\xe8\xbd\xac\xe4\xb8\xba\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84\xe8\xaf\x8d.\r\n\r\n        :param int idx: the index\r\n        :return str word: the word\r\n        """"""\r\n        return self.id2word[idx]\r\n\r\n    def build_vocab(self):\r\n        max_size = min(self.max_size, len(self.word_counter)) if self.max_size else None\r\n        words = self.word_counter.most_common(max_size)\r\n        if self.min_freq is not None:\r\n            words = filter(lambda kv: kv[1] >= self.min_freq, words)\r\n        if self.word2id:\r\n            words = filter(lambda kv: kv[0] not in self.word2id, words)\r\n        start_idx = len(self.word2id)\r\n        self.word2id.update({w: i + start_idx for i, (w, _) in enumerate(words)})\r\n        logger.info(f""The size of vocab is: {len(self.word2id)}"")\r\n        self.build_reverse_vocab()\r\n        self.rebuild = False\r\n\r\n    def save(self, file_path):\r\n        \'\'\'\r\n        \xe4\xbf\x9d\xe5\xad\x98vocab\r\n        :param file_name:\r\n        :param pickle_path:\r\n        :return:\r\n        \'\'\'\r\n        mappings = {\r\n            ""word2id"": self.word2id,\r\n            \'id2word\': self.id2word\r\n        }\r\n        save_pickle(data=mappings, file_path=file_path)\r\n\r\n    def save_bert_vocab(self,file_path):\r\n        bert_vocab = [x for x,y in self.word2id.items()]\r\n        with open(str(file_path),\'w\') as fo:\r\n            for token in bert_vocab:\r\n                fo.write(token+""\\n"")\r\n\r\n    def load_from_file(self, file_path):\r\n        \'\'\'\r\n        \xe4\xbb\x8e\xe6\x96\x87\xe4\xbb\xb6\xe7\xbb\x84\xe7\xba\xa2\xe5\x8a\xa0\xe8\xbd\xbdvocab\r\n        :param file_name:\r\n        :param pickle_path:\r\n        :return:\r\n        \'\'\'\r\n        mappings = load_pickle(input_file=file_path)\r\n        self.id2word = mappings[\'id2word\']\r\n        self.word2id = mappings[\'word2id\']\r\n\r\n    def build_reverse_vocab(self):\r\n        self.id2word = {i: w for w, i in self.word2id.items()}\r\n\r\n    def clear(self):\r\n        """"""\r\n        \xe5\x88\xa0\xe9\x99\xa4Vocabulary\xe4\xb8\xad\xe7\x9a\x84\xe8\xaf\x8d\xe8\xa1\xa8\xe6\x95\xb0\xe6\x8d\xae\xe3\x80\x82\xe7\x9b\xb8\xe5\xbd\x93\xe4\xba\x8e\xe9\x87\x8d\xe6\x96\xb0\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe4\xb8\x80\xe4\xb8\x8b\xe3\x80\x82\r\n        :return:\r\n        """"""\r\n        self.word_counter.clear()\r\n        self.word2id = None\r\n        self.id2word = None\r\n        self.rebuild = True\r\n        self.reset()\r\n\r\n    def __len__(self):\r\n        return len(self.id2word)\r\n'"
pybert/io/xlnet_processor.py,10,"b'import csv\nimport torch\nimport numpy as np\nfrom ..common.tools import load_pickle\nfrom ..common.tools import logger\nfrom ..callback.progressbar import ProgressBar\nfrom torch.utils.data import TensorDataset\nfrom transformers import XLNetTokenizer\n\nclass InputExample(object):\n    def __init__(self, guid, text_a, text_b=None, label=None):\n        """"""Constructs a InputExample.\n        Args:\n            guid: Unique id for the example.\n            text_a: string. The untokenized text of the first sequence. For single\n            sequence tasks, only this sequence must be specified.\n            text_b: (Optional) string. The untokenized text of the second sequence.\n            Only must be specified for sequence pair tasks.\n            label: (Optional) string. The label of the example. This should be\n            specified for train and dev examples, but not for test examples.\n        """"""\n        self.guid   = guid\n        self.text_a = text_a\n        self.text_b = text_b\n        self.label  = label\n\nclass InputFeature(object):\n    \'\'\'\n    A single set of features of data.\n    \'\'\'\n    def __init__(self,input_ids,input_mask,segment_ids,label_id,input_len):\n        self.input_ids   = input_ids\n        self.input_mask  = input_mask\n        self.segment_ids = segment_ids\n        self.label_id    = label_id\n        self.input_len = input_len\n\nclass XlnetProcessor(object):\n    """"""Base class for data converters for sequence classification data sets.""""""\n\n    def __init__(self,vocab_path,do_lower_case):\n        self.tokenizer = XLNetTokenizer(vocab_path,do_lower_case)\n\n    def get_train(self, data_file):\n        """"""Gets a collection of `InputExample`s for the train set.""""""\n        return self.read_data(data_file)\n\n    def get_dev(self, data_file):\n        """"""Gets a collection of `InputExample`s for the dev set.""""""\n        return self.read_data(data_file)\n\n    def get_test(self,lines):\n        return lines\n\n    def get_labels(self):\n        """"""Gets the list of labels for this data set.""""""\n        return [""toxic"",""severe_toxic"",""obscene"",""threat"",""insult"",""identity_hate""]\n\n    @classmethod\n    def read_data(cls, input_file,quotechar = None):\n        """"""Reads a tab separated value file.""""""\n        if \'pkl\' in str(input_file):\n            lines = load_pickle(input_file)\n        else:\n            lines = input_file\n        return lines\n\n    def truncate_seq_pair(self,tokens_a,tokens_b,max_length):\n        # This is a simple heuristic which will always truncate the longer sequence\n        # one token at a time. This makes more sense than truncating an equal percent\n        # of tokens from each, since if one sequence is very short then each token\n        # that\'s truncated likely contains more information than a longer sequence.\n        while True:\n            total_length = len(tokens_a) + len(tokens_b)\n            if total_length <= max_length:\n                break\n            if len(tokens_a) > len(tokens_b):\n                tokens_a.pop()\n            else:\n                tokens_b.pop()\n\n    def create_examples(self,lines,example_type,cached_examples_file):\n        \'\'\'\n        Creates examples for data\n        \'\'\'\n        pbar = ProgressBar(n_total=len(lines),desc=\'create examples\')\n        if cached_examples_file.exists():\n            logger.info(""Loading examples from cached file %s"", cached_examples_file)\n            examples = torch.load(cached_examples_file)\n        else:\n            examples = []\n            for i,line in enumerate(lines):\n                guid = \'%s-%d\'%(example_type,i)\n                text_a = line[0]\n                label = line[1]\n                if isinstance(label,str):\n                    label = [np.float(x) for x in label.split("","")]\n                else:\n                    label = [np.float(x) for x in list(label)]\n                text_b = None\n                example = InputExample(guid = guid,text_a = text_a,text_b=text_b,label= label)\n                examples.append(example)\n                pbar(step = i)\n            logger.info(""Saving examples into cached file %s"", cached_examples_file)\n            torch.save(examples, cached_examples_file)\n        return examples\n\n    def create_features(self,examples,max_seq_len,cached_features_file):\n        \'\'\'\n        # The convention in BERT is:\n        # (a) For sequence pairs:\n        #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n        #  type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1\n        # (b) For single sequences:\n        #  tokens:   [CLS] the dog is hairy . [SEP]\n        #  type_ids:   0   0   0   0  0     0   0\n        \'\'\'\n        # Load data features from cache or dataset file\n        pbar = ProgressBar(n_total=len(examples),desc=\'create features\')\n        if cached_features_file.exists():\n            logger.info(""Loading features from cached file %s"", cached_features_file)\n            features = torch.load(cached_features_file)\n        else:\n            features = []\n            pad_token = self.tokenizer.convert_tokens_to_ids([self.tokenizer.pad_token])[0]\n            cls_token = self.tokenizer.cls_token\n            sep_token = self.tokenizer.sep_token\n            cls_token_segment_id = 2\n            pad_token_segment_id = 4\n\n            for ex_id,example in enumerate(examples):\n                tokens_a = self.tokenizer.tokenize(example.text_a)\n                tokens_b = None\n                label_id = example.label\n\n                if example.text_b:\n                    tokens_b = self.tokenizer.tokenize(example.text_b)\n                    # Modifies `tokens_a` and `tokens_b` in place so that the total\n                    # length is less than the specified length.\n                    # Account for [CLS], [SEP], [SEP] with ""- 3""\n                    self.truncate_seq_pair(tokens_a,tokens_b,max_length = max_seq_len - 3)\n                else:\n                    # Account for [CLS] and [SEP] with \'-2\'\n                    if len(tokens_a) > max_seq_len - 2:\n                        tokens_a = tokens_a[:max_seq_len - 2]\n\n                # xlnet has a cls token at the end\n                tokens = tokens_a + [sep_token]\n                segment_ids = [0] * len(tokens)\n                if tokens_b:\n                    tokens += tokens_b + [sep_token]\n                    segment_ids += [1] * (len(tokens_b) + 1)\n                tokens += [cls_token]\n                segment_ids += [cls_token_segment_id]\n\n                input_ids = self.tokenizer.convert_tokens_to_ids(tokens)\n                input_mask = [1] * len(input_ids)\n                input_len = len(input_ids)\n                padding_len = max_seq_len - len(input_ids)\n\n                # pad on the left for xlnet\n                input_ids = ([pad_token] * padding_len) + input_ids\n                input_mask = ([0 ] * padding_len) + input_mask\n                segment_ids = ([pad_token_segment_id] * padding_len) + segment_ids\n\n                assert len(input_ids) == max_seq_len\n                assert len(input_mask) == max_seq_len\n                assert len(segment_ids) == max_seq_len\n\n                if ex_id < 2:\n                    logger.info(""*** Example ***"")\n                    logger.info(f""guid: {example.guid}"" % ())\n                    logger.info(f""tokens: {\' \'.join([str(x) for x in tokens])}"")\n                    logger.info(f""input_ids: {\' \'.join([str(x) for x in input_ids])}"")\n                    logger.info(f""input_mask: {\' \'.join([str(x) for x in input_mask])}"")\n                    logger.info(f""segment_ids: {\' \'.join([str(x) for x in segment_ids])}"")\n\n                feature = InputFeature(input_ids = input_ids,\n                                       input_mask = input_mask,\n                                       segment_ids = segment_ids,\n                                       label_id = label_id,\n                                       input_len = input_len)\n                features.append(feature)\n                pbar(step=ex_id)\n            logger.info(""Saving features into cached file %s"", cached_features_file)\n            torch.save(features, cached_features_file)\n        return features\n\n    def create_dataset(self,features,is_sorted = False):\n        # Convert to Tensors and build dataset\n        if is_sorted:\n            logger.info(""sorted data by th length of input"")\n            features = sorted(features,key=lambda x:x.input_len,reverse=True)\n        all_input_ids = torch.tensor([f.input_ids for f in features], dtype=torch.long)\n        all_input_mask = torch.tensor([f.input_mask for f in features], dtype=torch.long)\n        all_segment_ids = torch.tensor([f.segment_ids for f in features], dtype=torch.long)\n        all_label_ids = torch.tensor([f.label_id for f in features],dtype=torch.long)\n        all_input_lens = torch.tensor([f.input_len for f in features], dtype=torch.long)\n        dataset = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids,all_input_lens)\n        return dataset\n\n'"
pybert/model/__init__.py,0,b'#encoding:utf-8'
pybert/model/albert_for_multi_label.py,1,"b'import torch.nn as nn\nfrom .albert.modeling_albert import AlbertPreTrainedModel, AlbertModel\n\nclass AlbertForMultiLable(AlbertPreTrainedModel):\n    def __init__(self, config):\n        super(AlbertForMultiLable, self).__init__(config)\n        self.bert = AlbertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\n        self.init_weights()\n\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None,head_mask=None):\n        outputs = self.bert(input_ids, token_type_ids=token_type_ids,attention_mask=attention_mask, head_mask=head_mask)\n        pooled_output = outputs[1]\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        return logits'"
pybert/model/bert_for_multi_label.py,1,"b'import torch.nn as nn\r\nfrom transformers.modeling_bert import BertPreTrainedModel, BertModel\r\n\r\nclass BertForMultiLable(BertPreTrainedModel):\r\n    def __init__(self, config):\r\n        super(BertForMultiLable, self).__init__(config)\r\n        self.bert = BertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, token_type_ids=None, attention_mask=None,head_mask=None):\r\n        outputs = self.bert(input_ids, token_type_ids=token_type_ids,attention_mask=attention_mask, head_mask=head_mask)\r\n        pooled_output = outputs[1]\r\n        pooled_output = self.dropout(pooled_output)\r\n        logits = self.classifier(pooled_output)\r\n        return logits\r\n\r\n    def unfreeze(self,start_layer,end_layer):\r\n        def children(m):\r\n            return m if isinstance(m, (list, tuple)) else list(m.children())\r\n        def set_trainable_attr(m, b):\r\n            m.trainable = b\r\n            for p in m.parameters():\r\n                p.requires_grad = b\r\n        def apply_leaf(m, f):\r\n            c = children(m)\r\n            if isinstance(m, nn.Module):\r\n                f(m)\r\n            if len(c) > 0:\r\n                for l in c:\r\n                    apply_leaf(l, f)\r\n        def set_trainable(l, b):\r\n            apply_leaf(l, lambda m: set_trainable_attr(m, b))\r\n\r\n        # You can unfreeze the last layer of bert by calling set_trainable(model.bert.encoder.layer[23], True)\r\n        set_trainable(self.bert, False)\r\n        for i in range(start_layer, end_layer+1):\r\n            set_trainable(self.bert.encoder.layer[i], True)'"
pybert/model/xlnet_for_multi_label.py,1,"b""import torch.nn as nn\nfrom transformers.modeling_xlnet import XLNetPreTrainedModel, XLNetModel,SequenceSummary\n\nclass XlnetForMultiLable(XLNetPreTrainedModel):\n    def __init__(self, config):\n\n        super(XlnetForMultiLable, self).__init__(config)\n        self.transformer = XLNetModel(config)\n        self.sequence_summary = SequenceSummary(config)\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\n        self.init_weights()\n\n    def forward(self, input_ids, token_type_ids=None, input_mask=None,attention_mask=None,\n                mems=None, perm_mask=None, target_mapping=None,head_mask=None):\n        # XLM don't use segment_ids\n        token_type_ids = None\n        transformer_outputs = self.transformer(input_ids, token_type_ids=token_type_ids,\n                                    input_mask=input_mask, attention_mask=attention_mask,\n                                    mems=mems, perm_mask=perm_mask, target_mapping=target_mapping,\n                                    head_mask=head_mask)\n        output = transformer_outputs[0]\n        output = self.sequence_summary(output)\n        logits = self.classifier(output)\n        return logits\n"""
pybert/output/__init__.py,0,b'#encoding:utf-8'
pybert/preprocessing/__init__.py,0,b'#encoding:utf-8'
pybert/preprocessing/augmentation.py,0,"b""#encoding:utf-8\r\nimport numpy as np\r\nimport random\r\n\r\nclass Augmentator(object):\r\n    def __init__(self,is_train_mode = True, proba = 0.5):\r\n        self.mode = is_train_mode\r\n        self.proba = proba\r\n        self.augs = []\r\n        self._reset()\r\n\r\n\r\n    def _reset(self):\r\n        self.augs.append(lambda text: self._shuffle(text))\r\n        self.augs.append(lambda text: self._dropout(text,p = 0.5))\r\n\r\n\r\n    def _shuffle(self, text):\r\n        text = np.random.permutation(text.strip().split())\r\n        return ' '.join(text)\r\n\r\n\r\n    def _dropout(self, text, p=0.5):\r\n        # random delete some text\r\n        text = text.strip().split()\r\n        len_ = len(text)\r\n        indexs = np.random.choice(len_, int(len_ * p))\r\n        for i in indexs:\r\n            text[i] = ''\r\n        return ' '.join(text)\r\n\r\n    def __call__(self,text,aug_type):\r\n        '''\r\n        \xe7\x94\xa8aug_type\xe5\x8c\xba\xe5\x88\x86\xe6\x95\xb0\xe6\x8d\xae\r\n        '''\r\n        # TTA\xe6\xa8\xa1\xe5\xbc\x8f\r\n        if 0 <= aug_type <= 2:\r\n            pass\r\n        # \xe8\xae\xad\xe7\xbb\x83\xe6\xa8\xa1\xe5\xbc\x8f\r\n        if self.mode and  random.random() < self.proba:\r\n            aug = random.choice(self.augs)\r\n            text = aug(text)\r\n        return text\r\n"""
pybert/preprocessing/preprocessor.py,0,"b'#encoding:utf-8\r\nimport re\r\n\r\nreplacement = {\r\n    ""aren\'t"" : ""are not"",\r\n    ""can\'t"" : ""cannot"",\r\n    ""couldn\'t"" : ""could not"",\r\n    ""didn\'t"" : ""did not"",\r\n    ""doesn\'t"" : ""does not"",\r\n    ""don\'t"" : ""do not"",\r\n    ""hadn\'t"" : ""had not"",\r\n    ""hasn\'t"" : ""has not"",\r\n    ""haven\'t"" : ""have not"",\r\n    ""he\'d"" : ""he would"",\r\n    ""he\'ll"" : ""he will"",\r\n    ""he\'s"" : ""he is"",\r\n    ""i\'d"" : ""I would"",\r\n    ""i\'ll"" : ""I will"",\r\n    ""i\'m"" : ""I am"",\r\n    ""isn\'t"" : ""is not"",\r\n    ""it\'s"" : ""it is"",\r\n    ""it\'ll"":""it will"",\r\n    ""i\'ve"" : ""I have"",\r\n    ""let\'s"" : ""let us"",\r\n    ""mightn\'t"" : ""might not"",\r\n    ""mustn\'t"" : ""must not"",\r\n    ""shan\'t"" : ""shall not"",\r\n    ""she\'d"" : ""she would"",\r\n    ""she\'ll"" : ""she will"",\r\n    ""she\'s"" : ""she is"",\r\n    ""shouldn\'t"" : ""should not"",\r\n    ""that\'s"" : ""that is"",\r\n    ""there\'s"" : ""there is"",\r\n    ""they\'d"" : ""they would"",\r\n    ""they\'ll"" : ""they will"",\r\n    ""they\'re"" : ""they are"",\r\n    ""they\'ve"" : ""they have"",\r\n    ""we\'d"" : ""we would"",\r\n    ""we\'re"" : ""we are"",\r\n    ""weren\'t"" : ""were not"",\r\n    ""we\'ve"" : ""we have"",\r\n    ""what\'ll"" : ""what will"",\r\n    ""what\'re"" : ""what are"",\r\n    ""what\'s"" : ""what is"",\r\n    ""what\'ve"" : ""what have"",\r\n    ""where\'s"" : ""where is"",\r\n    ""who\'d"" : ""who would"",\r\n    ""who\'ll"" : ""who will"",\r\n    ""who\'re"" : ""who are"",\r\n    ""who\'s"" : ""who is"",\r\n    ""who\'ve"" : ""who have"",\r\n    ""won\'t"" : ""will not"",\r\n    ""wouldn\'t"" : ""would not"",\r\n    ""you\'d"" : ""you would"",\r\n    ""you\'ll"" : ""you will"",\r\n    ""you\'re"" : ""you are"",\r\n    ""you\'ve"" : ""you have"",\r\n    ""\'re"": "" are"",\r\n    ""wasn\'t"": ""was not"",\r\n    ""we\'ll"":"" will"",\r\n    ""tryin\'"":""trying"",\r\n}\r\n\r\nclass EnglishPreProcessor(object):\r\n    def __init__(self,min_len = 2,stopwords_path = None):\r\n        self.min_len = min_len\r\n        self.stopwords_path = stopwords_path\r\n        self.reset()\r\n\r\n    def lower(self,sentence):\r\n        \'\'\'\r\n        \xe5\xa4\xa7\xe5\x86\x99\xe8\xbd\xac\xe5\x8c\x96\xe4\xb8\xba\xe5\xb0\x8f\xe5\x86\x99\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        return sentence.lower()\r\n\r\n    def reset(self):\r\n        \'\'\'\r\n        \xe5\x8a\xa0\xe8\xbd\xbd\xe5\x81\x9c\xe7\x94\xa8\xe8\xaf\x8d\r\n        :return:\r\n        \'\'\'\r\n        if self.stopwords_path:\r\n            with open(self.stopwords_path,\'r\') as fr:\r\n                self.stopwords = {}\r\n                for line in fr:\r\n                    word = line.strip(\' \').strip(\'\\n\')\r\n                    self.stopwords[word] = 1\r\n\r\n\r\n    def clean_length(self,sentence):\r\n        \'\'\'\r\n        \xe5\x8e\xbb\xe9\x99\xa4\xe9\x95\xbf\xe5\xba\xa6\xe5\xb0\x8f\xe4\xba\x8emin_len\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        if len([x for x in sentence]) >= self.min_len:\r\n            return sentence\r\n\r\n    def replace(self,sentence):\r\n        \'\'\'\r\n        \xe4\xb8\x80\xe4\xba\x9b\xe7\x89\xb9\xe6\xae\x8a\xe7\xbc\xa9\xe5\x86\x99\xe6\x9b\xbf\xe6\x8d\xa2\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        # Replace words like gooood to good\r\n        sentence = re.sub(r\'(\\w)\\1{2,}\', r\'\\1\\1\', sentence)\r\n        # Normalize common abbreviations\r\n        words = sentence.split(\' \')\r\n        words = [replacement[word] if word in replacement else word for word in words]\r\n        sentence_repl = "" "".join(words)\r\n        return sentence_repl\r\n\r\n    def remove_website(self,sentence):\r\n        \'\'\'\r\n        \xe5\xa4\x84\xe7\x90\x86\xe7\xbd\x91\xe5\x9d\x80\xe7\xac\xa6\xe5\x8f\xb7\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        sentence_repl = sentence.replace(r""http\\S+"", """")\r\n        sentence_repl = sentence_repl.replace(r""https\\S+"", """")\r\n        sentence_repl = sentence_repl.replace(r""http"", """")\r\n        sentence_repl = sentence_repl.replace(r""https"", """")\r\n        return sentence_repl\r\n\r\n    def remove_name_tag(self,sentence):\r\n        # Remove name tag\r\n        sentence_repl = sentence.replace(r""@\\S+"", """")\r\n        return sentence_repl\r\n\r\n    def remove_time(self,sentence):\r\n        \'\'\'\r\n        \xe7\x89\xb9\xe6\xae\x8a\xe6\x95\xb0\xe6\x8d\xae\xe5\xa4\x84\xe7\x90\x86\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        # Remove time related text\r\n        sentence_repl = sentence.replace(r\'\\w{3}[+-][0-9]{1,2}\\:[0-9]{2}\\b\', """")  # e.g. UTC+09:00\r\n        sentence_repl = sentence_repl.replace(r\'\\d{1,2}\\:\\d{2}\\:\\d{2}\', """")  # e.g. 18:09:01\r\n        sentence_repl = sentence_repl.replace(r\'\\d{1,2}\\:\\d{2}\', """")  # e.g. 18:09\r\n        # Remove date related text\r\n        # e.g. 11/12/19, 11-1-19, 1.12.19, 11/12/2019\r\n        sentence_repl = sentence_repl.replace(r\'\\d{1,2}(?:\\/|\\-|\\.)\\d{1,2}(?:\\/|\\-|\\.)\\d{2,4}\', """")\r\n        # e.g. 11 dec, 2019   11 dec 2019   dec 11, 2019\r\n        sentence_repl = sentence_repl.replace(\r\n            r""([\\d]{1,2}\\s(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)|(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s[\\d]{1,2})(\\s|\\,|\\,\\s|\\s\\,)[\\d]{2,4}"",\r\n            """")\r\n        # e.g. 11 december, 2019   11 december 2019   december 11, 2019\r\n        sentence_repl = sentence_repl.replace(\r\n            r""[\\d]{1,2}\\s(january|february|march|april|may|june|july|august|september|october|november|december)(\\s|\\,|\\,\\s|\\s\\,)[\\d]{2,4}"",\r\n            """")\r\n        return sentence_repl\r\n\r\n    def remove_breaks(self,sentence):\r\n        # Remove line breaks\r\n        sentence_repl = sentence.replace(""\\r"", """")\r\n        sentence_repl = sentence_repl.replace(""\\n"", """")\r\n        sentence_repl = re.sub(r""\\\\n\\n"", ""."", sentence_repl)\r\n        return sentence_repl\r\n\r\n    def remove_ip(self,sentence):\r\n        # Remove phone number and IP address\r\n        sentence_repl = sentence.replace(r\'\\d{8,}\', """")\r\n        sentence_repl = sentence_repl.replace(r\'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\', """")\r\n        return sentence_repl\r\n\r\n    def adjust_common(self,sentence):\r\n        # Adjust common abbreviation\r\n        sentence_repl = sentence.replace(r"" you re "", "" you are "")\r\n        sentence_repl = sentence_repl.replace(r"" we re "", "" we are "")\r\n        sentence_repl = sentence_repl.replace(r"" they re "", "" they are "")\r\n        sentence_repl = sentence_repl.replace(r""@"", ""at"")\r\n        return sentence_repl\r\n\r\n    def remove_chinese(self,sentence):\r\n        # Chinese bad word\r\n        sentence_repl = re.sub(r""fucksex"", ""fuck sex"", sentence)\r\n        sentence_repl = re.sub(r""f u c k"", ""fuck"", sentence_repl)\r\n        sentence_repl = re.sub(r""\xe5\xb9\xb9"", ""fuck"", sentence_repl)\r\n        sentence_repl = re.sub(r""\xe6\xad\xbb"", ""die"", sentence_repl)\r\n        sentence_repl = re.sub(r""\xe4\xbb\x96\xe5\xa6\x88\xe7\x9a\x84"", ""fuck"", sentence_repl)\r\n        sentence_repl = re.sub(r""\xe5\x8e\xbb\xe4\xbd\xa0\xe5\xa6\x88\xe7\x9a\x84"", ""fuck off"", sentence_repl)\r\n        sentence_repl = re.sub(r""\xe8\x82\x8f\xe4\xbd\xa0\xe5\xa6\x88"", ""fuck your mother"", sentence_repl)\r\n        sentence_repl = re.sub(r""\xe8\x82\x8f\xe4\xbd\xa0\xe7\xa5\x96\xe5\xae\x97\xe5\x8d\x81\xe5\x85\xab\xe4\xbb\xa3"", ""your ancestors to the 18th generation"", sentence_repl)\r\n        return sentence_repl\r\n\r\n    def full2half(self,sentence):\r\n        \'\'\'\r\n        \xe5\x85\xa8\xe8\xa7\x92\xe8\xbd\xac\xe5\x8c\x96\xe4\xb8\xba\xe5\x8d\x8a\xe8\xa7\x92\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        ret_str = \'\'\r\n        for i in sentence:\r\n            if ord(i) >= 33 + 65248 and ord(i) <= 126 + 65248:\r\n                ret_str += chr(ord(i) - 65248)\r\n            else:\r\n                ret_str += i\r\n        return ret_str\r\n\r\n    def remove_stopword(self,sentence):\r\n        \'\'\'\r\n        \xe5\x8e\xbb\xe9\x99\xa4\xe5\x81\x9c\xe7\x94\xa8\xe8\xaf\x8d\r\n        :param sentence:\r\n        :return:\r\n        \'\'\'\r\n        words = sentence.split()\r\n        x = [word for word in words if word not in self.stopwords]\r\n        return "" "".join(x)\r\n\r\n    # \xe4\xb8\xbb\xe5\x87\xbd\xe6\x95\xb0\r\n    def __call__(self, sentence):\r\n        x = sentence\r\n        # x = self.lower(x)\r\n        x = self.replace(x)\r\n        x = self.remove_website(x)\r\n        x = self.remove_name_tag(x)\r\n        x = self.remove_time(x)\r\n        x = self.remove_breaks(x)\r\n        x = self.remove_ip(x)\r\n        x = self.adjust_common(x)\r\n        x = self.remove_chinese(x)\r\n        return x\r\n'"
pybert/pretrain/__init__.py,0,b'#encoding:utf-8'
pybert/test/__init__.py,0,b'#encoding:utf-8'
pybert/test/predictor.py,2,"b""#encoding:utf-8\nimport torch\nimport numpy as np\nfrom ..common.tools import model_device\nfrom ..callback.progressbar import ProgressBar\n\nclass Predictor(object):\n    def __init__(self,model,logger,n_gpu):\n        self.model = model\n        self.logger = logger\n        self.model, self.device = model_device(n_gpu= n_gpu, model=self.model)\n\n    def predict(self,data):\n        pbar = ProgressBar(n_total=len(data),desc='Testing')\n        all_logits = None\n        for step, batch in enumerate(data):\n            self.model.eval()\n            batch = tuple(t.to(self.device) for t in batch)\n            with torch.no_grad():\n                input_ids, input_mask, segment_ids, label_ids = batch\n                logits = self.model(input_ids, segment_ids, input_mask)\n                logits = logits.sigmoid()\n            if all_logits is None:\n                all_logits = logits.detach().cpu().numpy()\n            else:\n                all_logits = np.concatenate([all_logits,logits.detach().cpu().numpy()],axis = 0)\n            pbar(step=step)\n        if 'cuda' in str(self.device):\n            torch.cuda.empty_cache()\n        return all_logits\n\n\n\n\n\n\n"""
pybert/train/__init__.py,0,b'#encoding:utf-8'
pybert/train/losses.py,2,"b""from torch.nn import CrossEntropyLoss\r\nfrom torch.nn import BCEWithLogitsLoss\r\n\r\n\r\n__call__ = ['CrossEntropy','BCEWithLogLoss']\r\n\r\nclass CrossEntropy(object):\r\n    def __init__(self):\r\n        self.loss_f = CrossEntropyLoss()\r\n\r\n    def __call__(self, output, target):\r\n        loss = self.loss_f(input=output, target=target)\r\n        return loss\r\n\r\nclass BCEWithLogLoss(object):\r\n    def __init__(self):\r\n        self.loss_fn = BCEWithLogitsLoss()\r\n\r\n    def __call__(self,output,target):\r\n        output = output.float()\r\n        target = target.float()\r\n        loss = self.loss_fn(input = output,target = target)\r\n        return loss\r\n\r\n\r\n"""
pybert/train/metrics.py,1,"b'r""""""Functional interface""""""\r\nimport torch\r\nfrom tqdm import tqdm\r\nimport numpy as np\r\nfrom sklearn.metrics import roc_auc_score\r\nfrom sklearn.metrics import f1_score, classification_report\r\n\r\n__call__ = [\'Accuracy\',\'AUC\',\'F1Score\',\'EntityScore\',\'ClassReport\',\'MultiLabelReport\',\'AccuracyThresh\']\r\n\r\nclass Metric:\r\n    def __init__(self):\r\n        pass\r\n\r\n    def __call__(self, outputs, target):\r\n        raise NotImplementedError\r\n\r\n    def reset(self):\r\n        raise NotImplementedError\r\n\r\n    def value(self):\r\n        raise NotImplementedError\r\n\r\n    def name(self):\r\n        raise NotImplementedError\r\n\r\nclass Accuracy(Metric):\r\n    \'\'\'\r\n    \xe8\xae\xa1\xe7\xae\x97\xe5\x87\x86\xe7\xa1\xae\xe5\xba\xa6\r\n    \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8topK\xe5\x8f\x82\xe6\x95\xb0\xe8\xae\xbe\xe5\xae\x9a\xe8\xae\xa1\xe7\xae\x97K\xe5\x87\x86\xe7\xa1\xae\xe5\xba\xa6\r\n    Examples:\r\n        >>> metric = Accuracy(**)\r\n        >>> for epoch in range(epochs):\r\n        >>>     metric.reset()\r\n        >>>     for batch in batchs:\r\n        >>>         logits = model()\r\n        >>>         metric(logits,target)\r\n        >>>         print(metric.name(),metric.value())\r\n    \'\'\'\r\n    def __init__(self,topK):\r\n        super(Accuracy,self).__init__()\r\n        self.topK = topK\r\n        self.reset()\r\n\r\n    def __call__(self, logits, target):\r\n        _, pred = logits.topk(self.topK, 1, True, True)\r\n        pred = pred.t()\r\n        correct = pred.eq(target.view(1, -1).expand_as(pred))\r\n        self.correct_k = correct[:self.topK].view(-1).float().sum(0)\r\n        self.total = target.size(0)\r\n\r\n    def reset(self):\r\n        self.correct_k = 0\r\n        self.total = 0\r\n\r\n    def value(self):\r\n        return float(self.correct_k)  / self.total\r\n\r\n    def name(self):\r\n        return \'accuracy\'\r\n\r\n\r\nclass AccuracyThresh(Metric):\r\n    \'\'\'\r\n    \xe8\xae\xa1\xe7\xae\x97\xe5\x87\x86\xe7\xa1\xae\xe5\xba\xa6\r\n    \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8topK\xe5\x8f\x82\xe6\x95\xb0\xe8\xae\xbe\xe5\xae\x9a\xe8\xae\xa1\xe7\xae\x97K\xe5\x87\x86\xe7\xa1\xae\xe5\xba\xa6\r\n    Example:\r\n        >>> metric = AccuracyThresh(**)\r\n        >>> for epoch in range(epochs):\r\n        >>>     metric.reset()\r\n        >>>     for batch in batchs:\r\n        >>>         logits = model()\r\n        >>>         metric(logits,target)\r\n        >>>         print(metric.name(),metric.value())\r\n    \'\'\'\r\n    def __init__(self,thresh = 0.5):\r\n        super(AccuracyThresh,self).__init__()\r\n        self.thresh = thresh\r\n        self.reset()\r\n\r\n    def __call__(self, logits, target):\r\n        self.y_pred = logits.sigmoid()\r\n        self.y_true = target\r\n\r\n    def reset(self):\r\n        self.correct_k = 0\r\n        self.total = 0\r\n\r\n    def value(self):\r\n        data_size = self.y_pred.size(0)\r\n        acc = np.mean(((self.y_pred>self.thresh)==self.y_true.byte()).float().cpu().numpy(), axis=1).sum()\r\n        return acc / data_size\r\n\r\n    def name(self):\r\n        return \'accuracy\'\r\n\r\n\r\nclass AUC(Metric):\r\n    \'\'\'\r\n    AUC score\r\n    micro:\r\n            Calculate metrics globally by considering each element of the label\r\n            indicator matrix as a label.\r\n    macro:\r\n            Calculate metrics for each label, and find their unweighted\r\n            mean.  This does not take label imbalance into account.\r\n    weighted:\r\n            Calculate metrics for each label, and find their average, weighted\r\n            by support (the number of true instances for each label).\r\n    samples:\r\n            Calculate metrics for each instance, and find their average.\r\n    Example:\r\n        >>> metric = AUC(**)\r\n        >>> for epoch in range(epochs):\r\n        >>>     metric.reset()\r\n        >>>     for batch in batchs:\r\n        >>>         logits = model()\r\n        >>>         metric(logits,target)\r\n        >>>         print(metric.name(),metric.value())\r\n    \'\'\'\r\n\r\n    def __init__(self,task_type = \'binary\',average = \'binary\'):\r\n        super(AUC, self).__init__()\r\n\r\n        assert task_type in [\'binary\',\'multiclass\']\r\n        assert average in [\'binary\',\'micro\', \'macro\', \'samples\', \'weighted\']\r\n\r\n        self.task_type = task_type\r\n        self.average = average\r\n\r\n    def __call__(self,logits,target):\r\n        \'\'\'\r\n        \xe8\xae\xa1\xe7\xae\x97\xe6\x95\xb4\xe4\xb8\xaa\xe7\xbb\x93\xe6\x9e\x9c\r\n        \'\'\'\r\n        if self.task_type == \'binary\':\r\n            self.y_prob = logits.sigmoid().data.cpu().numpy()\r\n        else:\r\n            self.y_prob = logits.softmax(-1).data.cpu().detach().numpy()\r\n        self.y_true = target.cpu().numpy()\r\n\r\n    def reset(self):\r\n        self.y_prob = 0\r\n        self.y_true = 0\r\n\r\n    def value(self):\r\n        \'\'\'\r\n        \xe8\xae\xa1\xe7\xae\x97\xe6\x8c\x87\xe6\xa0\x87\xe5\xbe\x97\xe5\x88\x86\r\n        \'\'\'\r\n        auc = roc_auc_score(y_score=self.y_prob, y_true=self.y_true, average=self.average)\r\n        return auc\r\n\r\n    def name(self):\r\n        return \'auc\'\r\n\r\nclass F1Score(Metric):\r\n    \'\'\'\r\n    F1 Score\r\n    binary:\r\n            Only report results for the class specified by ``pos_label``.\r\n            This is applicable only if targets (``y_{true,pred}``) are binary.\r\n    micro:\r\n            Calculate metrics globally by considering each element of the label\r\n            indicator matrix as a label.\r\n    macro:\r\n            Calculate metrics for each label, and find their unweighted\r\n            mean.  This does not take label imbalance into account.\r\n    weighted:\r\n            Calculate metrics for each label, and find their average, weighted\r\n            by support (the number of true instances for each label).\r\n    samples:\r\n            Calculate metrics for each instance, and find their average.\r\n    Example:\r\n        >>> metric = F1Score(**)\r\n        >>> for epoch in range(epochs):\r\n        >>>     metric.reset()\r\n        >>>     for batch in batchs:\r\n        >>>         logits = model()\r\n        >>>         metric(logits,target)\r\n        >>>         print(metric.name(),metric.value())\r\n    \'\'\'\r\n    def __init__(self,thresh = 0.5, normalizate = True,task_type = \'binary\',average = \'binary\',search_thresh = False):\r\n        super(F1Score).__init__()\r\n        assert task_type in [\'binary\',\'multiclass\']\r\n        assert average in [\'binary\',\'micro\', \'macro\', \'samples\', \'weighted\']\r\n\r\n        self.thresh = thresh\r\n        self.task_type = task_type\r\n        self.normalizate  = normalizate\r\n        self.search_thresh = search_thresh\r\n        self.average = average\r\n\r\n    def thresh_search(self,y_prob):\r\n        \'\'\'\r\n        \xe5\xaf\xb9\xe4\xba\x8ef1\xe8\xaf\x84\xe5\x88\x86\xe7\x9a\x84\xe6\x8c\x87\xe6\xa0\x87\xef\xbc\x8c\xe4\xb8\x80\xe8\x88\xac\xe6\x88\x91\xe4\xbb\xac\xe9\x9c\x80\xe8\xa6\x81\xe5\xaf\xb9\xe9\x98\x88\xe5\x80\xbc\xe8\xbf\x9b\xe8\xa1\x8c\xe8\xb0\x83\xe6\x95\xb4\xef\xbc\x8c\xe4\xb8\x80\xe8\x88\xac\xe4\xb8\x8d\xe4\xbc\x9a\xe4\xbd\xbf\xe7\x94\xa8\xe9\xbb\x98\xe8\xae\xa4\xe7\x9a\x840.5\xe5\x80\xbc\xef\xbc\x8c\xe5\x9b\xa0\xe6\xad\xa4\r\n        \xe8\xbf\x99\xe9\x87\x8c\xe6\x88\x91\xe4\xbb\xac\xe9\x98\x9fThresh\xe8\xbf\x9b\xe8\xa1\x8c\xe4\xbc\x98\xe5\x8c\x96\r\n        :return:\r\n        \'\'\'\r\n        best_threshold = 0\r\n        best_score = 0\r\n        for threshold in tqdm([i * 0.01 for i in range(100)], disable=True):\r\n            self.y_pred = y_prob > threshold\r\n            score = self.value()\r\n            if score > best_score:\r\n                best_threshold = threshold\r\n                best_score = score\r\n        return best_threshold,best_score\r\n\r\n    def __call__(self,logits,target):\r\n        \'\'\'\r\n        \xe8\xae\xa1\xe7\xae\x97\xe6\x95\xb4\xe4\xb8\xaa\xe7\xbb\x93\xe6\x9e\x9c\r\n        :return:\r\n        \'\'\'\r\n        self.y_true = target.cpu().numpy()\r\n        if self.normalizate and self.task_type == \'binary\':\r\n            y_prob = logits.sigmoid().data.cpu().numpy()\r\n        elif self.normalizate and self.task_type == \'multiclass\':\r\n            y_prob = logits.softmax(-1).data.cpu().detach().numpy()\r\n        else:\r\n            y_prob = logits.cpu().detach().numpy()\r\n\r\n        if self.task_type == \'binary\':\r\n            if self.thresh and self.search_thresh == False:\r\n                self.y_pred = (y_prob > self.thresh ).astype(int)\r\n                self.value()\r\n            else:\r\n                thresh,f1 = self.thresh_search(y_prob = y_prob)\r\n                print(f""Best thresh: {thresh:.4f} - F1 Score: {f1:.4f}"")\r\n\r\n        if self.task_type == \'multiclass\':\r\n            self.y_pred = np.argmax(y_prob, 1)\r\n\r\n    def reset(self):\r\n        self.y_pred = 0\r\n        self.y_true = 0\r\n\r\n    def value(self):\r\n        \'\'\'\r\n         \xe8\xae\xa1\xe7\xae\x97\xe6\x8c\x87\xe6\xa0\x87\xe5\xbe\x97\xe5\x88\x86\r\n         \'\'\'\r\n        f1 = f1_score(y_true=self.y_true, y_pred=self.y_pred, average=self.average)\r\n        return f1\r\n\r\n    def name(self):\r\n        return \'f1\'\r\n\r\nclass ClassReport(Metric):\r\n    \'\'\'\r\n    class report\r\n    \'\'\'\r\n    def __init__(self,target_names = None):\r\n        super(ClassReport).__init__()\r\n        self.target_names = target_names\r\n\r\n    def reset(self):\r\n        self.y_pred = 0\r\n        self.y_true = 0\r\n\r\n    def value(self):\r\n        \'\'\'\r\n        \xe8\xae\xa1\xe7\xae\x97\xe6\x8c\x87\xe6\xa0\x87\xe5\xbe\x97\xe5\x88\x86\r\n        \'\'\'\r\n        score = classification_report(y_true = self.y_true,\r\n                                      y_pred = self.y_pred,\r\n                                      target_names=self.target_names)\r\n        print(f""\\n\\n classification report: {score}"")\r\n\r\n    def __call__(self,logits,target):\r\n        _, y_pred = torch.max(logits.data, 1)\r\n        self.y_pred = y_pred.cpu().numpy()\r\n        self.y_true = target.cpu().numpy()\r\n\r\n    def name(self):\r\n        return ""class_report""\r\n\r\nclass MultiLabelReport(Metric):\r\n    \'\'\'\r\n    multi label report\r\n    \'\'\'\r\n    def __init__(self,id2label = None):\r\n        super(MultiLabelReport).__init__()\r\n        self.id2label = id2label\r\n\r\n    def reset(self):\r\n        self.y_prob = 0\r\n        self.y_true = 0\r\n\r\n    def __call__(self,logits,target):\r\n\r\n        self.y_prob = logits.sigmoid().data.cpu().detach().numpy()\r\n        self.y_true = target.cpu().numpy()\r\n\r\n    def value(self):\r\n        \'\'\'\r\n        \xe8\xae\xa1\xe7\xae\x97\xe6\x8c\x87\xe6\xa0\x87\xe5\xbe\x97\xe5\x88\x86\r\n        \'\'\'\r\n        for i, label in self.id2label.items():\r\n            auc = roc_auc_score(y_score=self.y_prob[:, i], y_true=self.y_true[:, i])\r\n            print(f""label:{label} - auc: {auc:.4f}"")\r\n\r\n    def name(self):\r\n        return ""multilabel_report""\r\n'"
pybert/train/trainer.py,9,"b'import torch\r\nfrom ..callback.progressbar import ProgressBar\r\nfrom ..common.tools import model_device\r\nfrom ..common.tools import summary\r\nfrom ..common.tools import seed_everything\r\nfrom ..common.tools import AverageMeter\r\nfrom torch.nn.utils import clip_grad_norm_\r\n\r\nclass Trainer(object):\r\n    def __init__(self,args,model,logger,criterion,optimizer,scheduler,early_stopping,epoch_metrics,\r\n                 batch_metrics,verbose = 1,training_monitor = None,model_checkpoint = None\r\n                 ):\r\n        self.args = args\r\n        self.model = model\r\n        self.logger =logger\r\n        self.verbose = verbose\r\n        self.criterion = criterion\r\n        self.optimizer = optimizer\r\n        self.scheduler = scheduler\r\n        self.early_stopping = early_stopping\r\n        self.epoch_metrics = epoch_metrics\r\n        self.batch_metrics = batch_metrics\r\n        self.model_checkpoint = model_checkpoint\r\n        self.training_monitor = training_monitor\r\n        self.start_epoch = 1\r\n        self.global_step = 0\r\n        self.model, self.device = model_device(n_gpu = args.n_gpu, model=self.model)\r\n        if args.fp16:\r\n            try:\r\n                from apex import amp\r\n            except ImportError:\r\n                raise ImportError(""Please install apex from https://www.github.com/nvidia/apex to use fp16 training."")\r\n        if args.resume_path:\r\n            self.logger.info(f""\\nLoading checkpoint: {args.resume_path}"")\r\n            resume_dict = torch.load(args.resume_path / \'checkpoint_info.bin\')\r\n            best = resume_dict[\'best\']\r\n            self.start_epoch = resume_dict[\'epoch\']\r\n            if self.model_checkpoint:\r\n                self.model_checkpoint.best = best\r\n            self.logger.info(f""\\nCheckpoint \'{args.resume_path}\' and epoch {self.start_epoch} loaded"")\r\n\r\n    def epoch_reset(self):\r\n        self.outputs = []\r\n        self.targets = []\r\n        self.result = {}\r\n        for metric in self.epoch_metrics:\r\n            metric.reset()\r\n\r\n    def batch_reset(self):\r\n        self.info = {}\r\n        for metric in self.batch_metrics:\r\n            metric.reset()\r\n\r\n    def save_info(self,epoch,best):\r\n        model_save = self.model.module if hasattr(self.model, \'module\') else self.model\r\n        state = {""model"":model_save,\r\n                 \'epoch\':epoch,\r\n                 \'best\':best}\r\n        return state\r\n\r\n    def valid_epoch(self,data):\r\n        pbar = ProgressBar(n_total=len(data),desc=""Evaluating"")\r\n        self.epoch_reset()\r\n        for step, batch in enumerate(data):\r\n            self.model.eval()\r\n            batch = tuple(t.to(self.device) for t in batch)\r\n            with torch.no_grad():\r\n                input_ids, input_mask, segment_ids, label_ids = batch\r\n                logits = self.model(input_ids, segment_ids,input_mask)\r\n            self.outputs.append(logits.cpu().detach())\r\n            self.targets.append(label_ids.cpu().detach())\r\n            pbar(step=step)\r\n        self.outputs = torch.cat(self.outputs, dim = 0).cpu().detach()\r\n        self.targets = torch.cat(self.targets, dim = 0).cpu().detach()\r\n        loss = self.criterion(target = self.targets, output=self.outputs)\r\n        self.result[\'valid_loss\'] = loss.item()\r\n        print(""------------- valid result --------------"")\r\n        if self.epoch_metrics:\r\n            for metric in self.epoch_metrics:\r\n                metric(logits=self.outputs, target=self.targets)\r\n                value = metric.value()\r\n                if value:\r\n                    self.result[f\'valid_{metric.name()}\'] = value\r\n        if \'cuda\' in str(self.device):\r\n            torch.cuda.empty_cache()\r\n        return self.result\r\n\r\n    def train_epoch(self,data):\r\n        pbar = ProgressBar(n_total = len(data),desc=\'Training\')\r\n        tr_loss = AverageMeter()\r\n        self.epoch_reset()\r\n        for step,  batch in enumerate(data):\r\n            self.batch_reset()\r\n            self.model.train()\r\n            batch = tuple(t.to(self.device) for t in batch)\r\n            input_ids, input_mask, segment_ids, label_ids = batch\r\n            logits = self.model(input_ids, segment_ids,input_mask)\r\n            loss = self.criterion(output=logits,target=label_ids)\r\n            if len(self.args.n_gpu) >= 2:\r\n                loss = loss.mean()\r\n            if self.args.gradient_accumulation_steps > 1:\r\n                loss = loss / self.args.gradient_accumulation_steps\r\n            if self.args.fp16:\r\n                with amp.scale_loss(loss, self.optimizer) as scaled_loss:\r\n                    scaled_loss.backward()\r\n                clip_grad_norm_(amp.master_params(self.optimizer), self.args.grad_clip)\r\n            else:\r\n                loss.backward()\r\n                clip_grad_norm_(self.model.parameters(), self.args.grad_clip)\r\n            if (step + 1) % self.args.gradient_accumulation_steps == 0:\r\n                self.scheduler.step()\r\n                self.optimizer.step()\r\n                self.optimizer.zero_grad()\r\n                self.global_step += 1\r\n            if self.batch_metrics:\r\n                for metric in self.batch_metrics:\r\n                    metric(logits = logits,target = label_ids)\r\n                    self.info[metric.name()] = metric.value()\r\n            self.info[\'loss\'] = loss.item()\r\n            tr_loss.update(loss.item(),n = 1)\r\n            if self.verbose >= 1:\r\n                pbar(step= step,info = self.info)\r\n            self.outputs.append(logits.cpu().detach())\r\n            self.targets.append(label_ids.cpu().detach())\r\n        print(""\\n------------- train result --------------"")\r\n        # epoch metric\r\n        self.outputs = torch.cat(self.outputs, dim =0).cpu().detach()\r\n        self.targets = torch.cat(self.targets, dim =0).cpu().detach()\r\n        self.result[\'loss\'] = tr_loss.avg\r\n        if self.epoch_metrics:\r\n            for metric in self.epoch_metrics:\r\n                metric(logits=self.outputs, target=self.targets)\r\n                value = metric.value()\r\n                if value:\r\n                    self.result[f\'{metric.name()}\'] = value\r\n        if ""cuda"" in str(self.device):\r\n            torch.cuda.empty_cache()\r\n        return self.result\r\n\r\n    def train(self,train_data,valid_data):\r\n#         print(""model summary info: "")\r\n#         for step, (input_ids, input_mask, segment_ids, label_ids) in enumerate(train_data):\r\n#             input_ids = input_ids.to(self.device)\r\n#             input_mask = input_mask.to(self.device)\r\n#             segment_ids = segment_ids.to(self.device)\r\n#             summary(self.model,*(input_ids, segment_ids,input_mask),show_input=True)\r\n#             break\r\n        # ***************************************************************\r\n        self.model.zero_grad()\r\n        seed_everything(self.args.seed)  # Added here for reproductibility (even between python 2 a\r\n        for epoch in range(self.start_epoch,self.start_epoch+self.args.epochs):\r\n            self.logger.info(f""Epoch {epoch}/{self.args.epochs}"")\r\n            train_log = self.train_epoch(train_data)\r\n            valid_log = self.valid_epoch(valid_data)\r\n\r\n            logs = dict(train_log,**valid_log)\r\n            show_info = f\'\\nEpoch: {epoch} - \' + ""-"".join([f\' {key}: {value:.4f} \' for key,value in logs.items()])\r\n            self.logger.info(show_info)\r\n\r\n            # save\r\n            if self.training_monitor:\r\n                self.training_monitor.epoch_step(logs) \r\n\r\n            # save model\r\n            if self.model_checkpoint:\r\n                state = self.save_info(epoch,best=logs[self.model_checkpoint.monitor])\r\n                self.model_checkpoint.bert_epoch_step(current=logs[self.model_checkpoint.monitor],state = state)\r\n\r\n            # early_stopping\r\n            if self.early_stopping:\r\n                self.early_stopping.epoch_step(epoch=epoch, current=logs[self.early_stopping.monitor])\r\n                if self.early_stopping.stop_training:\r\n                    break\r\n\r\n\r\n\r\n\r\n\r\n\r\n'"
pybert/callback/optimizater/__init__.py,0,b''
pybert/callback/optimizater/adabound.py,6,"b'import torch\r\nimport math\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\nclass AdaBound(Optimizer):\r\n    """"""Implements AdaBound algorithm.\r\n    It has been proposed in `Adaptive Gradient Methods with Dynamic Bound of Learning Rate`_.\r\n    Arguments:\r\n        params (iterable): iterable of parameters to optimize or dicts defining\r\n            parameter groups\r\n        lr (float, optional): Adam learning rate (default: 1e-3)\r\n        betas (Tuple[float, float], optional): coefficients used for computing\r\n            running averages of gradient and its square (default: (0.9, 0.999))\r\n        final_lr (float, optional): final (SGD) learning rate (default: 0.1)\r\n        gamma (float, optional): convergence speed of the bound functions (default: 1e-3)\r\n        eps (float, optional): term added to the denominator to improve\r\n            numerical stability (default: 1e-8)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n        amsbound (boolean, optional): whether to use the AMSBound variant of this algorithm\r\n    .. Adaptive Gradient Methods with Dynamic Bound of Learning Rate:\r\n        https://openreview.net/forum?id=Bkg3g2R9FX\r\n    Example:\r\n        >>> model = LSTM()\r\n        >>> optimizer = AdaBound(model.parameters())\r\n    """"""\r\n\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), final_lr=0.1, gamma=1e-3,\r\n                 eps=1e-8, weight_decay=0, amsbound=False):\r\n        if not 0.0 <= lr:\r\n            raise ValueError(""Invalid learning rate: {}"".format(lr))\r\n        if not 0.0 <= eps:\r\n            raise ValueError(""Invalid epsilon value: {}"".format(eps))\r\n        if not 0.0 <= betas[0] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 0: {}"".format(betas[0]))\r\n        if not 0.0 <= betas[1] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 1: {}"".format(betas[1]))\r\n        if not 0.0 <= final_lr:\r\n            raise ValueError(""Invalid final learning rate: {}"".format(final_lr))\r\n        if not 0.0 <= gamma < 1.0:\r\n            raise ValueError(""Invalid gamma parameter: {}"".format(gamma))\r\n        defaults = dict(lr=lr, betas=betas, final_lr=final_lr, gamma=gamma, eps=eps,\r\n                        weight_decay=weight_decay, amsbound=amsbound)\r\n        super(AdaBound, self).__init__(params, defaults)\r\n\r\n        self.base_lrs = list(map(lambda group: group[\'lr\'], self.param_groups))\r\n\r\n    def __setstate__(self, state):\r\n        super(AdaBound, self).__setstate__(state)\r\n        for group in self.param_groups:\r\n            group.setdefault(\'amsbound\', False)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n        for group, base_lr in zip(self.param_groups, self.base_lrs):\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n                if grad.is_sparse:\r\n                    raise RuntimeError(\r\n                        \'Adam does not support sparse gradients, please consider SparseAdam instead\')\r\n                amsbound = group[\'amsbound\']\r\n                state = self.state[p]\r\n                # State initialization\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    # Exponential moving average of gradient values\r\n                    state[\'exp_avg\'] = torch.zeros_like(p.data)\r\n                    # Exponential moving average of squared gradient values\r\n                    state[\'exp_avg_sq\'] = torch.zeros_like(p.data)\r\n                    if amsbound:\r\n                        # Maintains max of all exp. moving avg. of sq. grad. values\r\n                        state[\'max_exp_avg_sq\'] = torch.zeros_like(p.data)\r\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\r\n                if amsbound:\r\n                    max_exp_avg_sq = state[\'max_exp_avg_sq\']\r\n                beta1, beta2 = group[\'betas\']\r\n                state[\'step\'] += 1\r\n                if group[\'weight_decay\'] != 0:\r\n                    grad = grad.add(group[\'weight_decay\'], p.data)\r\n                # Decay the first and second moment running average coefficient\r\n                exp_avg.mul_(beta1).add_(1 - beta1, grad)\r\n                exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)\r\n                if amsbound:\r\n                    # Maintains the maximum of all 2nd moment running avg. till now\r\n                    torch.max(max_exp_avg_sq, exp_avg_sq, out=max_exp_avg_sq)\r\n                    # Use the max. for normalizing running avg. of gradient\r\n                    denom = max_exp_avg_sq.sqrt().add_(group[\'eps\'])\r\n                else:\r\n                    denom = exp_avg_sq.sqrt().add_(group[\'eps\'])\r\n\r\n                bias_correction1 = 1 - beta1 ** state[\'step\']\r\n                bias_correction2 = 1 - beta2 ** state[\'step\']\r\n                step_size = group[\'lr\'] * math.sqrt(bias_correction2) / bias_correction1\r\n\r\n                # Applies bounds on actual learning rate\r\n                # lr_scheduler cannot affect final_lr, this is a workaround to apply lr decay\r\n                final_lr = group[\'final_lr\'] * group[\'lr\'] / base_lr\r\n                lower_bound = final_lr * (1 - 1 / (group[\'gamma\'] * state[\'step\'] + 1))\r\n                upper_bound = final_lr * (1 + 1 / (group[\'gamma\'] * state[\'step\']))\r\n                step_size = torch.full_like(denom, step_size)\r\n                step_size.div_(denom).clamp_(lower_bound, upper_bound).mul_(exp_avg)\r\n                p.data.add_(-step_size)\r\n        return loss'"
pybert/callback/optimizater/adafactor.py,19,"b""import operator\r\nimport torch\r\nfrom copy import copy\r\nimport functools\r\nfrom math import sqrt\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\n\r\nclass AdaFactor(Optimizer):\r\n    '''\r\n    # Code below is an implementation of https://arxiv.org/pdf/1804.04235.pdf\r\n    # inspired but modified from https://github.com/DeadAt0m/adafactor-pytorch\r\n    Example:\r\n        >>> model = LSTM()\r\n        >>> optimizer = AdaFactor(model.parameters(),lr= lr)\r\n    '''\r\n\r\n    def __init__(self, params, lr=None, beta1=0.9, beta2=0.999, eps1=1e-30,\r\n                 eps2=1e-3, cliping_threshold=1, non_constant_decay=True,\r\n                 enable_factorization=True, ams_grad=True, weight_decay=0):\r\n\r\n        enable_momentum = beta1 != 0\r\n        if non_constant_decay:\r\n            ams_grad = False\r\n\r\n        defaults = dict(lr=lr, beta1=beta1, beta2=beta2, eps1=eps1,\r\n                        eps2=eps2, cliping_threshold=cliping_threshold,\r\n                        weight_decay=weight_decay, ams_grad=ams_grad,\r\n                        enable_factorization=enable_factorization,\r\n                        enable_momentum=enable_momentum,\r\n                        non_constant_decay=non_constant_decay)\r\n\r\n        super(AdaFactor, self).__init__(params, defaults)\r\n\r\n    def __setstate__(self, state):\r\n        super(AdaFactor, self).__setstate__(state)\r\n\r\n    def _experimental_reshape(self, shape):\r\n        temp_shape = shape[2:]\r\n        if len(temp_shape) == 1:\r\n            new_shape = (shape[0], shape[1] * shape[2])\r\n        else:\r\n            tmp_div = len(temp_shape) // 2 + len(temp_shape) % 2\r\n            new_shape = (shape[0] * functools.reduce(operator.mul,\r\n                                                     temp_shape[tmp_div:], 1),\r\n                         shape[1] * functools.reduce(operator.mul,\r\n                                                     temp_shape[:tmp_div], 1))\r\n        return new_shape, copy(shape)\r\n\r\n    def _check_shape(self, shape):\r\n        '''\r\n        output1 - True - algorithm for matrix, False - vector;\r\n        output2 - need reshape\r\n        '''\r\n        if len(shape) > 2:\r\n            return True, True\r\n        elif len(shape) == 2:\r\n            return True, False\r\n        elif len(shape) == 2 and (shape[0] == 1 or shape[1] == 1):\r\n            return False, False\r\n        else:\r\n            return False, False\r\n\r\n    def _rms(self, x):\r\n        return sqrt(torch.mean(x.pow(2)))\r\n\r\n    def step(self, closure=None):\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n        for group in self.param_groups:\r\n            for p in group['params']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n\r\n                if grad.is_sparse:\r\n                    raise RuntimeError('Adam does not support sparse \\\r\n                                       gradients, use SparseAdam instead')\r\n\r\n                is_matrix, is_need_reshape = self._check_shape(grad.size())\r\n                new_shape = p.data.size()\r\n                if is_need_reshape and group['enable_factorization']:\r\n                    new_shape, old_shape = \\\r\n                        self._experimental_reshape(p.data.size())\r\n                    grad = grad.view(new_shape)\r\n\r\n                state = self.state[p]\r\n                if len(state) == 0:\r\n                    state['step'] = 0\r\n                    if group['enable_momentum']:\r\n                        state['exp_avg'] = torch.zeros(new_shape,\r\n                                                       dtype=torch.float32,\r\n                                                       device=p.grad.device)\r\n\r\n                    if is_matrix and group['enable_factorization']:\r\n                        state['exp_avg_sq_R'] = \\\r\n                            torch.zeros((1, new_shape[1]),\r\n                                        dtype=torch.float32,\r\n                                        device=p.grad.device)\r\n                        state['exp_avg_sq_C'] = \\\r\n                            torch.zeros((new_shape[0], 1),\r\n                                        dtype=torch.float32,\r\n                                        device=p.grad.device)\r\n                    else:\r\n                        state['exp_avg_sq'] = torch.zeros(new_shape,\r\n                                                          dtype=torch.float32,\r\n                                                          device=p.grad.device)\r\n                    if group['ams_grad']:\r\n                        state['exp_avg_sq_hat'] = \\\r\n                            torch.zeros(new_shape, dtype=torch.float32,\r\n                                        device=p.grad.device)\r\n\r\n                if group['enable_momentum']:\r\n                    exp_avg = state['exp_avg']\r\n\r\n                if is_matrix and group['enable_factorization']:\r\n                    exp_avg_sq_r = state['exp_avg_sq_R']\r\n                    exp_avg_sq_c = state['exp_avg_sq_C']\r\n                else:\r\n                    exp_avg_sq = state['exp_avg_sq']\r\n\r\n                if group['ams_grad']:\r\n                    exp_avg_sq_hat = state['exp_avg_sq_hat']\r\n\r\n                state['step'] += 1\r\n                lr_t = group['lr']\r\n                lr_t *= max(group['eps2'], self._rms(p.data))\r\n\r\n                if group['enable_momentum']:\r\n                    if group['non_constant_decay']:\r\n                        beta1_t = group['beta1'] * \\\r\n                                  (1 - group['beta1'] ** (state['step'] - 1)) \\\r\n                                  / (1 - group['beta1'] ** state['step'])\r\n                    else:\r\n                        beta1_t = group['beta1']\r\n                    exp_avg.mul_(beta1_t).add_(1 - beta1_t, grad)\r\n\r\n                if group['non_constant_decay']:\r\n                    beta2_t = group['beta2'] * \\\r\n                              (1 - group['beta2'] ** (state['step'] - 1)) / \\\r\n                              (1 - group['beta2'] ** state['step'])\r\n                else:\r\n                    beta2_t = group['beta2']\r\n\r\n                if is_matrix and group['enable_factorization']:\r\n                    exp_avg_sq_r.mul_(beta2_t). \\\r\n                        add_(1 - beta2_t, torch.sum(torch.mul(grad, grad).\r\n                                                    add_(group['eps1']),\r\n                                                    dim=0, keepdim=True))\r\n                    exp_avg_sq_c.mul_(beta2_t). \\\r\n                        add_(1 - beta2_t, torch.sum(torch.mul(grad, grad).\r\n                                                    add_(group['eps1']),\r\n                                                    dim=1, keepdim=True))\r\n                    v = torch.mul(exp_avg_sq_c,\r\n                                  exp_avg_sq_r).div_(torch.sum(exp_avg_sq_r))\r\n                else:\r\n                    exp_avg_sq.mul_(beta2_t). \\\r\n                        addcmul_(1 - beta2_t, grad, grad). \\\r\n                        add_((1 - beta2_t) * group['eps1'])\r\n                    v = exp_avg_sq\r\n                g = grad\r\n                if group['enable_momentum']:\r\n                    g = torch.div(exp_avg, 1 - beta1_t ** state['step'])\r\n                if group['ams_grad']:\r\n                    torch.max(exp_avg_sq_hat, v, out=exp_avg_sq_hat)\r\n                    v = exp_avg_sq_hat\r\n                    u = torch.div(g, (torch.div(v, 1 - beta2_t **\r\n                                                state['step'])).sqrt().add_(group['eps1']))\r\n                else:\r\n                    u = torch.div(g, v.sqrt())\r\n                u.div_(max(1, self._rms(u) / group['cliping_threshold']))\r\n                p.data.add_(-lr_t * (u.view(old_shape) if is_need_reshape and\r\n                                                          group['enable_factorization'] else u))\r\n                if group['weight_decay'] != 0:\r\n                    p.data.add_(-group['weight_decay'] * lr_t, p.data)\r\n        return loss\r\n"""
pybert/callback/optimizater/adamw.py,3,"b'import torch\r\nimport math\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\nclass AdamW(Optimizer):\r\n    """""" Implements Adam algorithm with weight decay fix.\r\n\r\n    Parameters:\r\n        lr (float): learning rate. Default 1e-3.\r\n        betas (tuple of 2 floats): Adams beta parameters (b1, b2). Default: (0.9, 0.999)\r\n        eps (float): Adams epsilon. Default: 1e-6\r\n        weight_decay (float): Weight decay. Default: 0.0\r\n        correct_bias (bool): can be set to False to avoid correcting bias in Adam (e.g. like in Bert TF repository). Default True.\r\n    Example:\r\n        >>> model = LSTM()\r\n        >>> optimizer = AdamW(model.parameters(), lr=1e-3, weight_decay=1e-5)\r\n    """"""\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-6, weight_decay=0.0, correct_bias=True):\r\n        if lr < 0.0:\r\n            raise ValueError(""Invalid learning rate: {} - should be >= 0.0"".format(lr))\r\n        if not 0.0 <= betas[0] < 1.0:\r\n            raise ValueError(""Invalid beta parameter: {} - should be in [0.0, 1.0["".format(betas[0]))\r\n        if not 0.0 <= betas[1]  < 1.0:\r\n            raise ValueError(""Invalid beta parameter: {} - should be in [0.0, 1.0["".format(betas[1]))\r\n        if not 0.0 <= eps:\r\n            raise ValueError(""Invalid epsilon value: {} - should be >= 0.0"".format(eps))\r\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay,\r\n                        correct_bias=correct_bias)\r\n        super(AdamW, self).__init__(params, defaults)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n                if grad.is_sparse:\r\n                    raise RuntimeError(\'Adam does not support sparse gradients, please consider SparseAdam instead\')\r\n\r\n                state = self.state[p]\r\n\r\n                # State initialization\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    # Exponential moving average of gradient values\r\n                    state[\'exp_avg\'] = torch.zeros_like(p.data)\r\n                    # Exponential moving average of squared gradient values\r\n                    state[\'exp_avg_sq\'] = torch.zeros_like(p.data)\r\n\r\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\r\n                beta1, beta2 = group[\'betas\']\r\n\r\n                state[\'step\'] += 1\r\n\r\n                # Decay the first and second moment running average coefficient\r\n                # In-place operations to update the averages at the same time\r\n                exp_avg.mul_(beta1).add_(1.0 - beta1, grad)\r\n                exp_avg_sq.mul_(beta2).addcmul_(1.0 - beta2, grad, grad)\r\n                denom = exp_avg_sq.sqrt().add_(group[\'eps\'])\r\n\r\n                step_size = group[\'lr\']\r\n                if group[\'correct_bias\']:  # No bias correction for Bert\r\n                    bias_correction1 = 1.0 - beta1 ** state[\'step\']\r\n                    bias_correction2 = 1.0 - beta2 ** state[\'step\']\r\n                    step_size = step_size * math.sqrt(bias_correction2) / bias_correction1\r\n\r\n                p.data.addcdiv_(-step_size, exp_avg, denom)\r\n\r\n                # Just adding the square of the weights to the loss function is *not*\r\n                # the correct way of using L2 regularization/weight decay with Adam,\r\n                # since that will interact with the m and v parameters in strange ways.\r\n                #\r\n                # Instead we want to decay the weights in a manner that doesn\'t interact\r\n                # with the m/v parameters. This is equivalent to adding the square\r\n                # of the weights to the loss with plain (non-momentum) SGD.\r\n                # Add weight decay at the end (fixed version)\r\n                if group[\'weight_decay\'] > 0.0:\r\n                    p.data.add_(-group[\'lr\'] * group[\'weight_decay\'], p.data)\r\n\r\n        return loss\r\n'"
pybert/callback/optimizater/lamb.py,3,"b'import torch\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\n\r\nclass Lamb(Optimizer):\r\n    r""""""Implements Lamb algorithm.\r\n    It has been proposed in `Large Batch Optimization for Deep Learning: Training BERT in 76 minutes`_.\r\n    Arguments:\r\n        params (iterable): iterable of parameters to optimize or dicts defining\r\n            parameter groups\r\n        lr (float, optional): learning rate (default: 1e-3)\r\n        betas (Tuple[float, float], optional): coefficients used for computing\r\n            running averages of gradient and its square (default: (0.9, 0.999))\r\n        eps (float, optional): term added to the denominator to improve\r\n            numerical stability (default: 1e-8)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n        adam (bool, optional): always use trust ratio = 1, which turns this into\r\n            Adam. Useful for comparison purposes.\r\n    .. _Large Batch Optimization for Deep Learning: Training BERT in 76 minutes:\r\n        https://arxiv.org/abs/1904.00962\r\n    Example:\r\n        >>> model = ResNet()\r\n        >>> optimizer = Lamb(model.parameters(), lr=1e-2, weight_decay=1e-5)\r\n    """"""\r\n\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-6,\r\n                 weight_decay=0, adam=False):\r\n        if not 0.0 <= lr:\r\n            raise ValueError(""Invalid learning rate: {}"".format(lr))\r\n        if not 0.0 <= eps:\r\n            raise ValueError(""Invalid epsilon value: {}"".format(eps))\r\n        if not 0.0 <= betas[0] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 0: {}"".format(betas[0]))\r\n        if not 0.0 <= betas[1] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 1: {}"".format(betas[1]))\r\n        defaults = dict(lr=lr, betas=betas, eps=eps,\r\n                        weight_decay=weight_decay)\r\n        self.adam = adam\r\n        super(Lamb, self).__init__(params, defaults)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n                if grad.is_sparse:\r\n                    raise RuntimeError(\'Lamb does not support sparse gradients, consider SparseAdam instad.\')\r\n\r\n                state = self.state[p]\r\n\r\n                # State initialization\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    # Exponential moving average of gradient values\r\n                    state[\'exp_avg\'] = torch.zeros_like(p.data)\r\n                    # Exponential moving average of squared gradient values\r\n                    state[\'exp_avg_sq\'] = torch.zeros_like(p.data)\r\n\r\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\r\n                beta1, beta2 = group[\'betas\']\r\n\r\n                state[\'step\'] += 1\r\n\r\n                # Decay the first and second moment running average coefficient\r\n                # m_t\r\n                exp_avg.mul_(beta1).add_(1 - beta1, grad)\r\n                # v_t\r\n                exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)\r\n\r\n                # Paper v3 does not use debiasing.\r\n                # bias_correction1 = 1 - beta1 ** state[\'step\']\r\n                # bias_correction2 = 1 - beta2 ** state[\'step\']\r\n                # Apply bias to lr to avoid broadcast.\r\n                step_size = group[\'lr\'] # * math.sqrt(bias_correction2) / bias_correction1\r\n\r\n                weight_norm = p.data.pow(2).sum().sqrt().clamp(0, 10)\r\n\r\n                adam_step = exp_avg / exp_avg_sq.sqrt().add(group[\'eps\'])\r\n                if group[\'weight_decay\'] != 0:\r\n                    adam_step.add_(group[\'weight_decay\'], p.data)\r\n\r\n                adam_norm = adam_step.pow(2).sum().sqrt()\r\n                if weight_norm == 0 or adam_norm == 0:\r\n                    trust_ratio = 1\r\n                else:\r\n                    trust_ratio = weight_norm / adam_norm\r\n                state[\'weight_norm\'] = weight_norm\r\n                state[\'adam_norm\'] = adam_norm\r\n                state[\'trust_ratio\'] = trust_ratio\r\n                if self.adam:\r\n                    trust_ratio = 1\r\n\r\n                p.data.add_(-step_size * trust_ratio, adam_step)\r\n\r\n        return loss'"
pybert/callback/optimizater/lars.py,2,"b'import torch\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\nclass Lars(Optimizer):\r\n    r""""""Implements the LARS optimizer from https://arxiv.org/pdf/1708.03888.pdf\r\n\r\n    Args:\r\n        params (iterable): iterable of parameters to optimize or dicts defining\r\n            parameter groups\r\n        lr (float): learning rate\r\n        momentum (float, optional): momentum factor (default: 0)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n        dampening (float, optional): dampening for momentum (default: 0)\r\n        nesterov (bool, optional): enables Nesterov momentum (default: False)\r\n        scale_clip (tuple, optional): the lower and upper bounds for the weight norm in local LR of LARS\r\n    Example:\r\n        >>> model = ResNet()\r\n        >>> optimizer = Lars(model.parameters(), lr=1e-2, weight_decay=1e-5)\r\n    """"""\r\n\r\n    def __init__(self, params, lr, momentum=0, dampening=0,\r\n                 weight_decay=0, nesterov=False, scale_clip=None):\r\n        if lr < 0.0:\r\n            raise ValueError(""Invalid learning rate: {}"".format(lr))\r\n        if momentum < 0.0:\r\n            raise ValueError(""Invalid momentum value: {}"".format(momentum))\r\n        if weight_decay < 0.0:\r\n            raise ValueError(""Invalid weight_decay value: {}"".format(weight_decay))\r\n\r\n        defaults = dict(lr=lr, momentum=momentum, dampening=dampening,\r\n                        weight_decay=weight_decay, nesterov=nesterov)\r\n        if nesterov and (momentum <= 0 or dampening != 0):\r\n            raise ValueError(""Nesterov momentum requires a momentum and zero dampening"")\r\n        super(Lars, self).__init__(params, defaults)\r\n        # LARS arguments\r\n        self.scale_clip = scale_clip\r\n        if self.scale_clip is None:\r\n            self.scale_clip = (0, 10)\r\n\r\n    def __setstate__(self, state):\r\n        super(Lars, self).__setstate__(state)\r\n        for group in self.param_groups:\r\n            group.setdefault(\'nesterov\', False)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n            weight_decay = group[\'weight_decay\']\r\n            momentum = group[\'momentum\']\r\n            dampening = group[\'dampening\']\r\n            nesterov = group[\'nesterov\']\r\n\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                d_p = p.grad.data\r\n                if weight_decay != 0:\r\n                    d_p.add_(weight_decay, p.data)\r\n                if momentum != 0:\r\n                    param_state = self.state[p]\r\n                    if \'momentum_buffer\' not in param_state:\r\n                        buf = param_state[\'momentum_buffer\'] = torch.clone(d_p).detach()\r\n                    else:\r\n                        buf = param_state[\'momentum_buffer\']\r\n                        buf.mul_(momentum).add_(1 - dampening, d_p)\r\n                    if nesterov:\r\n                        d_p = d_p.add(momentum, buf)\r\n                    else:\r\n                        d_p = buf\r\n\r\n                # LARS\r\n                p_norm = p.data.pow(2).sum().sqrt()\r\n                update_norm = d_p.pow(2).sum().sqrt()\r\n                # Compute the local LR\r\n                if p_norm == 0 or update_norm == 0:\r\n                    local_lr = 1\r\n                else:\r\n                    local_lr = p_norm / update_norm\r\n\r\n                p.data.add_(-group[\'lr\'] * local_lr, d_p)\r\n\r\n        return loss'"
pybert/callback/optimizater/lookahead.py,4,"b'import torch\r\nfrom torch.optim import Optimizer\r\nfrom collections import defaultdict\r\n\r\nclass Lookahead(Optimizer):\r\n    \'\'\'\r\n    PyTorch implementation of the lookahead wrapper.\r\n    Lookahead Optimizer: https://arxiv.org/abs/1907.08610\r\n\r\n    We found that evaluation performance is typically better using the slow weights.\r\n    This can be done in PyTorch with something like this in your eval loop:\r\n    if args.lookahead:\r\n        optimizer._backup_and_load_cache()\r\n        val_loss = eval_func(model)\r\n        optimizer._clear_and_load_backup()\r\n    \'\'\'\r\n    def __init__(self, optimizer,alpha=0.5, k=6,pullback_momentum=""none""):\r\n        \'\'\'\r\n        :param optimizer:inner optimizer\r\n        :param k (int): number of lookahead steps\r\n        :param alpha(float): linear interpolation factor. 1.0 recovers the inner optimizer.\r\n        :param pullback_momentum (str): change to inner optimizer momentum on interpolation update\r\n        \'\'\'\r\n        if not 0.0 <= alpha <= 1.0:\r\n            raise ValueError(f\'Invalid slow update rate: {alpha}\')\r\n        if not 1 <= k:\r\n            raise ValueError(f\'Invalid lookahead steps: {k}\')\r\n        self.optimizer = optimizer\r\n        self.param_groups = self.optimizer.param_groups\r\n        self.alpha = alpha\r\n        self.k = k\r\n        self.step_counter = 0\r\n        assert pullback_momentum in [""reset"", ""pullback"", ""none""]\r\n        self.pullback_momentum = pullback_momentum\r\n        self.state = defaultdict(dict)\r\n\r\n        # Cache the current optimizer parameters\r\n        for group in self.optimizer.param_groups:\r\n            for p in group[\'params\']:\r\n                param_state = self.state[p]\r\n                param_state[\'cached_params\'] = torch.zeros_like(p.data)\r\n                param_state[\'cached_params\'].copy_(p.data)\r\n\r\n    def __getstate__(self):\r\n        return {\r\n            \'state\': self.state,\r\n            \'optimizer\': self.optimizer,\r\n            \'alpha\': self.alpha,\r\n            \'step_counter\': self.step_counter,\r\n            \'k\':self.k,\r\n            \'pullback_momentum\': self.pullback_momentum\r\n        }\r\n\r\n    def zero_grad(self):\r\n        self.optimizer.zero_grad()\r\n\r\n    def state_dict(self):\r\n        return self.optimizer.state_dict()\r\n\r\n    def load_state_dict(self, state_dict):\r\n        self.optimizer.load_state_dict(state_dict)\r\n\r\n    def _backup_and_load_cache(self):\r\n        """"""Useful for performing evaluation on the slow weights (which typically generalize better)\r\n        """"""\r\n        for group in self.optimizer.param_groups:\r\n            for p in group[\'params\']:\r\n                param_state = self.state[p]\r\n                param_state[\'backup_params\'] = torch.zeros_like(p.data)\r\n                param_state[\'backup_params\'].copy_(p.data)\r\n                p.data.copy_(param_state[\'cached_params\'])\r\n\r\n    def _clear_and_load_backup(self):\r\n        for group in self.optimizer.param_groups:\r\n            for p in group[\'params\']:\r\n                param_state = self.state[p]\r\n                p.data.copy_(param_state[\'backup_params\'])\r\n                del param_state[\'backup_params\']\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single Lookahead optimization step.\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = self.optimizer.step(closure)\r\n        self.step_counter += 1\r\n\r\n        if self.step_counter >= self.k:\r\n            self.step_counter = 0\r\n            # Lookahead and cache the current optimizer parameters\r\n            for group in self.optimizer.param_groups:\r\n                for p in group[\'params\']:\r\n                    param_state = self.state[p]\r\n                    p.data.mul_(self.alpha).add_(1.0 - self.alpha, param_state[\'cached_params\'])  # crucial line\r\n                    param_state[\'cached_params\'].copy_(p.data)\r\n                    if self.pullback_momentum == ""pullback"":\r\n                        internal_momentum = self.optimizer.state[p][""momentum_buffer""]\r\n                        self.optimizer.state[p][""momentum_buffer""] = internal_momentum.mul_(self.alpha).add_(\r\n                            1.0 - self.alpha, param_state[""cached_mom""])\r\n                        param_state[""cached_mom""] = self.optimizer.state[p][""momentum_buffer""]\r\n                    elif self.pullback_momentum == ""reset"":\r\n                        self.optimizer.state[p][""momentum_buffer""] = torch.zeros_like(p.data)\r\n\r\n        return loss\r\n'"
pybert/callback/optimizater/nadam.py,1,"b'import torch\r\nimport math\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\nclass Nadam(Optimizer):\r\n    """"""Implements Nadam algorithm (a variant of Adam based on Nesterov momentum).\r\n\r\n    It has been proposed in `Incorporating Nesterov Momentum into Adam`__.\r\n\r\n    Arguments:\r\n        params (iterable): iterable of parameters to optimize or dicts defining\r\n            parameter groups\r\n        lr (float, optional): learning rate (default: 2e-3)\r\n        betas (Tuple[float, float], optional): coefficients used for computing\r\n            running averages of gradient and its square\r\n        eps (float, optional): term added to the denominator to improve\r\n            numerical stability (default: 1e-8)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n        schedule_decay (float, optional): momentum schedule decay (default: 4e-3)\r\n\r\n    __ http://cs229.stanford.edu/proj2015/054_report.pdf\r\n    __ http://www.cs.toronto.edu/~fritz/absps/momentum.pdf\r\n\r\n        Originally taken from: https://github.com/pytorch/pytorch/pull/1408\r\n        NOTE: Has potential issues but does work well on some problems.\r\n    Example:\r\n        >>> model = LSTM()\r\n        >>> optimizer = Nadam(model.parameters())\r\n    """"""\r\n\r\n    def __init__(self, params, lr=2e-3, betas=(0.9, 0.999), eps=1e-8,\r\n                 weight_decay=0, schedule_decay=4e-3):\r\n        defaults = dict(lr=lr, betas=betas, eps=eps,\r\n                        weight_decay=weight_decay, schedule_decay=schedule_decay)\r\n        super(Nadam, self).__init__(params, defaults)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n                state = self.state[p]\r\n\r\n                # State initialization\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    state[\'m_schedule\'] = 1.\r\n                    state[\'exp_avg\'] = grad.new().resize_as_(grad).zero_()\r\n                    state[\'exp_avg_sq\'] = grad.new().resize_as_(grad).zero_()\r\n\r\n                # Warming momentum schedule\r\n                m_schedule = state[\'m_schedule\']\r\n                schedule_decay = group[\'schedule_decay\']\r\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\r\n                beta1, beta2 = group[\'betas\']\r\n                eps = group[\'eps\']\r\n                state[\'step\'] += 1\r\n                t = state[\'step\']\r\n\r\n                if group[\'weight_decay\'] != 0:\r\n                    grad = grad.add(group[\'weight_decay\'], p.data)\r\n\r\n                momentum_cache_t = beta1 * \\\r\n                    (1. - 0.5 * (0.96 ** (t * schedule_decay)))\r\n                momentum_cache_t_1 = beta1 * \\\r\n                    (1. - 0.5 * (0.96 ** ((t + 1) * schedule_decay)))\r\n                m_schedule_new = m_schedule * momentum_cache_t\r\n                m_schedule_next = m_schedule * momentum_cache_t * momentum_cache_t_1\r\n                state[\'m_schedule\'] = m_schedule_new\r\n\r\n                # Decay the first and second moment running average coefficient\r\n                exp_avg.mul_(beta1).add_(1. - beta1, grad)\r\n                exp_avg_sq.mul_(beta2).addcmul_(1. - beta2, grad, grad)\r\n                exp_avg_sq_prime = exp_avg_sq / (1. - beta2 ** t)\r\n                denom = exp_avg_sq_prime.sqrt_().add_(eps)\r\n\r\n                p.data.addcdiv_(-group[\'lr\'] * (1. - momentum_cache_t) / (1. - m_schedule_new), grad, denom)\r\n                p.data.addcdiv_(-group[\'lr\'] * momentum_cache_t_1 / (1. - m_schedule_next), exp_avg, denom)\r\n\r\n        return loss'"
pybert/callback/optimizater/novograd.py,3,"b'import torch\r\nimport math\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\n\r\nclass NovoGrad(Optimizer):\r\n    """"""Implements NovoGrad algorithm.\r\n    Arguments:\r\n        params (iterable): iterable of parameters to optimize or dicts defining\r\n            parameter groups\r\n        lr (float, optional): learning rate (default: 1e-2)\r\n        betas (Tuple[float, float], optional): coefficients used for computing\r\n            running averages of gradient and its square (default: (0.95, 0.98))\r\n        eps (float, optional): term added to the denominator to improve\r\n            numerical stability (default: 1e-8)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n    Example:\r\n        >>> model = ResNet()\r\n        >>> optimizer = NovoGrad(model.parameters(), lr=1e-2, weight_decay=1e-5)\r\n    """"""\r\n\r\n    def __init__(self, params, lr=0.01, betas=(0.95, 0.98), eps=1e-8,\r\n                 weight_decay=0, grad_averaging=False):\r\n        if lr < 0.0:\r\n            raise ValueError(""Invalid learning rate: {}"".format(lr))\r\n        if not 0.0 <= betas[0] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 0: {}"".format(betas[0]))\r\n        if not 0.0 <= betas[1] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 1: {}"".format(betas[1]))\r\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay, grad_averaging=grad_averaging)\r\n        super().__init__(params, defaults)\r\n\r\n    def step(self, closure=None):\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n        for group in self.param_groups:\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n                if grad.is_sparse:\r\n                    raise RuntimeError(\'NovoGrad does not support sparse gradients\')\r\n                state = self.state[p]\r\n                g_2 = torch.sum(grad ** 2)\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    state[\'moments\'] = grad.div(g_2.sqrt() + group[\'eps\']) + \\\r\n                                       group[\'weight_decay\'] * p.data\r\n                    state[\'grads_ema\'] = g_2\r\n                moments = state[\'moments\']\r\n                grads_ema = state[\'grads_ema\']\r\n                beta1, beta2 = group[\'betas\']\r\n                state[\'step\'] += 1\r\n                grads_ema.mul_(beta2).add_(1 - beta2, g_2)\r\n\r\n                denom = grads_ema.sqrt().add_(group[\'eps\'])\r\n                grad.div_(denom)\r\n                # weight decay\r\n                if group[\'weight_decay\'] != 0:\r\n                    decayed_weights = torch.mul(p.data, group[\'weight_decay\'])\r\n                    grad.add_(decayed_weights)\r\n\r\n                # Momentum --> SAG\r\n                if group[\'grad_averaging\']:\r\n                    grad.mul_(1.0 - beta1)\r\n\r\n                moments.mul_(beta1).add_(grad)  # velocity\r\n\r\n                bias_correction1 = 1 - beta1 ** state[\'step\']\r\n                bias_correction2 = 1 - beta2 ** state[\'step\']\r\n                step_size = group[\'lr\'] * math.sqrt(bias_correction2) / bias_correction1\r\n                p.data.add_(-step_size, moments)\r\n\r\n        return loss\r\n'"
pybert/callback/optimizater/planradam.py,3,"b""import torch\r\nimport math\r\nfrom torch.optim.optimizer import Optimizer\r\nclass PlainRAdam(Optimizer):\r\n\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-8, weight_decay=0):\r\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay)\r\n\r\n        super(PlainRAdam, self).__init__(params, defaults)\r\n\r\n    def __setstate__(self, state):\r\n        super(PlainRAdam, self).__setstate__(state)\r\n\r\n    def step(self, closure=None):\r\n\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n\r\n            for p in group['params']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data.float()\r\n                if grad.is_sparse:\r\n                    raise RuntimeError('RAdam does not support sparse gradients')\r\n\r\n                p_data_fp32 = p.data.float()\r\n\r\n                state = self.state[p]\r\n\r\n                if len(state) == 0:\r\n                    state['step'] = 0\r\n                    state['exp_avg'] = torch.zeros_like(p_data_fp32)\r\n                    state['exp_avg_sq'] = torch.zeros_like(p_data_fp32)\r\n                else:\r\n                    state['exp_avg'] = state['exp_avg'].type_as(p_data_fp32)\r\n                    state['exp_avg_sq'] = state['exp_avg_sq'].type_as(p_data_fp32)\r\n\r\n                exp_avg, exp_avg_sq = state['exp_avg'], state['exp_avg_sq']\r\n                beta1, beta2 = group['betas']\r\n\r\n                exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)\r\n                exp_avg.mul_(beta1).add_(1 - beta1, grad)\r\n\r\n                state['step'] += 1\r\n                beta2_t = beta2 ** state['step']\r\n                N_sma_max = 2 / (1 - beta2) - 1\r\n                N_sma = N_sma_max - 2 * state['step'] * beta2_t / (1 - beta2_t)\r\n\r\n                if group['weight_decay'] != 0:\r\n                    p_data_fp32.add_(-group['weight_decay'] * group['lr'], p_data_fp32)\r\n\r\n                # more conservative since it's an approximated value\r\n                if N_sma >= 5:\r\n                    step_size = group['lr'] * math.sqrt((1 - beta2_t) * (N_sma - 4) / (N_sma_max - 4) * (N_sma - 2) / N_sma * N_sma_max / (N_sma_max - 2)) / (1 - beta1 ** state['step'])\r\n                    denom = exp_avg_sq.sqrt().add_(group['eps'])\r\n                    p_data_fp32.addcdiv_(-step_size, exp_avg, denom)\r\n                else:\r\n                    step_size = group['lr'] / (1 - beta1 ** state['step'])\r\n                    p_data_fp32.add_(-step_size, exp_avg)\r\n\r\n                p.data.copy_(p_data_fp32)\r\n\r\n        return loss"""
pybert/callback/optimizater/radam.py,3,"b'import torch\r\nimport math\r\nfrom torch.optim.optimizer import Optimizer\r\nclass RAdam(Optimizer):\r\n    """"""Implements the RAdam optimizer from https://arxiv.org/pdf/1908.03265.pdf\r\n    Args:\r\n        params (iterable): iterable of parameters to optimize or dicts defining parameter groups\r\n        lr (float, optional): learning rate\r\n        betas (Tuple[float, float], optional): coefficients used for computing running averages of gradient and its square (default: (0.9, 0.999))\r\n        eps (float, optional): term added to the denominator to improve numerical stability (default: 1e-8)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n    Example:\r\n        >>> model = ResNet()\r\n        >>> optimizer = RAdam(model.parameters(), lr=0.001)\r\n    """"""\r\n\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-8, weight_decay=0):\r\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay)\r\n        self.buffer = [[None, None, None] for ind in range(10)]\r\n        super(RAdam, self).__init__(params, defaults)\r\n\r\n    def __setstate__(self, state):\r\n        super(RAdam, self).__setstate__(state)\r\n\r\n    def step(self, closure=None):\r\n\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data.float()\r\n                if grad.is_sparse:\r\n                    raise RuntimeError(\'RAdam does not support sparse gradients\')\r\n\r\n                p_data_fp32 = p.data.float()\r\n\r\n                state = self.state[p]\r\n\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    state[\'exp_avg\'] = torch.zeros_like(p_data_fp32)\r\n                    state[\'exp_avg_sq\'] = torch.zeros_like(p_data_fp32)\r\n                else:\r\n                    state[\'exp_avg\'] = state[\'exp_avg\'].type_as(p_data_fp32)\r\n                    state[\'exp_avg_sq\'] = state[\'exp_avg_sq\'].type_as(p_data_fp32)\r\n\r\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\r\n                beta1, beta2 = group[\'betas\']\r\n\r\n                exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)\r\n                exp_avg.mul_(beta1).add_(1 - beta1, grad)\r\n\r\n                state[\'step\'] += 1\r\n                buffered = self.buffer[int(state[\'step\'] % 10)]\r\n                if state[\'step\'] == buffered[0]:\r\n                    N_sma, step_size = buffered[1], buffered[2]\r\n                else:\r\n                    buffered[0] = state[\'step\']\r\n                    beta2_t = beta2 ** state[\'step\']\r\n                    N_sma_max = 2 / (1 - beta2) - 1\r\n                    N_sma = N_sma_max - 2 * state[\'step\'] * beta2_t / (1 - beta2_t)\r\n                    buffered[1] = N_sma\r\n\r\n                    # more conservative since it\'s an approximated value\r\n                    if N_sma >= 5:\r\n                        step_size = math.sqrt((1 - beta2_t) * (N_sma - 4) / (N_sma_max - 4) * (N_sma - 2) / N_sma * N_sma_max / (N_sma_max - 2)) / (1 - beta1 ** state[\'step\'])\r\n                    else:\r\n                        step_size = 1.0 / (1 - beta1 ** state[\'step\'])\r\n                    buffered[2] = step_size\r\n\r\n                if group[\'weight_decay\'] != 0:\r\n                    p_data_fp32.add_(-group[\'weight_decay\'] * group[\'lr\'], p_data_fp32)\r\n\r\n                # more conservative since it\'s an approximated value\r\n                if N_sma >= 5:\r\n                    denom = exp_avg_sq.sqrt().add_(group[\'eps\'])\r\n                    p_data_fp32.addcdiv_(-step_size * group[\'lr\'], exp_avg, denom)\r\n                else:\r\n                    p_data_fp32.add_(-step_size * group[\'lr\'], exp_avg)\r\n\r\n                p.data.copy_(p_data_fp32)\r\n\r\n        return loss'"
pybert/callback/optimizater/ralamb.py,3,"b""import math\r\nimport torch\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\nclass Ralamb(Optimizer):\r\n    '''\r\n    RAdam + LARS\r\n    Example:\r\n        >>> model = ResNet()\r\n        >>> optimizer = Ralamb(model.parameters(), lr=0.001)\r\n    '''\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-8, weight_decay=0):\r\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay)\r\n        self.buffer = [[None, None, None] for ind in range(10)]\r\n        super(Ralamb, self).__init__(params, defaults)\r\n\r\n    def __setstate__(self, state):\r\n        super(Ralamb, self).__setstate__(state)\r\n\r\n    def step(self, closure=None):\r\n\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n\r\n            for p in group['params']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data.float()\r\n                if grad.is_sparse:\r\n                    raise RuntimeError('Ralamb does not support sparse gradients')\r\n\r\n                p_data_fp32 = p.data.float()\r\n\r\n                state = self.state[p]\r\n\r\n                if len(state) == 0:\r\n                    state['step'] = 0\r\n                    state['exp_avg'] = torch.zeros_like(p_data_fp32)\r\n                    state['exp_avg_sq'] = torch.zeros_like(p_data_fp32)\r\n                else:\r\n                    state['exp_avg'] = state['exp_avg'].type_as(p_data_fp32)\r\n                    state['exp_avg_sq'] = state['exp_avg_sq'].type_as(p_data_fp32)\r\n\r\n                exp_avg, exp_avg_sq = state['exp_avg'], state['exp_avg_sq']\r\n                beta1, beta2 = group['betas']\r\n\r\n                # Decay the first and second moment running average coefficient\r\n                # m_t\r\n                exp_avg.mul_(beta1).add_(1 - beta1, grad)\r\n                # v_t\r\n                exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)\r\n\r\n                state['step'] += 1\r\n                buffered = self.buffer[int(state['step'] % 10)]\r\n\r\n                if state['step'] == buffered[0]:\r\n                    N_sma, radam_step_size = buffered[1], buffered[2]\r\n                else:\r\n                    buffered[0] = state['step']\r\n                    beta2_t = beta2 ** state['step']\r\n                    N_sma_max = 2 / (1 - beta2) - 1\r\n                    N_sma = N_sma_max - 2 * state['step'] * beta2_t / (1 - beta2_t)\r\n                    buffered[1] = N_sma\r\n\r\n                    # more conservative since it's an approximated value\r\n                    if N_sma >= 5:\r\n                        radam_step_size = math.sqrt((1 - beta2_t) * (N_sma - 4) / (N_sma_max - 4) * (N_sma - 2) / N_sma * N_sma_max / (N_sma_max - 2)) / (1 - beta1 ** state['step'])\r\n                    else:\r\n                        radam_step_size = 1.0 / (1 - beta1 ** state['step'])\r\n                    buffered[2] = radam_step_size\r\n\r\n                if group['weight_decay'] != 0:\r\n                    p_data_fp32.add_(-group['weight_decay'] * group['lr'], p_data_fp32)\r\n\r\n                # more conservative since it's an approximated value\r\n                radam_step = p_data_fp32.clone()\r\n                if N_sma >= 5:\r\n                    denom = exp_avg_sq.sqrt().add_(group['eps'])\r\n                    radam_step.addcdiv_(-radam_step_size * group['lr'], exp_avg, denom)\r\n                else:\r\n                    radam_step.add_(-radam_step_size * group['lr'], exp_avg)\r\n\r\n                radam_norm = radam_step.pow(2).sum().sqrt()\r\n                weight_norm = p.data.pow(2).sum().sqrt().clamp(0, 10)\r\n                if weight_norm == 0 or radam_norm == 0:\r\n                    trust_ratio = 1\r\n                else:\r\n                    trust_ratio = weight_norm / radam_norm\r\n\r\n                state['weight_norm'] = weight_norm\r\n                state['adam_norm'] = radam_norm\r\n                state['trust_ratio'] = trust_ratio\r\n\r\n                if N_sma >= 5:\r\n                    p_data_fp32.addcdiv_(-radam_step_size * group['lr'] * trust_ratio, exp_avg, denom)\r\n                else:\r\n                    p_data_fp32.add_(-radam_step_size * group['lr'] * trust_ratio, exp_avg)\r\n\r\n                p.data.copy_(p_data_fp32)\r\n\r\n        return loss"""
pybert/callback/optimizater/ralars.py,4,"b'import math\r\nimport torch\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\n\r\nclass RaLars(Optimizer):\r\n    """"""Implements the RAdam optimizer from https://arxiv.org/pdf/1908.03265.pdf\r\n    with optional Layer-wise adaptive Scaling from https://arxiv.org/pdf/1708.03888.pdf\r\n\r\n    Args:\r\n        params (iterable): iterable of parameters to optimize or dicts defining parameter groups\r\n        lr (float, optional): learning rate\r\n        betas (Tuple[float, float], optional): coefficients used for computing running averages of gradient and its square (default: (0.9, 0.999))\r\n        eps (float, optional): term added to the denominator to improve numerical stability (default: 1e-8)\r\n        weight_decay (float, optional): weight decay (L2 penalty) (default: 0)\r\n        scale_clip (float, optional): the maximal upper bound for the scale factor of LARS\r\n    Example:\r\n        >>> model = ResNet()\r\n        >>> optimizer = RaLars(model.parameters(), lr=0.001)\r\n    """"""\r\n\r\n    def __init__(self, params, lr=1e-3, betas=(0.9, 0.999), eps=1e-8, weight_decay=0,\r\n                 scale_clip=None):\r\n        if not 0.0 <= lr:\r\n            raise ValueError(""Invalid learning rate: {}"".format(lr))\r\n        if not 0.0 <= eps:\r\n            raise ValueError(""Invalid epsilon value: {}"".format(eps))\r\n        if not 0.0 <= betas[0] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 0: {}"".format(betas[0]))\r\n        if not 0.0 <= betas[1] < 1.0:\r\n            raise ValueError(""Invalid beta parameter at index 1: {}"".format(betas[1]))\r\n        defaults = dict(lr=lr, betas=betas, eps=eps, weight_decay=weight_decay)\r\n        super(RaLars, self).__init__(params, defaults)\r\n        # LARS arguments\r\n        self.scale_clip = scale_clip\r\n        if self.scale_clip is None:\r\n            self.scale_clip = (0, 10)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n\r\n            # Get group-shared variables\r\n            beta1, beta2 = group[\'betas\']\r\n            sma_inf = group.get(\'sma_inf\')\r\n            # Compute max length of SMA on first step\r\n            if not isinstance(sma_inf, float):\r\n                group[\'sma_inf\'] = 2 / (1 - beta2) - 1\r\n                sma_inf = group.get(\'sma_inf\')\r\n\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                grad = p.grad.data\r\n                if grad.is_sparse:\r\n                    raise RuntimeError(\'RAdam does not support sparse gradients\')\r\n\r\n                state = self.state[p]\r\n\r\n                # State initialization\r\n                if len(state) == 0:\r\n                    state[\'step\'] = 0\r\n                    # Exponential moving average of gradient values\r\n                    state[\'exp_avg\'] = torch.zeros_like(p.data)\r\n                    # Exponential moving average of squared gradient values\r\n                    state[\'exp_avg_sq\'] = torch.zeros_like(p.data)\r\n\r\n                exp_avg, exp_avg_sq = state[\'exp_avg\'], state[\'exp_avg_sq\']\r\n\r\n                state[\'step\'] += 1\r\n\r\n                # Decay the first and second moment running average coefficient\r\n                exp_avg.mul_(beta1).add_(1 - beta1, grad)\r\n                exp_avg_sq.mul_(beta2).addcmul_(1 - beta2, grad, grad)\r\n\r\n                # Bias correction\r\n                bias_correction1 = 1 - beta1 ** state[\'step\']\r\n                bias_correction2 = 1 - beta2 ** state[\'step\']\r\n\r\n                # Compute length of SMA\r\n                sma_t = sma_inf - 2 * state[\'step\'] * (1 - bias_correction2) / bias_correction2\r\n\r\n                update = torch.zeros_like(p.data)\r\n                if sma_t > 4:\r\n                    # \xc2\xa0Variance rectification term\r\n                    r_t = math.sqrt((sma_t - 4) * (sma_t - 2) * sma_inf / ((sma_inf - 4) * (sma_inf - 2) * sma_t))\r\n                    # \xc2\xa0Adaptive momentum\r\n                    update.addcdiv_(r_t, exp_avg / bias_correction1,\r\n                                    (exp_avg_sq / bias_correction2).sqrt().add_(group[\'eps\']))\r\n                else:\r\n                    # Unadapted momentum\r\n                    update.add_(exp_avg / bias_correction1)\r\n\r\n                # Weight decay\r\n                if group[\'weight_decay\'] != 0:\r\n                    update.add_(group[\'weight_decay\'], p.data)\r\n\r\n                # LARS\r\n                p_norm = p.data.pow(2).sum().sqrt()\r\n                update_norm = update.pow(2).sum().sqrt()\r\n                phi_p = p_norm.clamp(*self.scale_clip)\r\n                # Compute the local LR\r\n                if phi_p == 0 or update_norm == 0:\r\n                    local_lr = 1\r\n                else:\r\n                    local_lr = phi_p / update_norm\r\n\r\n                state[\'local_lr\'] = local_lr\r\n\r\n                p.data.add_(-group[\'lr\'] * local_lr, update)\r\n\r\n        return loss\r\n'"
pybert/callback/optimizater/sgdw.py,2,"b'import torch\r\nfrom torch.optim.optimizer import Optimizer\r\n\r\nclass SGDW(Optimizer):\r\n    r""""""Implements stochastic gradient descent (optionally with momentum) with\r\n    weight decay from the paper `Fixing Weight Decay Regularization in Adam`_.\r\n\r\n    Nesterov momentum is based on the formula from\r\n    `On the importance of initialization and momentum in deep learning`__.\r\n\r\n    Args:\r\n        params (iterable): iterable of parameters to optimize or dicts defining\r\n            parameter groups\r\n        lr (float): learning rate\r\n        momentum (float, optional): momentum factor (default: 0)\r\n        weight_decay (float, optional): weight decay factor (default: 0)\r\n        dampening (float, optional): dampening for momentum (default: 0)\r\n        nesterov (bool, optional): enables Nesterov momentum (default: False)\r\n\r\n    .. _Fixing Weight Decay Regularization in Adam:\r\n        https://arxiv.org/abs/1711.05101\r\n\r\n    Example:\r\n        >>> model = LSTM()\r\n        >>> optimizer = SGDW(model.parameters(), lr=0.1, momentum=0.9,weight_decay=1e-5)\r\n    """"""\r\n    def __init__(self, params, lr=0.1, momentum=0, dampening=0,\r\n                 weight_decay=0, nesterov=False):\r\n        if lr < 0.0:\r\n            raise ValueError(f""Invalid learning rate: {lr}"")\r\n        if momentum < 0.0:\r\n            raise ValueError(f""Invalid momentum value: {momentum}"")\r\n        if weight_decay < 0.0:\r\n            raise ValueError(f""Invalid weight_decay value: {weight_decay}"")\r\n\r\n        defaults = dict(lr=lr, momentum=momentum, dampening=dampening,\r\n                        weight_decay=weight_decay, nesterov=nesterov)\r\n        if nesterov and (momentum <= 0 or dampening != 0):\r\n            raise ValueError(""Nesterov momentum requires a momentum and zero dampening"")\r\n        super(SGDW, self).__init__(params, defaults)\r\n\r\n    def __setstate__(self, state):\r\n        super(SGDW, self).__setstate__(state)\r\n        for group in self.param_groups:\r\n            group.setdefault(\'nesterov\', False)\r\n\r\n    def step(self, closure=None):\r\n        """"""Performs a single optimization step.\r\n\r\n        Arguments:\r\n            closure (callable, optional): A closure that reevaluates the model\r\n                and returns the loss.\r\n        """"""\r\n        loss = None\r\n        if closure is not None:\r\n            loss = closure()\r\n\r\n        for group in self.param_groups:\r\n            weight_decay = group[\'weight_decay\']\r\n            momentum = group[\'momentum\']\r\n            dampening = group[\'dampening\']\r\n            nesterov = group[\'nesterov\']\r\n            for p in group[\'params\']:\r\n                if p.grad is None:\r\n                    continue\r\n                d_p = p.grad.data\r\n                if momentum != 0:\r\n                    param_state = self.state[p]\r\n                    if \'momentum_buffer\' not in param_state:\r\n                        buf = param_state[\'momentum_buffer\'] = torch.zeros_like(p.data)\r\n                        buf.mul_(momentum).add_(d_p)\r\n                    else:\r\n                        buf = param_state[\'momentum_buffer\']\r\n                        buf.mul_(momentum).add_(1 - dampening, d_p)\r\n                    if nesterov:\r\n                        d_p = d_p.add(momentum, buf)\r\n                    else:\r\n                        d_p = buf\r\n                if weight_decay != 0:\r\n                    p.data.add_(-weight_decay, p.data)\r\n                p.data.add_(-group[\'lr\'], d_p)\r\n        return loss'"
pybert/model/albert/__init__.py,0,b'#encoding:utf-8'
pybert/model/albert/configuration_albert.py,0,"b'"""""" BERT model configuration """"""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\nlogger = logging.getLogger(__name__)\n\nclass AlbertConfig(PretrainedConfig):\n    r""""""\n        Arguments:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `BertModel`.\n            hidden_size: Size of the encoder layers and the pooler layer.\n            num_hidden_layers: Number of hidden layers in the Transformer encoder.\n            num_attention_heads: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n                layer in the Transformer encoder.\n            hidden_act: The non-linear activation function (function or string) in the\n                encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n            hidden_dropout_prob: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attention_probs_dropout_prob: The dropout ratio for the attention\n                probabilities.\n            max_position_embeddings: The maximum sequence length that this model might\n                ever be used with. Typically set this to something large just in case\n                (e.g., 512 or 1024 or 2048).\n            type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n                `BertModel`.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n            layer_norm_eps: The epsilon used by LayerNorm.\n    """"""\n    def __init__(self,\n                 vocab_size_or_config_json_file=30000,\n                 embedding_size=128,\n                 hidden_size=4096,\n                 num_hidden_layers=12,\n                 num_hidden_groups=1,\n                 num_attention_heads=64,\n                 intermediate_size=16384,\n                 inner_group_num=1,\n                 hidden_act=""gelu_new"",\n                 hidden_dropout_prob=0,\n                 attention_probs_dropout_prob=0,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02,\n                 layer_norm_eps=1e-12,\n                 **kwargs):\n        super(AlbertConfig, self).__init__(**kwargs)\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.hidden_size = hidden_size\n            self.num_hidden_layers = num_hidden_layers\n            self.num_attention_heads = num_attention_heads\n            self.hidden_act = hidden_act\n            self.intermediate_size = intermediate_size\n            self.hidden_dropout_prob = hidden_dropout_prob\n            self.attention_probs_dropout_prob = attention_probs_dropout_prob\n            self.max_position_embeddings = max_position_embeddings\n            self.type_vocab_size = type_vocab_size\n            self.initializer_range = initializer_range\n            self.layer_norm_eps = layer_norm_eps\n            self.embedding_size = embedding_size\n            self.inner_group_num = inner_group_num\n            self.num_hidden_groups = num_hidden_groups\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n'"
pybert/model/albert/configuration_bert.py,0,"b'\n"""""" BERT model configuration """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport sys\nfrom io import open\n\nfrom .configuration_utils import PretrainedConfig\n\nlogger = logging.getLogger(__name__)\n\nBERT_PRETRAINED_CONFIG_ARCHIVE_MAP = {}\nclass BertConfig(PretrainedConfig):\n    r""""""\n        :class:`~pytorch_transformers.BertConfig` is the configuration class to store the configuration of a\n        `BertModel`.\n\n\n        Arguments:\n            vocab_size_or_config_json_file: Vocabulary size of `inputs_ids` in `BertModel`.\n            hidden_size: Size of the encoder layers and the pooler layer.\n            num_hidden_layers: Number of hidden layers in the Transformer encoder.\n            num_attention_heads: Number of attention heads for each attention layer in\n                the Transformer encoder.\n            intermediate_size: The size of the ""intermediate"" (i.e., feed-forward)\n                layer in the Transformer encoder.\n            hidden_act: The non-linear activation function (function or string) in the\n                encoder and pooler. If string, ""gelu"", ""relu"" and ""swish"" are supported.\n            hidden_dropout_prob: The dropout probabilitiy for all fully connected\n                layers in the embeddings, encoder, and pooler.\n            attention_probs_dropout_prob: The dropout ratio for the attention\n                probabilities.\n            max_position_embeddings: The maximum sequence length that this model might\n                ever be used with. Typically set this to something large just in case\n                (e.g., 512 or 1024 or 2048).\n            type_vocab_size: The vocabulary size of the `token_type_ids` passed into\n                `BertModel`.\n            initializer_range: The sttdev of the truncated_normal_initializer for\n                initializing all weight matrices.\n            layer_norm_eps: The epsilon used by LayerNorm.\n    """"""\n    pretrained_config_archive_map = BERT_PRETRAINED_CONFIG_ARCHIVE_MAP\n\n    def __init__(self,\n                 vocab_size_or_config_json_file=30522,\n                 hidden_size=768,\n                 num_hidden_layers=12,\n                 num_attention_heads=12,\n                 intermediate_size=3072,\n                 hidden_act=""gelu"",\n                 hidden_dropout_prob=0.1,\n                 attention_probs_dropout_prob=0.1,\n                 max_position_embeddings=512,\n                 type_vocab_size=2,\n                 initializer_range=0.02,\n                 layer_norm_eps=1e-12,\n                 **kwargs):\n        super(BertConfig, self).__init__(**kwargs)\n        if isinstance(vocab_size_or_config_json_file, str) or (sys.version_info[0] == 2\n                        and isinstance(vocab_size_or_config_json_file, unicode)):\n            with open(vocab_size_or_config_json_file, ""r"", encoding=\'utf-8\') as reader:\n                json_config = json.loads(reader.read())\n            for key, value in json_config.items():\n                self.__dict__[key] = value\n        elif isinstance(vocab_size_or_config_json_file, int):\n            self.vocab_size = vocab_size_or_config_json_file\n            self.hidden_size = hidden_size\n            self.num_hidden_layers = num_hidden_layers\n            self.num_attention_heads = num_attention_heads\n            self.hidden_act = hidden_act\n            self.intermediate_size = intermediate_size\n            self.hidden_dropout_prob = hidden_dropout_prob\n            self.attention_probs_dropout_prob = attention_probs_dropout_prob\n            self.max_position_embeddings = max_position_embeddings\n            self.type_vocab_size = type_vocab_size\n            self.initializer_range = initializer_range\n            self.layer_norm_eps = layer_norm_eps\n        else:\n            raise ValueError(""First argument must be either a vocabulary size (int)""\n                             "" or the path to a pretrained model config file (str)"")\n'"
pybert/model/albert/configuration_utils.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n"""""" Configuration base class and utilities.""""""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport copy\nimport json\nimport logging\nimport os\nfrom io import open\n\nfrom .file_utils import cached_path, CONFIG_NAME\n\nlogger = logging.getLogger(__name__)\n\nclass PretrainedConfig(object):\n    r"""""" Base class for all configuration classes.\n        Handles a few parameters tools to all models\' configurations as well as methods for loading/downloading/saving configurations.\n\n        Note:\n            A configuration file can be loaded and saved to disk. Loading the configuration file and using this file to initialize a model does **not** load the model weights.\n            It only affects the model\'s configuration.\n\n        Class attributes (overridden by derived classes):\n            - ``pretrained_config_archive_map``: a python ``dict`` of with `short-cut-names` (string) as keys and `url` (string) of associated pretrained model configurations as values.\n\n        Parameters:\n            ``finetuning_task``: string, default `None`. Name of the task used to fine-tune the model. This can be used when converting from an original (TensorFlow or PyTorch) checkpoint.\n            ``num_labels``: integer, default `2`. Number of classes to use when the model is a classification model (sequences/tokens)\n            ``output_attentions``: boolean, default `False`. Should the model returns attentions weights.\n            ``output_hidden_states``: string, default `False`. Should the model returns all hidden-states.\n            ``torchscript``: string, default `False`. Is the model used with Torchscript.\n    """"""\n    pretrained_config_archive_map = {}\n\n    def __init__(self, **kwargs):\n        self.finetuning_task = kwargs.pop(\'finetuning_task\', None)\n        self.num_labels = kwargs.pop(\'num_labels\', 2)\n        self.output_attentions = kwargs.pop(\'output_attentions\', False)\n        self.output_hidden_states = kwargs.pop(\'output_hidden_states\', False)\n        self.torchscript = kwargs.pop(\'torchscript\', False)\n        self.pruned_heads = kwargs.pop(\'pruned_heads\', {})\n\n    def save_pretrained(self, save_directory):\n        """""" Save a configuration object to the directory `save_directory`, so that it\n            can be re-loaded using the :func:`~pytorch_transformers.PretrainedConfig.from_pretrained` class method.\n        """"""\n        assert os.path.isdir(save_directory), ""Saving path should be a directory where the model and configuration can be saved""\n\n        # If we save using the predefined names, we can load using `from_pretrained`\n        output_config_file = os.path.join(save_directory, CONFIG_NAME)\n\n        self.to_json_file(output_config_file)\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, **kwargs):\n        r"""""" Instantiate a :class:`~pytorch_transformers.PretrainedConfig` (or a derived class) from a pre-trained model configuration.\n\n        Parameters:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model configuration to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing a configuration file saved using the :func:`~pytorch_transformers.PretrainedConfig.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - a path or url to a saved configuration JSON `file`, e.g.: ``./my_model_directory/configuration.json``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            kwargs: (`optional`) dict: key/value pairs with which to update the configuration object after loading.\n\n                - The values in kwargs of any keys which are configuration attributes will be used to override the loaded values.\n                - Behavior concerning key/value pairs whose keys are *not* configuration attributes is controlled by the `return_unused_kwargs` keyword parameter.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            return_unused_kwargs: (`optional`) bool:\n\n                - If False, then this function returns just the final configuration object.\n                - If True, then this functions returns a tuple `(config, unused_kwargs)` where `unused_kwargs` is a dictionary consisting of the key/value pairs whose keys are not configuration attributes: ie the part of kwargs which has not been used to update `config` and is otherwise ignored.\n\n        Examples::\n\n            # We can\'t instantiate directly the base class `PretrainedConfig` so let\'s show the examples on a\n            # derived class: BertConfig\n            config = BertConfig.from_pretrained(\'bert-base-uncased\')    # Download configuration from S3 and cache.\n            config = BertConfig.from_pretrained(\'./test/saved_model/\')  # E.g. config (or model) was saved using `save_pretrained(\'./test/saved_model/\')`\n            config = BertConfig.from_pretrained(\'./test/saved_model/my_configuration.json\')\n            config = BertConfig.from_pretrained(\'bert-base-uncased\', output_attention=True, foo=False)\n            assert config.output_attention == True\n            config, unused_kwargs = BertConfig.from_pretrained(\'bert-base-uncased\', output_attention=True,\n                                                               foo=False, return_unused_kwargs=True)\n            assert config.output_attention == True\n            assert unused_kwargs == {\'foo\': False}\n\n        """"""\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        force_download = kwargs.pop(\'force_download\', False)\n        proxies = kwargs.pop(\'proxies\', None)\n        return_unused_kwargs = kwargs.pop(\'return_unused_kwargs\', False)\n\n        if pretrained_model_name_or_path in cls.pretrained_config_archive_map:\n            config_file = cls.pretrained_config_archive_map[pretrained_model_name_or_path]\n        elif os.path.isdir(pretrained_model_name_or_path):\n            config_file = os.path.join(pretrained_model_name_or_path, CONFIG_NAME)\n        else:\n            config_file = pretrained_model_name_or_path\n        # redirect to the cache, if necessary\n        try:\n            resolved_config_file = cached_path(config_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n        except EnvironmentError as e:\n            if pretrained_model_name_or_path in cls.pretrained_config_archive_map:\n                logger.error(\n                    ""Couldn\'t reach server at \'{}\' to download pretrained model configuration file."".format(\n                        config_file))\n            else:\n                logger.error(\n                    ""Model name \'{}\' was not found in model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url but couldn\'t find any file ""\n                    ""associated to this path or url."".format(\n                        pretrained_model_name_or_path,\n                        \', \'.join(cls.pretrained_config_archive_map.keys()),\n                        config_file))\n            raise e\n        if resolved_config_file == config_file:\n            logger.info(""loading configuration file {}"".format(config_file))\n        else:\n            logger.info(""loading configuration file {} from cache at {}"".format(\n                config_file, resolved_config_file))\n\n        # Load config\n        config = cls.from_json_file(resolved_config_file)\n\n        if hasattr(config, \'pruned_heads\'):\n            config.pruned_heads = dict((int(key), set(value)) for key, value in config.pruned_heads.items())\n\n        # Update config with kwargs if needed\n        to_remove = []\n        for key, value in kwargs.items():\n            if hasattr(config, key):\n                setattr(config, key, value)\n                to_remove.append(key)\n            else:\n                setattr(config,key,value)\n        for key in to_remove:\n            kwargs.pop(key, None)\n\n        logger.info(""Model config %s"", config)\n        if return_unused_kwargs:\n            return config, kwargs\n        else:\n            return config\n\n    @classmethod\n    def from_dict(cls, json_object):\n        """"""Constructs a `Config` from a Python dictionary of parameters.""""""\n        config = cls(vocab_size_or_config_json_file=-1)\n        for key, value in json_object.items():\n            config.__dict__[key] = value\n        return config\n\n    @classmethod\n    def from_json_file(cls, json_file):\n        """"""Constructs a `BertConfig` from a json file of parameters.""""""\n        with open(json_file, ""r"", encoding=\'utf-8\') as reader:\n            text = reader.read()\n        return cls.from_dict(json.loads(text))\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __repr__(self):\n        return str(self.to_json_string())\n\n    def to_dict(self):\n        """"""Serializes this instance to a Python dictionary.""""""\n        output = copy.deepcopy(self.__dict__)\n        return output\n\n    def to_json_string(self):\n        """"""Serializes this instance to a JSON string.""""""\n        return json.dumps(self.to_dict(), indent=2, sort_keys=True) + ""\\n""\n\n    def to_json_file(self, json_file_path):\n        """""" Save this instance to a json file.""""""\n        with open(json_file_path, ""w"", encoding=\'utf-8\') as writer:\n            writer.write(self.to_json_string())\n'"
pybert/model/albert/file_utils.py,1,"b'""""""\nUtilities for working with the local dataset cache.\nThis file is adapted from the AllenNLP library at https://github.com/allenai/allennlp\nCopyright by the AllenNLP authors.\n""""""\nfrom __future__ import (absolute_import, division, print_function, unicode_literals)\n\nimport sys\nimport json\nimport logging\nimport os\nimport six\nimport shutil\nimport tempfile\nimport fnmatch\nfrom functools import wraps\nfrom hashlib import sha256\nfrom io import open\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\nimport requests\nfrom tqdm import tqdm\n\ntry:\n    from torch.hub import _get_torch_home\n    torch_cache_home = _get_torch_home()\nexcept ImportError:\n    torch_cache_home = os.path.expanduser(\n        os.getenv(\'TORCH_HOME\', os.path.join(\n            os.getenv(\'XDG_CACHE_HOME\', \'~/.cache\'), \'torch\')))\ndefault_cache_path = os.path.join(torch_cache_home, \'pytorch_transformers\')\n\ntry:\n    from urllib.parse import urlparse\nexcept ImportError:\n    from urlparse import urlparse\n\ntry:\n    from pathlib import Path\n    PYTORCH_PRETRAINED_BERT_CACHE = Path(\n        os.getenv(\'PYTORCH_TRANSFORMERS_CACHE\', os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\', default_cache_path)))\nexcept (AttributeError, ImportError):\n    PYTORCH_PRETRAINED_BERT_CACHE = os.getenv(\'PYTORCH_TRANSFORMERS_CACHE\',\n                                              os.getenv(\'PYTORCH_PRETRAINED_BERT_CACHE\',\n                                                        default_cache_path))\n\nPYTORCH_TRANSFORMERS_CACHE = PYTORCH_PRETRAINED_BERT_CACHE  # Kept for backward compatibility\n\nWEIGHTS_NAME = ""pytorch_model.bin""\nTF_WEIGHTS_NAME = \'model.ckpt\'\nCONFIG_NAME = ""config.json""\n\nlogger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n\nif not six.PY2:\n    def add_start_docstrings(*docstr):\n        def docstring_decorator(fn):\n            fn.__doc__ = \'\'.join(docstr) + fn.__doc__\n            return fn\n        return docstring_decorator\n\n    def add_end_docstrings(*docstr):\n        def docstring_decorator(fn):\n            fn.__doc__ = fn.__doc__ + \'\'.join(docstr)\n            return fn\n        return docstring_decorator\nelse:\n    # Not possible to update class docstrings on python2\n    def add_start_docstrings(*docstr):\n        def docstring_decorator(fn):\n            return fn\n        return docstring_decorator\n\n    def add_end_docstrings(*docstr):\n        def docstring_decorator(fn):\n            return fn\n        return docstring_decorator\n\ndef url_to_filename(url, etag=None):\n    """"""\n    Convert `url` into a hashed filename in a repeatable way.\n    If `etag` is specified, append its hash to the url\'s, delimited\n    by a period.\n    """"""\n    url_bytes = url.encode(\'utf-8\')\n    url_hash = sha256(url_bytes)\n    filename = url_hash.hexdigest()\n\n    if etag:\n        etag_bytes = etag.encode(\'utf-8\')\n        etag_hash = sha256(etag_bytes)\n        filename += \'.\' + etag_hash.hexdigest()\n\n    return filename\n\n\ndef filename_to_url(filename, cache_dir=None):\n    """"""\n    Return the url and etag (which may be ``None``) stored for `filename`.\n    Raise ``EnvironmentError`` if `filename` or its stored metadata do not exist.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    cache_path = os.path.join(cache_dir, filename)\n    if not os.path.exists(cache_path):\n        raise EnvironmentError(""file {} not found"".format(cache_path))\n\n    meta_path = cache_path + \'.json\'\n    if not os.path.exists(meta_path):\n        raise EnvironmentError(""file {} not found"".format(meta_path))\n\n    with open(meta_path, encoding=""utf-8"") as meta_file:\n        metadata = json.load(meta_file)\n    url = metadata[\'url\']\n    etag = metadata[\'etag\']\n\n    return url, etag\n\n\ndef cached_path(url_or_filename, cache_dir=None, force_download=False, proxies=None):\n    """"""\n    Given something that might be a URL (or might be a local path),\n    determine which. If it\'s a URL, download the file and cache it, and\n    return the path to the cached file. If it\'s already a local path,\n    make sure the file exists and then return the path.\n    Args:\n        cache_dir: specify a cache directory to save the file to (overwrite the default cache dir).\n        force_download: if True, re-dowload the file even if it\'s already cached in the cache dir.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(url_or_filename, Path):\n        url_or_filename = str(url_or_filename)\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n\n    parsed = urlparse(url_or_filename)\n\n    if parsed.scheme in (\'http\', \'https\', \'s3\'):\n        # URL, so get it from the cache (downloading if necessary)\n        return get_from_cache(url_or_filename, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n    elif os.path.exists(url_or_filename):\n        # File, and it exists.\n        return url_or_filename\n    elif parsed.scheme == \'\':\n        # File, but it doesn\'t exist.\n        raise EnvironmentError(""file {} not found"".format(url_or_filename))\n    else:\n        # Something unknown\n        raise ValueError(""unable to parse {} as a URL or as a local path"".format(url_or_filename))\n\n\ndef split_s3_path(url):\n    """"""Split a full s3 path into the bucket name and path.""""""\n    parsed = urlparse(url)\n    if not parsed.netloc or not parsed.path:\n        raise ValueError(""bad s3 path {}"".format(url))\n    bucket_name = parsed.netloc\n    s3_path = parsed.path\n    # Remove \'/\' at beginning of path.\n    if s3_path.startswith(""/""):\n        s3_path = s3_path[1:]\n    return bucket_name, s3_path\n\n\ndef s3_request(func):\n    """"""\n    Wrapper function for s3 requests in order to create more helpful error\n    messages.\n    """"""\n\n    @wraps(func)\n    def wrapper(url, *args, **kwargs):\n        try:\n            return func(url, *args, **kwargs)\n        except ClientError as exc:\n            if int(exc.response[""Error""][""Code""]) == 404:\n                raise EnvironmentError(""file {} not found"".format(url))\n            else:\n                raise\n\n    return wrapper\n\n\n@s3_request\ndef s3_etag(url, proxies=None):\n    """"""Check ETag on S3 object.""""""\n    s3_resource = boto3.resource(""s3"", config=Config(proxies=proxies))\n    bucket_name, s3_path = split_s3_path(url)\n    s3_object = s3_resource.Object(bucket_name, s3_path)\n    return s3_object.e_tag\n\n\n@s3_request\ndef s3_get(url, temp_file, proxies=None):\n    """"""Pull a file directly from S3.""""""\n    s3_resource = boto3.resource(""s3"", config=Config(proxies=proxies))\n    bucket_name, s3_path = split_s3_path(url)\n    s3_resource.Bucket(bucket_name).download_fileobj(s3_path, temp_file)\n\n\ndef http_get(url, temp_file, proxies=None):\n    req = requests.get(url, stream=True, proxies=proxies)\n    content_length = req.headers.get(\'Content-Length\')\n    total = int(content_length) if content_length is not None else None\n    progress = tqdm(unit=""B"", total=total)\n    for chunk in req.iter_content(chunk_size=1024):\n        if chunk: # filter out keep-alive new chunks\n            progress.update(len(chunk))\n            temp_file.write(chunk)\n    progress.close()\n\n\ndef get_from_cache(url, cache_dir=None, force_download=False, proxies=None):\n    """"""\n    Given a URL, look for the corresponding dataset in the local cache.\n    If it\'s not there, download it. Then return the path to the cached file.\n    """"""\n    if cache_dir is None:\n        cache_dir = PYTORCH_TRANSFORMERS_CACHE\n    if sys.version_info[0] == 3 and isinstance(cache_dir, Path):\n        cache_dir = str(cache_dir)\n    if sys.version_info[0] == 2 and not isinstance(cache_dir, str):\n        cache_dir = str(cache_dir)\n\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    # Get eTag to add to filename, if it exists.\n    if url.startswith(""s3://""):\n        etag = s3_etag(url, proxies=proxies)\n    else:\n        try:\n            response = requests.head(url, allow_redirects=True, proxies=proxies)\n            if response.status_code != 200:\n                etag = None\n            else:\n                etag = response.headers.get(""ETag"")\n        except EnvironmentError:\n            etag = None\n\n    if sys.version_info[0] == 2 and etag is not None:\n        etag = etag.decode(\'utf-8\')\n    filename = url_to_filename(url, etag)\n\n    # get cache path to put the file\n    cache_path = os.path.join(cache_dir, filename)\n\n    # If we don\'t have a connection (etag is None) and can\'t identify the file\n    # try to get the last downloaded one\n    if not os.path.exists(cache_path) and etag is None:\n        matching_files = fnmatch.filter(os.listdir(cache_dir), filename + \'.*\')\n        matching_files = list(filter(lambda s: not s.endswith(\'.json\'), matching_files))\n        if matching_files:\n            cache_path = os.path.join(cache_dir, matching_files[-1])\n\n    if not os.path.exists(cache_path) or force_download:\n        # Download to temporary file, then copy to cache dir once finished.\n        # Otherwise you get corrupt cache entries if the download gets interrupted.\n        with tempfile.NamedTemporaryFile() as temp_file:\n            logger.info(""%s not found in cache or force_download set to True, downloading to %s"", url, temp_file.name)\n\n            # GET file object\n            if url.startswith(""s3://""):\n                s3_get(url, temp_file, proxies=proxies)\n            else:\n                http_get(url, temp_file, proxies=proxies)\n\n            # we are copying the file before closing it, so flush to avoid truncation\n            temp_file.flush()\n            # shutil.copyfileobj() starts at the current position, so go to the start\n            temp_file.seek(0)\n\n            logger.info(""copying %s to cache at %s"", temp_file.name, cache_path)\n            with open(cache_path, \'wb\') as cache_file:\n                shutil.copyfileobj(temp_file, cache_file)\n\n            logger.info(""creating metadata file for %s"", cache_path)\n            meta = {\'url\': url, \'etag\': etag}\n            meta_path = cache_path + \'.json\'\n            with open(meta_path, \'w\') as meta_file:\n                output_string = json.dumps(meta)\n                if sys.version_info[0] == 2 and isinstance(output_string, str):\n                    output_string = unicode(output_string, \'utf-8\')  # The beauty of python 2\n                meta_file.write(output_string)\n\n            logger.info(""removing temp file %s"", temp_file.name)\n\n    return cache_path\n'"
pybert/model/albert/modeling_albert.py,81,"b'""""""PyTorch ALBERT model. """"""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\nimport logging\nimport math\nimport os\nimport sys\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss, MSELoss\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer\nfrom .configuration_albert import AlbertConfig\nfrom .file_utils import add_start_docstrings\nlogger = logging.getLogger(__name__)\n\nALBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'albert-base\': """",\n    \'albert-large\': """",\n    \'albert-xlarge\': """",\n    \'albert-xxlarge\': """",\n}\ndef load_tf_weights_in_albert(model, config, tf_checkpoint_path):\n    """""" Load tf checkpoints in a pytorch model.\n    """"""\n    try:\n        import re\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\n                     ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    tf_path = os.path.abspath(tf_checkpoint_path)\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\n    if not os.path.exists(tf_path+\'/checkpoint\'):\n        tf_path = tf_path + ""/variables/variables""\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array)\n    for name, array in zip(names, arrays):\n        name = name.replace(""attention_1"",""attention"")\n        name = name.replace(""ffn_1"",""ffn"")\n        name = name.split(\'/\')\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if any(n in [""adam_v"", ""adam_m"", ""global_step""] for n in name):\n            logger.info(""Skipping {}"".format(""/"".join(name)))\n            continue\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\n                l = re.split(r\'_(\\d+)\', m_name)\n            elif re.fullmatch(r\'[A-Za-z]+_+[A-Za-z]+_\\d+\', m_name):\n                l = re.split(r\'_(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] in [\'LayerNorm\', \'attention\', \'ffn\'] and len(l) >= 2:\n                l = [""_"".join(l[:-1])]\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'output_weights\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'squad\':\n                pointer = getattr(pointer, \'classifier\')\n            else:\n                try:\n                    pointer = getattr(pointer, l[0])\n                except AttributeError:\n                    logger.info(""Skipping {}"".format(""/"".join(name)))\n                    continue\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n\n        if m_name[-11:] == \'_embeddings\':\n            pointer = getattr(pointer, \'weight\')\n        elif m_name == \'kernel\':\n            array = np.transpose(array)\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\ndef gelu(x):\n    """""" Original Implementation of the gelu activation function in Google Bert repo when initially created.\n        For information: OpenAI GPT\'s gelu is slightly different (and gives slightly different results):\n        0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return x * 0.5 * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\ndef gelu_new(x):\n    """""" Implementation of the gelu activation function currently in Google Bert repo (identical to OpenAI GPT).\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish, ""gelu_new"": gelu_new}\nAlbertLayerNorm = torch.nn.LayerNorm\n\nclass AlbertEmbeddings(nn.Module):\n    """"""Construct the embeddings from word, position and token_type embeddings.\n    """"""\n    def __init__(self, config):\n        super(AlbertEmbeddings, self).__init__()\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.embedding_size, padding_idx=0)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.embedding_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.embedding_size)\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        self.LayerNorm = AlbertLayerNorm(config.embedding_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n        words_embeddings = self.word_embeddings(input_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\nclass AlbertSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(AlbertSelfAttention, self).__init__()\n        if config.hidden_size % config.num_attention_heads != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.hidden_size, config.num_attention_heads))\n        self.output_attentions = config.output_attentions\n        self.num_attention_heads = config.num_attention_heads\n        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)\n        self.all_head_size = self.num_attention_heads * self.attention_head_size\n        self.query = nn.Linear(config.hidden_size, self.all_head_size)\n        self.key = nn.Linear(config.hidden_size, self.all_head_size)\n        self.value = nn.Linear(config.hidden_size, self.all_head_size)\n        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)\n\n    def transpose_for_scores(self, x):\n        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)\n        x = x.view(*new_x_shape)\n        return x.permute(0, 2, 1, 3)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        mixed_query_layer = self.query(hidden_states)\n        mixed_key_layer = self.key(hidden_states)\n        mixed_value_layer = self.value(hidden_states)\n\n        query_layer = self.transpose_for_scores(mixed_query_layer)\n        key_layer = self.transpose_for_scores(mixed_key_layer)\n        value_layer = self.transpose_for_scores(mixed_value_layer)\n\n        # Take the dot product between ""query"" and ""key"" to get the raw attention scores.\n        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))\n        attention_scores = attention_scores / math.sqrt(self.attention_head_size)\n        if attention_mask is not None:\n            # Apply the attention mask is (precomputed for all layers in BertModel forward() function)\n            attention_scores = attention_scores + attention_mask\n\n        # Normalize the attention scores to probabilities.\n        attention_probs = nn.Softmax(dim=-1)(attention_scores)\n\n        # This is actually dropping out entire tokens to attend to, which might\n        # seem a bit unusual, but is taken from the original Transformer paper.\n        attention_probs = self.dropout(attention_probs)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attention_probs = attention_probs * head_mask\n\n        context_layer = torch.matmul(attention_probs, value_layer)\n\n        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()\n        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)\n        context_layer = context_layer.view(*new_context_layer_shape)\n        outputs = (context_layer, attention_probs) if self.output_attentions else (context_layer,)\n        return outputs\n\nclass AlbertSelfOutput(nn.Module):\n    def __init__(self, config):\n        super(AlbertSelfOutput, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        return hidden_states\n\nclass AlbertAttention(nn.Module):\n    def __init__(self, config):\n        super(AlbertAttention, self).__init__()\n        self.self = AlbertSelfAttention(config)\n        self.output = AlbertSelfOutput(config)\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.self.num_attention_heads, self.self.attention_head_size)\n        heads = set(heads) - self.pruned_heads  # Convert to set and emove already pruned heads\n        for head in heads:\n            # Compute how many pruned heads are before the head and move the index accordingly\n            head = head - sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n\n        # Prune linear layers\n        self.self.query = prune_linear_layer(self.self.query, index)\n        self.self.key = prune_linear_layer(self.self.key, index)\n        self.self.value = prune_linear_layer(self.self.value, index)\n        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)\n\n        # Update hyper params and store pruned heads\n        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)\n        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def forward(self, input_tensor, attention_mask=None, head_mask=None):\n        self_outputs = self.self(input_tensor, attention_mask, head_mask)\n        attention_output = self.output(self_outputs[0], input_tensor)\n        outputs = (attention_output,self_outputs)\n        return outputs\n\nclass AlbertOutput(nn.Module):\n    def __init__(self, config):\n        super(AlbertOutput, self).__init__()\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        return hidden_states\n\nclass AlbertIntermediate(nn.Module):\n    def __init__(self, config):\n        super(AlbertIntermediate, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)\n        self.output = AlbertOutput(config)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.intermediate_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.intermediate_act_fn = config.hidden_act\n\n    def forward(self, hidden_states):\n        intermediate_output = self.dense(hidden_states)\n        intermediate_output = self.intermediate_act_fn(intermediate_output)\n        output = self.output(intermediate_output)\n        return output\n\nclass AlbertFFN(nn.Module):\n    def __init__(self, config):\n        super(AlbertFFN, self).__init__()\n        self.intermediate = AlbertIntermediate(config)\n\n    def forward(self, attention_output):\n        output = self.intermediate(attention_output)\n        return output\n\nclass AlbertLayer(nn.Module):\n    def __init__(self, config):\n        super(AlbertLayer, self).__init__()\n        self.attention = AlbertAttention(config)\n        self.ffn = AlbertFFN(config)\n        self.LayerNorm = AlbertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.LayerNorm_1 = AlbertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        attention_outputs = self.attention(hidden_states, attention_mask, head_mask)\n        attention_output = self.LayerNorm(attention_outputs[0] + hidden_states)\n        ffn_output = self.ffn(attention_output)\n        ffn_output = self.LayerNorm_1(ffn_output+attention_output)\n        outputs = (ffn_output,) + attention_outputs[1:] # add attentions if we output them\n        return outputs\n\nclass AlbertGroup(nn.Module):\n    def __init__(self, config):\n        super(AlbertGroup, self).__init__()\n        self.inner_group_num = config.inner_group_num\n        self.inner_group = nn.ModuleList([AlbertLayer(config) for _ in range(config.inner_group_num)])\n\n    def forward(self, hidden_states, attention_mask, head_mask):\n        layer_attentions = ()\n        layer_hidden_states = ()\n        for inner_group_idx in range(self.inner_group_num):\n            layer_module = self.inner_group[inner_group_idx]\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask)\n            hidden_states = layer_outputs[0]\n            layer_attentions = layer_attentions + (layer_outputs[1],)\n            layer_hidden_states = layer_hidden_states + (hidden_states,)\n        return (layer_hidden_states, layer_attentions)\n\nclass AlbertTransformer(nn.Module):\n    def __init__(self, config):\n        super(AlbertTransformer, self).__init__()\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n        self.num_hidden_layers = config.num_hidden_layers\n        self.num_hidden_groups = config.num_hidden_groups\n        self.group = nn.ModuleList([AlbertGroup(config) for _ in range(config.num_hidden_groups)])\n\n    def forward(self, hidden_states, attention_mask, head_mask):\n        all_hidden_states = ()\n        all_attentions = ()\n        for layer_idx in range(self.num_hidden_layers):\n            if self.output_hidden_states and layer_idx == 0:\n                all_hidden_states = all_hidden_states + (hidden_states,)\n            group_idx = int(layer_idx / self.num_hidden_layers * self.num_hidden_groups)\n            layer_module = self.group[group_idx]\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask[layer_idx])\n            hidden_states = layer_outputs[0][-1]\n            if self.output_attentions:\n                all_attentions = all_attentions + layer_outputs[1]\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + layer_outputs[0]\n        outputs = (hidden_states,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\n\nclass AlbertEncoder(nn.Module):\n    def __init__(self, config):\n        super(AlbertEncoder, self).__init__()\n        self.hidden_size = config.hidden_size\n        self.embedding_size = config.embedding_size\n        self.embedding_hidden_mapping_in = nn.Linear(self.embedding_size, self.hidden_size)\n        self.transformer = AlbertTransformer(config)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        if self.embedding_size != self.hidden_size:\n            prev_output = self.embedding_hidden_mapping_in(hidden_states)\n        else:\n            prev_output = hidden_states\n        outputs = self.transformer(prev_output, attention_mask, head_mask)\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\n\nclass AlbertPooler(nn.Module):\n    def __init__(self, config):\n        super(AlbertPooler, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\nclass AlbertPredictionHeadTransform(nn.Module):\n    def __init__(self, config):\n        super(AlbertPredictionHeadTransform, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.embedding_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.transform_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.transform_act_fn = config.hidden_act\n        self.LayerNorm = AlbertLayerNorm(config.embedding_size, eps=config.layer_norm_eps)\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.transform_act_fn(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states)\n        return hidden_states\n\nclass AlbertLMPredictionHead(nn.Module):\n    def __init__(self, config):\n        super(AlbertLMPredictionHead, self).__init__()\n        self.transform = AlbertPredictionHeadTransform(config)\n        # The output weights are the same as the input embeddings, but there is\n        # an output-only bias for each token.\n        self.decoder = nn.Linear(config.embedding_size,config.vocab_size,bias=False)\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\n\n    def forward(self, hidden_states):\n        hidden_states = self.transform(hidden_states)\n        hidden_states = self.decoder(hidden_states) + self.bias\n        return hidden_states\n\nclass AlbertOnlyMLMHead(nn.Module):\n    def __init__(self, config):\n        super(AlbertOnlyMLMHead, self).__init__()\n        self.predictions = AlbertLMPredictionHead(config)\n\n    def forward(self, sequence_output):\n        prediction_scores = self.predictions(sequence_output)\n        return prediction_scores\n\nclass AlbertOnlyNSPHead(nn.Module):\n    def __init__(self, config):\n        super(AlbertOnlyNSPHead, self).__init__()\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, pooled_output):\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return seq_relationship_score\n\nclass AlbertPreTrainingHeads(nn.Module):\n    def __init__(self, config):\n        super(AlbertPreTrainingHeads, self).__init__()\n        self.predictions = AlbertLMPredictionHead(config)\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, sequence_output, pooled_output):\n        prediction_scores = self.predictions(sequence_output)\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return prediction_scores, seq_relationship_score\n\nclass AlbertPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = AlbertConfig\n    pretrained_model_archive_map = ALBERT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_albert\n    base_model_prefix = ""bert""\n\n    def _init_weights(self, module):\n        """""" Initialize the weights """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, AlbertLayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n\nALBERT_START_DOCSTRING = r""""""    The ALBERT model was proposed in\n    `ALBERT: A Lite BERT for Self-supervised Learning of Language Representations`_\n    by Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, Radu Soricut. \n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n    .. _`BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`:\n        https://arxiv.org/abs/1909.11942\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n    Parameters:\n        config (:class:`~transformers.ALbertConfig`): Model configuration class with all the parameters of the model. \n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nALBERT_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            To match pre-training, ALBERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n            (a) For sequence pairs:\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\n            (b) For single sequences:\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n                ``token_type_ids:   0   0   0   0  0     0   0``\n            ALBert is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n            Indices can be obtained using :class:`transformers.BertTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n            corresponds to a `sentence B` token\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare Albert Model transformer outputting raw hidden-states without any specific head on top."",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertModel(AlbertPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\n            Last layer hidden-state of the first token of the sequence (classification token)\n            further processed by a Linear layer and a Tanh activation function. The Linear\n            layer weights are trained from the next sentence prediction (classification)\n            objective during Bert pretraining. This output is usually *not* a good summary\n            of the semantic content of the input, you\'re often better with averaging or pooling\n            the sequence of hidden-states for the whole input sequence.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertModel.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n    """"""\n\n    def __init__(self, config):\n        super(AlbertModel, self).__init__(config)\n\n        self.embeddings = AlbertEmbeddings(config)\n        self.encoder = AlbertEncoder(config)\n        self.pooler = AlbertPooler(config)\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        old_embeddings = self.embeddings.word_embeddings\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\n        self.embeddings.word_embeddings = new_embeddings\n        return self.embeddings.word_embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype)  # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(\n                    -1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(\n                dtype=next(self.parameters()).dtype)  # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.num_hidden_layers\n\n        embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids)\n        encoder_outputs = self.encoder(embedding_output,\n                                       extended_attention_mask,\n                                       head_mask=head_mask)\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output)\n\n        outputs = (sequence_output, pooled_output,) + encoder_outputs[\n                                                      1:]  # add hidden_states and attentions if they are here\n        return outputs  # sequence_output, pooled_output, (hidden_states), (attentions)\n\n@add_start_docstrings(""""""Bert Model with two heads on top as done during the pre-training:\n    a `masked language modeling` head and a `next sentence prediction (classification)` head. """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertForPreTraining(AlbertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when both ``masked_lm_labels`` and ``next_sentence_label`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total loss as the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForPreTraining.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        prediction_scores, seq_relationship_scores = outputs[:2]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForPreTraining, self).__init__(config)\n        self.bert = AlbertModel(config)\n        self.cls = AlbertPreTrainingHeads(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None, next_sentence_label=None):\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        sequence_output, pooled_output = outputs[:2]\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\n\n        outputs = (prediction_scores, seq_relationship_score,) + outputs[\n                                                                 2:]  # add hidden states and attention if they are here\n\n        if masked_lm_labels is not None and next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            total_loss = masked_lm_loss + next_sentence_loss\n            outputs = (total_loss,) + outputs\n        return outputs  # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\n\n@add_start_docstrings(""""""Bert Model with a `language modeling` head on top. """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertForMaskedLM(AlbertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMaskedLM.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForMaskedLM, self).__init__(config)\n\n        self.bert = AlbertModel(config)\n        self.cls = AlbertOnlyMLMHead(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None):\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n        prediction_scores = self.cls(sequence_output)\n\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            outputs = (masked_lm_loss,) + outputs\n\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `next sentence prediction (classification)` head on top. """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertForNextSentencePrediction(AlbertPreTrainedModel):\n    r""""""\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``next_sentence_label`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Next sequence prediction (classification) loss.\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForNextSentencePrediction.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        seq_relationship_scores = outputs[0]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForNextSentencePrediction, self).__init__(config)\n\n        self.bert = AlbertModel(config)\n        self.cls = AlbertOnlyNSPHead(config)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                next_sentence_label=None):\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        seq_relationship_score = self.cls(pooled_output)\n\n        outputs = (seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n        if next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            outputs = (next_sentence_loss,) + outputs\n\n        return outputs  # (next_sentence_loss), seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertForSequenceClassification(AlbertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = AlbertModel(config)\n        self.dropout = nn.Dropout(0.1 if config.hidden_dropout_prob == 0 else config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, self.config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output+0.1)\n        logits = self.classifier(pooled_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a multiple choice classification head on top (a linear layer on top of\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertForMultipleChoice(AlbertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above).\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMultipleChoice.from_pretrained(\'bert-base-uncased\')\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, classification_scores = outputs[:2]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForMultipleChoice, self).__init__(config)\n\n        self.bert = AlbertModel(config)\n        self.dropout = nn.Dropout(0.1 if config.hidden_dropout_prob == 0 else config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n        num_choices = input_ids.shape[1]\n\n        input_ids = input_ids.view(-1, input_ids.size(-1))\n        attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\n        token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\n        position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n        pooled_output = outputs[1]\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, num_choices)\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a token classification head on top (a linear layer on top of\n    the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks. """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\n\nclass AlbertForTokenClassification(AlbertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the token classification loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.num_labels)``\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForTokenClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, scores = outputs[:2]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForTokenClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = AlbertModel(config)\n        self.dropout = nn.Dropout(0.1 if config.hidden_dropout_prob == 0 else config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        sequence_output = self.dropout(sequence_output)\n        logits = self.classifier(sequence_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            # Only keep active parts of the loss\n            if attention_mask is not None:\n                active_loss = attention_mask.view(-1) == 1\n                active_logits = logits.view(-1, self.num_labels)[active_loss]\n                active_labels = labels.view(-1)[active_loss]\n                loss = loss_fct(active_logits, active_labels)\n            else:\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n                      ALBERT_START_DOCSTRING, ALBERT_INPUTS_DOCSTRING)\nclass AlbertForQuestionAnswering(AlbertPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n    Examples::\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForQuestionAnswering.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n    """"""\n\n    def __init__(self, config):\n        super(AlbertForQuestionAnswering, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = AlbertModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                start_positions=None, end_positions=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        outputs = (start_logits, end_logits,) + outputs[2:]\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\n'"
pybert/model/albert/modeling_albert_bright.py,74,"b'""""""PyTorch brightmart version  ALBERT model. """"""\r\nfrom __future__ import absolute_import, division, print_function, unicode_literals\r\n\r\nimport logging\r\nimport os\r\n\r\nimport torch\r\nfrom torch import nn\r\nfrom torch.nn import CrossEntropyLoss, MSELoss\r\n\r\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer\r\nfrom .configuration_albert import AlbertConfig\r\nfrom .file_utils import add_start_docstrings\r\nfrom .modeling_bert import (ACT2FN,\r\n                            BertSelfAttention,\r\n                            BertIntermediate,\r\n                            BertPooler,\r\n                            BertPredictionHeadTransform)\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nALBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\r\n    \'albert-base\': """",\r\n    \'albert-large\': """",\r\n    \'albert-xlarge\': """",\r\n    \'albert-xxlarge\': """",\r\n}\r\ndef load_tf_weights_in_albert(model, config, tf_checkpoint_path):\r\n    """""" Load tf checkpoints in a pytorch model.\r\n    """"""\r\n    try:\r\n        import re\r\n        import numpy as np\r\n        import tensorflow as tf\r\n    except ImportError:\r\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\r\n                     ""https://www.tensorflow.org/install/ for installation instructions."")\r\n        raise\r\n    tf_path = os.path.abspath(tf_checkpoint_path)\r\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\r\n    # Load weights from TF model\r\n    init_vars = tf.train.list_variables(tf_path)\r\n    names = []\r\n    arrays = []\r\n    for name, shape in init_vars:\r\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\r\n        array = tf.train.load_variable(tf_path, name)\r\n        names.append(name)\r\n        arrays.append(array)\r\n    for name, array in zip(names, arrays):\r\n        name = name.split(\'/\')\r\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\r\n        # which are not required for using pretrained model\r\n        if any(n in [""adam_v"", ""adam_m"", ""global_step""] for n in name):\r\n            logger.info(""Skipping {}"".format(""/"".join(name)))\r\n            continue\r\n        pointer = model\r\n        for m_name in name:\r\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\r\n                l = re.split(r\'_(\\d+)\', m_name)\r\n            else:\r\n                l = [m_name]\r\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\r\n                pointer = getattr(pointer, \'weight\')\r\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\r\n                pointer = getattr(pointer, \'bias\')\r\n            elif l[0] == \'output_weights\':\r\n                pointer = getattr(pointer, \'weight\')\r\n            elif l[0] == \'squad\':\r\n                pointer = getattr(pointer, \'classifier\')\r\n            else:\r\n                try:\r\n                    pointer = getattr(pointer, l[0])\r\n                except AttributeError:\r\n                    logger.info(""Skipping {}"".format(""/"".join(name)))\r\n                    continue\r\n            if len(l) >= 2:\r\n                num = int(l[1])\r\n                pointer = pointer[num]\r\n        if m_name[-11:] == \'_embeddings\':\r\n            pointer = getattr(pointer, \'weight\')\r\n        elif m_name[-13:] == \'_embeddings_2\':\r\n            pointer = getattr(pointer, \'weight\')\r\n            array = np.transpose(array)\r\n        elif m_name == \'kernel\':\r\n            array = np.transpose(array)\r\n        try:\r\n            assert pointer.shape == array.shape\r\n        except AssertionError as e:\r\n            e.args += (pointer.shape, array.shape)\r\n            raise\r\n        logger.info(""Initialize PyTorch weight {}"".format(name))\r\n        pointer.data = torch.from_numpy(array)\r\n    return model\r\n\r\nAlbertLayerNorm = torch.nn.LayerNorm\r\nclass AlbertEmbeddings(nn.Module):\r\n    """"""Construct the embeddings from word, position and token_type embeddings.\r\n    """"""\r\n    def __init__(self, config):\r\n        super(AlbertEmbeddings, self).__init__()\r\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.embedding_size, padding_idx=0)\r\n        # project layer\r\n        self.word_embeddings_2 = nn.Linear(config.embedding_size, config.hidden_size, bias=False)\r\n\r\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\r\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\r\n\r\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\r\n        # any TensorFlow checkpoint file\r\n        self.LayerNorm =AlbertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n\r\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\r\n        seq_length = input_ids.size(1)\r\n        if position_ids is None:\r\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\r\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\r\n        if token_type_ids is None:\r\n            token_type_ids = torch.zeros_like(input_ids)\r\n\r\n        words_embeddings = self.word_embeddings(input_ids)\r\n        # project transform\r\n        words_embeddings = self.word_embeddings_2(words_embeddings)\r\n        position_embeddings = self.position_embeddings(position_ids)\r\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\r\n\r\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\r\n        embeddings = self.LayerNorm(embeddings)\r\n        embeddings = self.dropout(embeddings)\r\n        return embeddings\r\n\r\nclass AlbertSelfOutput(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertSelfOutput, self).__init__()\r\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\r\n        self.LayerNorm = AlbertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n\r\n    def forward(self, hidden_states, input_tensor):\r\n        hidden_states = self.dense(hidden_states)\r\n        hidden_states = self.dropout(hidden_states)\r\n        # postln\r\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\r\n        return hidden_states\r\n\r\n\r\nclass AlbertAttention(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertAttention, self).__init__()\r\n        self.self = BertSelfAttention(config)\r\n        self.output = AlbertSelfOutput(config)\r\n        self.pruned_heads = set()\r\n\r\n    def prune_heads(self, heads):\r\n        if len(heads) == 0:\r\n            return\r\n        mask = torch.ones(self.self.num_attention_heads, self.self.attention_head_size)\r\n        heads = set(heads) - self.pruned_heads  # Convert to set and emove already pruned heads\r\n        for head in heads:\r\n            # Compute how many pruned heads are before the head and move the index accordingly\r\n            head = head - sum(1 if h < head else 0 for h in self.pruned_heads)\r\n            mask[head] = 0\r\n        mask = mask.view(-1).contiguous().eq(1)\r\n        index = torch.arange(len(mask))[mask].long()\r\n\r\n        # Prune linear layers\r\n        self.self.query = prune_linear_layer(self.self.query, index)\r\n        self.self.key = prune_linear_layer(self.self.key, index)\r\n        self.self.value = prune_linear_layer(self.self.value, index)\r\n        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)\r\n\r\n        # Update hyper params and store pruned heads\r\n        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)\r\n        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads\r\n        self.pruned_heads = self.pruned_heads.union(heads)\r\n\r\n    def forward(self, input_tensor, attention_mask=None, head_mask=None):\r\n        # postln\r\n        self_outputs = self.self(input_tensor, attention_mask, head_mask)\r\n        attention_output = self.output(self_outputs[0], input_tensor)\r\n        outputs = (attention_output,) + self_outputs[1:]  # add attentions if we output them\r\n        return outputs\r\n\r\nclass AlbertOutput(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertOutput, self).__init__()\r\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\r\n        self.LayerNorm = AlbertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n\r\n    def forward(self, hidden_states, input_tensor):\r\n        hidden_states = self.dense(hidden_states)\r\n        hidden_states = self.dropout(hidden_states)\r\n        # postln\r\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\r\n        return hidden_states\r\n\r\nclass BertLayer(nn.Module):\r\n    def __init__(self, config):\r\n        super(BertLayer, self).__init__()\r\n        self.attention = AlbertAttention(config)\r\n        self.intermediate = BertIntermediate(config)\r\n        self.output = AlbertOutput(config)\r\n\r\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\r\n        attention_outputs = self.attention(hidden_states, attention_mask, head_mask)\r\n        attention_output = attention_outputs[0]\r\n        # postln\r\n        attention_output_pre = attention_output\r\n        intermediate_output = self.intermediate(attention_output_pre)\r\n        layer_output = self.output(intermediate_output, attention_output)\r\n        outputs = (layer_output,) + attention_outputs[1:]  # add attentions if we output them\r\n        return outputs\r\n\r\nclass AlbertEncoder(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertEncoder, self).__init__()\r\n        self.output_attentions = config.output_attentions\r\n        self.output_hidden_states = config.output_hidden_states\r\n        self.num_hidden_layers = config.num_hidden_layers\r\n        self.layer_shared = BertLayer(config)\r\n\r\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\r\n        all_hidden_states = ()\r\n        all_attentions = ()\r\n        for i in range(self.num_hidden_layers):\r\n            layer_module = self.layer_shared\r\n            if self.output_hidden_states:\r\n                all_hidden_states = all_hidden_states + (hidden_states,)\r\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask[i])\r\n            hidden_states = layer_outputs[0]\r\n\r\n            if self.output_attentions:\r\n                all_attentions = all_attentions + (layer_outputs[1],)\r\n        # Add last layer\r\n        if self.output_hidden_states:\r\n            all_hidden_states = all_hidden_states + (hidden_states,)\r\n        outputs = (hidden_states,)\r\n        if self.output_hidden_states:\r\n            outputs = outputs + (all_hidden_states,)\r\n        if self.output_attentions:\r\n            outputs = outputs + (all_attentions,)\r\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\r\n\r\nclass AlbertLMPredictionHead(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertLMPredictionHead, self).__init__()\r\n        self.transform = BertPredictionHeadTransform(config)\r\n        # The output weights are the same as the input embeddings, but there is\r\n        # an output-only bias for each token.\r\n        self.project_layer = nn.Linear(config.hidden_size, config.embedding_size, bias=False)\r\n        self.decoder = nn.Linear(config.embedding_size,\r\n                                 config.vocab_size,\r\n                                 bias=False)\r\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\r\n\r\n    def forward(self, hidden_states):\r\n        hidden_states = self.transform(hidden_states)\r\n        hidden_states = self.project_layer(hidden_states)\r\n        hidden_states = self.decoder(hidden_states) + self.bias\r\n        return hidden_states\r\n\r\nclass AlbertOnlyMLMHead(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertOnlyMLMHead, self).__init__()\r\n        self.predictions = AlbertLMPredictionHead(config)\r\n\r\n    def forward(self, sequence_output):\r\n        prediction_scores = self.predictions(sequence_output)\r\n        return prediction_scores\r\n\r\nclass AlbertOnlyNSPHead(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertOnlyNSPHead, self).__init__()\r\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\r\n\r\n    def forward(self, pooled_output):\r\n        seq_relationship_score = self.seq_relationship(pooled_output)\r\n        return seq_relationship_score\r\n\r\nclass AlbertPreTrainingHeads(nn.Module):\r\n    def __init__(self, config):\r\n        super(AlbertPreTrainingHeads, self).__init__()\r\n        self.predictions = AlbertLMPredictionHead(config)\r\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\r\n\r\n    def forward(self, sequence_output, pooled_output):\r\n        prediction_scores = self.predictions(sequence_output)\r\n        seq_relationship_score = self.seq_relationship(pooled_output)\r\n        return prediction_scores, seq_relationship_score\r\n\r\nclass AlbertPreTrainedModel(PreTrainedModel):\r\n    """""" An abstract class to handle weights initialization and\r\n        a simple interface for dowloading and loading pretrained models.\r\n    """"""\r\n    config_class = AlbertConfig\r\n    pretrained_model_archive_map = ALBERT_PRETRAINED_MODEL_ARCHIVE_MAP\r\n    load_tf_weights = load_tf_weights_in_albert\r\n    base_model_prefix = ""bert""\r\n\r\n    def _init_weights(self, module):\r\n        """""" Initialize the weights """"""\r\n        if isinstance(module, (nn.Linear, nn.Embedding)):\r\n            # Slightly different from the TF version which uses truncated_normal for initialization\r\n            # cf https://github.com/pytorch/pytorch/pull/5617\r\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\r\n        elif isinstance(module, AlbertLayerNorm):\r\n            module.bias.data.zero_()\r\n            module.weight.data.fill_(1.0)\r\n        if isinstance(module, nn.Linear) and module.bias is not None:\r\n            module.bias.data.zero_()\r\n\r\nBERT_START_DOCSTRING = r""""""    The BERT model was proposed in\r\n    `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_\r\n    by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. It\'s a bidirectional transformer\r\n    pre-trained using a combination of masked language modeling objective and next sentence prediction\r\n    on a large corpus comprising the Toronto Book Corpus and Wikipedia.\r\n\r\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\r\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\r\n\r\n    .. _`BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`:\r\n        https://arxiv.org/abs/1810.04805\r\n\r\n    .. _`torch.nn.Module`:\r\n        https://pytorch.org/docs/stable/nn.html#module\r\n\r\n    Parameters:\r\n        config (:class:`~transformers.BertConfig`): Model configuration class with all the parameters of the model. \r\n            Initializing with a config file does not load the weights associated with the model, only the configuration.\r\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\r\n""""""\r\n\r\nBERT_INPUTS_DOCSTRING = r""""""\r\n    Inputs:\r\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Indices of input sequence tokens in the vocabulary.\r\n            To match pre-training, BERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\r\n\r\n            (a) For sequence pairs:\r\n\r\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\r\n\r\n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\r\n\r\n            (b) For single sequences:\r\n\r\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\r\n\r\n                ``token_type_ids:   0   0   0   0  0     0   0``\r\n\r\n            Bert is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\r\n            the right rather than the left.\r\n\r\n            Indices can be obtained using :class:`transformers.BertTokenizer`.\r\n            See :func:`transformers.PreTrainedTokenizer.encode` and\r\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\r\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Mask to avoid performing attention on padding token indices.\r\n            Mask values selected in ``[0, 1]``:\r\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\r\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Segment token indices to indicate first and second portions of the inputs.\r\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\r\n            corresponds to a `sentence B` token\r\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\r\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Indices of positions of each input sequence tokens in the position embeddings.\r\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\r\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\r\n            Mask to nullify selected heads of the self-attention modules.\r\n            Mask values selected in ``[0, 1]``:\r\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\r\n""""""\r\n\r\n\r\n@add_start_docstrings(""The bare Bert Model transformer outputting raw hidden-states without any specific head on top."",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertModel(AlbertPreTrainedModel):\r\n    r""""""\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\r\n            Sequence of hidden-states at the output of the last layer of the model.\r\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\r\n            Last layer hidden-state of the first token of the sequence (classification token)\r\n            further processed by a Linear layer and a Tanh activation function. The Linear\r\n            layer weights are trained from the next sentence prediction (classification)\r\n            objective during Bert pretraining. This output is usually *not* a good summary\r\n            of the semantic content of the input, you\'re often better with averaging or pooling\r\n            the sequence of hidden-states for the whole input sequence.\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertModel.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids)\r\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertModel, self).__init__(config)\r\n\r\n        self.embeddings = AlbertEmbeddings(config)\r\n        self.encoder = AlbertEncoder(config)\r\n        self.pooler = BertPooler(config)\r\n\r\n        self.init_weights()\r\n\r\n    def _resize_token_embeddings(self, new_num_tokens):\r\n        old_embeddings = self.embeddings.word_embeddings\r\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\r\n        self.embeddings.word_embeddings = new_embeddings\r\n        return self.embeddings.word_embeddings\r\n\r\n    def _prune_heads(self, heads_to_prune):\r\n        """""" Prunes heads of the model.\r\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\r\n            See base class PreTrainedModel\r\n        """"""\r\n        for layer, heads in heads_to_prune.items():\r\n            self.encoder.layer[layer].attention.prune_heads(heads)\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\r\n        if attention_mask is None:\r\n            attention_mask = torch.ones_like(input_ids)\r\n        if token_type_ids is None:\r\n            token_type_ids = torch.zeros_like(input_ids)\r\n\r\n        # We create a 3D attention mask from a 2D tensor mask.\r\n        # Sizes are [batch_size, 1, 1, to_seq_length]\r\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\r\n        # this attention mask is more simple than the triangular masking of causal attention\r\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\r\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\r\n\r\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\r\n        # masked positions, this operation will create a tensor which is 0.0 for\r\n        # positions we want to attend and -10000.0 for masked positions.\r\n        # Since we are adding it to the raw scores before the softmax, this is\r\n        # effectively the same as removing these entirely.\r\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype)  # fp16 compatibility\r\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\r\n\r\n        # Prepare head mask if needed\r\n        # 1.0 in head_mask indicate we keep the head\r\n        # attention_probs has shape bsz x n_heads x N x N\r\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\r\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\r\n        if head_mask is not None:\r\n            if head_mask.dim() == 1:\r\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\r\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\r\n            elif head_mask.dim() == 2:\r\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(\r\n                    -1)  # We can specify head_mask for each layer\r\n            head_mask = head_mask.to(\r\n                dtype=next(self.parameters()).dtype)  # switch to fload if need + fp16 compatibility\r\n        else:\r\n            head_mask = [None] * self.config.num_hidden_layers\r\n\r\n        embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids)\r\n        encoder_outputs = self.encoder(embedding_output,\r\n                                       extended_attention_mask,\r\n                                       head_mask=head_mask)\r\n        sequence_output = encoder_outputs[0]\r\n        pooled_output = self.pooler(sequence_output)\r\n\r\n        outputs = (sequence_output, pooled_output,) + encoder_outputs[\r\n                                                      1:]  # add hidden_states and attentions if they are here\r\n        return outputs  # sequence_output, pooled_output, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with two heads on top as done during the pre-training:\r\n    a `masked language modeling` head and a `next sentence prediction (classification)` head. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForPreTraining(AlbertPreTrainedModel):\r\n    r""""""\r\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Labels for computing the masked language modeling loss.\r\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\r\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\r\n            in ``[0, ..., config.vocab_size]``\r\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\r\n            Indices should be in ``[0, 1]``.\r\n            ``0`` indicates sequence B is a continuation of sequence A,\r\n            ``1`` indicates sequence B is a random sequence.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when both ``masked_lm_labels`` and ``next_sentence_label`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Total loss as the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\r\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\r\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\r\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\r\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForPreTraining.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids)\r\n        prediction_scores, seq_relationship_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForPreTraining, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.cls = AlbertPreTrainingHeads(config)\r\n\r\n        self.init_weights()\r\n        self.tie_weights()\r\n\r\n    def tie_weights(self):\r\n        """""" Make sure we are sharing the input and output embeddings.\r\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\r\n        """"""\r\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\r\n                                       self.bert.embeddings.word_embeddings)\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                masked_lm_labels=None, next_sentence_label=None):\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output, pooled_output = outputs[:2]\r\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\r\n\r\n        outputs = (prediction_scores, seq_relationship_score,) + outputs[\r\n                                                                 2:]  # add hidden states and attention if they are here\r\n\r\n        if masked_lm_labels is not None and next_sentence_label is not None:\r\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\r\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\r\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\r\n            total_loss = masked_lm_loss + next_sentence_loss\r\n            outputs = (total_loss,) + outputs\r\n\r\n        return outputs  # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a `language modeling` head on top. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForMaskedLM(AlbertPreTrainedModel):\r\n    r""""""\r\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Labels for computing the masked language modeling loss.\r\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\r\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\r\n            in ``[0, ..., config.vocab_size]``\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Masked language modeling loss.\r\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\r\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForMaskedLM.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, masked_lm_labels=input_ids)\r\n        loss, prediction_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForMaskedLM, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.cls = AlbertOnlyMLMHead(config)\r\n\r\n        self.init_weights()\r\n        self.tie_weights()\r\n\r\n    def tie_weights(self):\r\n        """""" Make sure we are sharing the input and output embeddings.\r\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\r\n        """"""\r\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\r\n                                   self.bert.embeddings.word_embeddings)\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                masked_lm_labels=None):\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output = outputs[0]\r\n        prediction_scores = self.cls(sequence_output)\r\n\r\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\r\n        if masked_lm_labels is not None:\r\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\r\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\r\n            outputs = (masked_lm_loss,) + outputs\r\n\r\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a `next sentence prediction (classification)` head on top. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForNextSentencePrediction(AlbertPreTrainedModel):\r\n    r""""""\r\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\r\n            Indices should be in ``[0, 1]``.\r\n            ``0`` indicates sequence B is a continuation of sequence A,\r\n            ``1`` indicates sequence B is a random sequence.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``next_sentence_label`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Next sequence prediction (classification) loss.\r\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\r\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForNextSentencePrediction.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids)\r\n        seq_relationship_scores = outputs[0]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForNextSentencePrediction, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.cls = AlbertOnlyNSPHead(config)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                next_sentence_label=None):\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        pooled_output = outputs[1]\r\n\r\n        seq_relationship_score = self.cls(pooled_output)\r\n\r\n        outputs = (seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\r\n        if next_sentence_label is not None:\r\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\r\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\r\n            outputs = (next_sentence_loss,) + outputs\r\n\r\n        return outputs  # (next_sentence_loss), seq_relationship_score, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of\r\n    the pooled output) e.g. for GLUE tasks. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForSequenceClassification(AlbertPreTrainedModel):\r\n    r""""""\r\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the sequence classification/regression loss.\r\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\r\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\r\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Classification (or regression if config.num_labels==1) loss.\r\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\r\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, labels=labels)\r\n        loss, logits = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForSequenceClassification, self).__init__(config)\r\n        self.num_labels = config.num_labels\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, self.config.num_labels)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\r\n                position_ids=None, head_mask=None, labels=None):\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        pooled_output = outputs[1]\r\n\r\n        pooled_output = self.dropout(pooled_output)\r\n        logits = self.classifier(pooled_output)\r\n\r\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\r\n\r\n        if labels is not None:\r\n            if self.num_labels == 1:\r\n                #  We are doing regression\r\n                loss_fct = MSELoss()\r\n                loss = loss_fct(logits.view(-1), labels.view(-1))\r\n            else:\r\n                loss_fct = CrossEntropyLoss()\r\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\r\n            outputs = (loss,) + outputs\r\n\r\n        return outputs  # (loss), logits, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a multiple choice classification head on top (a linear layer on top of\r\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForMultipleChoice(AlbertPreTrainedModel):\r\n    r""""""\r\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for computing the multiple choice classification loss.\r\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\r\n            of the input tensors. (see `input_ids` above)\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Classification loss.\r\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\r\n            of the input tensors. (see `input_ids` above).\r\n            Classification scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForMultipleChoice.from_pretrained(\'bert-base-uncased\')\r\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\r\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\r\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, labels=labels)\r\n        loss, classification_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForMultipleChoice, self).__init__(config)\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, 1)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\r\n                position_ids=None, head_mask=None, labels=None):\r\n        num_choices = input_ids.shape[1]\r\n\r\n        input_ids = input_ids.view(-1, input_ids.size(-1))\r\n        attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\r\n        token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\r\n        position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        pooled_output = outputs[1]\r\n\r\n        pooled_output = self.dropout(pooled_output)\r\n        logits = self.classifier(pooled_output)\r\n        reshaped_logits = logits.view(-1, num_choices)\r\n\r\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\r\n\r\n        if labels is not None:\r\n            loss_fct = CrossEntropyLoss()\r\n            loss = loss_fct(reshaped_logits, labels)\r\n            outputs = (loss,) + outputs\r\n\r\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a token classification head on top (a linear layer on top of\r\n    the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks. """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForTokenClassification(AlbertPreTrainedModel):\r\n    r""""""\r\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\r\n            Labels for computing the token classification loss.\r\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Classification loss.\r\n        **scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.num_labels)``\r\n            Classification scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForTokenClassification.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        labels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\r\n        outputs = model(input_ids, labels=labels)\r\n        loss, scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForTokenClassification, self).__init__(config)\r\n        self.num_labels = config.num_labels\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\r\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\r\n                position_ids=None, head_mask=None, labels=None):\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output = outputs[0]\r\n\r\n        sequence_output = self.dropout(sequence_output)\r\n        logits = self.classifier(sequence_output)\r\n\r\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\r\n        if labels is not None:\r\n            loss_fct = CrossEntropyLoss()\r\n            # Only keep active parts of the loss\r\n            if attention_mask is not None:\r\n                active_loss = attention_mask.view(-1) == 1\r\n                active_logits = logits.view(-1, self.num_labels)[active_loss]\r\n                active_labels = labels.view(-1)[active_loss]\r\n                loss = loss_fct(active_logits, active_labels)\r\n            else:\r\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\r\n            outputs = (loss,) + outputs\r\n\r\n        return outputs  # (loss), scores, (hidden_states), (attentions)\r\n\r\n\r\n@add_start_docstrings(""""""Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\r\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\r\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\r\nclass AlbertForQuestionAnswering(AlbertPreTrainedModel):\r\n    r""""""\r\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\r\n            Positions are clamped to the length of the sequence (`sequence_length`).\r\n            Position outside of the sequence are not taken into account for computing the loss.\r\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\r\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\r\n            Positions are clamped to the length of the sequence (`sequence_length`).\r\n            Position outside of the sequence are not taken into account for computing the loss.\r\n\r\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\r\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\r\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\r\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\r\n            Span-start scores (before SoftMax).\r\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\r\n            Span-end scores (before SoftMax).\r\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\r\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\r\n            of shape ``(batch_size, sequence_length, hidden_size)``:\r\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\r\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\r\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\r\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\r\n\r\n    Examples::\r\n\r\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\r\n        model = BertForQuestionAnswering.from_pretrained(\'bert-base-uncased\')\r\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\r\n        start_positions = torch.tensor([1])\r\n        end_positions = torch.tensor([3])\r\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\r\n        loss, start_scores, end_scores = outputs[:2]\r\n\r\n    """"""\r\n\r\n    def __init__(self, config):\r\n        super(AlbertForQuestionAnswering, self).__init__(config)\r\n        self.num_labels = config.num_labels\r\n\r\n        self.bert = AlbertModel(config)\r\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\r\n\r\n        self.init_weights()\r\n\r\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\r\n                start_positions=None, end_positions=None):\r\n\r\n        outputs = self.bert(input_ids,\r\n                            attention_mask=attention_mask,\r\n                            token_type_ids=token_type_ids,\r\n                            position_ids=position_ids,\r\n                            head_mask=head_mask)\r\n\r\n        sequence_output = outputs[0]\r\n\r\n        logits = self.qa_outputs(sequence_output)\r\n        start_logits, end_logits = logits.split(1, dim=-1)\r\n        start_logits = start_logits.squeeze(-1)\r\n        end_logits = end_logits.squeeze(-1)\r\n\r\n        outputs = (start_logits, end_logits,) + outputs[2:]\r\n        if start_positions is not None and end_positions is not None:\r\n            # If we are on multi-GPU, split add a dimension\r\n            if len(start_positions.size()) > 1:\r\n                start_positions = start_positions.squeeze(-1)\r\n            if len(end_positions.size()) > 1:\r\n                end_positions = end_positions.squeeze(-1)\r\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\r\n            ignored_index = start_logits.size(1)\r\n            start_positions.clamp_(0, ignored_index)\r\n            end_positions.clamp_(0, ignored_index)\r\n\r\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\r\n            start_loss = loss_fct(start_logits, start_positions)\r\n            end_loss = loss_fct(end_logits, end_positions)\r\n            total_loss = (start_loss + end_loss) / 2\r\n            outputs = (total_loss,) + outputs\r\n\r\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\r\n'"
pybert/model/albert/modeling_bert.py,81,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""PyTorch BERT model. """"""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport logging\nimport math\nimport os\nimport sys\nfrom io import open\n\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss, MSELoss\n\nfrom .modeling_utils import PreTrainedModel, prune_linear_layer\nfrom .configuration_bert import BertConfig\nfrom .file_utils import add_start_docstrings\n\nlogger = logging.getLogger(__name__)\n\nBERT_PRETRAINED_MODEL_ARCHIVE_MAP = {\n    \'bert-base-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-pytorch_model.bin"",\n    \'bert-large-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-pytorch_model.bin"",\n    \'bert-base-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-pytorch_model.bin"",\n    \'bert-large-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-pytorch_model.bin"",\n    \'bert-base-multilingual-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-pytorch_model.bin"",\n    \'bert-base-multilingual-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-pytorch_model.bin"",\n    \'bert-base-chinese\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-pytorch_model.bin"",\n    \'bert-base-german-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-cased-pytorch_model.bin"",\n    \'bert-large-uncased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-pytorch_model.bin"",\n    \'bert-large-cased-whole-word-masking\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-pytorch_model.bin"",\n    \'bert-large-uncased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-whole-word-masking-finetuned-squad-pytorch_model.bin"",\n    \'bert-large-cased-whole-word-masking-finetuned-squad\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-whole-word-masking-finetuned-squad-pytorch_model.bin"",\n    \'bert-base-cased-finetuned-mrpc\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-finetuned-mrpc-pytorch_model.bin"",\n    \'bert-base-german-dbmdz-cased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-cased-pytorch_model.bin"",\n    \'bert-base-german-dbmdz-uncased\': ""https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-german-dbmdz-uncased-pytorch_model.bin"",\n}\n\ndef load_tf_weights_in_bert(model, config, tf_checkpoint_path):\n    """""" Load tf checkpoints in a pytorch model.\n    """"""\n    try:\n        import re\n        import numpy as np\n        import tensorflow as tf\n    except ImportError:\n        logger.error(""Loading a TensorFlow model in PyTorch, requires TensorFlow to be installed. Please see ""\n            ""https://www.tensorflow.org/install/ for installation instructions."")\n        raise\n    tf_path = os.path.abspath(tf_checkpoint_path)\n    logger.info(""Converting TensorFlow checkpoint from {}"".format(tf_path))\n    # Load weights from TF model\n    init_vars = tf.train.list_variables(tf_path)\n    names = []\n    arrays = []\n    for name, shape in init_vars:\n        logger.info(""Loading TF weight {} with shape {}"".format(name, shape))\n        array = tf.train.load_variable(tf_path, name)\n        names.append(name)\n        arrays.append(array)\n\n    for name, array in zip(names, arrays):\n        name = name.split(\'/\')\n        # adam_v and adam_m are variables used in AdamWeightDecayOptimizer to calculated m and v\n        # which are not required for using pretrained model\n        if any(n in [""adam_v"", ""adam_m"", ""global_step""] for n in name):\n            logger.info(""Skipping {}"".format(""/"".join(name)))\n            continue\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r\'[A-Za-z]+_\\d+\', m_name):\n                l = re.split(r\'_(\\d+)\', m_name)\n            else:\n                l = [m_name]\n            if l[0] == \'kernel\' or l[0] == \'gamma\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'output_bias\' or l[0] == \'beta\':\n                pointer = getattr(pointer, \'bias\')\n            elif l[0] == \'output_weights\':\n                pointer = getattr(pointer, \'weight\')\n            elif l[0] == \'squad\':\n                pointer = getattr(pointer, \'classifier\')\n            else:\n                try:\n                    pointer = getattr(pointer, l[0])\n                except AttributeError:\n                    logger.info(""Skipping {}"".format(""/"".join(name)))\n                    continue\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        if m_name[-11:] == \'_embeddings\':\n            pointer = getattr(pointer, \'weight\')\n        elif m_name == \'kernel\':\n            array = np.transpose(array)\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        logger.info(""Initialize PyTorch weight {}"".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model\n\n\ndef gelu(x):\n    """""" Original Implementation of the gelu activation function in Google Bert repo when initially created.\n        For information: OpenAI GPT\'s gelu is slightly different (and gives slightly different results):\n        0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return x * 0.5 * (1.0 + torch.erf(x / math.sqrt(2.0)))\n\ndef gelu_new(x):\n    """""" Implementation of the gelu activation function currently in Google Bert repo (identical to OpenAI GPT).\n        Also see https://arxiv.org/abs/1606.08415\n    """"""\n    return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\n\ndef swish(x):\n    return x * torch.sigmoid(x)\n\n\nACT2FN = {""gelu"": gelu, ""relu"": torch.nn.functional.relu, ""swish"": swish, ""gelu_new"": gelu_new}\n\n\nBertLayerNorm = torch.nn.LayerNorm\n\nclass BertEmbeddings(nn.Module):\n    """"""Construct the embeddings from word, position and token_type embeddings.\n    """"""\n    def __init__(self, config):\n        super(BertEmbeddings, self).__init__()\n        self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0)\n        self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)\n        self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)\n\n        # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load\n        # any TensorFlow checkpoint file\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, input_ids, token_type_ids=None, position_ids=None):\n        seq_length = input_ids.size(1)\n        if position_ids is None:\n            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)\n            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        words_embeddings = self.word_embeddings(input_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n        token_type_embeddings = self.token_type_embeddings(token_type_ids)\n\n        embeddings = words_embeddings + position_embeddings + token_type_embeddings\n        embeddings = self.LayerNorm(embeddings)\n        embeddings = self.dropout(embeddings)\n        return embeddings\n\n\nclass BertSelfAttention(nn.Module):\n    def __init__(self, config):\n        super(BertSelfAttention, self).__init__()\n        if config.hidden_size % config.num_attention_heads != 0:\n            raise ValueError(\n                ""The hidden size (%d) is not a multiple of the number of attention ""\n                ""heads (%d)"" % (config.hidden_size, config.num_attention_heads))\n        self.output_attentions = config.output_attentions\n\n        self.num_attention_heads = config.num_attention_heads\n        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)\n        self.all_head_size = self.num_attention_heads * self.attention_head_size\n\n        self.query = nn.Linear(config.hidden_size, self.all_head_size)\n        self.key = nn.Linear(config.hidden_size, self.all_head_size)\n        self.value = nn.Linear(config.hidden_size, self.all_head_size)\n\n        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)\n\n    def transpose_for_scores(self, x):\n        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)\n        x = x.view(*new_x_shape)\n        return x.permute(0, 2, 1, 3)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        mixed_query_layer = self.query(hidden_states)\n        mixed_key_layer = self.key(hidden_states)\n        mixed_value_layer = self.value(hidden_states)\n\n        query_layer = self.transpose_for_scores(mixed_query_layer)\n        key_layer = self.transpose_for_scores(mixed_key_layer)\n        value_layer = self.transpose_for_scores(mixed_value_layer)\n\n        # Take the dot product between ""query"" and ""key"" to get the raw attention scores.\n        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))\n        attention_scores = attention_scores / math.sqrt(self.attention_head_size)\n        if attention_mask is not None:\n            # Apply the attention mask is (precomputed for all layers in BertModel forward() function)\n            attention_scores = attention_scores + attention_mask\n\n        # Normalize the attention scores to probabilities.\n        attention_probs = nn.Softmax(dim=-1)(attention_scores)\n\n        # This is actually dropping out entire tokens to attend to, which might\n        # seem a bit unusual, but is taken from the original Transformer paper.\n        attention_probs = self.dropout(attention_probs)\n\n        # Mask heads if we want to\n        if head_mask is not None:\n            attention_probs = attention_probs * head_mask\n\n        context_layer = torch.matmul(attention_probs, value_layer)\n\n        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()\n        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)\n        context_layer = context_layer.view(*new_context_layer_shape)\n\n        outputs = (context_layer, attention_probs) if self.output_attentions else (context_layer,)\n        return outputs\n\n\nclass BertSelfOutput(nn.Module):\n    def __init__(self, config):\n        super(BertSelfOutput, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertAttention(nn.Module):\n    def __init__(self, config):\n        super(BertAttention, self).__init__()\n        self.self = BertSelfAttention(config)\n        self.output = BertSelfOutput(config)\n        self.pruned_heads = set()\n\n    def prune_heads(self, heads):\n        if len(heads) == 0:\n            return\n        mask = torch.ones(self.self.num_attention_heads, self.self.attention_head_size)\n        heads = set(heads) - self.pruned_heads  # Convert to set and emove already pruned heads\n        for head in heads:\n            # Compute how many pruned heads are before the head and move the index accordingly\n            head = head - sum(1 if h < head else 0 for h in self.pruned_heads)\n            mask[head] = 0\n        mask = mask.view(-1).contiguous().eq(1)\n        index = torch.arange(len(mask))[mask].long()\n\n        # Prune linear layers\n        self.self.query = prune_linear_layer(self.self.query, index)\n        self.self.key = prune_linear_layer(self.self.key, index)\n        self.self.value = prune_linear_layer(self.self.value, index)\n        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)\n\n        # Update hyper params and store pruned heads\n        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)\n        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads\n        self.pruned_heads = self.pruned_heads.union(heads)\n\n    def forward(self, input_tensor, attention_mask=None, head_mask=None):\n        self_outputs = self.self(input_tensor, attention_mask, head_mask)\n        attention_output = self.output(self_outputs[0], input_tensor)\n        outputs = (attention_output,) + self_outputs[1:]  # add attentions if we output them\n        return outputs\n\n\nclass BertIntermediate(nn.Module):\n    def __init__(self, config):\n        super(BertIntermediate, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.intermediate_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.intermediate_act_fn = config.hidden_act\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.intermediate_act_fn(hidden_states)\n        return hidden_states\n\n\nclass BertOutput(nn.Module):\n    def __init__(self, config):\n        super(BertOutput, self).__init__()\n        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n\n    def forward(self, hidden_states, input_tensor):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.dropout(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states + input_tensor)\n        return hidden_states\n\n\nclass BertLayer(nn.Module):\n    def __init__(self, config):\n        super(BertLayer, self).__init__()\n        self.attention = BertAttention(config)\n        self.intermediate = BertIntermediate(config)\n        self.output = BertOutput(config)\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        attention_outputs = self.attention(hidden_states, attention_mask, head_mask)\n        attention_output = attention_outputs[0]\n        intermediate_output = self.intermediate(attention_output)\n        layer_output = self.output(intermediate_output, attention_output)\n        outputs = (layer_output,) + attention_outputs[1:]  # add attentions if we output them\n        return outputs\n\n\nclass BertEncoder(nn.Module):\n    def __init__(self, config):\n        super(BertEncoder, self).__init__()\n        self.output_attentions = config.output_attentions\n        self.output_hidden_states = config.output_hidden_states\n        self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)])\n\n    def forward(self, hidden_states, attention_mask=None, head_mask=None):\n        all_hidden_states = ()\n        all_attentions = ()\n        for i, layer_module in enumerate(self.layer):\n            if self.output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states,)\n\n            layer_outputs = layer_module(hidden_states, attention_mask, head_mask[i])\n            hidden_states = layer_outputs[0]\n\n            if self.output_attentions:\n                all_attentions = all_attentions + (layer_outputs[1],)\n\n        # Add last layer\n        if self.output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        outputs = (hidden_states,)\n        if self.output_hidden_states:\n            outputs = outputs + (all_hidden_states,)\n        if self.output_attentions:\n            outputs = outputs + (all_attentions,)\n        return outputs  # last-layer hidden state, (all hidden states), (all attentions)\n\n\nclass BertPooler(nn.Module):\n    def __init__(self, config):\n        super(BertPooler, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We ""pool"" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\n\nclass BertPredictionHeadTransform(nn.Module):\n    def __init__(self, config):\n        super(BertPredictionHeadTransform, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, config.hidden_size)\n        if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)):\n            self.transform_act_fn = ACT2FN[config.hidden_act]\n        else:\n            self.transform_act_fn = config.hidden_act\n        self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n\n    def forward(self, hidden_states):\n        hidden_states = self.dense(hidden_states)\n        hidden_states = self.transform_act_fn(hidden_states)\n        hidden_states = self.LayerNorm(hidden_states)\n        return hidden_states\n\n\nclass BertLMPredictionHead(nn.Module):\n    def __init__(self, config):\n        super(BertLMPredictionHead, self).__init__()\n        self.transform = BertPredictionHeadTransform(config)\n\n        # The output weights are the same as the input embeddings, but there is\n        # an output-only bias for each token.\n        self.decoder = nn.Linear(config.hidden_size,\n                                 config.vocab_size,\n                                 bias=False)\n\n        self.bias = nn.Parameter(torch.zeros(config.vocab_size))\n\n    def forward(self, hidden_states):\n        hidden_states = self.transform(hidden_states)\n        hidden_states = self.decoder(hidden_states) + self.bias\n        return hidden_states\n\n\nclass BertOnlyMLMHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyMLMHead, self).__init__()\n        self.predictions = BertLMPredictionHead(config)\n\n    def forward(self, sequence_output):\n        prediction_scores = self.predictions(sequence_output)\n        return prediction_scores\n\n\nclass BertOnlyNSPHead(nn.Module):\n    def __init__(self, config):\n        super(BertOnlyNSPHead, self).__init__()\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, pooled_output):\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return seq_relationship_score\n\n\nclass BertPreTrainingHeads(nn.Module):\n    def __init__(self, config):\n        super(BertPreTrainingHeads, self).__init__()\n        self.predictions = BertLMPredictionHead(config)\n        self.seq_relationship = nn.Linear(config.hidden_size, 2)\n\n    def forward(self, sequence_output, pooled_output):\n        prediction_scores = self.predictions(sequence_output)\n        seq_relationship_score = self.seq_relationship(pooled_output)\n        return prediction_scores, seq_relationship_score\n\n\nclass BertPreTrainedModel(PreTrainedModel):\n    """""" An abstract class to handle weights initialization and\n        a simple interface for dowloading and loading pretrained models.\n    """"""\n    config_class = BertConfig\n    pretrained_model_archive_map = BERT_PRETRAINED_MODEL_ARCHIVE_MAP\n    load_tf_weights = load_tf_weights_in_bert\n    base_model_prefix = ""bert""\n\n    def _init_weights(self, module):\n        """""" Initialize the weights """"""\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n        elif isinstance(module, BertLayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n        if isinstance(module, nn.Linear) and module.bias is not None:\n            module.bias.data.zero_()\n\n\nBERT_START_DOCSTRING = r""""""    The BERT model was proposed in\n    `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_\n    by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova. It\'s a bidirectional transformer\n    pre-trained using a combination of masked language modeling objective and next sentence prediction\n    on a large corpus comprising the Toronto Book Corpus and Wikipedia.\n\n    This model is a PyTorch `torch.nn.Module`_ sub-class. Use it as a regular PyTorch Module and\n    refer to the PyTorch documentation for all matter related to general usage and behavior.\n\n    .. _`BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`:\n        https://arxiv.org/abs/1810.04805\n\n    .. _`torch.nn.Module`:\n        https://pytorch.org/docs/stable/nn.html#module\n\n    Parameters:\n        config (:class:`~transformers.BertConfig`): Model configuration class with all the parameters of the model. \n            Initializing with a config file does not load the weights associated with the model, only the configuration.\n            Check out the :meth:`~transformers.PreTrainedModel.from_pretrained` method to load the model weights.\n""""""\n\nBERT_INPUTS_DOCSTRING = r""""""\n    Inputs:\n        **input_ids**: ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of input sequence tokens in the vocabulary.\n            To match pre-training, BERT input sequence should be formatted with [CLS] and [SEP] tokens as follows:\n\n            (a) For sequence pairs:\n\n                ``tokens:         [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]``\n                \n                ``token_type_ids:   0   0  0    0    0     0       0   0   1  1  1  1   1   1``\n\n            (b) For single sequences:\n\n                ``tokens:         [CLS] the dog is hairy . [SEP]``\n                \n                ``token_type_ids:   0   0   0   0  0     0   0``\n\n            Bert is a model with absolute position embeddings so it\'s usually advised to pad the inputs on\n            the right rather than the left.\n\n            Indices can be obtained using :class:`transformers.BertTokenizer`.\n            See :func:`transformers.PreTrainedTokenizer.encode` and\n            :func:`transformers.PreTrainedTokenizer.convert_tokens_to_ids` for details.\n        **attention_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, sequence_length)``:\n            Mask to avoid performing attention on padding token indices.\n            Mask values selected in ``[0, 1]``:\n            ``1`` for tokens that are NOT MASKED, ``0`` for MASKED tokens.\n        **token_type_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Segment token indices to indicate first and second portions of the inputs.\n            Indices are selected in ``[0, 1]``: ``0`` corresponds to a `sentence A` token, ``1``\n            corresponds to a `sentence B` token\n            (see `BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding`_ for more details).\n        **position_ids**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Indices of positions of each input sequence tokens in the position embeddings.\n            Selected in the range ``[0, config.max_position_embeddings - 1]``.\n        **head_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(num_heads,)`` or ``(num_layers, num_heads)``:\n            Mask to nullify selected heads of the self-attention modules.\n            Mask values selected in ``[0, 1]``:\n            ``1`` indicates the head is **not masked**, ``0`` indicates the head is **masked**.\n""""""\n\n@add_start_docstrings(""The bare Bert Model transformer outputting raw hidden-states without any specific head on top."",\n                      BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertModel(BertPreTrainedModel):\n    r""""""\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **last_hidden_state**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, hidden_size)``\n            Sequence of hidden-states at the output of the last layer of the model.\n        **pooler_output**: ``torch.FloatTensor`` of shape ``(batch_size, hidden_size)``\n            Last layer hidden-state of the first token of the sequence (classification token)\n            further processed by a Linear layer and a Tanh activation function. The Linear\n            layer weights are trained from the next sentence prediction (classification)\n            objective during Bert pretraining. This output is usually *not* a good summary\n            of the semantic content of the input, you\'re often better with averaging or pooling\n            the sequence of hidden-states for the whole input sequence.\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertModel.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        last_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple\n\n    """"""\n    def __init__(self, config):\n        super(BertModel, self).__init__(config)\n\n        self.embeddings = BertEmbeddings(config)\n        self.encoder = BertEncoder(config)\n        self.pooler = BertPooler(config)\n\n        self.init_weights()\n\n    def _resize_token_embeddings(self, new_num_tokens):\n        old_embeddings = self.embeddings.word_embeddings\n        new_embeddings = self._get_resized_embeddings(old_embeddings, new_num_tokens)\n        self.embeddings.word_embeddings = new_embeddings\n        return self.embeddings.word_embeddings\n\n    def _prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the model.\n            heads_to_prune: dict of {layer_num: list of heads to prune in this layer}\n            See base class PreTrainedModel\n        """"""\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None):\n        if attention_mask is None:\n            attention_mask = torch.ones_like(input_ids)\n        if token_type_ids is None:\n            token_type_ids = torch.zeros_like(input_ids)\n\n        # We create a 3D attention mask from a 2D tensor mask.\n        # Sizes are [batch_size, 1, 1, to_seq_length]\n        # So we can broadcast to [batch_size, num_heads, from_seq_length, to_seq_length]\n        # this attention mask is more simple than the triangular masking of causal attention\n        # used in OpenAI GPT, we just need to prepare the broadcast dimension here.\n        extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2)\n\n        # Since attention_mask is 1.0 for positions we want to attend and 0.0 for\n        # masked positions, this operation will create a tensor which is 0.0 for\n        # positions we want to attend and -10000.0 for masked positions.\n        # Since we are adding it to the raw scores before the softmax, this is\n        # effectively the same as removing these entirely.\n        extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility\n        extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        if head_mask is not None:\n            if head_mask.dim() == 1:\n                head_mask = head_mask.unsqueeze(0).unsqueeze(0).unsqueeze(-1).unsqueeze(-1)\n                head_mask = head_mask.expand(self.config.num_hidden_layers, -1, -1, -1, -1)\n            elif head_mask.dim() == 2:\n                head_mask = head_mask.unsqueeze(1).unsqueeze(-1).unsqueeze(-1)  # We can specify head_mask for each layer\n            head_mask = head_mask.to(dtype=next(self.parameters()).dtype) # switch to fload if need + fp16 compatibility\n        else:\n            head_mask = [None] * self.config.num_hidden_layers\n\n        embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids)\n        encoder_outputs = self.encoder(embedding_output,\n                                       extended_attention_mask,\n                                       head_mask=head_mask)\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output)\n\n        outputs = (sequence_output, pooled_output,) + encoder_outputs[1:]  # add hidden_states and attentions if they are here\n        return outputs  # sequence_output, pooled_output, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with two heads on top as done during the pre-training:\n    a `masked language modeling` head and a `next sentence prediction (classification)` head. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForPreTraining(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when both ``masked_lm_labels`` and ``next_sentence_label`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total loss as the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForPreTraining.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        prediction_scores, seq_relationship_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForPreTraining, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertPreTrainingHeads(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None, next_sentence_label=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output, pooled_output = outputs[:2]\n        prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output)\n\n        outputs = (prediction_scores, seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if masked_lm_labels is not None and next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            total_loss = masked_lm_loss + next_sentence_loss\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `language modeling` head on top. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForMaskedLM(BertPreTrainedModel):\n    r""""""\n        **masked_lm_labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the masked language modeling loss.\n            Indices should be in ``[-1, 0, ..., config.vocab_size]`` (see ``input_ids`` docstring)\n            Tokens with indices set to ``-1`` are ignored (masked), the loss is only computed for the tokens with labels\n            in ``[0, ..., config.vocab_size]``\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``masked_lm_labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Masked language modeling loss.\n        **prediction_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.vocab_size)``\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMaskedLM.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, masked_lm_labels=input_ids)\n        loss, prediction_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForMaskedLM, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertOnlyMLMHead(config)\n\n        self.init_weights()\n        self.tie_weights()\n\n    def tie_weights(self):\n        """""" Make sure we are sharing the input and output embeddings.\n            Export to TorchScript can\'t handle parameter sharing so we are cloning them instead.\n        """"""\n        self._tie_or_clone_weights(self.cls.predictions.decoder,\n                                   self.bert.embeddings.word_embeddings)\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                masked_lm_labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n        prediction_scores = self.cls(sequence_output)\n\n        outputs = (prediction_scores,) + outputs[2:]  # Add hidden states and attention if they are here\n        if masked_lm_labels is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1))\n            outputs = (masked_lm_loss,) + outputs\n\n        return outputs  # (masked_lm_loss), prediction_scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a `next sentence prediction (classification)` head on top. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForNextSentencePrediction(BertPreTrainedModel):\n    r""""""\n        **next_sentence_label**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the next sequence prediction (classification) loss. Input should be a sequence pair (see ``input_ids`` docstring)\n            Indices should be in ``[0, 1]``.\n            ``0`` indicates sequence B is a continuation of sequence A,\n            ``1`` indicates sequence B is a random sequence.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``next_sentence_label`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Next sequence prediction (classification) loss.\n        **seq_relationship_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, 2)``\n            Prediction scores of the next sequence prediction (classification) head (scores of True/False continuation before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForNextSentencePrediction.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids)\n        seq_relationship_scores = outputs[0]\n\n    """"""\n    def __init__(self, config):\n        super(BertForNextSentencePrediction, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.cls = BertOnlyNSPHead(config)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                next_sentence_label=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        seq_relationship_score = self.cls(pooled_output)\n\n        outputs = (seq_relationship_score,) + outputs[2:]  # add hidden states and attention if they are here\n        if next_sentence_label is not None:\n            loss_fct = CrossEntropyLoss(ignore_index=-1)\n            next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1))\n            outputs = (next_sentence_loss,) + outputs\n\n        return outputs  # (next_sentence_loss), seq_relationship_score, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model transformer with a sequence classification/regression head on top (a linear layer on top of\n    the pooled output) e.g. for GLUE tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForSequenceClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the sequence classification/regression loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n            If ``config.num_labels == 1`` a regression loss is computed (Mean-Square loss),\n            If ``config.num_labels > 1`` a classification loss is computed (Cross-Entropy).\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification (or regression if config.num_labels==1) loss.\n        **logits**: ``torch.FloatTensor`` of shape ``(batch_size, config.num_labels)``\n            Classification (or regression if config.num_labels==1) scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, logits = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForSequenceClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, self.config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            if self.num_labels == 1:\n                #  We are doing regression\n                loss_fct = MSELoss()\n                loss = loss_fct(logits.view(-1), labels.view(-1))\n            else:\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a multiple choice classification head on top (a linear layer on top of\n    the pooled output and a softmax) e.g. for RocStories/SWAG tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForMultipleChoice(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for computing the multiple choice classification loss.\n            Indices should be in ``[0, ..., num_choices]`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above)\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **classification_scores**: ``torch.FloatTensor`` of shape ``(batch_size, num_choices)`` where `num_choices` is the size of the second dimension\n            of the input tensors. (see `input_ids` above).\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForMultipleChoice.from_pretrained(\'bert-base-uncased\')\n        choices = [""Hello, my dog is cute"", ""Hello, my cat is amazing""]\n        input_ids = torch.tensor([tokenizer.encode(s) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\n        labels = torch.tensor(1).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, classification_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForMultipleChoice, self).__init__(config)\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, 1)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n        num_choices = input_ids.shape[1]\n\n        input_ids = input_ids.view(-1, input_ids.size(-1))\n        attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None\n        token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None\n        position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids,\n                            head_mask=head_mask)\n\n        pooled_output = outputs[1]\n\n        pooled_output = self.dropout(pooled_output)\n        logits = self.classifier(pooled_output)\n        reshaped_logits = logits.view(-1, num_choices)\n\n        outputs = (reshaped_logits,) + outputs[2:]  # add hidden states and attention if they are here\n\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(reshaped_logits, labels)\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), reshaped_logits, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a token classification head on top (a linear layer on top of\n    the hidden-states output) e.g. for Named-Entity-Recognition (NER) tasks. """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForTokenClassification(BertPreTrainedModel):\n    r""""""\n        **labels**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size, sequence_length)``:\n            Labels for computing the token classification loss.\n            Indices should be in ``[0, ..., config.num_labels - 1]``.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss.\n        **scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length, config.num_labels)``\n            Classification scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForTokenClassification.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        labels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\n        outputs = model(input_ids, labels=labels)\n        loss, scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForTokenClassification, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.dropout = nn.Dropout(config.hidden_dropout_prob)\n        self.classifier = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None,\n                position_ids=None, head_mask=None, labels=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        sequence_output = self.dropout(sequence_output)\n        logits = self.classifier(sequence_output)\n\n        outputs = (logits,) + outputs[2:]  # add hidden states and attention if they are here\n        if labels is not None:\n            loss_fct = CrossEntropyLoss()\n            # Only keep active parts of the loss\n            if attention_mask is not None:\n                active_loss = attention_mask.view(-1) == 1\n                active_logits = logits.view(-1, self.num_labels)[active_loss]\n                active_labels = labels.view(-1)[active_loss]\n                loss = loss_fct(active_logits, active_labels)\n            else:\n                loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n            outputs = (loss,) + outputs\n\n        return outputs  # (loss), scores, (hidden_states), (attentions)\n\n\n@add_start_docstrings(""""""Bert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear layers on top of\n    the hidden-states output to compute `span start logits` and `span end logits`). """""",\n    BERT_START_DOCSTRING, BERT_INPUTS_DOCSTRING)\nclass BertForQuestionAnswering(BertPreTrainedModel):\n    r""""""\n        **start_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n        **end_positions**: (`optional`) ``torch.LongTensor`` of shape ``(batch_size,)``:\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`).\n            Position outside of the sequence are not taken into account for computing the loss.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned when ``labels`` is provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.\n        **start_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-start scores (before SoftMax).\n        **end_scores**: ``torch.FloatTensor`` of shape ``(batch_size, sequence_length,)``\n            Span-end scores (before SoftMax).\n        **hidden_states**: (`optional`, returned when ``config.output_hidden_states=True``)\n            list of ``torch.FloatTensor`` (one for the output of each layer + the output of the embeddings)\n            of shape ``(batch_size, sequence_length, hidden_size)``:\n            Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n        **attentions**: (`optional`, returned when ``config.output_attentions=True``)\n            list of ``torch.FloatTensor`` (one for each layer) of shape ``(batch_size, num_heads, sequence_length, sequence_length)``:\n            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n\n    Examples::\n\n        tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n        model = BertForQuestionAnswering.from_pretrained(\'bert-base-uncased\')\n        input_ids = torch.tensor(tokenizer.encode(""Hello, my dog is cute"")).unsqueeze(0)  # Batch size 1\n        start_positions = torch.tensor([1])\n        end_positions = torch.tensor([3])\n        outputs = model(input_ids, start_positions=start_positions, end_positions=end_positions)\n        loss, start_scores, end_scores = outputs[:2]\n\n    """"""\n    def __init__(self, config):\n        super(BertForQuestionAnswering, self).__init__(config)\n        self.num_labels = config.num_labels\n\n        self.bert = BertModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        self.init_weights()\n\n    def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None,\n                start_positions=None, end_positions=None):\n\n        outputs = self.bert(input_ids,\n                            attention_mask=attention_mask,\n                            token_type_ids=token_type_ids,\n                            position_ids=position_ids, \n                            head_mask=head_mask)\n\n        sequence_output = outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1)\n        end_logits = end_logits.squeeze(-1)\n\n        outputs = (start_logits, end_logits,) + outputs[2:]\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions.clamp_(0, ignored_index)\n            end_positions.clamp_(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n            outputs = (total_loss,) + outputs\n\n        return outputs  # (loss), start_logits, end_logits, (hidden_states), (attentions)\n'"
pybert/model/albert/modeling_utils.py,38,"b'""""""PyTorch BERT model.""""""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\nimport os\n\nimport torch\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss\nfrom torch.nn import functional as F\n\nfrom .configuration_utils import PretrainedConfig\nfrom .file_utils import cached_path, WEIGHTS_NAME, TF_WEIGHTS_NAME\n\nlogger = logging.getLogger(__name__)\n\n\ntry:\n    from torch.nn import Identity\nexcept ImportError:\n    # Older PyTorch compatibility\n    class Identity(nn.Module):\n        r""""""A placeholder identity operator that is argument-insensitive.\n        """"""\n        def __init__(self, *args, **kwargs):\n            super(Identity, self).__init__()\n\n        def forward(self, input):\n            return input\n\nclass PreTrainedModel(nn.Module):\n    r"""""" Base class for all models.\n\n        :class:`~pytorch_transformers.PreTrainedModel` takes care of storing the configuration of the models and handles methods for loading/downloading/saving models\n        as well as a few methods commons to all models to (i) resize the input embeddings and (ii) prune heads in the self-attention heads.\n\n        Class attributes (overridden by derived classes):\n            - ``config_class``: a class derived from :class:`~pytorch_transformers.PretrainedConfig` to use as configuration class for this model architecture.\n            - ``pretrained_model_archive_map``: a python ``dict`` of with `short-cut-names` (string) as keys and `url` (string) of associated pretrained weights as values.\n            - ``load_tf_weights``: a python ``method`` for loading a TensorFlow checkpoint in a PyTorch model, taking as arguments:\n\n                - ``model``: an instance of the relevant subclass of :class:`~pytorch_transformers.PreTrainedModel`,\n                - ``config``: an instance of the relevant subclass of :class:`~pytorch_transformers.PretrainedConfig`,\n                - ``path``: a path (string) to the TensorFlow checkpoint.\n\n            - ``base_model_prefix``: a string indicating the attribute associated to the base model in derived classes of the same architecture adding modules on top of the base model.\n    """"""\n    config_class = None\n    pretrained_model_archive_map = {}\n    load_tf_weights = lambda model, config, path: None\n    base_model_prefix = """"\n\n    def __init__(self, config, *inputs, **kwargs):\n        super(PreTrainedModel, self).__init__()\n        if not isinstance(config, PretrainedConfig):\n            raise ValueError(\n                ""Parameter config in `{}(config)` should be an instance of class `PretrainedConfig`. ""\n                ""To create a model from a pretrained model use ""\n                ""`model = {}.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(\n                    self.__class__.__name__, self.__class__.__name__\n                ))\n        # Save config in model\n        self.config = config\n\n    def _get_resized_embeddings(self, old_embeddings, new_num_tokens=None):\n        """""" Build a resized Embedding Module from a provided token Embedding Module.\n            Increasing the size will add newly initialized vectors at the end\n            Reducing the size will remove vectors from the end\n\n        Args:\n            new_num_tokens: (`optional`) int\n                New number of tokens in the embedding matrix.\n                Increasing the size will add newly initialized vectors at the end\n                Reducing the size will remove vectors from the end\n                If not provided or None: return the provided token Embedding Module.\n        Return: ``torch.nn.Embeddings``\n            Pointer to the resized Embedding Module or the old Embedding Module if new_num_tokens is None\n        """"""\n        if new_num_tokens is None:\n            return old_embeddings\n\n        old_num_tokens, old_embedding_dim = old_embeddings.weight.size()\n        if old_num_tokens == new_num_tokens:\n            return old_embeddings\n\n        # Build new embeddings\n        new_embeddings = nn.Embedding(new_num_tokens, old_embedding_dim)\n        new_embeddings.to(old_embeddings.weight.device)\n\n        # initialize all new embeddings (in particular added tokens)\n        self._init_weights(new_embeddings)\n\n        # Copy word embeddings from the previous weights\n        num_tokens_to_copy = min(old_num_tokens, new_num_tokens)\n        new_embeddings.weight.data[:num_tokens_to_copy, :] = old_embeddings.weight.data[:num_tokens_to_copy, :]\n\n        return new_embeddings\n\n    def _tie_or_clone_weights(self, first_module, second_module):\n        """""" Tie or clone module weights depending of weither we are using TorchScript or not\n        """"""\n\n        if self.config.torchscript:\n            first_module.weight = nn.Parameter(second_module.weight.clone())\n        else:\n            first_module.weight = second_module.weight\n\n\n        if hasattr(first_module, \'bias\') and first_module.bias is not None:\n            first_module.bias.data = torch.nn.functional.pad(\n                first_module.bias.data,\n                (0, first_module.weight.shape[0] - first_module.bias.shape[0]),\n                \'constant\',\n                0\n            )\n\n    def resize_token_embeddings(self, new_num_tokens=None):\n        """""" Resize input token embeddings matrix of the model if new_num_tokens != config.vocab_size.\n        Take care of tying weights embeddings afterwards if the model class has a `tie_weights()` method.\n\n        Arguments:\n\n            new_num_tokens: (`optional`) int:\n                New number of tokens in the embedding matrix. Increasing the size will add newly initialized vectors at the end. Reducing the size will remove vectors from the end. \n                If not provided or None: does nothing and just returns a pointer to the input tokens ``torch.nn.Embeddings`` Module of the model.\n\n        Return: ``torch.nn.Embeddings``\n            Pointer to the input tokens Embeddings Module of the model\n        """"""\n        base_model = getattr(self, self.base_model_prefix, self)  # get the base model if needed\n        model_embeds = base_model._resize_token_embeddings(new_num_tokens)\n        if new_num_tokens is None:\n            return model_embeds\n\n        # Update base model and current model config\n        self.config.vocab_size = new_num_tokens\n        base_model.vocab_size = new_num_tokens\n\n        # Tie weights again if needed\n        if hasattr(self, \'tie_weights\'):\n            self.tie_weights()\n\n        return model_embeds\n\n    def init_weights(self):\n        """""" Initialize and prunes weights if needed. """"""\n        # Initialize weights\n        self.apply(self._init_weights)\n\n        # Prune heads if needed\n        if self.config.pruned_heads:\n            self.prune_heads(self.config.pruned_heads)\n\n    def prune_heads(self, heads_to_prune):\n        """""" Prunes heads of the base model.\n\n            Arguments:\n\n                heads_to_prune: dict with keys being selected layer indices (`int`) and associated values being the list of heads to prune in said layer (list of `int`).\n                E.g. {1: [0, 2], 2: [2, 3]} will prune heads 0 and 2 on layer 1 and heads 2 and 3 on layer 2.\n        """"""\n        base_model = getattr(self, self.base_model_prefix, self)  # get the base model if needed\n\n        # save new sets of pruned heads as union of previously stored pruned heads and newly pruned heads\n        for layer, heads in heads_to_prune.items():\n            union_heads = set(self.config.pruned_heads.get(layer, [])) | set(heads)\n            self.config.pruned_heads[layer] = list(union_heads)  # Unfortunately we have to store it as list for JSON\n\n        base_model._prune_heads(heads_to_prune)\n\n    def save_pretrained(self, save_directory):\n        """""" Save a model and its configuration file to a directory, so that it\n            can be re-loaded using the `:func:`~pytorch_transformers.PreTrainedModel.from_pretrained`` class method.\n        """"""\n        assert os.path.isdir(save_directory), ""Saving path should be a directory where the model and configuration can be saved""\n\n        # Only save the model it-self if we are using distributed training\n        model_to_save = self.module if hasattr(self, \'module\') else self\n\n        # Save configuration file\n        model_to_save.config.save_pretrained(save_directory)\n\n        # If we save using the predefined names, we can load using `from_pretrained`\n        output_model_file = os.path.join(save_directory, WEIGHTS_NAME)\n\n        torch.save(model_to_save.state_dict(), output_model_file)\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n        r""""""Instantiate a pretrained pytorch model from a pre-trained model configuration.\n\n        The model is set in evaluation mode by default using ``model.eval()`` (Dropout modules are deactivated)\n        To train the model, you should first set it back in training mode with ``model.train()``\n\n        The warning ``Weights from XXX not initialized from pretrained model`` means that the weights of XXX do not come pre-trained with the rest of the model.\n        It is up to you to train those weights with a downstream fine-tuning task.\n\n        The warning ``Weights from XXX not used in YYY`` means that the layer XXX is not used by YYY, therefore those weights are discarded.\n\n        Parameters:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a pre-trained model to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing model weights saved using :func:`~pytorch_transformers.PreTrainedModel.save_pretrained`, e.g.: ``./my_model_directory/``.\n                - a path or url to a `tensorflow index checkpoint file` (e.g. `./tf_model/model.ckpt.index`). In this case, ``from_tf`` should be set to True and a configuration object should be provided as ``config`` argument. This loading path is slower than converting the TensorFlow checkpoint in a PyTorch model using the provided conversion scripts and loading the PyTorch model afterwards.\n\n            model_args: (`optional`) Sequence of positional arguments:\n                All remaning positional arguments will be passed to the underlying model\'s ``__init__`` method\n\n            config: (`optional`) instance of a class derived from :class:`~pytorch_transformers.PretrainedConfig`:\n                Configuration for the model to use instead of an automatically loaded configuation. Configuration can be automatically loaded when:\n\n                - the model is a model provided by the library (loaded with the ``shortcut-name`` string of a pretrained model), or\n                - the model was saved using :func:`~pytorch_transformers.PreTrainedModel.save_pretrained` and is reloaded by suppling the save directory.\n                - the model is loaded by suppling a local directory as ``pretrained_model_name_or_path`` and a configuration JSON file named `config.json` is found in the directory.\n\n            state_dict: (`optional`) dict:\n                an optional state dictionnary for the model to use instead of a state dictionary loaded from saved weights file.\n                This option can be used if you want to create a model from a pretrained configuration but load your own weights.\n                In this case though, you should check if using :func:`~pytorch_transformers.PreTrainedModel.save_pretrained` and :func:`~pytorch_transformers.PreTrainedModel.from_pretrained` is not a simpler option.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded pre-trained model\n                configuration should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the model weights and configuration files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            output_loading_info: (`optional`) boolean:\n                Set to ``True`` to also return a dictionnary containing missing keys, unexpected keys and error messages.\n\n            kwargs: (`optional`) Remaining dictionary of keyword arguments:\n                Can be used to update the configuration object (after it being loaded) and initiate the model. (e.g. ``output_attention=True``). Behave differently depending on whether a `config` is provided or automatically loaded:\n\n                - If a configuration is provided with ``config``, ``**kwargs`` will be directly passed to the underlying model\'s ``__init__`` method (we assume all relevant updates to the configuration have already been done)\n                - If a configuration is not provided, ``kwargs`` will be first passed to the configuration class initialization function (:func:`~pytorch_transformers.PretrainedConfig.from_pretrained`). Each key of ``kwargs`` that corresponds to a configuration attribute will be used to override said attribute with the supplied ``kwargs`` value. Remaining keys that do not correspond to any configuration attribute will be passed to the underlying model\'s ``__init__`` function.\n\n        Examples::\n\n            model = BertModel.from_pretrained(\'bert-base-uncased\')    # Download model and configuration from S3 and cache.\n            model = BertModel.from_pretrained(\'./test/saved_model/\')  # E.g. model was saved using `save_pretrained(\'./test/saved_model/\')`\n            model = BertModel.from_pretrained(\'bert-base-uncased\', output_attention=True)  # Update configuration during loading\n            assert model.config.output_attention == True\n            # Loading from a TF checkpoint file instead of a PyTorch model (slower)\n            config = BertConfig.from_json_file(\'./tf_model/my_tf_model_config.json\')\n            model = BertModel.from_pretrained(\'./tf_model/my_tf_checkpoint.ckpt.index\', from_tf=True, config=config)\n\n        """"""\n        config = kwargs.pop(\'config\', None)\n        state_dict = kwargs.pop(\'state_dict\', None)\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        from_tf = kwargs.pop(\'from_tf\', False)\n        force_download = kwargs.pop(\'force_download\', False)\n        proxies = kwargs.pop(\'proxies\', None)\n        output_loading_info = kwargs.pop(\'output_loading_info\', False)\n\n        # Load config\n        if config is None:\n            config, model_kwargs = cls.config_class.from_pretrained(\n                pretrained_model_name_or_path, *model_args,\n                cache_dir=cache_dir, return_unused_kwargs=True,\n                force_download=force_download,\n                **kwargs\n            )\n        else:\n            model_kwargs = kwargs\n\n        # Load model\n        if pretrained_model_name_or_path in cls.pretrained_model_archive_map:\n            archive_file = cls.pretrained_model_archive_map[pretrained_model_name_or_path]\n        elif os.path.isdir(pretrained_model_name_or_path):\n            if from_tf:\n                # Directly load from a TensorFlow checkpoint\n                archive_file = os.path.join(pretrained_model_name_or_path, TF_WEIGHTS_NAME + "".index"")\n            else:\n                archive_file = os.path.join(pretrained_model_name_or_path, WEIGHTS_NAME)\n        else:\n            if from_tf:\n                # Directly load from a TensorFlow checkpoint\n                archive_file = pretrained_model_name_or_path + "".index""\n            else:\n                archive_file = pretrained_model_name_or_path\n        # redirect to the cache, if necessary\n        try:\n            resolved_archive_file = cached_path(archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n        except EnvironmentError as e:\n            if pretrained_model_name_or_path in cls.pretrained_model_archive_map:\n                logger.error(\n                    ""Couldn\'t reach server at \'{}\' to download pretrained weights."".format(\n                        archive_file))\n            else:\n                logger.error(\n                    ""Model name \'{}\' was not found in model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url but couldn\'t find any file ""\n                    ""associated to this path or url."".format(\n                        pretrained_model_name_or_path,\n                        \', \'.join(cls.pretrained_model_archive_map.keys()),\n                        archive_file))\n            raise e\n        if resolved_archive_file == archive_file:\n            logger.info(""loading weights file {}"".format(archive_file))\n        else:\n            logger.info(""loading weights file {} from cache at {}"".format(\n                archive_file, resolved_archive_file))\n\n        # Instantiate model.\n        model = cls(config, *model_args, **model_kwargs)\n\n        if state_dict is None and not from_tf:\n            state_dict = torch.load(resolved_archive_file, map_location=\'cpu\')\n        if from_tf:\n            # Directly load from a TensorFlow checkpoint\n            return cls.load_tf_weights(model, config, resolved_archive_file[:-6])  # Remove the \'.index\'\n\n        # Convert old format to new format if needed from a PyTorch state_dict\n        old_keys = []\n        new_keys = []\n        for key in state_dict.keys():\n            new_key = None\n            if \'gamma\' in key:\n                new_key = key.replace(\'gamma\', \'weight\')\n            if \'beta\' in key:\n                new_key = key.replace(\'beta\', \'bias\')\n            if new_key:\n                old_keys.append(key)\n                new_keys.append(new_key)\n        for old_key, new_key in zip(old_keys, new_keys):\n            state_dict[new_key] = state_dict.pop(old_key)\n\n        # Load from a PyTorch state_dict\n        missing_keys = []\n        unexpected_keys = []\n        error_msgs = []\n        # copy state_dict so _load_from_state_dict can modify it\n        metadata = getattr(state_dict, \'_metadata\', None)\n        state_dict = state_dict.copy()\n        if metadata is not None:\n            state_dict._metadata = metadata\n\n        def load(module, prefix=\'\'):\n            local_metadata = {} if metadata is None else metadata.get(prefix[:-1], {})\n            module._load_from_state_dict(\n                state_dict, prefix, local_metadata, True, missing_keys, unexpected_keys, error_msgs)\n            for name, child in module._modules.items():\n                if child is not None:\n                    load(child, prefix + name + \'.\')\n\n        # Make sure we are able to load base models as well as derived models (with heads)\n        start_prefix = \'\'\n        model_to_load = model\n        if not hasattr(model, cls.base_model_prefix) and any(s.startswith(cls.base_model_prefix) for s in state_dict.keys()):\n            start_prefix = cls.base_model_prefix + \'.\'\n        if hasattr(model, cls.base_model_prefix) and not any(s.startswith(cls.base_model_prefix) for s in state_dict.keys()):\n            model_to_load = getattr(model, cls.base_model_prefix)\n\n        load(model_to_load, prefix=start_prefix)\n        if len(missing_keys) > 0:\n            logger.info(""Weights of {} not initialized from pretrained model: {}"".format(\n                model.__class__.__name__, missing_keys))\n        if len(unexpected_keys) > 0:\n            logger.info(""Weights from pretrained model not used in {}: {}"".format(\n                model.__class__.__name__, unexpected_keys))\n        if len(error_msgs) > 0:\n            raise RuntimeError(\'Error(s) in loading state_dict for {}:\\n\\t{}\'.format(\n                               model.__class__.__name__, ""\\n\\t"".join(error_msgs)))\n\n        if hasattr(model, \'tie_weights\'):\n            model.tie_weights()  # make sure word embedding weights are still tied\n\n        # Set model in evaluation mode to desactivate DropOut modules by default\n        model.eval()\n\n        if output_loading_info:\n            loading_info = {""missing_keys"": missing_keys, ""unexpected_keys"": unexpected_keys, ""error_msgs"": error_msgs}\n            return model, loading_info\n\n        return model\n\n\nclass Conv1D(nn.Module):\n    def __init__(self, nf, nx):\n        """""" Conv1D layer as defined by Radford et al. for OpenAI GPT (and also used in GPT-2)\n            Basically works like a Linear layer but the weights are transposed\n        """"""\n        super(Conv1D, self).__init__()\n        self.nf = nf\n        w = torch.empty(nx, nf)\n        nn.init.normal_(w, std=0.02)\n        self.weight = nn.Parameter(w)\n        self.bias = nn.Parameter(torch.zeros(nf))\n\n    def forward(self, x):\n        size_out = x.size()[:-1] + (self.nf,)\n        x = torch.addmm(self.bias, x.view(-1, x.size(-1)), self.weight)\n        x = x.view(*size_out)\n        return x\n\n\nclass PoolerStartLogits(nn.Module):\n    """""" Compute SQuAD start_logits from sequence hidden states. """"""\n    def __init__(self, config):\n        super(PoolerStartLogits, self).__init__()\n        self.dense = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, hidden_states, p_mask=None):\n        """""" Args:\n            **p_mask**: (`optional`) ``torch.FloatTensor`` of shape `(batch_size, seq_len)`\n                invalid position mask such as query and special symbols (PAD, SEP, CLS)\n                1.0 means token should be masked.\n        """"""\n        x = self.dense(hidden_states).squeeze(-1)\n\n        if p_mask is not None:\n            x = x * (1 - p_mask) - 1e30 * p_mask\n\n        return x\n\n\nclass PoolerEndLogits(nn.Module):\n    """""" Compute SQuAD end_logits from sequence hidden states and start token hidden state.\n    """"""\n    def __init__(self, config):\n        super(PoolerEndLogits, self).__init__()\n        self.dense_0 = nn.Linear(config.hidden_size * 2, config.hidden_size)\n        self.activation = nn.Tanh()\n        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n        self.dense_1 = nn.Linear(config.hidden_size, 1)\n\n    def forward(self, hidden_states, start_states=None, start_positions=None, p_mask=None):\n        """""" Args:\n            One of ``start_states``, ``start_positions`` should be not None.\n            If both are set, ``start_positions`` overrides ``start_states``.\n\n            **start_states**: ``torch.LongTensor`` of shape identical to hidden_states\n                hidden states of the first tokens for the labeled span.\n            **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n                position of the first token for the labeled span:\n            **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, seq_len)``\n                Mask of invalid position such as query and special symbols (PAD, SEP, CLS)\n                1.0 means token should be masked.\n        """"""\n        assert start_states is not None or start_positions is not None, ""One of start_states, start_positions should be not None""\n        if start_positions is not None:\n            slen, hsz = hidden_states.shape[-2:]\n            start_positions = start_positions[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            start_states = hidden_states.gather(-2, start_positions) # shape (bsz, 1, hsz)\n            start_states = start_states.expand(-1, slen, -1) # shape (bsz, slen, hsz)\n\n        x = self.dense_0(torch.cat([hidden_states, start_states], dim=-1))\n        x = self.activation(x)\n        x = self.LayerNorm(x)\n        x = self.dense_1(x).squeeze(-1)\n\n        if p_mask is not None:\n            x = x * (1 - p_mask) - 1e30 * p_mask\n\n        return x\n\n\nclass PoolerAnswerClass(nn.Module):\n    """""" Compute SQuAD 2.0 answer class from classification and start tokens hidden states. """"""\n    def __init__(self, config):\n        super(PoolerAnswerClass, self).__init__()\n        self.dense_0 = nn.Linear(config.hidden_size * 2, config.hidden_size)\n        self.activation = nn.Tanh()\n        self.dense_1 = nn.Linear(config.hidden_size, 1, bias=False)\n\n    def forward(self, hidden_states, start_states=None, start_positions=None, cls_index=None):\n        """"""\n        Args:\n            One of ``start_states``, ``start_positions`` should be not None.\n            If both are set, ``start_positions`` overrides ``start_states``.\n\n            **start_states**: ``torch.LongTensor`` of shape identical to ``hidden_states``.\n                hidden states of the first tokens for the labeled span.\n            **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n                position of the first token for the labeled span.\n            **cls_index**: torch.LongTensor of shape ``(batch_size,)``\n                position of the CLS token. If None, take the last token.\n\n            note(Original repo):\n                no dependency on end_feature so that we can obtain one single `cls_logits`\n                for each sample\n        """"""\n        hsz = hidden_states.shape[-1]\n        assert start_states is not None or start_positions is not None, ""One of start_states, start_positions should be not None""\n        if start_positions is not None:\n            start_positions = start_positions[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            start_states = hidden_states.gather(-2, start_positions).squeeze(-2) # shape (bsz, hsz)\n\n        if cls_index is not None:\n            cls_index = cls_index[:, None, None].expand(-1, -1, hsz) # shape (bsz, 1, hsz)\n            cls_token_state = hidden_states.gather(-2, cls_index).squeeze(-2) # shape (bsz, hsz)\n        else:\n            cls_token_state = hidden_states[:, -1, :] # shape (bsz, hsz)\n\n        x = self.dense_0(torch.cat([start_states, cls_token_state], dim=-1))\n        x = self.activation(x)\n        x = self.dense_1(x).squeeze(-1)\n\n        return x\n\n\nclass SQuADHead(nn.Module):\n    r"""""" A SQuAD head inspired by XLNet.\n\n    Parameters:\n        config (:class:`~pytorch_transformers.XLNetConfig`): Model configuration class with all the parameters of the model.\n\n    Inputs:\n        **hidden_states**: ``torch.FloatTensor`` of shape ``(batch_size, seq_len, hidden_size)``\n            hidden states of sequence tokens\n        **start_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            position of the first token for the labeled span.\n        **end_positions**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            position of the last token for the labeled span.\n        **cls_index**: torch.LongTensor of shape ``(batch_size,)``\n            position of the CLS token. If None, take the last token.\n        **is_impossible**: ``torch.LongTensor`` of shape ``(batch_size,)``\n            Whether the question has a possible answer in the paragraph or not.\n        **p_mask**: (`optional`) ``torch.FloatTensor`` of shape ``(batch_size, seq_len)``\n            Mask of invalid position such as query and special symbols (PAD, SEP, CLS)\n            1.0 means token should be masked.\n\n    Outputs: `Tuple` comprising various elements depending on the configuration (config) and inputs:\n        **loss**: (`optional`, returned if both ``start_positions`` and ``end_positions`` are provided) ``torch.FloatTensor`` of shape ``(1,)``:\n            Classification loss as the sum of start token, end token (and is_impossible if provided) classification losses.\n        **start_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top)``\n            Log probabilities for the top config.start_n_top start token possibilities (beam-search).\n        **start_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top)``\n            Indices for the top config.start_n_top start token possibilities (beam-search).\n        **end_top_log_probs**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Log probabilities for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **end_top_index**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.LongTensor`` of shape ``(batch_size, config.start_n_top * config.end_n_top)``\n            Indices for the top ``config.start_n_top * config.end_n_top`` end token possibilities (beam-search).\n        **cls_logits**: (`optional`, returned if ``start_positions`` or ``end_positions`` is not provided)\n            ``torch.FloatTensor`` of shape ``(batch_size,)``\n            Log probabilities for the ``is_impossible`` label of the answers.\n    """"""\n    def __init__(self, config):\n        super(SQuADHead, self).__init__()\n        self.start_n_top = config.start_n_top\n        self.end_n_top = config.end_n_top\n\n        self.start_logits = PoolerStartLogits(config)\n        self.end_logits = PoolerEndLogits(config)\n        self.answer_class = PoolerAnswerClass(config)\n\n    def forward(self, hidden_states, start_positions=None, end_positions=None,\n                cls_index=None, is_impossible=None, p_mask=None):\n        outputs = ()\n\n        start_logits = self.start_logits(hidden_states, p_mask=p_mask)\n\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, let\'s remove the dimension added by batch splitting\n            for x in (start_positions, end_positions, cls_index, is_impossible):\n                if x is not None and x.dim() > 1:\n                    x.squeeze_(-1)\n\n            # during training, compute the end logits based on the ground truth of the start position\n            end_logits = self.end_logits(hidden_states, start_positions=start_positions, p_mask=p_mask)\n\n            loss_fct = CrossEntropyLoss()\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n\n            if cls_index is not None and is_impossible is not None:\n                # Predict answerability from the representation of CLS and START\n                cls_logits = self.answer_class(hidden_states, start_positions=start_positions, cls_index=cls_index)\n                loss_fct_cls = nn.BCEWithLogitsLoss()\n                cls_loss = loss_fct_cls(cls_logits, is_impossible)\n\n                # note(zhiliny): by default multiply the loss by 0.5 so that the scale is comparable to start_loss and end_loss\n                total_loss += cls_loss * 0.5\n\n            outputs = (total_loss,) + outputs\n\n        else:\n            # during inference, compute the end logits based on beam search\n            bsz, slen, hsz = hidden_states.size()\n            start_log_probs = F.softmax(start_logits, dim=-1) # shape (bsz, slen)\n\n            start_top_log_probs, start_top_index = torch.topk(start_log_probs, self.start_n_top, dim=-1) # shape (bsz, start_n_top)\n            start_top_index_exp = start_top_index.unsqueeze(-1).expand(-1, -1, hsz) # shape (bsz, start_n_top, hsz)\n            start_states = torch.gather(hidden_states, -2, start_top_index_exp) # shape (bsz, start_n_top, hsz)\n            start_states = start_states.unsqueeze(1).expand(-1, slen, -1, -1) # shape (bsz, slen, start_n_top, hsz)\n\n            hidden_states_expanded = hidden_states.unsqueeze(2).expand_as(start_states) # shape (bsz, slen, start_n_top, hsz)\n            p_mask = p_mask.unsqueeze(-1) if p_mask is not None else None\n            end_logits = self.end_logits(hidden_states_expanded, start_states=start_states, p_mask=p_mask)\n            end_log_probs = F.softmax(end_logits, dim=1) # shape (bsz, slen, start_n_top)\n\n            end_top_log_probs, end_top_index = torch.topk(end_log_probs, self.end_n_top, dim=1) # shape (bsz, end_n_top, start_n_top)\n            end_top_log_probs = end_top_log_probs.view(-1, self.start_n_top * self.end_n_top)\n            end_top_index = end_top_index.view(-1, self.start_n_top * self.end_n_top)\n\n            start_states = torch.einsum(""blh,bl->bh"", hidden_states, start_log_probs)\n            cls_logits = self.answer_class(hidden_states, start_states=start_states, cls_index=cls_index)\n\n            outputs = (start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits) + outputs\n\n        # return start_top_log_probs, start_top_index, end_top_log_probs, end_top_index, cls_logits\n        # or (if labels are provided) (total_loss,)\n        return outputs\n\n\nclass SequenceSummary(nn.Module):\n    r"""""" Compute a single vector summary of a sequence hidden states according to various possibilities:\n        Args of the config class:\n            summary_type:\n                - \'last\' => [default] take the last token hidden state (like XLNet)\n                - \'first\' => take the first token hidden state (like Bert)\n                - \'mean\' => take the mean of all tokens hidden states\n                - \'cls_index\' => supply a Tensor of classification token position (GPT/GPT-2)\n                - \'attn\' => Not implemented now, use multi-head attention\n            summary_use_proj: Add a projection after the vector extraction\n            summary_proj_to_labels: If True, the projection outputs to config.num_labels classes (otherwise to hidden_size). Default: False.\n            summary_activation: \'tanh\' => add a tanh activation to the output, Other => no activation. Default\n            summary_first_dropout: Add a dropout before the projection and activation\n            summary_last_dropout: Add a dropout after the projection and activation\n    """"""\n    def __init__(self, config):\n        super(SequenceSummary, self).__init__()\n\n        self.summary_type = config.summary_type if hasattr(config, \'summary_use_proj\') else \'last\'\n        if self.summary_type == \'attn\':\n            # We should use a standard multi-head attention module with absolute positional embedding for that.\n            # Cf. https://github.com/zihangdai/xlnet/blob/master/modeling.py#L253-L276\n            # We can probably just use the multi-head attention module of PyTorch >=1.1.0\n            raise NotImplementedError\n\n        self.summary = Identity()\n        if hasattr(config, \'summary_use_proj\') and config.summary_use_proj:\n            if hasattr(config, \'summary_proj_to_labels\') and config.summary_proj_to_labels and config.num_labels > 0:\n                num_classes = config.num_labels\n            else:\n                num_classes = config.hidden_size\n            self.summary = nn.Linear(config.hidden_size, num_classes)\n\n        self.activation = Identity()\n        if hasattr(config, \'summary_activation\') and config.summary_activation == \'tanh\':\n            self.activation = nn.Tanh()\n\n        self.first_dropout = Identity()\n        if hasattr(config, \'summary_first_dropout\') and config.summary_first_dropout > 0:\n            self.first_dropout = nn.Dropout(config.summary_first_dropout)\n\n        self.last_dropout = Identity()\n        if hasattr(config, \'summary_last_dropout\') and config.summary_last_dropout > 0:\n            self.last_dropout = nn.Dropout(config.summary_last_dropout)\n\n    def forward(self, hidden_states, cls_index=None):\n        """""" hidden_states: float Tensor in shape [bsz, seq_len, hidden_size], the hidden-states of the last layer.\n            cls_index: [optional] position of the classification token if summary_type == \'cls_index\',\n                shape (bsz,) or more generally (bsz, ...) where ... are optional leading dimensions of hidden_states.\n                if summary_type == \'cls_index\' and cls_index is None:\n                    we take the last token of the sequence as classification token\n        """"""\n        if self.summary_type == \'last\':\n            output = hidden_states[:, -1]\n        elif self.summary_type == \'first\':\n            output = hidden_states[:, 0]\n        elif self.summary_type == \'mean\':\n            output = hidden_states.mean(dim=1)\n        elif self.summary_type == \'cls_index\':\n            if cls_index is None:\n                cls_index = torch.full_like(hidden_states[..., :1, :], hidden_states.shape[-2]-1, dtype=torch.long)\n            else:\n                cls_index = cls_index.unsqueeze(-1).unsqueeze(-1)\n                cls_index = cls_index.expand((-1,) * (cls_index.dim()-1) + (hidden_states.size(-1),))\n            # shape of cls_index: (bsz, XX, 1, hidden_size) where XX are optional leading dim of hidden_states\n            output = hidden_states.gather(-2, cls_index).squeeze(-2) # shape (bsz, XX, hidden_size)\n        elif self.summary_type == \'attn\':\n            raise NotImplementedError\n\n        output = self.first_dropout(output)\n        output = self.summary(output)\n        output = self.activation(output)\n        output = self.last_dropout(output)\n\n        return output\n\n\ndef prune_linear_layer(layer, index, dim=0):\n    """""" Prune a linear layer (a model parameters) to keep only entries in index.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    index = index.to(layer.weight.device)\n    W = layer.weight.index_select(dim, index).clone().detach()\n    if layer.bias is not None:\n        if dim == 1:\n            b = layer.bias.clone().detach()\n        else:\n            b = layer.bias[index].clone().detach()\n    new_size = list(layer.weight.size())\n    new_size[dim] = len(index)\n    new_layer = nn.Linear(new_size[1], new_size[0], bias=layer.bias is not None).to(layer.weight.device)\n    new_layer.weight.requires_grad = False\n    new_layer.weight.copy_(W.contiguous())\n    new_layer.weight.requires_grad = True\n    if layer.bias is not None:\n        new_layer.bias.requires_grad = False\n        new_layer.bias.copy_(b.contiguous())\n        new_layer.bias.requires_grad = True\n    return new_layer\n\n\ndef prune_conv1d_layer(layer, index, dim=1):\n    """""" Prune a Conv1D layer (a model parameters) to keep only entries in index.\n        A Conv1D work as a Linear layer (see e.g. BERT) but the weights are transposed.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    index = index.to(layer.weight.device)\n    W = layer.weight.index_select(dim, index).clone().detach()\n    if dim == 0:\n        b = layer.bias.clone().detach()\n    else:\n        b = layer.bias[index].clone().detach()\n    new_size = list(layer.weight.size())\n    new_size[dim] = len(index)\n    new_layer = Conv1D(new_size[1], new_size[0]).to(layer.weight.device)\n    new_layer.weight.requires_grad = False\n    new_layer.weight.copy_(W.contiguous())\n    new_layer.weight.requires_grad = True\n    new_layer.bias.requires_grad = False\n    new_layer.bias.copy_(b.contiguous())\n    new_layer.bias.requires_grad = True\n    return new_layer\n\n\ndef prune_layer(layer, index, dim=None):\n    """""" Prune a Conv1D or nn.Linear layer (a model parameters) to keep only entries in index.\n        Return the pruned layer as a new layer with requires_grad=True.\n        Used to remove heads.\n    """"""\n    if isinstance(layer, nn.Linear):\n        return prune_linear_layer(layer, index, dim=0 if dim is None else dim)\n    elif isinstance(layer, Conv1D):\n        return prune_conv1d_layer(layer, index, dim=1 if dim is None else dim)\n    else:\n        raise ValueError(""Can\'t prune layer of class {}"".format(layer.__class__))\n'"
pybert/model/albert/tokenization_albert.py,0,"b'""""""Tokenization classes.""""""\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\nimport collections\nimport unicodedata\nimport six\nimport logging\nimport sentencepiece as spm\n\nlogger = logging.getLogger(__name__)\nSPIECE_UNDERLINE = u""\xe2\x96\x81""\n\ndef preprocess_text(inputs,remove_space=True,do_lower_case=True):\n  if remove_space:\n    outputs = \' \'.join(inputs.strip().split())\n  else:\n    outputs = inputs\n  outputs = outputs.replace(""``"", \'""\').replace(""\'\'"", \'""\')\n  if six.PY2 and isinstance(outputs, str):\n    outputs = outputs.decode(\'utf-8\')\n  outputs = unicodedata.normalize(""NFKD"", outputs)\n  outputs = """".join([c for c in outputs if not unicodedata.combining(c)])\n  if do_lower_case:\n    outputs = outputs.lower()\n  return outputs\n\ndef encode_pieces(sp_model, text, return_unicode=True, sample=False):\n  """"""turn sentences into word pieces.""""""\n  text = preprocess_text(text,)\n  if six.PY2 and isinstance(text, unicode):\n    text = text.encode(\'utf-8\')\n  if not sample:\n    pieces = sp_model.EncodeAsPieces(text)\n  else:\n    pieces = sp_model.SampleEncodeAsPieces(text, 64, 0.1)\n  new_pieces = []\n  for piece in pieces:\n    if len(piece) > 1 and piece[-1] == \',\' and piece[-2].isdigit():\n      cur_pieces = sp_model.EncodeAsPieces(\n        piece[:-1].replace(SPIECE_UNDERLINE, \'\'))\n      if piece[0] != SPIECE_UNDERLINE and cur_pieces[0][0] == SPIECE_UNDERLINE:\n        if len(cur_pieces[0]) == 1:\n          cur_pieces = cur_pieces[1:]\n        else:\n          cur_pieces[0] = cur_pieces[0][1:]\n      cur_pieces.append(piece[-1])\n      new_pieces.extend(cur_pieces)\n    else:\n      new_pieces.append(piece)\n\n  # note(zhiliny): convert back to unicode for py2\n  if six.PY2 and return_unicode:\n    ret_pieces = []\n    for piece in new_pieces:\n      if isinstance(piece, str):\n        piece = piece.decode(piece, ""utf-8"")\n      ret_pieces.append(piece)\n    new_pieces = ret_pieces\n\n  return new_pieces\n\ndef encode_ids(sp_model, text, sample=False):\n  pieces = encode_pieces(sp_model, text, return_unicode=False, sample=sample)\n  ids = [sp_model.PieceToId(piece) for piece in pieces]\n  return ids\n\n\ndef load_vocab(vocab_file):\n  """"""Loads a vocabulary file into a dictionary.""""""\n  vocab = collections.OrderedDict()\n  with open(vocab_file, ""r"", encoding=""utf-8"") as reader:\n    tokens = reader.readlines()\n  for index, token in enumerate(tokens):\n    token = token.rstrip(\'\\n\')\n    vocab[token] = index\n  return vocab\n\ndef convert_by_vocab(vocab, items):\n  """"""Converts a sequence of [tokens|ids] using the vocab.""""""\n  output = []\n  for item in items:\n    output.append(vocab[item])\n  return output\n\ndef convert_tokens_to_ids(vocab, tokens):\n  return convert_by_vocab(vocab, tokens)\n\ndef convert_ids_to_tokens(inv_vocab, ids):\n  return convert_by_vocab(inv_vocab, ids)\n\ndef whitespace_tokenize(text):\n  """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n  text = text.strip()\n  if not text:\n    return []\n  tokens = text.split()\n  return tokens\n\nclass FullTokenizer(object):\n  """"""Runs end-to-end tokenziation.""""""\n\n  def __init__(self, vocab_file, do_lower_case=True, spm_model_file=None):\n    self.vocab = None\n    self.sp_model = None\n    print(spm_model_file)\n    if spm_model_file:\n      self.sp_model = spm.SentencePieceProcessor()\n      logger.info(""loading sentence piece model"")\n      self.sp_model.Load(str(spm_model_file))\n      # # Note(mingdachen): For the purpose of consisent API, we are\n      # # generating a vocabulary for the sentence piece tokenizer.\n      self.vocab = {self.sp_model.IdToPiece(i): i for i\n                    in range(self.sp_model.GetPieceSize())}\n    else:\n      print(""load vocab"")\n      self.vocab = load_vocab(vocab_file)\n      print(""load token"")\n      self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case)\n      self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab,unk_token=""[UNK]"", max_input_chars_per_word=100)\n    self.inv_vocab = {v: k for k, v in self.vocab.items()}\n\n  def tokenize(self, text):\n    if self.sp_model:\n      split_tokens = encode_pieces(self.sp_model, text, return_unicode=False)\n    else:\n      split_tokens = []\n      for token in self.basic_tokenizer.tokenize(text):\n        for sub_token in self.wordpiece_tokenizer.tokenize(token):\n          split_tokens.append(sub_token)\n\n    return split_tokens\n\n  def convert_tokens_to_ids(self, tokens):\n    if self.sp_model:\n      return [self.sp_model.PieceToId(token) for token in tokens]\n    else:\n      return convert_by_vocab(self.vocab, tokens)\n\n  def convert_ids_to_tokens(self, ids):\n    if self.sp_model:\n      logger.info(""using sentence piece tokenzier."")\n      return [self.sp_model.IdToPiece(id_) for id_ in ids]\n    else:\n      return convert_by_vocab(self.inv_vocab, ids)\n\nclass BasicTokenizer(object):\n  """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n  def __init__(self, do_lower_case=True):\n    """"""Constructs a BasicTokenizer.\n\n    Args:\n      do_lower_case: Whether to lower case the input.\n    """"""\n    self.do_lower_case = do_lower_case\n\n  def tokenize(self, text):\n    """"""Tokenizes a piece of text.""""""\n    text = self._clean_text(text)\n\n    # This was added on November 1st, 2018 for the multilingual and Chinese\n    # models. This is also applied to the English models now, but it doesn\'t\n    # matter since the English models were not trained on any Chinese data\n    # and generally don\'t have any Chinese data in them (there are Chinese\n    # characters in the vocabulary because Wikipedia does have some Chinese\n    # words in the English Wikipedia.).\n    text = self._tokenize_chinese_chars(text)\n    orig_tokens = whitespace_tokenize(text)\n    split_tokens = []\n    for token in orig_tokens:\n      if self.do_lower_case:\n        token = token.lower()\n        token = self._run_strip_accents(token)\n      split_tokens.extend(self._run_split_on_punc(token))\n    output_tokens = whitespace_tokenize("" "".join(split_tokens))\n    return output_tokens\n\n  def _run_strip_accents(self, text):\n    """"""Strips accents from a piece of text.""""""\n    text = unicodedata.normalize(""NFD"", text)\n    output = []\n    for char in text:\n      cat = unicodedata.category(char)\n      if cat == ""Mn"":\n        continue\n      output.append(char)\n    return """".join(output)\n\n  def _run_split_on_punc(self, text):\n    """"""Splits punctuation on a piece of text.""""""\n    chars = list(text)\n    i = 0\n    start_new_word = True\n    output = []\n    while i < len(chars):\n      char = chars[i]\n      if _is_punctuation(char):\n        output.append([char])\n        start_new_word = True\n      else:\n        if start_new_word:\n          output.append([])\n        start_new_word = False\n        output[-1].append(char)\n      i += 1\n\n    return ["""".join(x) for x in output]\n\n  def _tokenize_chinese_chars(self, text):\n    """"""Adds whitespace around any CJK character.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if self._is_chinese_char(cp):\n        output.append("" "")\n        output.append(char)\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\n  def _is_chinese_char(self, cp):\n    """"""Checks whether CP is the codepoint of a CJK character.""""""\n    # This defines a ""chinese character"" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n        (cp >= 0x3400 and cp <= 0x4DBF) or  #\n        (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n        (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n        (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n        (cp >= 0x2B820 and cp <= 0x2CEAF) or\n        (cp >= 0xF900 and cp <= 0xFAFF) or  #\n        (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n      return True\n\n    return False\n\n  def _clean_text(self, text):\n    """"""Performs invalid character removal and whitespace cleanup on text.""""""\n    output = []\n    for char in text:\n      cp = ord(char)\n      if cp == 0 or cp == 0xfffd or _is_control(char):\n        continue\n      if _is_whitespace(char):\n        output.append("" "")\n      else:\n        output.append(char)\n    return """".join(output)\n\nclass WordpieceTokenizer(object):\n    """"""Runs WordPiece tokenization.""""""\n\n    def __init__(self, vocab, unk_token, max_input_chars_per_word=100):\n      self.vocab = vocab\n      self.unk_token = unk_token\n      self.max_input_chars_per_word = max_input_chars_per_word\n\n    def tokenize(self, text):\n      """"""Tokenizes a piece of text into its word pieces.\n\n      This uses a greedy longest-match-first algorithm to perform tokenization\n      using the given vocabulary.\n\n      For example:\n        input = ""unaffable""\n        output = [""un"", ""##aff"", ""##able""]\n\n      Args:\n        text: A single token or whitespace separated tokens. This should have\n          already been passed through `BasicTokenizer`.\n\n      Returns:\n        A list of wordpiece tokens.\n      """"""\n\n      output_tokens = []\n      for token in whitespace_tokenize(text):\n        chars = list(token)\n        if len(chars) > self.max_input_chars_per_word:\n          output_tokens.append(self.unk_token)\n          continue\n\n        is_bad = False\n        start = 0\n        sub_tokens = []\n        while start < len(chars):\n          end = len(chars)\n          cur_substr = None\n          while start < end:\n            substr = """".join(chars[start:end])\n            if start > 0:\n              substr = ""##"" + substr\n            if substr in self.vocab:\n              cur_substr = substr\n              break\n            end -= 1\n          if cur_substr is None:\n            is_bad = True\n            break\n          sub_tokens.append(cur_substr)\n          start = end\n\n        if is_bad:\n          output_tokens.append(self.unk_token)\n        else:\n          output_tokens.extend(sub_tokens)\n      return output_tokens\n\ndef _is_whitespace(char):\n  """"""Checks whether `chars` is a whitespace character.""""""\n  # \\t, \\n, and \\r are technically control characters but we treat them\n  # as whitespace since they are generally considered as such.\n  if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return True\n  cat = unicodedata.category(char)\n  if cat == ""Zs"":\n    return True\n  return False\n\n\ndef _is_control(char):\n  """"""Checks whether `chars` is a control character.""""""\n  # These are technically control characters but we count them as whitespace\n  # characters.\n  if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n    return False\n  cat = unicodedata.category(char)\n  if cat in (""Cc"", ""Cf""):\n    return True\n  return False\n\ndef _is_punctuation(char):\n  """"""Checks whether `chars` is a punctuation character.""""""\n  cp = ord(char)\n  # We treat all non-letter/number ASCII as punctuation.\n  # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n  # Punctuation class but we treat them as punctuation anyways, for\n  # consistency.\n  if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n      (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n    return True\n  cat = unicodedata.category(char)\n  if cat.startswith(""P""):\n    return True\n  return False\n'"
pybert/model/albert/tokenization_bert.py,0,"b'# coding=utf-8\n# Copyright 2018 The Google AI Language Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes.""""""\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport collections\nimport logging\nimport os\nimport unicodedata\nfrom io import open\n\nfrom .tokenization_utils import PreTrainedTokenizer\n\nlogger = logging.getLogger(__name__)\n\nVOCAB_FILES_NAMES = {\'vocab_file\': \'vocab.txt\'}\n\ndef load_vocab(vocab_file):\n    """"""Loads a vocabulary file into a dictionary.""""""\n    vocab = collections.OrderedDict()\n    with open(vocab_file, ""r"", encoding=""utf-8"") as reader:\n        tokens = reader.readlines()\n    for index, token in enumerate(tokens):\n        token = token.rstrip(\'\\n\')\n        vocab[token] = index\n    return vocab\n\n\ndef whitespace_tokenize(text):\n    """"""Runs basic whitespace cleaning and splitting on a piece of text.""""""\n    text = text.strip()\n    if not text:\n        return []\n    tokens = text.split()\n    return tokens\n\n\nclass BertTokenizer(PreTrainedTokenizer):\n    r""""""\n    Constructs a BertTokenizer.\n    :class:`~transformers.BertTokenizer` runs end-to-end tokenization: punctuation splitting + wordpiece\n\n    Args:\n        vocab_file: Path to a one-wordpiece-per-line vocabulary file\n        do_lower_case: Whether to lower case the input. Only has an effect when do_wordpiece_only=False\n        do_basic_tokenize: Whether to do basic tokenization before wordpiece.\n        max_len: An artificial maximum length to truncate tokenized sequences to; Effective maximum length is always the\n            minimum of this value (if specified) and the underlying BERT model\'s sequence length.\n        never_split: List of tokens which will never be split during tokenization. Only has an effect when\n            do_wordpiece_only=False\n    """"""\n\n    vocab_files_names = VOCAB_FILES_NAMES\n\n    def __init__(self, vocab_file, do_lower_case=True, do_basic_tokenize=True, never_split=None,\n                 unk_token=""[UNK]"", sep_token=""[SEP]"", pad_token=""[PAD]"", cls_token=""[CLS]"",\n                 mask_token=""[MASK]"", tokenize_chinese_chars=True, **kwargs):\n        """"""Constructs a BertTokenizer.\n\n        Args:\n            **vocab_file**: Path to a one-wordpiece-per-line vocabulary file\n            **do_lower_case**: (`optional`) boolean (default True)\n                Whether to lower case the input\n                Only has an effect when do_basic_tokenize=True\n            **do_basic_tokenize**: (`optional`) boolean (default True)\n                Whether to do basic tokenization before wordpiece.\n            **never_split**: (`optional`) list of string\n                List of tokens which will never be split during tokenization.\n                Only has an effect when do_basic_tokenize=True\n            **tokenize_chinese_chars**: (`optional`) boolean (default True)\n                Whether to tokenize Chinese characters.\n                This should likely be deactivated for Japanese:\n                see: https://github.com/huggingface/pytorch-pretrained-BERT/issues/328\n        """"""\n        super(BertTokenizer, self).__init__(unk_token=unk_token, sep_token=sep_token,\n                                            pad_token=pad_token, cls_token=cls_token,\n                                            mask_token=mask_token, **kwargs)\n        self.max_len_single_sentence = self.max_len - 2  # take into account special tokens\n        self.max_len_sentences_pair = self.max_len - 3  # take into account special tokens\n\n        if not os.path.isfile(vocab_file):\n            raise ValueError(\n                ""Can\'t find a vocabulary file at path \'{}\'. To load the vocabulary from a Google pretrained ""\n                ""model use `tokenizer = BertTokenizer.from_pretrained(PRETRAINED_MODEL_NAME)`"".format(vocab_file))\n        self.vocab = load_vocab(vocab_file)\n        self.ids_to_tokens = collections.OrderedDict(\n            [(ids, tok) for tok, ids in self.vocab.items()])\n        self.do_basic_tokenize = do_basic_tokenize\n        if do_basic_tokenize:\n            self.basic_tokenizer = BasicTokenizer(do_lower_case=do_lower_case,\n                                                  never_split=never_split,\n                                                  tokenize_chinese_chars=tokenize_chinese_chars)\n        self.wordpiece_tokenizer = WordpieceTokenizer(vocab=self.vocab, unk_token=self.unk_token)\n\n    @property\n    def vocab_size(self):\n        return len(self.vocab)\n\n    def _tokenize(self, text):\n        split_tokens = []\n        if self.do_basic_tokenize:\n            for token in self.basic_tokenizer.tokenize(text, never_split=self.all_special_tokens):\n                for sub_token in self.wordpiece_tokenizer.tokenize(token):\n                    split_tokens.append(sub_token)\n        else:\n            split_tokens = self.wordpiece_tokenizer.tokenize(text)\n        return split_tokens\n\n    def _convert_token_to_id(self, token):\n        """""" Converts a token (str/unicode) in an id using the vocab. """"""\n        return self.vocab.get(token, self.vocab.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        """"""Converts an index (integer) in a token (string/unicode) using the vocab.""""""\n        return self.ids_to_tokens.get(index, self.unk_token)\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string. """"""\n        out_string = \' \'.join(tokens).replace(\' ##\', \'\').strip()\n        return out_string\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A BERT sequence has the following format:\n            single sequence: [CLS] X [SEP]\n            pair of sequences: [CLS] A [SEP] B [SEP]\n        """"""\n        if token_ids_1 is None:\n            return [self.cls_token_id] + token_ids_0 + [self.sep_token_id]\n        cls = [self.cls_token_id]\n        sep = [self.sep_token_id]\n        return cls + token_ids_0 + sep + token_ids_1 + sep\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n\n        if already_has_special_tokens:\n            if token_ids_1 is not None:\n                raise ValueError(""You should not supply a second sequence if the provided sequence of ""\n                                 ""ids is already formated with special tokens for the model."")\n            return list(map(lambda x: 1 if x in [self.sep_token_id, self.cls_token_id] else 0, token_ids_0))\n\n        if token_ids_1 is not None:\n            return [1] + ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1]\n        return [1] + ([0] * len(token_ids_0)) + [1]\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        """"""\n        Creates a mask from the two sequences passed to be used in a sequence-pair classification task.\n        A BERT sequence pair mask has the following format:\n        0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1\n        | first sequence    | second sequence\n\n        if token_ids_1 is None, only returns the first portion of the mask (0\'s).\n        """"""\n        sep = [self.sep_token_id]\n        cls = [self.cls_token_id]\n        if token_ids_1 is None:\n            return len(cls + token_ids_0 + sep) * [0]\n        return len(cls + token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1]\n\n    def save_vocabulary(self, vocab_path):\n        """"""Save the tokenizer vocabulary to a directory or file.""""""\n        index = 0\n        if os.path.isdir(vocab_path):\n            vocab_file = os.path.join(vocab_path, VOCAB_FILES_NAMES[\'vocab_file\'])\n        else:\n            vocab_file = vocab_path\n        with open(vocab_file, ""w"", encoding=""utf-8"") as writer:\n            for token, token_index in sorted(self.vocab.items(), key=lambda kv: kv[1]):\n                if index != token_index:\n                    logger.warning(""Saving vocabulary to {}: vocabulary indices are not consecutive.""\n                                   "" Please check that the vocabulary is not corrupted!"".format(vocab_file))\n                    index = token_index\n                writer.write(token + u\'\\n\')\n                index += 1\n        return (vocab_file,)\n\n\nclass BasicTokenizer(object):\n    """"""Runs basic tokenization (punctuation splitting, lower casing, etc.).""""""\n\n    def __init__(self, do_lower_case=True, never_split=None, tokenize_chinese_chars=True):\n        """""" Constructs a BasicTokenizer.\n\n        Args:\n            **do_lower_case**: Whether to lower case the input.\n            **never_split**: (`optional`) list of str\n                Kept for backward compatibility purposes.\n                Now implemented directly at the base class level (see :func:`PreTrainedTokenizer.tokenize`)\n                List of token not to split.\n            **tokenize_chinese_chars**: (`optional`) boolean (default True)\n                Whether to tokenize Chinese characters.\n                This should likely be deactivated for Japanese:\n                see: https://github.com/huggingface/pytorch-pretrained-BERT/issues/328\n        """"""\n        if never_split is None:\n            never_split = []\n        self.do_lower_case = do_lower_case\n        self.never_split = never_split\n        self.tokenize_chinese_chars = tokenize_chinese_chars\n\n    def tokenize(self, text, never_split=None):\n        """""" Basic Tokenization of a piece of text.\n            Split on ""white spaces"" only, for sub-word tokenization, see WordPieceTokenizer.\n\n        Args:\n            **never_split**: (`optional`) list of str\n                Kept for backward compatibility purposes.\n                Now implemented directly at the base class level (see :func:`PreTrainedTokenizer.tokenize`)\n                List of token not to split.\n        """"""\n        never_split = self.never_split + (never_split if never_split is not None else [])\n        text = self._clean_text(text)\n        # This was added on November 1st, 2018 for the multilingual and Chinese\n        # models. This is also applied to the English models now, but it doesn\'t\n        # matter since the English models were not trained on any Chinese data\n        # and generally don\'t have any Chinese data in them (there are Chinese\n        # characters in the vocabulary because Wikipedia does have some Chinese\n        # words in the English Wikipedia.).\n        if self.tokenize_chinese_chars:\n            text = self._tokenize_chinese_chars(text)\n        orig_tokens = whitespace_tokenize(text)\n        split_tokens = []\n        for token in orig_tokens:\n            if self.do_lower_case and token not in never_split:\n                token = token.lower()\n                token = self._run_strip_accents(token)\n            split_tokens.extend(self._run_split_on_punc(token))\n\n        output_tokens = whitespace_tokenize("" "".join(split_tokens))\n        return output_tokens\n\n    def _run_strip_accents(self, text):\n        """"""Strips accents from a piece of text.""""""\n        text = unicodedata.normalize(""NFD"", text)\n        output = []\n        for char in text:\n            cat = unicodedata.category(char)\n            if cat == ""Mn"":\n                continue\n            output.append(char)\n        return """".join(output)\n\n    def _run_split_on_punc(self, text, never_split=None):\n        """"""Splits punctuation on a piece of text.""""""\n        if never_split is not None and text in never_split:\n            return [text]\n        chars = list(text)\n        i = 0\n        start_new_word = True\n        output = []\n        while i < len(chars):\n            char = chars[i]\n            if _is_punctuation(char):\n                output.append([char])\n                start_new_word = True\n            else:\n                if start_new_word:\n                    output.append([])\n                start_new_word = False\n                output[-1].append(char)\n            i += 1\n\n        return ["""".join(x) for x in output]\n\n    def _tokenize_chinese_chars(self, text):\n        """"""Adds whitespace around any CJK character.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if self._is_chinese_char(cp):\n                output.append("" "")\n                output.append(char)\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n    def _is_chinese_char(self, cp):\n        """"""Checks whether CP is the codepoint of a CJK character.""""""\n        # This defines a ""chinese character"" as anything in the CJK Unicode block:\n        #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n        #\n        # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n        # despite its name. The modern Korean Hangul alphabet is a different block,\n        # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n        # space-separated words, so they are not treated specially and handled\n        # like the all of the other languages.\n        if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n                (cp >= 0x3400 and cp <= 0x4DBF) or  #\n                (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n                (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n                (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n                (cp >= 0x2B820 and cp <= 0x2CEAF) or\n                (cp >= 0xF900 and cp <= 0xFAFF) or  #\n                (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n            return True\n\n        return False\n\n    def _clean_text(self, text):\n        """"""Performs invalid character removal and whitespace cleanup on text.""""""\n        output = []\n        for char in text:\n            cp = ord(char)\n            if cp == 0 or cp == 0xfffd or _is_control(char):\n                continue\n            if _is_whitespace(char):\n                output.append("" "")\n            else:\n                output.append(char)\n        return """".join(output)\n\n\nclass WordpieceTokenizer(object):\n    """"""Runs WordPiece tokenization.""""""\n\n    def __init__(self, vocab, unk_token, max_input_chars_per_word=100):\n        self.vocab = vocab\n        self.unk_token = unk_token\n        self.max_input_chars_per_word = max_input_chars_per_word\n\n    def tokenize(self, text):\n        """"""Tokenizes a piece of text into its word pieces.\n\n        This uses a greedy longest-match-first algorithm to perform tokenization\n        using the given vocabulary.\n\n        For example:\n          input = ""unaffable""\n          output = [""un"", ""##aff"", ""##able""]\n\n        Args:\n          text: A single token or whitespace separated tokens. This should have\n            already been passed through `BasicTokenizer`.\n\n        Returns:\n          A list of wordpiece tokens.\n        """"""\n\n        output_tokens = []\n        for token in whitespace_tokenize(text):\n            chars = list(token)\n            if len(chars) > self.max_input_chars_per_word:\n                output_tokens.append(self.unk_token)\n                continue\n\n            is_bad = False\n            start = 0\n            sub_tokens = []\n            while start < len(chars):\n                end = len(chars)\n                cur_substr = None\n                while start < end:\n                    substr = """".join(chars[start:end])\n                    if start > 0:\n                        substr = ""##"" + substr\n                    if substr in self.vocab:\n                        cur_substr = substr\n                        break\n                    end -= 1\n                if cur_substr is None:\n                    is_bad = True\n                    break\n                sub_tokens.append(cur_substr)\n                start = end\n\n            if is_bad:\n                output_tokens.append(self.unk_token)\n            else:\n                output_tokens.extend(sub_tokens)\n        return output_tokens\n\n\ndef _is_whitespace(char):\n    """"""Checks whether `chars` is a whitespace character.""""""\n    # \\t, \\n, and \\r are technically contorl characters but we treat them\n    # as whitespace since they are generally considered as such.\n    if char == "" "" or char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return True\n    cat = unicodedata.category(char)\n    if cat == ""Zs"":\n        return True\n    return False\n\n\ndef _is_control(char):\n    """"""Checks whether `chars` is a control character.""""""\n    # These are technically control characters but we count them as whitespace\n    # characters.\n    if char == ""\\t"" or char == ""\\n"" or char == ""\\r"":\n        return False\n    cat = unicodedata.category(char)\n    if cat.startswith(""C""):\n        return True\n    return False\n\n\ndef _is_punctuation(char):\n    """"""Checks whether `chars` is a punctuation character.""""""\n    cp = ord(char)\n    # We treat all non-letter/number ASCII as punctuation.\n    # Characters such as ""^"", ""$"", and ""`"" are not in the Unicode\n    # Punctuation class but we treat them as punctuation anyways, for\n    # consistency.\n    if ((cp >= 33 and cp <= 47) or (cp >= 58 and cp <= 64) or\n            (cp >= 91 and cp <= 96) or (cp >= 123 and cp <= 126)):\n        return True\n    cat = unicodedata.category(char)\n    if cat.startswith(""P""):\n        return True\n    return False\n'"
pybert/model/albert/tokenization_utils.py,5,"b'# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n""""""Tokenization classes for OpenAI GPT.""""""\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nimport logging\nimport os\nimport json\nimport six\nimport copy\nfrom io import open\n\nfrom .file_utils import cached_path\n\nimport torch\n\nlogger = logging.getLogger(__name__)\n\nSPECIAL_TOKENS_MAP_FILE = \'special_tokens_map.json\'\nADDED_TOKENS_FILE = \'added_tokens.json\'\nTOKENIZER_CONFIG_FILE = \'tokenizer_config.json\'\n\nclass PreTrainedTokenizer(object):\n    """""" Base class for all tokenizers.\n    Handle all the shared methods for tokenization and special tokens as well as methods dowloading/caching/loading pretrained tokenizers as well as adding tokens to the vocabulary.\n\n    This class also contain the added tokens in a unified way on top of all tokenizers so we don\'t have to handle the specific vocabulary augmentation methods of the various underlying dictionary structures (BPE, sentencepiece...).\n\n    Class attributes (overridden by derived classes):\n\n        - ``vocab_files_names``: a python ``dict`` with, as keys, the ``__init__`` keyword name of each vocabulary file required by the model, and as associated values, the filename for saving the associated file (string).\n        - ``pretrained_vocab_files_map``: a python ``dict of dict`` the high-level keys being the ``__init__`` keyword name of each vocabulary file required by the model, the low-level being the `short-cut-names` (string) of the pretrained models with, as associated values, the `url` (string) to the associated pretrained vocabulary file.\n        - ``max_model_input_sizes``: a python ``dict`` with, as keys, the `short-cut-names` (string) of the pretrained models, and as associated values, the maximum length of the sequence inputs of this model, or None if the model has no maximum input size.\n        - ``pretrained_init_configuration``: a python ``dict`` with, as keys, the `short-cut-names` (string) of the pretrained models, and as associated values, a dictionnary of specific arguments to pass to the ``__init__``method of the tokenizer class for this pretrained model when loading the tokenizer with the ``from_pretrained()`` method.\n\n    Parameters:\n\n        - ``bos_token``: (`Optional`) string: a beginning of sentence token. Will be associated to ``self.bos_token`` and ``self.bos_token_id``\n\n        - ``eos_token``: (`Optional`) string: an end of sentence token. Will be associated to ``self.eos_token`` and ``self.eos_token_id``\n\n        - ``unk_token``: (`Optional`) string: an unknown token. Will be associated to ``self.unk_token`` and ``self.unk_token_id``\n\n        - ``sep_token``: (`Optional`) string: a separation token (e.g. to separate context and query in an input sequence). Will be associated to ``self.sep_token`` and ``self.sep_token_id``\n\n        - ``pad_token``: (`Optional`) string: a padding token. Will be associated to ``self.pad_token`` and ``self.pad_token_id``\n\n        - ``cls_token``: (`Optional`) string: a classification token (e.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model). Will be associated to ``self.cls_token`` and ``self.cls_token_id``\n\n        - ``mask_token``: (`Optional`) string: a masking token (e.g. when training a model with masked-language modeling). Will be associated to ``self.mask_token`` and ``self.mask_token_id``\n\n        - ``additional_special_tokens``: (`Optional`) list: a list of additional special tokens. Adding all special tokens here ensure they won\'t be split by the tokenization process. Will be associated to ``self.additional_special_tokens`` and ``self.additional_special_tokens_ids``\n    """"""\n    vocab_files_names = {}\n    pretrained_vocab_files_map = {}\n    pretrained_init_configuration = {}\n    max_model_input_sizes = {}\n\n    SPECIAL_TOKENS_ATTRIBUTES = [""bos_token"", ""eos_token"", ""unk_token"", ""sep_token"",\n                                 ""pad_token"", ""cls_token"", ""mask_token"",\n                                 ""additional_special_tokens""]\n\n    @property\n    def bos_token(self):\n        """""" Beginning of sentence token (string). Log an error if used while not having been set. """"""\n        if self._bos_token is None:\n            logger.error(""Using bos_token, but it is not set yet."")\n        return self._bos_token\n\n    @property\n    def eos_token(self):\n        """""" End of sentence token (string). Log an error if used while not having been set. """"""\n        if self._eos_token is None:\n            logger.error(""Using eos_token, but it is not set yet."")\n        return self._eos_token\n\n    @property\n    def unk_token(self):\n        """""" Unknown token (string). Log an error if used while not having been set. """"""\n        if self._unk_token is None:\n            logger.error(""Using unk_token, but it is not set yet."")\n        return self._unk_token\n\n    @property\n    def sep_token(self):\n        """""" Separation token (string). E.g. separate context and query in an input sequence. Log an error if used while not having been set. """"""\n        if self._sep_token is None:\n            logger.error(""Using sep_token, but it is not set yet."")\n        return self._sep_token\n\n    @property\n    def pad_token(self):\n        """""" Padding token (string). Log an error if used while not having been set. """"""\n        if self._pad_token is None:\n            logger.error(""Using pad_token, but it is not set yet."")\n        return self._pad_token\n\n    @property\n    def cls_token(self):\n        """""" Classification token (string). E.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model. Log an error if used while not having been set. """"""\n        if self._cls_token is None:\n            logger.error(""Using cls_token, but it is not set yet."")\n        return self._cls_token\n\n    @property\n    def mask_token(self):\n        """""" Mask token (string). E.g. when training a model with masked-language modeling. Log an error if used while not having been set. """"""\n        if self._mask_token is None:\n            logger.error(""Using mask_token, but it is not set yet."")\n        return self._mask_token\n\n    @property\n    def additional_special_tokens(self):\n        """""" All the additional special tokens you may want to use (list of strings). Log an error if used while not having been set. """"""\n        if self._additional_special_tokens is None:\n            logger.error(""Using additional_special_tokens, but it is not set yet."")\n        return self._additional_special_tokens\n\n    @bos_token.setter\n    def bos_token(self, value):\n        self._bos_token = value\n\n    @eos_token.setter\n    def eos_token(self, value):\n        self._eos_token = value\n\n    @unk_token.setter\n    def unk_token(self, value):\n        self._unk_token = value\n\n    @sep_token.setter\n    def sep_token(self, value):\n        self._sep_token = value\n\n    @pad_token.setter\n    def pad_token(self, value):\n        self._pad_token = value\n\n    @cls_token.setter\n    def cls_token(self, value):\n        self._cls_token = value\n\n    @mask_token.setter\n    def mask_token(self, value):\n        self._mask_token = value\n\n    @additional_special_tokens.setter\n    def additional_special_tokens(self, value):\n        self._additional_special_tokens = value\n\n    @property\n    def bos_token_id(self):\n        """""" Id of the beginning of sentence token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.bos_token)\n\n    @property\n    def eos_token_id(self):\n        """""" Id of the end of sentence token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.eos_token)\n\n    @property\n    def unk_token_id(self):\n        """""" Id of the unknown token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.unk_token)\n\n    @property\n    def sep_token_id(self):\n        """""" Id of the separation token in the vocabulary. E.g. separate context and query in an input sequence. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.sep_token)\n\n    @property\n    def pad_token_id(self):\n        """""" Id of the padding token in the vocabulary. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.pad_token)\n\n    @property\n    def cls_token_id(self):\n        """""" Id of the classification token in the vocabulary. E.g. to extract a summary of an input sequence leveraging self-attention along the full depth of the model. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.cls_token)\n\n    @property\n    def mask_token_id(self):\n        """""" Id of the mask token in the vocabulary. E.g. when training a model with masked-language modeling. Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.mask_token)\n\n    @property\n    def additional_special_tokens_ids(self):\n        """""" Ids of all the additional special tokens in the vocabulary (list of integers). Log an error if used while not having been set. """"""\n        return self.convert_tokens_to_ids(self.additional_special_tokens)\n\n    def __init__(self, max_len=None, **kwargs):\n        self._bos_token = None\n        self._eos_token = None\n        self._unk_token = None\n        self._sep_token = None\n        self._pad_token = None\n        self._cls_token = None\n        self._mask_token = None\n        self._additional_special_tokens = []\n\n        self.max_len = max_len if max_len is not None else int(1e12)\n\n        # Added tokens\n        self.added_tokens_encoder = {}\n        self.added_tokens_decoder = {}\n\n        # inputs and kwargs for saving and re-loading (see ``from_pretrained`` and ``save_pretrained``)\n        self.init_inputs = ()\n        self.init_kwargs = {}\n\n        for key, value in kwargs.items():\n            if key in self.SPECIAL_TOKENS_ATTRIBUTES:\n                if key == \'additional_special_tokens\':\n                    assert isinstance(value, (list, tuple)) and all(isinstance(t, str) or (six.PY2 and isinstance(t, unicode)) for t in value)\n                else:\n                    assert isinstance(value, str) or (six.PY2 and isinstance(value, unicode))\n                setattr(self, key, value)\n\n\n    @classmethod\n    def from_pretrained(cls, *inputs, **kwargs):\n        r""""""\n        Instantiate a :class:`~transformers.PreTrainedTokenizer` (or a derived class) from a predefined tokenizer.\n\n        Args:\n            pretrained_model_name_or_path: either:\n\n                - a string with the `shortcut name` of a predefined tokenizer to load from cache or download, e.g.: ``bert-base-uncased``.\n                - a path to a `directory` containing vocabulary files required by the tokenizer, for instance saved using the :func:`~transformers.PreTrainedTokenizer.save_pretrained` method, e.g.: ``./my_model_directory/``.\n                - (not applicable to all derived classes) a path or url to a single saved vocabulary file if and only if the tokenizer only requires a single vocabulary file (e.g. Bert, XLNet), e.g.: ``./my_model_directory/vocab.txt``.\n\n            cache_dir: (`optional`) string:\n                Path to a directory in which a downloaded predefined tokenizer vocabulary files should be cached if the standard cache should not be used.\n\n            force_download: (`optional`) boolean, default False:\n                Force to (re-)download the vocabulary files and override the cached versions if they exists.\n\n            proxies: (`optional`) dict, default None:\n                A dictionary of proxy servers to use by protocol or endpoint, e.g.: {\'http\': \'foo.bar:3128\', \'http://hostname\': \'foo.bar:4012\'}.\n                The proxies are used on each request.\n\n            inputs: (`optional`) positional arguments: will be passed to the Tokenizer ``__init__`` method.\n\n            kwargs: (`optional`) keyword arguments: will be passed to the Tokenizer ``__init__`` method. Can be used to set special tokens like ``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``, ``additional_special_tokens``. See parameters in the doc string of :class:`~transformers.PreTrainedTokenizer` for details.\n\n        Examples::\n\n            # We can\'t instantiate directly the base class `PreTrainedTokenizer` so let\'s show our examples on a derived class: BertTokenizer\n\n            # Download vocabulary from S3 and cache.\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n\n            # If vocabulary files are in a directory (e.g. tokenizer was saved using `save_pretrained(\'./test/saved_model/\')`)\n            tokenizer = BertTokenizer.from_pretrained(\'./test/saved_model/\')\n\n            # If the tokenizer uses a single vocabulary file, you can point directly to this file\n            tokenizer = BertTokenizer.from_pretrained(\'./test/saved_model/my_vocab.txt\')\n\n            # You can link tokens to special vocabulary when instantiating\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\', unk_token=\'<unk>\')\n            # You should be sure \'<unk>\' is in the vocabulary when doing that.\n            # Otherwise use tokenizer.add_special_tokens({\'unk_token\': \'<unk>\'}) instead)\n            assert tokenizer.unk_token == \'<unk>\'\n\n        """"""\n        return cls._from_pretrained(*inputs, **kwargs)\n\n\n    @classmethod\n    def _from_pretrained(cls, pretrained_model_name_or_path, *init_inputs, **kwargs):\n        cache_dir = kwargs.pop(\'cache_dir\', None)\n        force_download = kwargs.pop(\'force_download\', False)\n        proxies = kwargs.pop(\'proxies\', None)\n\n        s3_models = list(cls.max_model_input_sizes.keys())\n        vocab_files = {}\n        init_configuration = {}\n        if pretrained_model_name_or_path in s3_models:\n            # Get the vocabulary from AWS S3 bucket\n            for file_id, map_list in cls.pretrained_vocab_files_map.items():\n                vocab_files[file_id] = map_list[pretrained_model_name_or_path]\n            if cls.pretrained_init_configuration and pretrained_model_name_or_path in cls.pretrained_init_configuration:\n                init_configuration = cls.pretrained_init_configuration[pretrained_model_name_or_path]\n        else:\n            # Get the vocabulary from local files\n            logger.info(\n                ""Model name \'{}\' not found in model shortcut name list ({}). ""\n                ""Assuming \'{}\' is a path or url to a directory containing tokenizer files."".format(\n                    pretrained_model_name_or_path, \', \'.join(s3_models),\n                    pretrained_model_name_or_path))\n\n            # Look for the tokenizer main vocabulary files\n            for file_id, file_name in cls.vocab_files_names.items():\n                if os.path.isdir(pretrained_model_name_or_path):\n                    # If a directory is provided we look for the standard filenames\n                    full_file_name = os.path.join(pretrained_model_name_or_path, file_name)\n                else:\n                    # If a path to a file is provided we use it (will only work for non-BPE tokenizer using a single vocabulary file)\n                    full_file_name = pretrained_model_name_or_path\n                if not os.path.exists(full_file_name):\n                    logger.info(""Didn\'t find file {}. We won\'t load it."".format(full_file_name))\n                    full_file_name = None\n                vocab_files[file_id] = full_file_name\n\n            # Look for the additional tokens files\n            additional_files_names = {\'added_tokens_file\': ADDED_TOKENS_FILE,\n                                      \'special_tokens_map_file\': SPECIAL_TOKENS_MAP_FILE,\n                                      \'tokenizer_config_file\': TOKENIZER_CONFIG_FILE,\n                                      }\n\n            # If a path to a file was provided, get the parent directory\n            saved_directory = pretrained_model_name_or_path\n            if os.path.exists(saved_directory) and not os.path.isdir(saved_directory):\n                saved_directory = os.path.dirname(saved_directory)\n\n            for file_id, file_name in additional_files_names.items():\n                full_file_name = os.path.join(saved_directory, file_name)\n                if not os.path.exists(full_file_name):\n                    logger.info(""Didn\'t find file {}. We won\'t load it."".format(full_file_name))\n                    full_file_name = None\n                vocab_files[file_id] = full_file_name\n\n            if all(full_file_name is None for full_file_name in vocab_files.values()):\n                raise EnvironmentError(\n                    ""Model name \'{}\' was not found in tokenizers model name list ({}). ""\n                    ""We assumed \'{}\' was a path or url to a directory containing vocabulary files ""\n                    ""named {} but couldn\'t find such vocabulary files at this path or url."".format(\n                        pretrained_model_name_or_path, \', \'.join(s3_models),\n                        pretrained_model_name_or_path, \n                        list(cls.vocab_files_names.values())))\n\n        # Get files from url, cache, or disk depending on the case\n        try:\n            resolved_vocab_files = {}\n            for file_id, file_path in vocab_files.items():\n                if file_path is None:\n                    resolved_vocab_files[file_id] = None\n                else:\n                    resolved_vocab_files[file_id] = cached_path(file_path, cache_dir=cache_dir, force_download=force_download, proxies=proxies)\n        except EnvironmentError:\n            if pretrained_model_name_or_path in s3_models:\n                msg = ""Couldn\'t reach server at \'{}\' to download vocabulary files.""\n            else:\n                msg = ""Model name \'{}\' was not found in tokenizers model name list ({}). "" \\\n                    ""We assumed \'{}\' was a path or url to a directory containing vocabulary files "" \\\n                    ""named {}, but couldn\'t find such vocabulary files at this path or url."".format(\n                        pretrained_model_name_or_path, \', \'.join(s3_models),\n                        pretrained_model_name_or_path,\n                        list(cls.vocab_files_names.values()))\n\n            raise EnvironmentError(msg)\n\n        for file_id, file_path in vocab_files.items():\n            if file_path == resolved_vocab_files[file_id]:\n                logger.info(""loading file {}"".format(file_path))\n            else:\n                logger.info(""loading file {} from cache at {}"".format(\n                    file_path, resolved_vocab_files[file_id]))\n\n        # Prepare tokenizer initialization kwargs\n        # Did we saved some inputs and kwargs to reload ?\n        tokenizer_config_file = resolved_vocab_files.pop(\'tokenizer_config_file\', None)\n        if tokenizer_config_file is not None:\n            init_kwargs = json.load(open(tokenizer_config_file, encoding=""utf-8""))\n            saved_init_inputs = init_kwargs.pop(\'init_inputs\', ())\n            if not init_inputs:\n                init_inputs = saved_init_inputs\n        else:\n            init_kwargs = init_configuration\n\n        # Update with newly provided kwargs\n        init_kwargs.update(kwargs)\n\n        # Set max length if needed\n        if pretrained_model_name_or_path in cls.max_model_input_sizes:\n            # if we\'re using a pretrained model, ensure the tokenizer\n            # wont index sequences longer than the number of positional embeddings\n            max_len = cls.max_model_input_sizes[pretrained_model_name_or_path]\n            if max_len is not None and isinstance(max_len, (int, float)):\n                init_kwargs[\'max_len\'] = min(init_kwargs.get(\'max_len\', int(1e12)), max_len)\n\n        # Merge resolved_vocab_files arguments in init_kwargs.\n        added_tokens_file = resolved_vocab_files.pop(\'added_tokens_file\', None)\n        special_tokens_map_file = resolved_vocab_files.pop(\'special_tokens_map_file\', None)\n        for args_name, file_path in resolved_vocab_files.items():\n            if args_name not in init_kwargs:\n                init_kwargs[args_name] = file_path\n        if special_tokens_map_file is not None:\n            special_tokens_map = json.load(open(special_tokens_map_file, encoding=""utf-8""))\n            for key, value in special_tokens_map.items():\n                if key not in init_kwargs:\n                    init_kwargs[key] = value\n\n        # Instantiate tokenizer.\n        tokenizer = cls(*init_inputs, **init_kwargs)\n\n        # Save inputs and kwargs for saving and re-loading with ``save_pretrained``\n        tokenizer.init_inputs = init_inputs\n        tokenizer.init_kwargs = init_kwargs\n\n        # Add supplementary tokens.\n        if added_tokens_file is not None:\n            added_tok_encoder = json.load(open(added_tokens_file, encoding=""utf-8""))\n            added_tok_decoder = {v:k for k, v in added_tok_encoder.items()}\n            tokenizer.added_tokens_encoder.update(added_tok_encoder)\n            tokenizer.added_tokens_decoder.update(added_tok_decoder)\n\n        return tokenizer\n\n\n    def save_pretrained(self, save_directory):\n        """""" Save the tokenizer vocabulary files together with:\n                - added tokens,\n                - special-tokens-to-class-attributes-mapping,\n                - tokenizer instantiation positional and keywords inputs (e.g. do_lower_case for Bert).\n\n            This won\'t save modifications other than (added tokens and special token mapping) you may have\n            applied to the tokenizer after the instantiation (e.g. modifying tokenizer.do_lower_case after creation).\n\n            This method make sure the full tokenizer can then be re-loaded using the :func:`~transformers.PreTrainedTokenizer.from_pretrained` class method.\n        """"""\n        if not os.path.isdir(save_directory):\n            logger.error(""Saving directory ({}) should be a directory"".format(save_directory))\n            return\n\n        special_tokens_map_file = os.path.join(save_directory, SPECIAL_TOKENS_MAP_FILE)\n        added_tokens_file = os.path.join(save_directory, ADDED_TOKENS_FILE)\n        tokenizer_config_file = os.path.join(save_directory, TOKENIZER_CONFIG_FILE)\n\n        tokenizer_config = copy.deepcopy(self.init_kwargs)\n        tokenizer_config[\'init_inputs\'] = copy.deepcopy(self.init_inputs)\n        for file_id in self.vocab_files_names.keys():\n            tokenizer_config.pop(file_id, None)\n\n        with open(tokenizer_config_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(tokenizer_config, ensure_ascii=False))\n\n        with open(special_tokens_map_file, \'w\', encoding=\'utf-8\') as f:\n            f.write(json.dumps(self.special_tokens_map, ensure_ascii=False))\n\n        with open(added_tokens_file, \'w\', encoding=\'utf-8\') as f:\n            if self.added_tokens_encoder:\n                out_str = json.dumps(self.added_tokens_encoder, ensure_ascii=False)\n            else:\n                out_str = u""{}""\n            f.write(out_str)\n\n        vocab_files = self.save_vocabulary(save_directory)\n\n        return vocab_files + (special_tokens_map_file, added_tokens_file)\n\n\n    def save_vocabulary(self, save_directory):\n        """""" Save the tokenizer vocabulary to a directory. This method does *NOT* save added tokens\n            and special token mappings.\n\n            Please use :func:`~transformers.PreTrainedTokenizer.save_pretrained` `()` to save the full Tokenizer state if you want to reload it using the :func:`~transformers.PreTrainedTokenizer.from_pretrained` class method.\n        """"""\n        raise NotImplementedError\n\n\n    def vocab_size(self):\n        """""" Size of the base vocabulary (without the added tokens) """"""\n        raise NotImplementedError\n\n\n    def __len__(self):\n        """""" Size of the full vocabulary with the added tokens """"""\n        return self.vocab_size + len(self.added_tokens_encoder)\n\n\n    def add_tokens(self, new_tokens):\n        """"""\n        Add a list of new tokens to the tokenizer class. If the new tokens are not in the\n        vocabulary, they are added to it with indices starting from length of the current vocabulary.\n\n        Args:\n            new_tokens: list of string. Each string is a token to add. Tokens are only added if they are not already in the vocabulary (tested by checking if the tokenizer assign the index of the ``unk_token`` to them).\n\n        Returns:\n            Number of tokens added to the vocabulary.\n\n        Examples::\n\n            # Let\'s see how to increase the vocabulary of Bert model and tokenizer\n            tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\')\n            model = BertModel.from_pretrained(\'bert-base-uncased\')\n\n            num_added_toks = tokenizer.add_tokens([\'new_tok1\', \'my_new-tok2\'])\n            print(\'We have added\', num_added_toks, \'tokens\')\n            model.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.\n        """"""\n        if not new_tokens:\n            return 0\n\n        to_add_tokens = []\n        for token in new_tokens:\n            assert isinstance(token, str) or (six.PY2 and isinstance(token, unicode))\n            if token != self.unk_token and \\\n                    self.convert_tokens_to_ids(token) == self.convert_tokens_to_ids(self.unk_token) and \\\n                    token not in to_add_tokens:\n                to_add_tokens.append(token)\n                logger.info(""Adding %s to the vocabulary"", token)\n\n        added_tok_encoder = dict((tok, len(self) + i) for i, tok in enumerate(to_add_tokens))\n        added_tok_decoder = {v:k for k, v in added_tok_encoder.items()}\n        self.added_tokens_encoder.update(added_tok_encoder)\n        self.added_tokens_decoder.update(added_tok_decoder)\n\n        return len(to_add_tokens)\n\n    def num_added_tokens(self, pair=False):\n        """"""\n        Returns the number of added tokens when encoding a sequence with special tokens.\n\n        Note:\n            This encodes inputs and checks the number of added tokens, and is therefore not efficient. Do not put this\n            inside your training loop.\n\n        Args:\n            pair: Returns the number of added tokens in the case of a sequence pair if set to True, returns the\n                number of added tokens in the case of a single sequence if set to False.\n\n        Returns:\n            Number of tokens added to sequences\n        """"""\n        token_ids_0 = []\n        token_ids_1 = []\n        return len(self.build_inputs_with_special_tokens(token_ids_0, token_ids_1 if pair else None))\n\n    def add_special_tokens(self, special_tokens_dict):\n        """"""\n        Add a dictionary of special tokens (eos, pad, cls...) to the encoder and link them\n        to class attributes. If special tokens are NOT in the vocabulary, they are added\n        to it (indexed starting from the last index of the current vocabulary).\n\n        Using `add_special_tokens` will ensure your special tokens can be used in several ways:\n\n        - special tokens are carefully handled by the tokenizer (they are never split)\n        - you can easily refer to special tokens using tokenizer class attributes like `tokenizer.cls_token`. This makes it easy to develop model-agnostic training and fine-tuning scripts.\n\n        When possible, special tokens are already registered for provided pretrained models (ex: BertTokenizer cls_token is already registered to be \'[CLS]\' and XLM\'s one is also registered to be \'</s>\')\n\n        Args:\n            special_tokens_dict: dict of string. Keys should be in the list of predefined special attributes:\n                [``bos_token``, ``eos_token``, ``unk_token``, ``sep_token``, ``pad_token``, ``cls_token``, ``mask_token``,\n                ``additional_special_tokens``].\n\n                Tokens are only added if they are not already in the vocabulary (tested by checking if the tokenizer assign the index of the ``unk_token`` to them).\n\n        Returns:\n            Number of tokens added to the vocabulary.\n\n        Examples::\n\n            # Let\'s see how to add a new classification token to GPT-2\n            tokenizer = GPT2Tokenizer.from_pretrained(\'gpt2\')\n            model = GPT2Model.from_pretrained(\'gpt2\')\n\n            special_tokens_dict = {\'cls_token\': \'<CLS>\'}\n\n            num_added_toks = tokenizer.add_special_tokens(special_tokens_dict)\n            print(\'We have added\', num_added_toks, \'tokens\')\n            model.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.\n\n            assert tokenizer.cls_token == \'<CLS>\'\n        """"""\n        if not special_tokens_dict:\n            return 0\n\n        added_tokens = 0\n        for key, value in special_tokens_dict.items():\n            assert key in self.SPECIAL_TOKENS_ATTRIBUTES\n            if key == \'additional_special_tokens\':\n                assert isinstance(value, (list, tuple)) and all(isinstance(t, str) or (six.PY2 and isinstance(t, unicode)) for t in value)\n                added_tokens += self.add_tokens(value)\n            else:\n                assert isinstance(value, str) or (six.PY2 and isinstance(value, unicode))\n                added_tokens += self.add_tokens([value])\n            logger.info(""Assigning %s to the %s key of the tokenizer"", value, key)\n            setattr(self, key, value)\n\n        return added_tokens\n\n    def tokenize(self, text, **kwargs):\n        """""" Converts a string in a sequence of tokens (string), using the tokenizer.\n            Split in words for word-based vocabulary or sub-words for sub-word-based\n            vocabularies (BPE/SentencePieces/WordPieces).\n\n            Take care of added tokens.\n        """"""\n        def split_on_token(tok, text):\n            result = []\n            split_text = text.split(tok)\n            for i, sub_text in enumerate(split_text):\n                sub_text = sub_text.strip()\n                if i == 0 and not sub_text:\n                    result += [tok]\n                elif i == len(split_text) - 1:\n                    if sub_text:\n                        result += [sub_text]\n                    else:\n                        pass\n                else:\n                    if sub_text:\n                        result += [sub_text]\n                    result += [tok]\n            return result\n\n        def split_on_tokens(tok_list, text):\n            if not text:\n                return []\n            if not tok_list:\n                return self._tokenize(text, **kwargs)\n\n            tokenized_text = []\n            text_list = [text]\n            for tok in tok_list:\n                tokenized_text = []\n                for sub_text in text_list:\n                    if sub_text not in self.added_tokens_encoder \\\n                            and sub_text not in self.all_special_tokens:\n                        tokenized_text += split_on_token(tok, sub_text)\n                    else:\n                        tokenized_text += [sub_text]\n                text_list = tokenized_text\n\n            return sum((self._tokenize(token, **kwargs) if token not \\\n                    in self.added_tokens_encoder and token not in self.all_special_tokens \\\n                    else [token] for token in tokenized_text), [])\n\n        added_tokens = list(self.added_tokens_encoder.keys()) + self.all_special_tokens\n        tokenized_text = split_on_tokens(added_tokens, text)\n        return tokenized_text\n\n    def _tokenize(self, text, **kwargs):\n        """""" Converts a string in a sequence of tokens (string), using the tokenizer.\n            Split in words for word-based vocabulary or sub-words for sub-word-based\n            vocabularies (BPE/SentencePieces/WordPieces).\n\n            Do NOT take care of added tokens.\n        """"""\n        raise NotImplementedError\n\n    def convert_tokens_to_ids(self, tokens):\n        """""" Converts a single token, or a sequence of tokens, (str/unicode) in a single integer id\n            (resp. a sequence of ids), using the vocabulary.\n        """"""\n        if tokens is None:\n            return None\n\n        if isinstance(tokens, str) or (six.PY2 and isinstance(tokens, unicode)):\n            return self._convert_token_to_id_with_added_voc(tokens)\n\n        ids = []\n        for token in tokens:\n            ids.append(self._convert_token_to_id_with_added_voc(token))\n        if len(ids) > self.max_len:\n            logger.warning(""Token indices sequence length is longer than the specified maximum sequence length ""\n                           ""for this model ({} > {}). Running this sequence through the model will result in ""\n                           ""indexing errors"".format(len(ids), self.max_len))\n        return ids\n\n    def _convert_token_to_id_with_added_voc(self, token):\n        if token is None:\n            return None\n\n        if token in self.added_tokens_encoder:\n            return self.added_tokens_encoder[token]\n        return self._convert_token_to_id(token)\n\n    def _convert_token_to_id(self, token):\n        raise NotImplementedError\n\n    def encode(self,\n                text,\n                text_pair=None,\n                add_special_tokens=False,\n                max_length=None,\n                stride=0,\n                truncation_strategy=\'longest_first\',\n                return_tensors=None,\n                **kwargs):\n        """"""\n        Converts a string in a sequence of ids (integer), using the tokenizer and vocabulary.\n\n        Same as doing ``self.convert_tokens_to_ids(self.tokenize(text))``.\n\n        Args:\n            text: The first sequence to be encoded. This can be a string, a list of strings (tokenized string using\n                the `tokenize` method) or a list of integers (tokenized string ids using the `convert_tokens_to_ids`\n                method)\n            text_pair: Optional second sequence to be encoded. This can be a string, a list of strings (tokenized\n                string using the `tokenize` method) or a list of integers (tokenized string ids using the\n                `convert_tokens_to_ids` method)\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n            max_length: if set to a number, will limit the total sequence returned so that it has a maximum length.\n                If there are overflowing tokens, those will be added to the returned dictionary\n            stride: if set to a number along with max_length, the overflowing tokens returned will contain some tokens\n                from the main sequence returned. The value of this argument defines the number of additional tokens.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences)\n                - \'only_first\': Only truncate the first sequence\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n            return_tensors: (optional) can be set to \'tf\' or \'pt\' to return respectively TensorFlow tf.constant\n                or PyTorch torch.Tensor instead of a list of python integers.\n            **kwargs: passed to the `self.tokenize()` method\n        """"""\n        encoded_inputs = self.encode_plus(text,\n                                          text_pair=text_pair,\n                                          max_length=max_length,\n                                          add_special_tokens=add_special_tokens,\n                                          stride=stride,\n                                          truncation_strategy=truncation_strategy,\n                                          return_tensors=return_tensors,\n                                          **kwargs)\n\n        return encoded_inputs[""input_ids""]\n\n    def encode_plus(self,\n                    text,\n                    text_pair=None,\n                    add_special_tokens=False,\n                    max_length=None,\n                    stride=0,\n                    truncation_strategy=\'longest_first\',\n                    return_tensors=None,\n                    **kwargs):\n        """"""\n        Returns a dictionary containing the encoded sequence or sequence pair and additional informations:\n        the mask for sequence classification and the overflowing elements if a ``max_length`` is specified.\n\n        Args:\n            text: The first sequence to be encoded. This can be a string, a list of strings (tokenized string using\n                the `tokenize` method) or a list of integers (tokenized string ids using the `convert_tokens_to_ids`\n                method)\n            text_pair: Optional second sequence to be encoded. This can be a string, a list of strings (tokenized\n                string using the `tokenize` method) or a list of integers (tokenized string ids using the\n                `convert_tokens_to_ids` method)\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n            max_length: if set to a number, will limit the total sequence returned so that it has a maximum length.\n                If there are overflowing tokens, those will be added to the returned dictionary\n            stride: if set to a number along with max_length, the overflowing tokens returned will contain some tokens\n                from the main sequence returned. The value of this argument defines the number of additional tokens.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences)\n                - \'only_first\': Only truncate the first sequence\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n            return_tensors: (optional) can be set to \'tf\' or \'pt\' to return respectively TensorFlow tf.constant\n                or PyTorch torch.Tensor instead of a list of python integers.\n            **kwargs: passed to the `self.tokenize()` method\n        """"""\n\n        def get_input_ids(text):\n            if isinstance(text, six.string_types):\n                return self.convert_tokens_to_ids(self.tokenize(text, **kwargs))\n            elif isinstance(text, (list, tuple)) and len(text) > 0 and isinstance(text[0], six.string_types):\n                return self.convert_tokens_to_ids(text)\n            elif isinstance(text, (list, tuple)) and len(text) > 0 and isinstance(text[0], int):\n                return text\n            else:\n                raise ValueError(""Input is not valid. Should be a string, a list/tuple of strings or a list/tuple of integers."")\n\n        first_ids = get_input_ids(text)\n        second_ids = get_input_ids(text_pair) if text_pair is not None else None\n\n        return self.prepare_for_model(first_ids,\n                                      pair_ids=second_ids,\n                                      max_length=max_length,\n                                      add_special_tokens=add_special_tokens,\n                                      stride=stride,\n                                      truncation_strategy=truncation_strategy,\n                                      return_tensors=return_tensors)\n\n    def prepare_for_model(self, ids, pair_ids=None, max_length=None, add_special_tokens=False, stride=0,\n                          truncation_strategy=\'longest_first\', return_tensors=None):\n        """"""\n        Prepares a sequence of input id, or a pair of sequences of inputs ids so that it can be used by the model.\n        It adds special tokens, truncates\n        sequences if overflowing while taking into account the special tokens and manages a window stride for\n        overflowing tokens\n\n        Args:\n            ids: list of tokenized input ids. Can be obtained from a string by chaining the\n                `tokenize` and `convert_tokens_to_ids` methods.\n            pair_ids: Optional second list of input ids. Can be obtained from a string by chaining the\n                `tokenize` and `convert_tokens_to_ids` methods.\n            max_length: maximum length of the returned list. Will truncate by taking into account the special tokens.\n            add_special_tokens: if set to ``True``, the sequences will be encoded with the special tokens relative\n                to their model.\n            stride: window stride for overflowing tokens. Can be useful for edge effect removal when using sequential\n                list of inputs.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences)\n                - \'only_first\': Only truncate the first sequence\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n            return_tensors: (optional) can be set to \'tf\' or \'pt\' to return respectively TensorFlow tf.constant\n                or PyTorch torch.Tensor instead of a list of python integers.\n\n        Return:\n            A Dictionary of shape::\n\n                {\n                    input_ids: list[int],\n                    overflowing_tokens: list[int] if a ``max_length`` is specified, else None\n                    special_tokens_mask: list[int] if ``add_special_tokens`` if set to ``True``\n                }\n\n            With the fields:\n                ``input_ids``: list of tokens to be fed to a model\n\n                ``overflowing_tokens``: list of overflowing tokens if a max length is specified.\n\n                ``special_tokens_mask``: if adding special tokens, this is a list of [0, 1], with 0 specifying special added\n                tokens and 1 specifying sequence tokens.\n        """"""\n        pair = bool(pair_ids is not None)\n        len_ids = len(ids)\n        len_pair_ids = len(pair_ids) if pair else 0\n\n        encoded_inputs = {}\n        total_len = len_ids + len_pair_ids + (self.num_added_tokens(pair=pair) if add_special_tokens else 0)\n        if max_length and total_len > max_length:\n            ids, pair_ids, overflowing_tokens = self.truncate_sequences(ids, pair_ids=pair_ids,\n                                                                        num_tokens_to_remove=total_len-max_length,\n                                                                        truncation_strategy=truncation_strategy,\n                                                                        stride=stride)\n            encoded_inputs[""overflowing_tokens""] = overflowing_tokens\n            encoded_inputs[""num_truncated_tokens""] = total_len - max_length\n\n        if add_special_tokens:\n            sequence = self.build_inputs_with_special_tokens(ids, pair_ids)\n            token_type_ids = self.create_token_type_ids_from_sequences(ids, pair_ids)\n            encoded_inputs[""special_tokens_mask""] = self.get_special_tokens_mask(ids, pair_ids)\n        else:\n            sequence = ids + pair_ids if pair else ids\n            token_type_ids = [0] * len(ids) + ([1] * len(pair_ids) if pair else [])\n\n        if return_tensors == \'tf\' and is_tf_available():\n            sequence = tf.constant([sequence])\n            token_type_ids = tf.constant([token_type_ids])\n        elif return_tensors == \'pt\' and is_torch_available():\n            sequence = torch.tensor([sequence])\n            token_type_ids = torch.tensor([token_type_ids])\n        elif return_tensors is not None:\n            logger.warning(""Unable to convert output to tensors format {}, PyTorch or TensorFlow is not available."".format(return_tensors))\n\n        encoded_inputs[""input_ids""] = sequence\n        encoded_inputs[""token_type_ids""] = token_type_ids\n\n        if max_length and len(encoded_inputs[""input_ids""]) > max_length:\n            encoded_inputs[""input_ids""] = encoded_inputs[""input_ids""][:max_length]\n            encoded_inputs[""token_type_ids""] = encoded_inputs[""token_type_ids""][:max_length]\n            encoded_inputs[""special_tokens_mask""] = encoded_inputs[""special_tokens_mask""][:max_length]\n\n        return encoded_inputs\n\n    def truncate_sequences(self, ids, pair_ids=None, num_tokens_to_remove=0, truncation_strategy=\'longest_first\', stride=0):\n        """"""Truncates a sequence pair in place to the maximum length.\n            truncation_strategy: string selected in the following options:\n                - \'longest_first\' (default) Iteratively reduce the inputs sequence until the input is under max_length\n                    starting from the longest one at each token (when there is a pair of input sequences).\n                    Overflowing tokens only contains overflow from the first sequence.\n                - \'only_first\': Only truncate the first sequence. raise an error if the first sequence is shorter or equal to than num_tokens_to_remove.\n                - \'only_second\': Only truncate the second sequence\n                - \'do_not_truncate\': Does not truncate (raise an error if the input sequence is longer than max_length)\n        """"""\n        if num_tokens_to_remove <= 0:\n            return ids, pair_ids, []\n\n        if truncation_strategy == \'longest_first\':\n            overflowing_tokens = []\n            for _ in range(num_tokens_to_remove):\n                if pair_ids is None or len(ids) > len(pair_ids):\n                    overflowing_tokens = [ids[-1]] + overflowing_tokens\n                    ids = ids[:-1]\n                else:\n                    pair_ids = pair_ids[:-1]\n            window_len = min(len(ids), stride)\n            if window_len > 0:\n                overflowing_tokens = ids[-window_len:] + overflowing_tokens\n        elif truncation_strategy == \'only_first\':\n            assert len(ids) > num_tokens_to_remove\n            window_len = min(len(ids), stride + num_tokens_to_remove)\n            overflowing_tokens = ids[-window_len:]\n            ids = ids[:-num_tokens_to_remove]\n        elif truncation_strategy == \'only_second\':\n            assert pair_ids is not None and len(pair_ids) > num_tokens_to_remove\n            window_len = min(len(pair_ids), stride + num_tokens_to_remove)\n            overflowing_tokens = pair_ids[-window_len:]\n            pair_ids = pair_ids[:-num_tokens_to_remove]\n        elif truncation_strategy == \'do_not_truncate\':\n            raise ValueError(""Input sequence are too long for max_length. Please select a truncation strategy."")\n        else:\n            raise ValueError(""Truncation_strategy should be selected in [\'longest_first\', \'only_first\', \'only_second\', \'do_not_truncate\']"")\n        return (ids, pair_ids, overflowing_tokens)\n\n    def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None):\n        logger.warning(""This tokenizer does not make use of special tokens."")\n        if token_ids_1 is None:\n            return len(token_ids_0) * [0]\n        return [0] * len(token_ids_0) + [1] * len(token_ids_1)\n\n    def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None):\n        """"""\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks\n        by concatenating and adding special tokens.\n        A RoBERTa sequence has the following format:\n            single sequence: <s> X </s>\n            pair of sequences: <s> A </s></s> B </s>\n        """"""\n        logger.warning(""This tokenizer does not make use of special tokens. Input is returned with no modification."")\n        if token_ids_1 is None:\n            return token_ids_0\n        return token_ids_0 + token_ids_1\n\n    def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False):\n        """"""\n        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer ``prepare_for_model`` or ``encode_plus`` methods.\n\n        Args:\n            token_ids_0: list of ids (must not contain special tokens)\n            token_ids_1: Optional list of ids (must not contain special tokens), necessary when fetching sequence ids\n                for sequence pairs\n            already_has_special_tokens: (default False) Set to True if the token list is already formated with\n                special tokens for the model\n\n        Returns:\n            A list of integers in the range [0, 1]: 0 for a special token, 1 for a sequence token.\n        """"""\n        return [0] * ((len(token_ids_1) if token_ids_1 else 0) + len(token_ids_0))\n\n    def convert_ids_to_tokens(self, ids, skip_special_tokens=False):\n        """""" Converts a single index or a sequence of indices (integers) in a token ""\n            (resp.) a sequence of tokens (str/unicode), using the vocabulary and added tokens.\n\n            Args:\n                skip_special_tokens: Don\'t decode special tokens (self.all_special_tokens). Default: False\n        """"""\n        if isinstance(ids, int):\n            if ids in self.added_tokens_decoder:\n                return self.added_tokens_decoder[ids]\n            else:\n                return self._convert_id_to_token(ids)\n        tokens = []\n        for index in ids:\n            if skip_special_tokens and index in self.all_special_ids:\n                continue\n            if index in self.added_tokens_decoder:\n                tokens.append(self.added_tokens_decoder[index])\n            else:\n                tokens.append(self._convert_id_to_token(index))\n        return tokens\n\n    def _convert_id_to_token(self, index):\n        raise NotImplementedError\n\n    def convert_tokens_to_string(self, tokens):\n        """""" Converts a sequence of tokens (string) in a single string.\n            The most simple way to do it is \' \'.join(self.convert_ids_to_tokens(token_ids))\n            but we often want to remove sub-word tokenization artifacts at the same time.\n        """"""\n        return \' \'.join(self.convert_ids_to_tokens(tokens))\n\n    def decode(self, token_ids, skip_special_tokens=False, clean_up_tokenization_spaces=True):\n        """"""\n        Converts a sequence of ids (integer) in a string, using the tokenizer and vocabulary\n        with options to remove special tokens and clean up tokenization spaces.\n        Similar to doing ``self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))``.\n\n        Args:\n            token_ids: list of tokenized input ids. Can be obtained using the `encode` or `encode_plus` methods.\n            skip_special_tokens: if set to True, will replace special tokens.\n            clean_up_tokenization_spaces: if set to True, will clean up the tokenization spaces.\n        """"""\n        filtered_tokens = self.convert_ids_to_tokens(token_ids, skip_special_tokens=skip_special_tokens)\n\n        # To avoid mixing byte-level and unicode for byte-level BPT\n        # we need to build string separatly for added tokens and byte-level tokens\n        # cf. https://github.com/huggingface/transformers/issues/1133\n        sub_texts = []\n        current_sub_text = []\n        for token in filtered_tokens:\n            if skip_special_tokens and token in self.all_special_ids:\n                continue\n            if token in self.added_tokens_encoder:\n                if current_sub_text:\n                    sub_texts.append(self.convert_tokens_to_string(current_sub_text))\n                    current_sub_text = []\n                sub_texts.append("" "" + token)\n            else:\n                current_sub_text.append(token)\n        if current_sub_text:\n            sub_texts.append(self.convert_tokens_to_string(current_sub_text))\n        text = \'\'.join(sub_texts)\n\n        if clean_up_tokenization_spaces:\n            clean_text = self.clean_up_tokenization(text)\n            return clean_text\n        else:\n            return text\n\n    @property\n    def special_tokens_map(self):\n        """""" A dictionary mapping special token class attribute (cls_token, unk_token...) to their\n            values (\'<unk>\', \'<cls>\'...)\n        """"""\n        set_attr = {}\n        for attr in self.SPECIAL_TOKENS_ATTRIBUTES:\n            attr_value = getattr(self, ""_"" + attr)\n            if attr_value:\n                set_attr[attr] = attr_value\n        return set_attr\n\n    @property\n    def all_special_tokens(self):\n        """""" List all the special tokens (\'<unk>\', \'<cls>\'...) mapped to class attributes\n            (cls_token, unk_token...).\n        """"""\n        all_toks = []\n        set_attr = self.special_tokens_map\n        for attr_value in set_attr.values():\n            all_toks = all_toks + (list(attr_value) if isinstance(attr_value, (list, tuple)) else [attr_value])\n        all_toks = list(set(all_toks))\n        return all_toks\n\n    @property\n    def all_special_ids(self):\n        """""" List the vocabulary indices of the special tokens (\'<unk>\', \'<cls>\'...) mapped to\n            class attributes (cls_token, unk_token...).\n        """"""\n        all_toks = self.all_special_tokens\n        all_ids = list(self._convert_token_to_id(t) for t in all_toks)\n        return all_ids\n\n    @staticmethod\n    def clean_up_tokenization(out_string):\n        """""" Clean up a list of simple English tokenization artifacts like spaces before punctuations and abreviated forms.\n        """"""\n        out_string = out_string.replace(\' .\', \'.\').replace(\' ?\', \'?\').replace(\' !\', \'!\').replace(\' ,\', \',\'\n                        ).replace("" \' "", ""\'"").replace("" n\'t"", ""n\'t"").replace("" \'m"", ""\'m"").replace("" do not"", "" don\'t""\n                        ).replace("" \'s"", ""\'s"").replace("" \'ve"", ""\'ve"").replace("" \'re"", ""\'re"")\n        return out_string\n'"
pybert/output/checkpoints/__init__.py,0,b'#encoding:utf-8'
pybert/output/embedding/__init__.py,0,b'#encoding:utf-8'
pybert/output/feature/__init__.py,0,b'#encoding:utf-8'
pybert/output/figure/__init__.py,0,b'#encoding:utf-8'
pybert/output/log/__init__.py,0,b'#encoding:utf-8'
pybert/output/result/__init__.py,0,b'#encoding:utf-8'
pybert/pretrain/albert/albert-base/__init__.py,0,b'#encoding:utf-8'
pybert/pretrain/bert/base-uncased/__init__.py,0,b'#encoding:utf-8'
pybert/pretrain/xlnet/base-cased/__init__.py,0,b'#encoding:utf-8'
