file_path,api_count,code
main.py,2,"b'import argparse\nimport datetime\nimport gym\nimport numpy as np\nimport itertools\nimport torch\nfrom sac import SAC\nfrom torch.utils.tensorboard import SummaryWriter\nfrom replay_memory import ReplayMemory\n\nparser = argparse.ArgumentParser(description=\'PyTorch Soft Actor-Critic Args\')\nparser.add_argument(\'--env-name\', default=""HalfCheetah-v2"",\n                    help=\'Mujoco Gym environment (default: HalfCheetah-v2)\')\nparser.add_argument(\'--policy\', default=""Gaussian"",\n                    help=\'Policy Type: Gaussian | Deterministic (default: Gaussian)\')\nparser.add_argument(\'--eval\', type=bool, default=True,\n                    help=\'Evaluates a policy a policy every 10 episode (default: True)\')\nparser.add_argument(\'--gamma\', type=float, default=0.99, metavar=\'G\',\n                    help=\'discount factor for reward (default: 0.99)\')\nparser.add_argument(\'--tau\', type=float, default=0.005, metavar=\'G\',\n                    help=\'target smoothing coefficient(\xcf\x84) (default: 0.005)\')\nparser.add_argument(\'--lr\', type=float, default=0.0003, metavar=\'G\',\n                    help=\'learning rate (default: 0.0003)\')\nparser.add_argument(\'--alpha\', type=float, default=0.2, metavar=\'G\',\n                    help=\'Temperature parameter \xce\xb1 determines the relative importance of the entropy\\\n                            term against the reward (default: 0.2)\')\nparser.add_argument(\'--automatic_entropy_tuning\', type=bool, default=False, metavar=\'G\',\n                    help=\'Automaically adjust \xce\xb1 (default: False)\')\nparser.add_argument(\'--seed\', type=int, default=123456, metavar=\'N\',\n                    help=\'random seed (default: 123456)\')\nparser.add_argument(\'--batch_size\', type=int, default=256, metavar=\'N\',\n                    help=\'batch size (default: 256)\')\nparser.add_argument(\'--num_steps\', type=int, default=1000001, metavar=\'N\',\n                    help=\'maximum number of steps (default: 1000000)\')\nparser.add_argument(\'--hidden_size\', type=int, default=256, metavar=\'N\',\n                    help=\'hidden size (default: 256)\')\nparser.add_argument(\'--updates_per_step\', type=int, default=1, metavar=\'N\',\n                    help=\'model updates per simulator step (default: 1)\')\nparser.add_argument(\'--start_steps\', type=int, default=10000, metavar=\'N\',\n                    help=\'Steps sampling random actions (default: 10000)\')\nparser.add_argument(\'--target_update_interval\', type=int, default=1, metavar=\'N\',\n                    help=\'Value target update per no. of updates per step (default: 1)\')\nparser.add_argument(\'--replay_size\', type=int, default=1000000, metavar=\'N\',\n                    help=\'size of replay buffer (default: 10000000)\')\nparser.add_argument(\'--cuda\', action=""store_true"",\n                    help=\'run on CUDA (default: False)\')\nargs = parser.parse_args()\n\n# Environment\n# env = NormalizedActions(gym.make(args.env_name))\nenv = gym.make(args.env_name)\ntorch.manual_seed(args.seed)\nnp.random.seed(args.seed)\nenv.seed(args.seed)\n\n# Agent\nagent = SAC(env.observation_space.shape[0], env.action_space, args)\n\n#Tesnorboard\nwriter = SummaryWriter(\'runs/{}_SAC_{}_{}_{}\'.format(datetime.datetime.now().strftime(""%Y-%m-%d_%H-%M-%S""), args.env_name,\n                                                             args.policy, ""autotune"" if args.automatic_entropy_tuning else """"))\n\n# Memory\nmemory = ReplayMemory(args.replay_size)\n\n# Training Loop\ntotal_numsteps = 0\nupdates = 0\n\nfor i_episode in itertools.count(1):\n    episode_reward = 0\n    episode_steps = 0\n    done = False\n    state = env.reset()\n\n    while not done:\n        if args.start_steps > total_numsteps:\n            action = env.action_space.sample()  # Sample random action\n        else:\n            action = agent.select_action(state)  # Sample action from policy\n\n        if len(memory) > args.batch_size:\n            # Number of updates per step in environment\n            for i in range(args.updates_per_step):\n                # Update parameters of all the networks\n                critic_1_loss, critic_2_loss, policy_loss, ent_loss, alpha = agent.update_parameters(memory, args.batch_size, updates)\n\n                writer.add_scalar(\'loss/critic_1\', critic_1_loss, updates)\n                writer.add_scalar(\'loss/critic_2\', critic_2_loss, updates)\n                writer.add_scalar(\'loss/policy\', policy_loss, updates)\n                writer.add_scalar(\'loss/entropy_loss\', ent_loss, updates)\n                writer.add_scalar(\'entropy_temprature/alpha\', alpha, updates)\n                updates += 1\n\n        next_state, reward, done, _ = env.step(action) # Step\n        episode_steps += 1\n        total_numsteps += 1\n        episode_reward += reward\n\n        # Ignore the ""done"" signal if it comes from hitting the time horizon.\n        # (https://github.com/openai/spinningup/blob/master/spinup/algos/sac/sac.py)\n        mask = 1 if episode_steps == env._max_episode_steps else float(not done)\n\n        memory.push(state, action, reward, next_state, mask) # Append transition to memory\n\n        state = next_state\n\n    if total_numsteps > args.num_steps:\n        break\n\n    writer.add_scalar(\'reward/train\', episode_reward, i_episode)\n    print(""Episode: {}, total numsteps: {}, episode steps: {}, reward: {}"".format(i_episode, total_numsteps, episode_steps, round(episode_reward, 2)))\n\n    if i_episode % 10 == 0 and args.eval is True:\n        avg_reward = 0.\n        episodes = 10\n        for _  in range(episodes):\n            state = env.reset()\n            episode_reward = 0\n            done = False\n            while not done:\n                action = agent.select_action(state, evaluate=True)\n\n                next_state, reward, done, _ = env.step(action)\n                episode_reward += reward\n\n\n                state = next_state\n            avg_reward += episode_reward\n        avg_reward /= episodes\n\n\n        writer.add_scalar(\'avg_reward/test\', avg_reward, i_episode)\n\n        print(""----------------------------------------"")\n        print(""Test Episodes: {}, Avg. Reward: {}"".format(episodes, round(avg_reward, 2)))\n        print(""----------------------------------------"")\n\nenv.close()\n\n'"
model.py,19,"b'import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.distributions import Normal\n\nLOG_SIG_MAX = 2\nLOG_SIG_MIN = -20\nepsilon = 1e-6\n\n# Initialize Policy weights\ndef weights_init_(m):\n    if isinstance(m, nn.Linear):\n        torch.nn.init.xavier_uniform_(m.weight, gain=1)\n        torch.nn.init.constant_(m.bias, 0)\n\n\nclass ValueNetwork(nn.Module):\n    def __init__(self, num_inputs, hidden_dim):\n        super(ValueNetwork, self).__init__()\n\n        self.linear1 = nn.Linear(num_inputs, hidden_dim)\n        self.linear2 = nn.Linear(hidden_dim, hidden_dim)\n        self.linear3 = nn.Linear(hidden_dim, 1)\n\n        self.apply(weights_init_)\n\n    def forward(self, state):\n        x = F.relu(self.linear1(state))\n        x = F.relu(self.linear2(x))\n        x = self.linear3(x)\n        return x\n\n\nclass QNetwork(nn.Module):\n    def __init__(self, num_inputs, num_actions, hidden_dim):\n        super(QNetwork, self).__init__()\n\n        # Q1 architecture\n        self.linear1 = nn.Linear(num_inputs + num_actions, hidden_dim)\n        self.linear2 = nn.Linear(hidden_dim, hidden_dim)\n        self.linear3 = nn.Linear(hidden_dim, 1)\n\n        # Q2 architecture\n        self.linear4 = nn.Linear(num_inputs + num_actions, hidden_dim)\n        self.linear5 = nn.Linear(hidden_dim, hidden_dim)\n        self.linear6 = nn.Linear(hidden_dim, 1)\n\n        self.apply(weights_init_)\n\n    def forward(self, state, action):\n        xu = torch.cat([state, action], 1)\n        \n        x1 = F.relu(self.linear1(xu))\n        x1 = F.relu(self.linear2(x1))\n        x1 = self.linear3(x1)\n\n        x2 = F.relu(self.linear4(xu))\n        x2 = F.relu(self.linear5(x2))\n        x2 = self.linear6(x2)\n\n        return x1, x2\n\n\nclass GaussianPolicy(nn.Module):\n    def __init__(self, num_inputs, num_actions, hidden_dim, action_space=None):\n        super(GaussianPolicy, self).__init__()\n        \n        self.linear1 = nn.Linear(num_inputs, hidden_dim)\n        self.linear2 = nn.Linear(hidden_dim, hidden_dim)\n\n        self.mean_linear = nn.Linear(hidden_dim, num_actions)\n        self.log_std_linear = nn.Linear(hidden_dim, num_actions)\n\n        self.apply(weights_init_)\n\n        # action rescaling\n        if action_space is None:\n            self.action_scale = torch.tensor(1.)\n            self.action_bias = torch.tensor(0.)\n        else:\n            self.action_scale = torch.FloatTensor(\n                (action_space.high - action_space.low) / 2.)\n            self.action_bias = torch.FloatTensor(\n                (action_space.high + action_space.low) / 2.)\n\n    def forward(self, state):\n        x = F.relu(self.linear1(state))\n        x = F.relu(self.linear2(x))\n        mean = self.mean_linear(x)\n        log_std = self.log_std_linear(x)\n        log_std = torch.clamp(log_std, min=LOG_SIG_MIN, max=LOG_SIG_MAX)\n        return mean, log_std\n\n    def sample(self, state):\n        mean, log_std = self.forward(state)\n        std = log_std.exp()\n        normal = Normal(mean, std)\n        x_t = normal.rsample()  # for reparameterization trick (mean + std * N(0,1))\n        y_t = torch.tanh(x_t)\n        action = y_t * self.action_scale + self.action_bias\n        log_prob = normal.log_prob(x_t)\n        # Enforcing Action Bound\n        log_prob -= torch.log(self.action_scale * (1 - y_t.pow(2)) + epsilon)\n        log_prob = log_prob.sum(1, keepdim=True)\n        mean = torch.tanh(mean) * self.action_scale + self.action_bias\n        return action, log_prob, mean\n\n    def to(self, device):\n        self.action_scale = self.action_scale.to(device)\n        self.action_bias = self.action_bias.to(device)\n        return super(GaussianPolicy, self).to(device)\n\n\nclass DeterministicPolicy(nn.Module):\n    def __init__(self, num_inputs, num_actions, hidden_dim, action_space=None):\n        super(DeterministicPolicy, self).__init__()\n        self.linear1 = nn.Linear(num_inputs, hidden_dim)\n        self.linear2 = nn.Linear(hidden_dim, hidden_dim)\n\n        self.mean = nn.Linear(hidden_dim, num_actions)\n        self.noise = torch.Tensor(num_actions)\n\n        self.apply(weights_init_)\n\n        # action rescaling\n        if action_space is None:\n            self.action_scale = 1.\n            self.action_bias = 0.\n        else:\n            self.action_scale = torch.FloatTensor(\n                (action_space.high - action_space.low) / 2.)\n            self.action_bias = torch.FloatTensor(\n                (action_space.high + action_space.low) / 2.)\n\n    def forward(self, state):\n        x = F.relu(self.linear1(state))\n        x = F.relu(self.linear2(x))\n        mean = torch.tanh(self.mean(x)) * self.action_scale + self.action_bias\n        return mean\n\n    def sample(self, state):\n        mean = self.forward(state)\n        noise = self.noise.normal_(0., std=0.1)\n        noise = noise.clamp(-0.25, 0.25)\n        action = mean + noise\n        return action, torch.tensor(0.), mean\n\n    def to(self, device):\n        self.action_scale = self.action_scale.to(device)\n        self.action_bias = self.action_bias.to(device)\n        self.noise = self.noise.to(device)\n        return super(DeterministicPolicy, self).to(device)\n'"
replay_memory.py,0,"b'import random\nimport numpy as np\n\nclass ReplayMemory:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.buffer = []\n        self.position = 0\n\n    def push(self, state, action, reward, next_state, done):\n        if len(self.buffer) < self.capacity:\n            self.buffer.append(None)\n        self.buffer[self.position] = (state, action, reward, next_state, done)\n        self.position = (self.position + 1) % self.capacity\n\n    def sample(self, batch_size):\n        batch = random.sample(self.buffer, batch_size)\n        state, action, reward, next_state, done = map(np.stack, zip(*batch))\n        return state, action, reward, next_state, done\n\n    def __len__(self):\n        return len(self.buffer)\n'"
sac.py,20,"b'import os\nimport torch\nimport torch.nn.functional as F\nfrom torch.optim import Adam\nfrom utils import soft_update, hard_update\nfrom model import GaussianPolicy, QNetwork, DeterministicPolicy\n\n\nclass SAC(object):\n    def __init__(self, num_inputs, action_space, args):\n\n        self.gamma = args.gamma\n        self.tau = args.tau\n        self.alpha = args.alpha\n\n        self.policy_type = args.policy\n        self.target_update_interval = args.target_update_interval\n        self.automatic_entropy_tuning = args.automatic_entropy_tuning\n\n        self.device = torch.device(""cuda"" if args.cuda else ""cpu"")\n\n        self.critic = QNetwork(num_inputs, action_space.shape[0], args.hidden_size).to(device=self.device)\n        self.critic_optim = Adam(self.critic.parameters(), lr=args.lr)\n\n        self.critic_target = QNetwork(num_inputs, action_space.shape[0], args.hidden_size).to(self.device)\n        hard_update(self.critic_target, self.critic)\n\n        if self.policy_type == ""Gaussian"":\n            # Target Entropy = \xe2\x88\x92dim(A) (e.g. , -6 for HalfCheetah-v2) as given in the paper\n            if self.automatic_entropy_tuning is True:\n                self.target_entropy = -torch.prod(torch.Tensor(action_space.shape).to(self.device)).item()\n                self.log_alpha = torch.zeros(1, requires_grad=True, device=self.device)\n                self.alpha_optim = Adam([self.log_alpha], lr=args.lr)\n\n            self.policy = GaussianPolicy(num_inputs, action_space.shape[0], args.hidden_size, action_space).to(self.device)\n            self.policy_optim = Adam(self.policy.parameters(), lr=args.lr)\n\n        else:\n            self.alpha = 0\n            self.automatic_entropy_tuning = False\n            self.policy = DeterministicPolicy(num_inputs, action_space.shape[0], args.hidden_size, action_space).to(self.device)\n            self.policy_optim = Adam(self.policy.parameters(), lr=args.lr)\n\n    def select_action(self, state, evaluate=False):\n        state = torch.FloatTensor(state).to(self.device).unsqueeze(0)\n        if evaluate is False:\n            action, _, _ = self.policy.sample(state)\n        else:\n            _, _, action = self.policy.sample(state)\n        return action.detach().cpu().numpy()[0]\n\n    def update_parameters(self, memory, batch_size, updates):\n        # Sample a batch from memory\n        state_batch, action_batch, reward_batch, next_state_batch, mask_batch = memory.sample(batch_size=batch_size)\n\n        state_batch = torch.FloatTensor(state_batch).to(self.device)\n        next_state_batch = torch.FloatTensor(next_state_batch).to(self.device)\n        action_batch = torch.FloatTensor(action_batch).to(self.device)\n        reward_batch = torch.FloatTensor(reward_batch).to(self.device).unsqueeze(1)\n        mask_batch = torch.FloatTensor(mask_batch).to(self.device).unsqueeze(1)\n\n        with torch.no_grad():\n            next_state_action, next_state_log_pi, _ = self.policy.sample(next_state_batch)\n            qf1_next_target, qf2_next_target = self.critic_target(next_state_batch, next_state_action)\n            min_qf_next_target = torch.min(qf1_next_target, qf2_next_target) - self.alpha * next_state_log_pi\n            next_q_value = reward_batch + mask_batch * self.gamma * (min_qf_next_target)\n        qf1, qf2 = self.critic(state_batch, action_batch)  # Two Q-functions to mitigate positive bias in the policy improvement step\n        qf1_loss = F.mse_loss(qf1, next_q_value)  # JQ = \xf0\x9d\x94\xbc(st,at)~D[0.5(Q1(st,at) - r(st,at) - \xce\xb3(\xf0\x9d\x94\xbcst+1~p[V(st+1)]))^2]\n        qf2_loss = F.mse_loss(qf2, next_q_value)  # JQ = \xf0\x9d\x94\xbc(st,at)~D[0.5(Q1(st,at) - r(st,at) - \xce\xb3(\xf0\x9d\x94\xbcst+1~p[V(st+1)]))^2]\n        qf_loss = qf1_loss + qf2_loss\n\n        self.critic_optim.zero_grad()\n        qf_loss.backward()\n        self.critic_optim.step()\n\n        pi, log_pi, _ = self.policy.sample(state_batch)\n\n        qf1_pi, qf2_pi = self.critic(state_batch, pi)\n        min_qf_pi = torch.min(qf1_pi, qf2_pi)\n\n        policy_loss = ((self.alpha * log_pi) - min_qf_pi).mean() # J\xcf\x80 = \xf0\x9d\x94\xbcst\xe2\x88\xbcD,\xce\xb5t\xe2\x88\xbcN[\xce\xb1 * log\xcf\x80(f(\xce\xb5t;st)|st) \xe2\x88\x92 Q(st,f(\xce\xb5t;st))]\n\n        self.policy_optim.zero_grad()\n        policy_loss.backward()\n        self.policy_optim.step()\n\n        if self.automatic_entropy_tuning:\n            alpha_loss = -(self.log_alpha * (log_pi + self.target_entropy).detach()).mean()\n\n            self.alpha_optim.zero_grad()\n            alpha_loss.backward()\n            self.alpha_optim.step()\n\n            self.alpha = self.log_alpha.exp()\n            alpha_tlogs = self.alpha.clone() # For TensorboardX logs\n        else:\n            alpha_loss = torch.tensor(0.).to(self.device)\n            alpha_tlogs = torch.tensor(self.alpha) # For TensorboardX logs\n\n\n        if updates % self.target_update_interval == 0:\n            soft_update(self.critic_target, self.critic, self.tau)\n\n        return qf1_loss.item(), qf2_loss.item(), policy_loss.item(), alpha_loss.item(), alpha_tlogs.item()\n\n    # Save model parameters\n    def save_model(self, env_name, suffix="""", actor_path=None, critic_path=None):\n        if not os.path.exists(\'models/\'):\n            os.makedirs(\'models/\')\n\n        if actor_path is None:\n            actor_path = ""models/sac_actor_{}_{}"".format(env_name, suffix)\n        if critic_path is None:\n            critic_path = ""models/sac_critic_{}_{}"".format(env_name, suffix)\n        print(\'Saving models to {} and {}\'.format(actor_path, critic_path))\n        torch.save(self.policy.state_dict(), actor_path)\n        torch.save(self.critic.state_dict(), critic_path)\n\n    # Load model parameters\n    def load_model(self, actor_path, critic_path):\n        print(\'Loading models from {} and {}\'.format(actor_path, critic_path))\n        if actor_path is not None:\n            self.policy.load_state_dict(torch.load(actor_path))\n        if critic_path is not None:\n            self.critic.load_state_dict(torch.load(critic_path))\n\n'"
utils.py,1,"b'import math\nimport torch\n\ndef create_log_gaussian(mean, log_std, t):\n    quadratic = -((0.5 * (t - mean) / (log_std.exp())).pow(2))\n    l = mean.shape\n    log_z = log_std\n    z = l[-1] * math.log(2 * math.pi)\n    log_p = quadratic.sum(dim=-1) - log_z.sum(dim=-1) - 0.5 * z\n    return log_p\n\ndef logsumexp(inputs, dim=None, keepdim=False):\n    if dim is None:\n        inputs = inputs.view(-1)\n        dim = 0\n    s, _ = torch.max(inputs, dim=dim, keepdim=True)\n    outputs = s + (inputs - s).exp().sum(dim=dim, keepdim=True).log()\n    if not keepdim:\n        outputs = outputs.squeeze(dim)\n    return outputs\n\ndef soft_update(target, source, tau):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(target_param.data * (1.0 - tau) + param.data * tau)\n\ndef hard_update(target, source):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(param.data)\n'"
