file_path,api_count,code
setup.py,3,"b""import os\nimport os.path as osp\nimport glob\nfrom setuptools import setup, find_packages\n\nimport torch\nfrom torch.utils.cpp_extension import BuildExtension\nfrom torch.utils.cpp_extension import CppExtension, CUDAExtension, CUDA_HOME\n\nWITH_CUDA = torch.cuda.is_available() and CUDA_HOME is not None\nif os.getenv('FORCE_CUDA', '0') == '1':\n    WITH_CUDA = True\nif os.getenv('FORCE_CPU', '0') == '1':\n    WITH_CUDA = False\n\nBUILD_DOCS = os.getenv('BUILD_DOCS', '0') == '1'\n\n\ndef get_extensions():\n    Extension = CppExtension\n    define_macros = []\n    extra_compile_args = {'cxx': []}\n\n    if WITH_CUDA:\n        Extension = CUDAExtension\n        define_macros += [('WITH_CUDA', None)]\n        nvcc_flags = os.getenv('NVCC_FLAGS', '')\n        nvcc_flags = [] if nvcc_flags == '' else nvcc_flags.split(' ')\n        nvcc_flags += ['-arch=sm_35', '--expt-relaxed-constexpr']\n        extra_compile_args['nvcc'] = nvcc_flags\n\n    extensions_dir = osp.join(osp.dirname(osp.abspath(__file__)), 'csrc')\n    main_files = glob.glob(osp.join(extensions_dir, '*.cpp'))\n    extensions = []\n    for main in main_files:\n        name = main.split(os.sep)[-1][:-4]\n\n        sources = [main]\n\n        path = osp.join(extensions_dir, 'cpu', f'{name}_cpu.cpp')\n        if osp.exists(path):\n            sources += [path]\n\n        path = osp.join(extensions_dir, 'cuda', f'{name}_cuda.cu')\n        if WITH_CUDA and osp.exists(path):\n            sources += [path]\n\n        extension = Extension(\n            'torch_cluster._' + name,\n            sources,\n            include_dirs=[extensions_dir],\n            define_macros=define_macros,\n            extra_compile_args=extra_compile_args,\n        )\n        extensions += [extension]\n\n    return extensions\n\n\ninstall_requires = ['scipy']\nsetup_requires = ['pytest-runner']\ntests_require = ['pytest', 'pytest-cov']\n\nsetup(\n    name='torch_cluster',\n    version='1.5.4',\n    author='Matthias Fey',\n    author_email='matthias.fey@tu-dortmund.de',\n    url='https://github.com/rusty1s/pytorch_cluster',\n    description=('PyTorch Extension Library of Optimized Graph Cluster '\n                 'Algorithms'),\n    keywords=[\n        'pytorch',\n        'geometric-deep-learning',\n        'graph-neural-networks',\n        'cluster-algorithms',\n    ],\n    license='MIT',\n    python_requires='>=3.6',\n    install_requires=install_requires,\n    setup_requires=setup_requires,\n    tests_require=tests_require,\n    ext_modules=get_extensions() if not BUILD_DOCS else [],\n    cmdclass={\n        'build_ext':\n        BuildExtension.with_options(no_python_abi_suffix=True, use_ninja=False)\n    },\n    packages=find_packages(),\n)\n"""
script/rename_wheel.py,0,"b""import sys\nimport os\nimport os.path as osp\nimport glob\nimport shutil\n\nidx = sys.argv[1]\nassert idx in ['cpu', 'cu92', 'cu101', 'cu102']\n\ndist_dir = osp.join(osp.dirname(osp.abspath(__file__)), '..', 'dist')\nwheels = glob.glob(osp.join('dist', '**', '*.whl'), recursive=True)\n\nfor wheel in wheels:\n    if idx in wheel:\n        continue\n\n    paths = wheel.split(osp.sep)\n    names = paths[-1].split('-')\n\n    name = '-'.join(names[:-4] + ['latest+' + idx] + names[-3:])\n    shutil.copyfile(wheel, osp.join(*paths[:-1], name))\n\n    name = '-'.join(names[:-4] + [names[-4] + '+' + idx] + names[-3:])\n    os.rename(wheel, osp.join(*paths[:-1], name))\n"""
test/__init__.py,0,b''
test/test_fps.py,5,"b""from itertools import product\n\nimport pytest\nimport torch\nfrom torch_cluster import fps\n\nfrom .utils import grad_dtypes, devices, tensor\n\n\n@pytest.mark.parametrize('dtype,device', product(grad_dtypes, devices))\ndef test_fps(dtype, device):\n    x = tensor([\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n        [-2, -2],\n        [-2, +2],\n        [+2, +2],\n        [+2, -2],\n    ], dtype, device)\n    batch = tensor([0, 0, 0, 0, 1, 1, 1, 1], torch.long, device)\n\n    out = fps(x, batch, ratio=0.5, random_start=False)\n    assert out.tolist() == [0, 2, 4, 6]\n\n    out = fps(x, ratio=0.5, random_start=False)\n    assert out.sort()[0].tolist() == [0, 5, 6, 7]\n\n\n@pytest.mark.parametrize('device', devices)\ndef test_random_fps(device):\n    N = 1024\n    for _ in range(5):\n        pos = torch.randn((2 * N, 3), device=device)\n        batch_1 = torch.zeros(N, dtype=torch.long, device=device)\n        batch_2 = torch.ones(N, dtype=torch.long, device=device)\n        batch = torch.cat([batch_1, batch_2])\n        idx = fps(pos, batch, ratio=0.5)\n        assert idx.min() >= 0 and idx.max() < 2 * N\n"""
test/test_graclus.py,6,"b""from itertools import product\n\nimport pytest\nimport torch\nfrom torch_cluster import graclus_cluster\n\nfrom .utils import dtypes, devices, tensor\n\ntests = [{\n    'row': [0, 0, 1, 1, 1, 2, 2, 2, 3, 3],\n    'col': [1, 2, 0, 2, 3, 0, 1, 3, 1, 2],\n}, {\n    'row': [0, 0, 1, 1, 1, 2, 2, 2, 3, 3],\n    'col': [1, 2, 0, 2, 3, 0, 1, 3, 1, 2],\n    'weight': [1, 2, 1, 3, 2, 2, 3, 1, 2, 1],\n}]\n\n\ndef assert_correct(row, col, cluster):\n    row, col, cluster = row.to('cpu'), col.to('cpu'), cluster.to('cpu')\n    n = cluster.size(0)\n\n    # Every node was assigned a cluster.\n    assert cluster.min() >= 0\n\n    # There are no more than two nodes in each cluster.\n    _, index = torch.unique(cluster, return_inverse=True)\n    count = torch.zeros_like(cluster)\n    count.scatter_add_(0, index, torch.ones_like(cluster))\n    assert (count > 2).max() == 0\n\n    # Cluster value is minimal.\n    assert (cluster <= torch.arange(n, dtype=cluster.dtype)).sum() == n\n\n    # Corresponding clusters must be adjacent.\n    for i in range(n):\n        x = cluster[col[row == i]] == cluster[i]  # Neighbors with same cluster\n        y = cluster == cluster[i]  # Nodes with same cluster.\n        y[i] = 0  # Do not look at cluster of `i`.\n        assert x.sum() == y.sum()\n\n\n@pytest.mark.parametrize('test,dtype,device', product(tests, dtypes, devices))\ndef test_graclus_cluster(test, dtype, device):\n    row = tensor(test['row'], torch.long, device)\n    col = tensor(test['col'], torch.long, device)\n    weight = tensor(test.get('weight'), dtype, device)\n\n    cluster = graclus_cluster(row, col, weight)\n    assert_correct(row, col, cluster)\n"""
test/test_grid.py,0,"b""from itertools import product\n\nimport pytest\nfrom torch_cluster import grid_cluster\n\nfrom .utils import dtypes, devices, tensor\n\ntests = [{\n    'pos': [2, 6],\n    'size': [5],\n    'cluster': [0, 0],\n}, {\n    'pos': [2, 6],\n    'size': [5],\n    'start': [0],\n    'cluster': [0, 1],\n}, {\n    'pos': [[0, 0], [11, 9], [2, 8], [2, 2], [8, 3]],\n    'size': [5, 5],\n    'cluster': [0, 5, 3, 0, 1],\n}, {\n    'pos': [[0, 0], [11, 9], [2, 8], [2, 2], [8, 3]],\n    'size': [5, 5],\n    'end': [19, 19],\n    'cluster': [0, 6, 4, 0, 1],\n}]\n\n\n@pytest.mark.parametrize('test,dtype,device', product(tests, dtypes, devices))\ndef test_grid_cluster(test, dtype, device):\n    pos = tensor(test['pos'], dtype, device)\n    size = tensor(test['size'], dtype, device)\n    start = tensor(test.get('start'), dtype, device)\n    end = tensor(test.get('end'), dtype, device)\n\n    cluster = grid_cluster(pos, size, start, end)\n    assert cluster.tolist() == test['cluster']\n"""
test/test_knn.py,2,"b""from itertools import product\n\nimport pytest\nimport torch\nfrom torch_cluster import knn, knn_graph\n\nfrom .utils import grad_dtypes, devices, tensor\n\n\n@pytest.mark.parametrize('dtype,device', product(grad_dtypes, devices))\ndef test_knn(dtype, device):\n    x = tensor([\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n    ], dtype, device)\n    y = tensor([\n        [1, 0],\n        [-1, 0],\n    ], dtype, device)\n\n    batch_x = tensor([0, 0, 0, 0, 1, 1, 1, 1], torch.long, device)\n    batch_y = tensor([0, 1], torch.long, device)\n\n    row, col = knn(x, y, 2, batch_x, batch_y)\n    col = col.view(-1, 2).sort(dim=-1)[0].view(-1)\n\n    assert row.tolist() == [0, 0, 1, 1]\n    assert col.tolist() == [2, 3, 4, 5]\n\n    if x.is_cuda:\n        row, col = knn(x, y, 2, batch_x, batch_y, cosine=True)\n        assert row.tolist() == [0, 0, 1, 1]\n        assert col.tolist() == [0, 1, 4, 5]\n\n\n@pytest.mark.parametrize('dtype,device', product(grad_dtypes, devices))\ndef test_knn_graph(dtype, device):\n    x = tensor([\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n    ], dtype, device)\n\n    row, col = knn_graph(x, k=2, flow='target_to_source')\n    col = col.view(-1, 2).sort(dim=-1)[0].view(-1)\n    assert row.tolist() == [0, 0, 1, 1, 2, 2, 3, 3]\n    assert col.tolist() == [1, 3, 0, 2, 1, 3, 0, 2]\n\n    row, col = knn_graph(x, k=2, flow='source_to_target')\n    row = row.view(-1, 2).sort(dim=-1)[0].view(-1)\n    assert row.tolist() == [1, 3, 0, 2, 1, 3, 0, 2]\n    assert col.tolist() == [0, 0, 1, 1, 2, 2, 3, 3]\n"""
test/test_nearest.py,2,"b""from itertools import product\n\nimport pytest\nimport torch\nfrom torch_cluster import nearest\n\nfrom .utils import grad_dtypes, devices, tensor\n\n\n@pytest.mark.parametrize('dtype,device', product(grad_dtypes, devices))\ndef test_nearest(dtype, device):\n    x = tensor([\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n        [-2, -2],\n        [-2, +2],\n        [+2, +2],\n        [+2, -2],\n    ], dtype, device)\n    y = tensor([\n        [-1, 0],\n        [+1, 0],\n        [-2, 0],\n        [+2, 0],\n    ], dtype, device)\n\n    batch_x = tensor([0, 0, 0, 0, 1, 1, 1, 1], torch.long, device)\n    batch_y = tensor([0, 0, 1, 1], torch.long, device)\n\n    out = nearest(x, y, batch_x, batch_y)\n    assert out.tolist() == [0, 0, 1, 1, 2, 2, 3, 3]\n\n    out = nearest(x, y)\n    assert out.tolist() == [0, 0, 1, 1, 2, 2, 3, 3]\n"""
test/test_radius.py,4,"b""from itertools import product\n\nimport pytest\nimport torch\nfrom torch_cluster import radius, radius_graph\n\nfrom .utils import grad_dtypes, devices, tensor\n\n\ndef coalesce(index):\n    N = index.max().item() + 1\n    tensor = torch.sparse_coo_tensor(index, index.new_ones(index.size(1)),\n                                     torch.Size([N, N]))\n    return tensor.coalesce().indices()\n\n\n@pytest.mark.parametrize('dtype,device', product(grad_dtypes, devices))\ndef test_radius(dtype, device):\n    x = tensor([\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n    ], dtype, device)\n    y = tensor([\n        [0, 0],\n        [0, 1],\n    ], dtype, device)\n\n    batch_x = tensor([0, 0, 0, 0, 1, 1, 1, 1], torch.long, device)\n    batch_y = tensor([0, 1], torch.long, device)\n\n    out = radius(x, y, 2, batch_x, batch_y, max_num_neighbors=4)\n    assert coalesce(out).tolist() == [[0, 0, 0, 0, 1, 1], [0, 1, 2, 3, 5, 6]]\n\n\n@pytest.mark.parametrize('dtype,device', product(grad_dtypes, devices))\ndef test_radius_graph(dtype, device):\n    x = tensor([\n        [-1, -1],\n        [-1, +1],\n        [+1, +1],\n        [+1, -1],\n    ], dtype, device)\n\n    row, col = radius_graph(x, r=2, flow='target_to_source')\n    col = col.view(-1, 2).sort(dim=-1)[0].view(-1)\n    assert row.tolist() == [0, 0, 1, 1, 2, 2, 3, 3]\n    assert col.tolist() == [1, 3, 0, 2, 1, 3, 0, 2]\n\n    row, col = radius_graph(x, r=2, flow='source_to_target')\n    row = row.view(-1, 2).sort(dim=-1)[0].view(-1)\n    assert row.tolist() == [1, 3, 0, 2, 1, 3, 0, 2]\n    assert col.tolist() == [0, 0, 1, 1, 2, 2, 3, 3]\n"""
test/test_rw.py,3,"b""import pytest\nimport torch\nfrom torch_cluster import random_walk\n\nfrom .utils import devices, tensor\n\n\n@pytest.mark.parametrize('device', devices)\ndef test_rw(device):\n    row = tensor([0, 1, 1, 1, 2, 2, 3, 3, 4, 4], torch.long, device)\n    col = tensor([1, 0, 2, 3, 1, 4, 1, 4, 2, 3], torch.long, device)\n    start = tensor([0, 1, 2, 3, 4], torch.long, device)\n    walk_length = 10\n\n    out = random_walk(row, col, start, walk_length, coalesced=True)\n    assert out[:, 0].tolist() == start.tolist()\n\n    for n in range(start.size(0)):\n        cur = start[n].item()\n        for l in range(1, walk_length):\n            assert out[n, l].item() in col[row == cur].tolist()\n            cur = out[n, l].item()\n"""
test/test_sampler.py,3,"b'import torch\n\nfrom torch_cluster import neighbor_sampler\n\n\ndef test_neighbor_sampler():\n    torch.manual_seed(1234)\n\n    start = torch.tensor([0, 1])\n    cumdeg = torch.tensor([0, 3, 7])\n\n    e_id = neighbor_sampler(start, cumdeg, size=1.0)\n    assert e_id.tolist() == [0, 2, 1, 5, 6, 3, 4]\n\n    e_id = neighbor_sampler(start, cumdeg, size=3)\n    assert e_id.tolist() == [1, 0, 2, 4, 5, 6]\n'"
test/utils.py,6,"b""import torch\n\ndtypes = [torch.float, torch.double, torch.int, torch.long]\ngrad_dtypes = [torch.float, torch.double]\n\ndevices = [torch.device('cpu')]\nif torch.cuda.is_available():\n    devices += [torch.device(f'cuda:{torch.cuda.current_device()}')]\n\n\ndef tensor(x, dtype, device):\n    return None if x is None else torch.tensor(x, dtype=dtype, device=device)\n"""
torch_cluster/__init__.py,4,"b""import importlib\nimport os.path as osp\n\nimport torch\n\n__version__ = '1.5.4'\n\nfor library in [\n        '_version', '_grid', '_graclus', '_fps', '_rw', '_sampler', '_nearest',\n        '_knn', '_radius'\n]:\n    torch.ops.load_library(importlib.machinery.PathFinder().find_spec(\n        library, [osp.dirname(__file__)]).origin)\n\nif torch.version.cuda is not None:  # pragma: no cover\n    cuda_version = torch.ops.torch_cluster.cuda_version()\n\n    if cuda_version == -1:\n        major = minor = 0\n    elif cuda_version < 10000:\n        major, minor = int(str(cuda_version)[0]), int(str(cuda_version)[2])\n    else:\n        major, minor = int(str(cuda_version)[0:2]), int(str(cuda_version)[3])\n    t_major, t_minor = [int(x) for x in torch.version.cuda.split('.')]\n\n    if t_major != major or t_minor != minor:\n        raise RuntimeError(\n            f'Detected that PyTorch and torch_cluster were compiled with '\n            f'different CUDA versions. PyTorch has CUDA version '\n            f'{t_major}.{t_minor} and torch_cluster has CUDA version '\n            f'{major}.{minor}. Please reinstall the torch_cluster that '\n            f'matches your PyTorch install.')\n\nfrom .graclus import graclus_cluster  # noqa\nfrom .grid import grid_cluster  # noqa\nfrom .fps import fps  # noqa\nfrom .nearest import nearest  # noqa\nfrom .knn import knn, knn_graph  # noqa\nfrom .radius import radius, radius_graph  # noqa\nfrom .rw import random_walk  # noqa\nfrom .sampler import neighbor_sampler  # noqa\n\n__all__ = [\n    'graclus_cluster',\n    'grid_cluster',\n    'fps',\n    'nearest',\n    'knn',\n    'knn_graph',\n    'radius',\n    'radius_graph',\n    'random_walk',\n    'neighbor_sampler',\n    '__version__',\n]\n"""
torch_cluster/fps.py,10,"b'from typing import Optional\n\nimport torch\n\n\n@torch.jit.script\ndef fps(src: torch.Tensor, batch: Optional[torch.Tensor] = None,\n        ratio: float = 0.5, random_start: bool = True) -> torch.Tensor:\n    r""""""""A sampling algorithm from the `""PointNet++: Deep Hierarchical Feature\n    Learning on Point Sets in a Metric Space""\n    <https://arxiv.org/abs/1706.02413>`_ paper, which iteratively samples the\n    most distant point with regard to the rest points.\n\n    Args:\n        src (Tensor): Point feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{N \\times F}`.\n        batch (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^N`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        ratio (float, optional): Sampling ratio. (default: :obj:`0.5`)\n        random_start (bool, optional): If set to :obj:`False`, use the first\n            node in :math:`\\mathbf{X}` as starting node. (default: obj:`True`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import fps\n\n        src = torch.Tensor([[-1, -1], [-1, 1], [1, -1], [1, 1]])\n        batch = torch.tensor([0, 0, 0, 0])\n        index = fps(src, batch, ratio=0.5)\n    """"""\n\n    if batch is not None:\n        assert src.size(0) == batch.numel()\n        batch_size = int(batch.max()) + 1\n\n        deg = src.new_zeros(batch_size, dtype=torch.long)\n        deg.scatter_add_(0, batch, torch.ones_like(batch))\n\n        ptr = deg.new_zeros(batch_size + 1)\n        torch.cumsum(deg, 0, out=ptr[1:])\n    else:\n        ptr = torch.tensor([0, src.size(0)], device=src.device)\n\n    return torch.ops.torch_cluster.fps(src, ptr, ratio, random_start)\n'"
torch_cluster/graclus.py,12,"b'from typing import Optional\n\nimport torch\n\n\n@torch.jit.script\ndef graclus_cluster(row: torch.Tensor, col: torch.Tensor,\n                    weight: Optional[torch.Tensor] = None,\n                    num_nodes: Optional[int] = None) -> torch.Tensor:\n    """"""A greedy clustering algorithm of picking an unmarked vertex and matching\n    it with one its unmarked neighbors (that maximizes its edge weight).\n\n    Args:\n        row (LongTensor): Source nodes.\n        col (LongTensor): Target nodes.\n        weight (Tensor, optional): Edge weights. (default: :obj:`None`)\n        num_nodes (int, optional): The number of nodes. (default: :obj:`None`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import graclus_cluster\n\n        row = torch.tensor([0, 1, 1, 2])\n        col = torch.tensor([1, 0, 2, 1])\n        weight = torch.Tensor([1, 1, 1, 1])\n        cluster = graclus_cluster(row, col, weight)\n    """"""\n\n    if num_nodes is None:\n        num_nodes = max(int(row.max()), int(col.max())) + 1\n\n    # Remove self-loops.\n    mask = row != col\n    row, col = row[mask], col[mask]\n\n    if weight is not None:\n        weight = weight[mask]\n\n    # Randomly shuffle nodes.\n    if weight is None:\n        perm = torch.randperm(row.size(0), dtype=torch.long, device=row.device)\n        row, col = row[perm], col[perm]\n\n    # To CSR.\n    perm = torch.argsort(row)\n    row, col = row[perm], col[perm]\n\n    if weight is not None:\n        weight = weight[perm]\n\n    deg = row.new_zeros(num_nodes)\n    deg.scatter_add_(0, row, torch.ones_like(row))\n    rowptr = row.new_zeros(num_nodes + 1)\n    torch.cumsum(deg, 0, out=rowptr[1:])\n\n    return torch.ops.torch_cluster.graclus(rowptr, col, weight)\n'"
torch_cluster/grid.py,7,"b'from typing import Optional\n\nimport torch\n\n\n@torch.jit.script\ndef grid_cluster(pos: torch.Tensor, size: torch.Tensor,\n                 start: Optional[torch.Tensor] = None,\n                 end: Optional[torch.Tensor] = None) -> torch.Tensor:\n    """"""A clustering algorithm, which overlays a regular grid of user-defined\n    size over a point cloud and clusters all points within a voxel.\n\n    Args:\n        pos (Tensor): D-dimensional position of points.\n        size (Tensor): Size of a voxel in each dimension.\n        start (Tensor, optional): Start position of the grid (in each\n            dimension). (default: :obj:`None`)\n        end (Tensor, optional): End position of the grid (in each\n            dimension). (default: :obj:`None`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import grid_cluster\n\n        pos = torch.Tensor([[0, 0], [11, 9], [2, 8], [2, 2], [8, 3]])\n        size = torch.Tensor([5, 5])\n        cluster = grid_cluster(pos, size)\n    """"""\n    return torch.ops.torch_cluster.grid(pos, size, start, end)\n'"
torch_cluster/knn.py,31,"b'from typing import Optional\n\nimport torch\nimport scipy.spatial\n\n\ndef knn(x: torch.Tensor, y: torch.Tensor, k: int,\n        batch_x: Optional[torch.Tensor] = None,\n        batch_y: Optional[torch.Tensor] = None,\n        cosine: bool = False) -> torch.Tensor:\n    r""""""Finds for each element in :obj:`y` the :obj:`k` nearest points in\n    :obj:`x`.\n\n    Args:\n        x (Tensor): Node feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{N \\times F}`.\n        y (Tensor): Node feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{M \\times F}`.\n        k (int): The number of neighbors.\n        batch_x (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^N`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        batch_y (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^M`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        cosine (boolean, optional): If :obj:`True`, will use the cosine\n            distance instead of euclidean distance to find nearest neighbors.\n            (default: :obj:`False`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import knn\n\n        x = torch.Tensor([[-1, -1], [-1, 1], [1, -1], [1, 1]])\n        batch_x = torch.tensor([0, 0, 0, 0])\n        y = torch.Tensor([[-1, 0], [1, 0]])\n        batch_x = torch.tensor([0, 0])\n        assign_index = knn(x, y, 2, batch_x, batch_y)\n    """"""\n\n    x = x.view(-1, 1) if x.dim() == 1 else x\n    y = y.view(-1, 1) if y.dim() == 1 else y\n\n    if x.is_cuda:\n        if batch_x is not None:\n            assert x.size(0) == batch_x.numel()\n            batch_size = int(batch_x.max()) + 1\n\n            deg = x.new_zeros(batch_size, dtype=torch.long)\n            deg.scatter_add_(0, batch_x, torch.ones_like(batch_x))\n\n            ptr_x = deg.new_zeros(batch_size + 1)\n            torch.cumsum(deg, 0, out=ptr_x[1:])\n        else:\n            ptr_x = torch.tensor([0, x.size(0)], device=x.device)\n\n        if batch_y is not None:\n            assert y.size(0) == batch_y.numel()\n            batch_size = int(batch_y.max()) + 1\n\n            deg = y.new_zeros(batch_size, dtype=torch.long)\n            deg.scatter_add_(0, batch_y, torch.ones_like(batch_y))\n\n            ptr_y = deg.new_zeros(batch_size + 1)\n            torch.cumsum(deg, 0, out=ptr_y[1:])\n        else:\n            ptr_y = torch.tensor([0, y.size(0)], device=y.device)\n\n        return torch.ops.torch_cluster.knn(x, y, ptr_x, ptr_y, k, cosine)\n    else:\n        if batch_x is None:\n            batch_x = x.new_zeros(x.size(0), dtype=torch.long)\n\n        if batch_y is None:\n            batch_y = y.new_zeros(y.size(0), dtype=torch.long)\n\n        assert x.dim() == 2 and batch_x.dim() == 1\n        assert y.dim() == 2 and batch_y.dim() == 1\n        assert x.size(1) == y.size(1)\n        assert x.size(0) == batch_x.size(0)\n        assert y.size(0) == batch_y.size(0)\n\n        if cosine:\n            raise NotImplementedError(\'`cosine` argument not supported on CPU\')\n\n        # Translate and rescale x and y to [0, 1].\n        min_xy = min(x.min().item(), y.min().item())\n        x, y = x - min_xy, y - min_xy\n\n        max_xy = max(x.max().item(), y.max().item())\n        x.div_(max_xy)\n        y.div_(max_xy)\n\n        # Concat batch/features to ensure no cross-links between examples.\n        x = torch.cat([x, 2 * x.size(1) * batch_x.view(-1, 1).to(x.dtype)], -1)\n        y = torch.cat([y, 2 * y.size(1) * batch_y.view(-1, 1).to(y.dtype)], -1)\n\n        tree = scipy.spatial.cKDTree(x.detach().numpy())\n        dist, col = tree.query(y.detach().cpu(), k=k,\n                               distance_upper_bound=x.size(1))\n        dist = torch.from_numpy(dist).to(x.dtype)\n        col = torch.from_numpy(col).to(torch.long)\n        row = torch.arange(col.size(0), dtype=torch.long)\n        row = row.view(-1, 1).repeat(1, k)\n        mask = ~torch.isinf(dist).view(-1)\n        row, col = row.view(-1)[mask], col.view(-1)[mask]\n\n        return torch.stack([row, col], dim=0)\n\n\ndef knn_graph(x: torch.Tensor, k: int, batch: Optional[torch.Tensor] = None,\n              loop: bool = False, flow: str = \'source_to_target\',\n              cosine: bool = False) -> torch.Tensor:\n    r""""""Computes graph edges to the nearest :obj:`k` points.\n\n    Args:\n        x (Tensor): Node feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{N \\times F}`.\n        k (int): The number of neighbors.\n        batch (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^N`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        loop (bool, optional): If :obj:`True`, the graph will contain\n            self-loops. (default: :obj:`False`)\n        flow (string, optional): The flow direction when using in combination\n            with message passing (:obj:`""source_to_target""` or\n            :obj:`""target_to_source""`). (default: :obj:`""source_to_target""`)\n        cosine (boolean, optional): If :obj:`True`, will use the cosine\n            distance instead of euclidean distance to find nearest neighbors.\n            (default: :obj:`False`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import knn_graph\n\n        x = torch.Tensor([[-1, -1], [-1, 1], [1, -1], [1, 1]])\n        batch = torch.tensor([0, 0, 0, 0])\n        edge_index = knn_graph(x, k=2, batch=batch, loop=False)\n    """"""\n\n    assert flow in [\'source_to_target\', \'target_to_source\']\n    row, col = knn(x, x, k if loop else k + 1, batch, batch, cosine=cosine)\n    row, col = (col, row) if flow == \'source_to_target\' else (row, col)\n    if not loop:\n        mask = row != col\n        row, col = row[mask], col[mask]\n    return torch.stack([row, col], dim=0)\n'"
torch_cluster/nearest.py,22,"b'from typing import Optional\n\nimport torch\nimport scipy.cluster\n\n\ndef nearest(x: torch.Tensor, y: torch.Tensor,\n            batch_x: Optional[torch.Tensor] = None,\n            batch_y: Optional[torch.Tensor] = None) -> torch.Tensor:\n    r""""""Clusters points in :obj:`x` together which are nearest to a given query\n    point in :obj:`y`.\n\n    Args:\n        x (Tensor): Node feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{N \\times F}`.\n        y (Tensor): Node feature matrix\n            :math:`\\mathbf{Y} \\in \\mathbb{R}^{M \\times F}`.\n        batch_x (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^N`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        batch_y (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^M`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import nearest\n\n        x = torch.Tensor([[-1, -1], [-1, 1], [1, -1], [1, 1]])\n        batch_x = torch.tensor([0, 0, 0, 0])\n        y = torch.Tensor([[-1, 0], [1, 0]])\n        batch_y = torch.tensor([0, 0])\n        cluster = nearest(x, y, batch_x, batch_y)\n    """"""\n\n    x = x.view(-1, 1) if x.dim() == 1 else x\n    y = y.view(-1, 1) if y.dim() == 1 else y\n\n    if x.is_cuda:\n        if batch_x is not None:\n            assert x.size(0) == batch_x.numel()\n            batch_size = int(batch_x.max()) + 1\n\n            deg = x.new_zeros(batch_size, dtype=torch.long)\n            deg.scatter_add_(0, batch_x, torch.ones_like(batch_x))\n\n            ptr_x = deg.new_zeros(batch_size + 1)\n            torch.cumsum(deg, 0, out=ptr_x[1:])\n        else:\n            ptr_x = torch.tensor([0, x.size(0)], device=x.device)\n\n        if batch_y is not None:\n            assert y.size(0) == batch_y.numel()\n            batch_size = int(batch_y.max()) + 1\n\n            deg = y.new_zeros(batch_size, dtype=torch.long)\n            deg.scatter_add_(0, batch_y, torch.ones_like(batch_y))\n\n            ptr_y = deg.new_zeros(batch_size + 1)\n            torch.cumsum(deg, 0, out=ptr_y[1:])\n        else:\n            ptr_y = torch.tensor([0, y.size(0)], device=y.device)\n\n        return torch.ops.torch_cluster.nearest(x, y, ptr_x, ptr_y)\n    else:\n        if batch_x is None:\n            batch_x = x.new_zeros(x.size(0), dtype=torch.long)\n\n        if batch_y is None:\n            batch_y = y.new_zeros(y.size(0), dtype=torch.long)\n\n        assert x.dim() == 2 and batch_x.dim() == 1\n        assert y.dim() == 2 and batch_y.dim() == 1\n        assert x.size(1) == y.size(1)\n        assert x.size(0) == batch_x.size(0)\n        assert y.size(0) == batch_y.size(0)\n\n        # Translate and rescale x and y to [0, 1].\n        min_xy = min(x.min().item(), y.min().item())\n        x, y = x - min_xy, y - min_xy\n\n        max_xy = max(x.max().item(), y.max().item())\n        x.div_(max_xy)\n        y.div_(max_xy)\n\n        # Concat batch/features to ensure no cross-links between examples.\n        x = torch.cat([x, 2 * x.size(1) * batch_x.view(-1, 1).to(x.dtype)], -1)\n        y = torch.cat([y, 2 * y.size(1) * batch_y.view(-1, 1).to(y.dtype)], -1)\n\n        return torch.from_numpy(\n            scipy.cluster.vq.vq(x.detach().cpu(),\n                                y.detach().cpu())[0]).to(torch.long)\n'"
torch_cluster/radius.py,34,"b'from typing import Optional\n\nimport torch\nimport scipy.spatial\n\n\n@torch.jit.script\ndef sample(col: torch.Tensor, count: int) -> torch.Tensor:\n    if col.size(0) > count:\n        col = col[torch.randperm(col.size(0), dtype=torch.long)][:count]\n    return col\n\n\ndef radius(x: torch.Tensor, y: torch.Tensor, r: float,\n           batch_x: Optional[torch.Tensor] = None,\n           batch_y: Optional[torch.Tensor] = None,\n           max_num_neighbors: int = 32) -> torch.Tensor:\n    r""""""Finds for each element in :obj:`y` all points in :obj:`x` within\n    distance :obj:`r`.\n\n    Args:\n        x (Tensor): Node feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{N \\times F}`.\n        y (Tensor): Node feature matrix\n            :math:`\\mathbf{Y} \\in \\mathbb{R}^{M \\times F}`.\n        r (float): The radius.\n        batch_x (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^N`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        batch_y (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^M`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        max_num_neighbors (int, optional): The maximum number of neighbors to\n            return for each element in :obj:`y`. (default: :obj:`32`)\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import radius\n\n        x = torch.Tensor([[-1, -1], [-1, 1], [1, -1], [1, 1]])\n        batch_x = torch.tensor([0, 0, 0, 0])\n        y = torch.Tensor([[-1, 0], [1, 0]])\n        batch_y = torch.tensor([0, 0])\n        assign_index = radius(x, y, 1.5, batch_x, batch_y)\n    """"""\n\n    x = x.view(-1, 1) if x.dim() == 1 else x\n    y = y.view(-1, 1) if y.dim() == 1 else y\n\n    if x.is_cuda:\n        if batch_x is not None:\n            assert x.size(0) == batch_x.numel()\n            batch_size = int(batch_x.max()) + 1\n\n            deg = x.new_zeros(batch_size, dtype=torch.long)\n            deg.scatter_add_(0, batch_x, torch.ones_like(batch_x))\n\n            ptr_x = deg.new_zeros(batch_size + 1)\n            torch.cumsum(deg, 0, out=ptr_x[1:])\n        else:\n            ptr_x = torch.tensor([0, x.size(0)], device=x.device)\n\n        if batch_y is not None:\n            assert y.size(0) == batch_y.numel()\n            batch_size = int(batch_y.max()) + 1\n\n            deg = y.new_zeros(batch_size, dtype=torch.long)\n            deg.scatter_add_(0, batch_y, torch.ones_like(batch_y))\n            ptr_y = deg.new_zeros(batch_size + 1)\n            torch.cumsum(deg, 0, out=ptr_y[1:])\n        else:\n            ptr_y = torch.tensor([0, y.size(0)], device=y.device)\n\n        return torch.ops.torch_cluster.radius(x, y, ptr_x, ptr_y, r,\n                                              max_num_neighbors)\n    else:\n        if batch_x is None:\n            batch_x = x.new_zeros(x.size(0), dtype=torch.long)\n\n        if batch_y is None:\n            batch_y = y.new_zeros(y.size(0), dtype=torch.long)\n\n        assert x.dim() == 2 and batch_x.dim() == 1\n        assert y.dim() == 2 and batch_y.dim() == 1\n        assert x.size(1) == y.size(1)\n        assert x.size(0) == batch_x.size(0)\n        assert y.size(0) == batch_y.size(0)\n\n        x = torch.cat([x, 2 * r * batch_x.view(-1, 1).to(x.dtype)], dim=-1)\n        y = torch.cat([y, 2 * r * batch_y.view(-1, 1).to(y.dtype)], dim=-1)\n\n        tree = scipy.spatial.cKDTree(x.detach().numpy())\n        col = tree.query_ball_point(y.detach().numpy(), r)\n        col = [torch.tensor(c, dtype=torch.long) for c in col]\n        col = [sample(c, max_num_neighbors) for c in col]\n        row = [torch.full_like(c, i) for i, c in enumerate(col)]\n        row, col = torch.cat(row, dim=0), torch.cat(col, dim=0)\n        mask = col < int(tree.n)\n        return torch.stack([row[mask], col[mask]], dim=0)\n\n\ndef radius_graph(x: torch.Tensor, r: float,\n                 batch: Optional[torch.Tensor] = None, loop: bool = False,\n                 max_num_neighbors: int = 32,\n                 flow: str = \'source_to_target\') -> torch.Tensor:\n    r""""""Computes graph edges to all points within a given distance.\n\n    Args:\n        x (Tensor): Node feature matrix\n            :math:`\\mathbf{X} \\in \\mathbb{R}^{N \\times F}`.\n        r (float): The radius.\n        batch (LongTensor, optional): Batch vector\n            :math:`\\mathbf{b} \\in {\\{ 0, \\ldots, B-1\\}}^N`, which assigns each\n            node to a specific example. (default: :obj:`None`)\n        loop (bool, optional): If :obj:`True`, the graph will contain\n            self-loops. (default: :obj:`False`)\n        max_num_neighbors (int, optional): The maximum number of neighbors to\n            return for each element in :obj:`y`. (default: :obj:`32`)\n        flow (string, optional): The flow direction when using in combination\n            with message passing (:obj:`""source_to_target""` or\n            :obj:`""target_to_source""`). (default: :obj:`""source_to_target""`)\n\n    :rtype: :class:`LongTensor`\n\n    .. code-block:: python\n\n        import torch\n        from torch_cluster import radius_graph\n\n        x = torch.Tensor([[-1, -1], [-1, 1], [1, -1], [1, 1]])\n        batch = torch.tensor([0, 0, 0, 0])\n        edge_index = radius_graph(x, r=1.5, batch=batch, loop=False)\n    """"""\n\n    assert flow in [\'source_to_target\', \'target_to_source\']\n    row, col = radius(x, x, r, batch, batch,\n                      max_num_neighbors if loop else max_num_neighbors + 1)\n    row, col = (col, row) if flow == \'source_to_target\' else (row, col)\n    if not loop:\n        mask = row != col\n        row, col = row[mask], col[mask]\n    return torch.stack([row, col], dim=0)\n'"
torch_cluster/rw.py,6,"b'import warnings\nfrom typing import Optional\n\nimport torch\n\n\n@torch.jit.script\ndef random_walk(row: torch.Tensor, col: torch.Tensor, start: torch.Tensor,\n                walk_length: int, p: float = 1, q: float = 1,\n                coalesced: bool = True, num_nodes: Optional[int] = None):\n    """"""Samples random walks of length :obj:`walk_length` from all node indices\n    in :obj:`start` in the graph given by :obj:`(row, col)` as described in the\n    `""node2vec: Scalable Feature Learning for Networks""\n    <https://arxiv.org/abs/1607.00653>`_ paper.\n    Edge indices :obj:`(row, col)` need to be coalesced/sorted according to\n    :obj:`row` (use the :obj:`coalesced` attribute to force).\n\n    Args:\n        row (LongTensor): Source nodes.\n        col (LongTensor): Target nodes.\n        start (LongTensor): Nodes from where random walks start.\n        walk_length (int): The walk length.\n        p (float, optional): Likelihood of immediately revisiting a node in the\n            walk. (default: :obj:`1`)\n        q (float, optional): Control parameter to interpolate between\n            breadth-first strategy and depth-first strategy (default: :obj:`1`)\n        coalesced (bool, optional): If set to :obj:`True`, will coalesce/sort\n            the graph given by :obj:`(row, col)` according to :obj:`row`.\n            (default: :obj:`True`)\n        num_nodes (int, optional): The number of nodes. (default: :obj:`None`)\n\n    :rtype: :class:`LongTensor`\n    """"""\n    if num_nodes is None:\n        num_nodes = max(int(row.max()), int(col.max())) + 1\n\n    if coalesced:\n        perm = torch.argsort(row * num_nodes + col)\n        row, col = row[perm], col[perm]\n\n    deg = row.new_zeros(num_nodes)\n    deg.scatter_add_(0, row, torch.ones_like(row))\n    rowptr = row.new_zeros(num_nodes + 1)\n    torch.cumsum(deg, 0, out=rowptr[1:])\n\n    if p != 1. or q != 1.:  # pragma: no cover\n        warnings.warn(\'Parameters `p` and `q` are not supported yet and will\'\n                      \'be restored to their default values `p=1` and `q=1`.\')\n        p = q = 1.\n\n    return torch.ops.torch_cluster.random_walk(rowptr, col, start, walk_length,\n                                               p, q)\n'"
torch_cluster/sampler.py,3,"b'import torch\n\n\n@torch.jit.script\ndef neighbor_sampler(start: torch.Tensor, rowptr: torch.Tensor, size: float):\n    assert not start.is_cuda\n\n    factor: float = -1.\n    count: int = -1\n    if size <= 1:\n        factor = size\n        assert factor > 0\n    else:\n        count = int(size)\n\n    return torch.ops.torch_cluster.neighbor_sampler(start, rowptr, count,\n                                                    factor)\n'"
