file_path,api_count,code
clean.py,6,"b'import argparse\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nfrom segan.models import *\nfrom segan.datasets import *\nimport soundfile as sf\nfrom scipy.io import wavfile\nfrom torch.autograd import Variable\nimport numpy as np\nimport random\nimport librosa\nimport matplotlib\nimport timeit\nmatplotlib.use(\'Agg\')\nimport matplotlib.pyplot as plt\nimport json\nimport glob\nimport os\n\n\nclass ArgParser(object):\n\n    def __init__(self, args):\n        for k, v in args.items():\n            setattr(self, k, v)\n\ndef main(opts):\n    assert opts.cfg_file is not None\n    assert opts.test_files is not None\n    assert opts.g_pretrained_ckpt is not None\n\n    with open(opts.cfg_file, \'r\') as cfg_f:\n        args = ArgParser(json.load(cfg_f))\n        print(\'Loaded train config: \')\n        print(json.dumps(vars(args), indent=2))\n    args.cuda = opts.cuda\n    if hasattr(args, \'wsegan\') and args.wsegan:\n        segan = WSEGAN(args)     \n    else:\n        segan = SEGAN(args)     \n    segan.G.load_pretrained(opts.g_pretrained_ckpt, True)\n    if opts.cuda:\n        segan.cuda()\n    segan.G.eval()\n    if opts.h5:\n        with h5py.File(opts.test_files[0], \'r\') as f:\n            twavs = f[\'data\'][:]\n    else:\n        # process every wav in the test_files\n        if len(opts.test_files) == 1:\n            # assume we read directory\n            twavs = glob.glob(os.path.join(opts.test_files[0], \'*.wav\'))\n        else:\n            # assume we have list of files in input\n            twavs = opts.test_files\n    print(\'Cleaning {} wavs\'.format(len(twavs)))\n    beg_t = timeit.default_timer()\n    for t_i, twav in enumerate(twavs, start=1):\n        if not opts.h5:\n            tbname = os.path.basename(twav)\n            rate, wav = wavfile.read(twav)\n            wav = normalize_wave_minmax(wav)\n        else:\n            tbname = \'tfile_{}.wav\'.format(t_i)\n            wav = twav\n            twav = tbname\n        wav = pre_emphasize(wav, args.preemph)\n        pwav = torch.FloatTensor(wav).view(1,1,-1)\n        if opts.cuda:\n            pwav = pwav.cuda()\n        g_wav, g_c = segan.generate(pwav)\n        out_path = os.path.join(opts.synthesis_path,\n                                tbname) \n        if opts.soundfile:\n            sf.write(out_path, g_wav, 16000)\n        else:\n            wavfile.write(out_path, 16000, g_wav)\n        end_t = timeit.default_timer()\n        print(\'Cleaned {}/{}: {} in {} s\'.format(t_i, len(twavs), twav,\n                                                 end_t-beg_t))\n        beg_t = timeit.default_timer()\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--g_pretrained_ckpt\', type=str, default=None)\n    parser.add_argument(\'--test_files\', type=str, nargs=\'+\', default=None)\n    parser.add_argument(\'--h5\', action=\'store_true\', default=False)\n    parser.add_argument(\'--seed\', type=int, default=111, \n                        help=""Random seed (Def: 111)."")\n    parser.add_argument(\'--synthesis_path\', type=str, default=\'segan_samples\',\n                        help=\'Path to save output samples (Def: \' \\\n                             \'segan_samples).\')\n    parser.add_argument(\'--cuda\', action=\'store_true\', default=False)\n    parser.add_argument(\'--soundfile\', action=\'store_true\', default=False)\n    parser.add_argument(\'--cfg_file\', type=str, default=None)\n\n    opts = parser.parse_args()\n\n    if not os.path.exists(opts.synthesis_path):\n        os.makedirs(opts.synthesis_path)\n    \n    # seed initialization\n    random.seed(opts.seed)\n    np.random.seed(opts.seed)\n    torch.manual_seed(opts.seed)\n    if opts.cuda:\n        torch.cuda.manual_seed_all(opts.seed)\n\n    main(opts)\n'"
eval_noisy_performance.py,0,"b""import librosa\nimport numpy as np\nfrom segan.utils import *\nimport glob\nimport timeit\nimport argparse\nfrom scipy.io import wavfile\n\n# eval expanded noisy testset with composite metrics\n#NOISY_TEST_PATH = 'data/expanded_segan1_additive/noisy_testset'\n\ndef main(opts):\n    NOISY_TEST_PATH = opts.test_wavs\n    CLEAN_TEST_PATH = opts.clean_wavs\n\n    noisy_wavs = glob.glob(os.path.join(NOISY_TEST_PATH, '*.wav'))\n    metrics = {'csig':[], 'cbak':[], 'covl':[]}\n    timings = []\n    #out_log = open('eval_noisy.log', 'w')\n    out_log = open(opts.logfile, 'w')\n    out_log.write('FILE CSIG CBAK COVL PESQ SSNR\\n')\n    for n_i, noisy_wav in enumerate(noisy_wavs, start=1):\n        bname = os.path.splitext(os.path.basename(noisy_wav))[0]\n        clean_wav = os.path.join(CLEAN_TEST_PATH, bname + '.wav')\n        noisy, rate = librosa.load(noisy_wav, 16000)\n        clean, rate = librosa.load(clean_wav, 16000)\n        #rate, noisy = wavfile.read(noisy_wav)\n        #rate, clean = wavfile.read(clean_wav)\n        beg_t = timeit.default_timer()\n        csig, cbak, covl, pesq, ssnr = CompositeEval(clean, noisy, True)\n        end_t = timeit.default_timer()\n        timings.append(end_t - beg_t)\n        metrics['csig'].append(csig)\n        metrics['cbak'].append(cbak)\n        metrics['covl'].append(covl)\n        out_log.write('{} {:.3f} {:.3f} {:.3f} {:.3f} {:.3}\\n'.format(bname + '.wav', \n                                                                      csig, \n                                                                      cbak, \n                                                                      covl,\n                                                                      pesq,\n                                                                      ssnr))\n        print('Processed {}/{} wav, CSIG:{:.3f} CBAK:{:.3f} COVL:{:.3f} '\n              'PESQ:{:.3f} SSNR:{:.3f} '\n              'total time: {:.2f} seconds, mproc: {:.2f}'\n              ' seconds'.format(n_i, len(noisy_wavs), csig, cbak, covl,\n                                pesq, ssnr,\n                                np.sum(timings),\n                                np.mean(timings)))\n    out_log.close()\n\n    print('mean Csig: ', np.mean(metrics['csig']))\n    print('mean Cbak: ', np.mean(metrics['cbak']))\n    print('mean Covl: ', np.mean(metrics['covl']))\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--test_wavs', type=str, default=None)\n    parser.add_argument('--clean_wavs', type=str, default=None)\n    parser.add_argument('--logfile', type=str, default=None)\n\n    opts = parser.parse_args()\n\n    assert opts.test_wavs is not None\n    assert opts.clean_wavs is not None\n    assert opts.logfile is not None\n\n    main(opts)\n"""
purge_ckpts.py,0,"b""import argparse\nimport json\nimport glob\nimport os\n\n\ndef clean(opts):\n    logs = glob.glob(os.path.join(opts.ckpt_dir, '*checkpoint*'))\n    print(logs)\n    for log in logs:\n        with open(log, 'r') as log_f:\n            log_ = json.load(log_f)\n            # first assertive check that all files exist, no mismatch\n            # b/w log and filenames existence\n            for fname in log_['latest']:\n                fpath = os.path.join(opts.ckpt_dir, 'weights_' + fname)\n                assert os.path.exists(fpath), fpath\n            to_rm = [l for l in log_['latest'][:-1] if l != log_['current']]\n            to_kp = log_['latest'][-1]\n            for fname in to_rm:\n                fpath = os.path.join(opts.ckpt_dir, 'weights_' + fname)\n                os.unlink(fpath)\n                print('Removed file ', fpath)\n            print('Kept file ', os.path.join(opts.ckpt_dir, 'weights_' + \\\n                                             to_kp))\n        # re-write log\n        with open(log, 'w') as log_f:\n            log_['latest'] = [log_['latest'][-1]]\n            log_f.write(json.dumps(log_, indent=2))\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('ckpt_dir', type=str, default=None)\n    opts = parser.parse_args()\n\n    clean(opts)\n"""
select_speakers.py,0,"b""import os\nfrom random import shuffle\nimport numpy as np\nimport operator\nimport glob\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\nimport re\nimport json\n\n\n\ndef txt_clean_file(txtfile):\n    with open(txtf, 'r') as txt_f:\n        txt = txt_f.read().rstrip().lower()\n        txt = re.sub(r'[^\\w\\s]','',txt)\n        txt = re.sub(r'\\s+',' ',txt)\n        return txt\n    \nVCTK_PATH='/veu/spascual/git/speakagan/data/vctk/raw/VCTK-Corpus/'\n\n# Select test speakers maximizing textual contents, taking\n# 14 speakers with minium intersection of contents with \n# others in the 109 available in VCTKA.\n\nspks = [l.rstrip().split(' ') for l in open(os.path.join(VCTK_PATH,\n                                                         'speaker-info.txt'))]\nspks = spks[1:]\nspk2gen = dict(('p' + el[0], el[4]) for el in spks)\n# add lost speaker\nspk2gen['p280'] = 'F'\nassert len(spk2gen) == 109, len(spk2gen)\n\ntxtfs = glob.glob(os.path.join(VCTK_PATH, 'txt', '**', '*.txt'), recursive=True)\nprint(len(txtfs))\n\nif not os.path.exists('txt2spk') or not os.path.exists('spk2txt'):\n    spk2txt = {}\n    txt2spk = {}\n    for ii, txtf in enumerate(txtfs, start=1):\n        spk = txtf.split('/')[-2]\n        txtname = txtf.split('/')[-1]\n        txt = txt_clean_file(txtf)\n        if spk not in spk2txt:\n            spk2txt[spk] = []\n        spk2txt[spk].append(txt)\n        if txt not in txt2spk:\n            txt2spk[txt] = []\n        txt2spk[txt].append(spk)\n        print('Processed {}/{}'.format(ii, len(txtfs)))\n    with open('txt2spk', 'w') as txt2spk_f:\n        txt2spk_f.write(json.dumps(txt2spk))\n    with open('spk2txt', 'w') as spk2txt_f:\n        spk2txt_f.write(json.dumps(spk2txt))\nelse:\n    with open('txt2spk', 'r') as txt2spk_f:\n        txt2spk = json.load(txt2spk_f)\n    with open('spk2txt', 'r') as spk2txt_f:\n        spk2txt = json.load(spk2txt_f)\ntxt2count = dict((k, len(v)) for k, v in txt2spk.items())\nprint(len(txt2count))\n#print(txt2count)\nplt.hist(list(txt2count.values()), bins=50)\nplt.xlabel('# spks per txt')\nplt.savefig('txt2count_hist.png', dpi=200)\nspk2count = dict((k, len(v)) for k, v in spk2txt.items())\nprint(spk2count)\nprint(len(spk2count))\nprint('**********')\n\nif not os.path.exists('spk2maxcount'):\n    # matrix of spkxspk with interection counts of txts\n    spkmat = {}\n    # store repetition counts for each spk\n    spk2maxcount = dict((k, 0) for k in list(spk2txt.keys()))\n    spk2mincount = dict((k, np.inf) for k in list(spk2txt.keys()))\n    spk2count = dict((k, 0) for k in list(spk2txt.keys()))\n    for ii, txtf in enumerate(txtfs, start=1):\n        spk = txtf.split('/')[-2]\n        txt = txt_clean_file(txtf)\n        spk2maxcount[spk] = max(spk2maxcount[spk], len(txt2spk[txt]))\n        spk2mincount[spk] = min(spk2mincount[spk], len(txt2spk[txt]))\n        spk2count[spk] += len(txt2spk[txt])\n        if spk not in spkmat:\n            spkmat[spk] = {}\n        for intspk in txt2spk[txt]:\n            if intspk not in spkmat[spk]:\n                spkmat[spk][intspk] = 0\n            spkmat[spk][intspk] += 1\n        print('Processed {}/{}'.format(ii, len(txtfs)))\n    with open('spk2maxcount', 'w') as spk2maxcount_f:\n        spk2maxcount_f.write(json.dumps(spk2maxcount))\n    with open('spk2mincount', 'w') as spk2mincount_f:\n        spk2mincount_f.write(json.dumps(spk2mincount))\n    with open('spkmat', 'w') as spkmat_f:\n        spkmat_f.write(json.dumps(spkmat))\n    with open('spk2count', 'w') as spk2count_f:\n        spk2count_f.write(json.dumps(spk2count))\nelse:\n    with open('spk2count', 'r') as spk2count_f:\n        spk2count = json.load(spk2count_f)\n    with open('spk2maxcount', 'r') as spk2maxcount_f:\n        spk2maxcount = json.load(spk2maxcount_f)\n    with open('spk2mincount', 'r') as spk2mincount_f:\n        spk2mincount = json.load(spk2mincount_f)\n    with open('spkmat', 'r') as spkmat_f:\n        spkmat = json.load(spkmat_f)\nprint(sorted(spk2maxcount.items(), key=operator.itemgetter(1)))\nprint('---------------')\nprint(sorted(spk2mincount.items(), key=operator.itemgetter(1)))\nprint('ooooooooooooooo')\nsorted_counts = sorted(spk2count.items(), key=operator.itemgetter(1))\nprint(sorted_counts)\nwith open('spkmat.txt', 'w') as mattxt_f:\n    spks_h = list(spkmat.keys())\n    header = ''\n    for spk_h in spks_h:\n        header += spk_h + ' '\n    header = '     ' + header[:-1] + '\\n'\n    mattxt_f.write(header)\n    # print header\n    for si, spk in enumerate(spks_h):\n        mattxt_f.write(spk + ' ')\n        row = spkmat[spk]\n        row_txt = ''\n        for row_spk in spks_h:\n            row_txt += '{:4d} '.format(spkmat[spk][row_spk])\n        row_txt = row_txt[:-1] + '\\n'\n        mattxt_f.write(row_txt)\n\nTEST_FILES = 14\nVALID_FILES = 15\ntest_spks = []\nvalid_spks = []\ntrain_spks = []\nnontest_counts = []\n# Now with minimum counts create test set, ensuring 50% 50% in male female\nf = 0\nm = 0\nfor spk in sorted_counts:\n    if f + m < TEST_FILES:\n        gen = spk2gen[spk[0]]\n        if gen == 'F': \n            if f <= TEST_FILES // 2:\n                print('Adding F spk: ', spk)\n                f += 1\n            else:\n                print('Skipping F spk: ', spk)\n                continue\n        if gen == 'M':\n            if m <= TEST_FILES // 2:\n                print('Adding M spk: ', spk)\n                m += 1\n            else:\n                print('Skipping M spk: ', spk)\n                continue\n        print('f: {}, m: {}'.format(f, m))\n        test_spks.append(spk[0])\n    else:\n        nontest_counts.append(spk)\n\n#re-shuffle counts now to mix valid-train\nshuffle(nontest_counts)\nprint('DOING VALID -------------------------')\n# Valid spks 50% 50%\nf = 0\nm = 0\nfor spk in nontest_counts:\n    gen = spk2gen[spk[0]]\n    if spk[0] in test_spks:\n        continue\n    if gen == 'F': \n        if f <= VALID_FILES // 2:\n            print('Adding F spk: ', spk)\n            f += 1\n        else:\n            print('Skipping F spk: ', spk)\n            continue\n    if gen == 'M':\n        if m <= VALID_FILES // 2:\n            print('Adding M spk: ', spk)\n            m += 1\n        else:\n            print('Skipping M spk: ', spk)\n            continue\n    print('f: {}, m: {}'.format(f, m))\n    valid_spks.append(spk[0])\n    if f + m >= VALID_FILES:\n        print('Out of valid')\n        break\n\nfor spk in spk2gen.keys():\n    if spk in (test_spks + valid_spks):\n        continue\n    train_spks.append(spk)\n\nprint('train spks: ', len(train_spks))\nprint('valid spks: ', len(valid_spks))\nprint('test spks: ', len(test_spks))\n\nwith open('train_split.txt', 'w') as train_f:\n    for tr_spk in train_spks:\n        train_f.write(tr_spk[1:] + '\\n')\n\nwith open('valid_split.txt', 'w') as valid_f:\n    for va_spk in valid_spks:\n        valid_f.write(va_spk[1:] + '\\n')\n\nwith open('test_split.txt', 'w') as test_f:\n    for te_spk in test_spks:\n        test_f.write(te_spk[1:] + '\\n')\n"""
train.py,5,"b'import argparse\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import DataLoader\nfrom segan.models import SEGAN, WSEGAN, AEWSEGAN\nfrom segan.datasets import SEDataset, SEH5Dataset, collate_fn\nfrom segan.utils import Additive\nimport numpy as np\nimport random\nimport json\nimport os\n\n\ndef main(opts):\n    # select device to work on \n    device = \'cpu\'\n    if torch.cuda.is_available and not opts.no_cuda:\n        device = \'cuda\'\n        opts.cuda = True\n    CUDA = (device == \'cuda\')\n    # seed initialization\n    random.seed(opts.seed)\n    np.random.seed(opts.seed)\n    torch.manual_seed(opts.seed)\n    if CUDA:\n        torch.cuda.manual_seed_all(opts.seed)\n    # create SEGAN model\n    if opts.wsegan:\n        segan = WSEGAN(opts)\n    elif opts.aewsegan:\n        segan = AEWSEGAN(opts)\n    else:\n        segan = SEGAN(opts)     \n    segan.to(device)\n    # possibly load pre-trained sections of networks G or D\n    print(\'Total model parameters: \',  segan.get_n_params())\n    if opts.g_pretrained_ckpt is not None:\n        segan.G.load_pretrained(opts.g_pretrained_ckpt, True)\n    if opts.d_pretrained_ckpt is not None:\n        segan.D.load_pretrained(opts.d_pretrained_ckpt, True)\n    # create Dataset(s) and Dataloader(s)\n    if opts.h5:\n        # H5 Dataset with processed speech chunks\n        if opts.h5_data_root is None:\n            raise ValueError(\'Please specify an H5 data root\')\n        dset = SEH5Dataset(opts.h5_data_root, split=\'train\',\n                           preemph=opts.preemph,\n                           verbose=True,\n                           random_scale=opts.random_scale)\n    else:\n        # Directory Dataset from raw wav files\n        dset = SEDataset(opts.clean_trainset, \n                         opts.noisy_trainset, \n                         opts.preemph,\n                         do_cache=True,\n                         cache_dir=opts.cache_dir,\n                         split=\'train\',\n                         stride=opts.data_stride,\n                         slice_size=opts.slice_size,\n                         max_samples=opts.max_samples,\n                         verbose=True,\n                         slice_workers=opts.slice_workers,\n                         preemph_norm=opts.preemph_norm,\n                         random_scale=opts.random_scale\n                        )\n    dloader = DataLoader(dset, batch_size=opts.batch_size,\n                         shuffle=True, num_workers=opts.num_workers,\n                         pin_memory=CUDA,\n                         collate_fn=collate_fn)\n    if opts.clean_valset is not None:\n        if opts.h5:\n            dset = SEH5Dataset(opts.h5_data_root, split=\'valid\',\n                               preemph=opts.preemph,\n                               verbose=True)\n        else:\n            va_dset = SEDataset(opts.clean_valset, \n                                opts.noisy_valset, \n                                opts.preemph,\n                                do_cache=True,\n                                cache_dir=opts.cache_dir,\n                                split=\'valid\',\n                                stride=opts.data_stride,\n                                slice_size=opts.slice_size,\n                                max_samples=opts.max_samples,\n                                verbose=True,\n                                slice_workers=opts.slice_workers,\n                                preemph_norm=opts.preemph_norm)\n        va_dloader = DataLoader(va_dset, batch_size=300,\n                                shuffle=False, num_workers=opts.num_workers,\n                                pin_memory=CUDA,\n                                collate_fn=collate_fn)\n    else:\n        va_dloader = None\n    criterion = nn.MSELoss()\n    segan.train(opts, dloader, criterion, opts.l1_weight,\n                opts.l1_dec_step, opts.l1_dec_epoch,\n                opts.save_freq,\n                va_dloader=va_dloader, device=device)\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\'--save_path\', type=str, default=""seganv1_ckpt"",\n                        help=""Path to save models (Def: seganv1_ckpt)."")\n    parser.add_argument(\'--d_pretrained_ckpt\', type=str, default=None,\n                        help=\'Path to ckpt file to pre-load in training \'\n                             \'(Def: None).\')\n    parser.add_argument(\'--g_pretrained_ckpt\', type=str, default=None,\n                        help=\'Path to ckpt file to pre-load in training \'\n                             \'(Def: None).\')\n    parser.add_argument(\'--cache_dir\', type=str, default=\'data_cache\')\n    parser.add_argument(\'--clean_trainset\', type=str,\n                        default=\'data/clean_trainset\')\n    parser.add_argument(\'--noisy_trainset\', type=str,\n                        default=\'data/noisy_trainset\')\n    parser.add_argument(\'--clean_valset\', type=str,\n                        default=None)#\'data/clean_valset\')\n    parser.add_argument(\'--noisy_valset\', type=str,\n                        default=None)#\'data/noisy_valset\')\n    parser.add_argument(\'--h5_data_root\', type=str, default=None,\n                        help=\'H5 data root dir (Def: None). The \'\n                             \'files will be found by split name \'\n                             \'{train, valid, test}.h5\')\n    parser.add_argument(\'--h5\', action=\'store_true\', default=False,\n                        help=\'Activate H5 dataset mode (Def: False).\')\n    parser.add_argument(\'--data_stride\', type=float,\n                        default=0.5, help=\'Stride in seconds for data read\')\n    parser.add_argument(\'--seed\', type=int, default=111, \n                        help=""Random seed (Def: 111)."")\n    parser.add_argument(\'--epoch\', type=int, default=100)\n    parser.add_argument(\'--patience\', type=int, default=100,\n                        help=\'If validation path is set, there are \'\n                             \'denoising evaluations running for which \'\n                             \'COVL, CSIG, CBAK, PESQ and SSNR are \'\n                             \'computed. Patience is number of validation \'\n                             \'epochs to wait til breakining train loop. This \'\n                             \'is an unstable and slow process though, so we\'\n                             \'avoid patience by setting it high atm (Def: 100).\'\n                       )\n    parser.add_argument(\'--batch_size\', type=int, default=100)\n    parser.add_argument(\'--save_freq\', type=int, default=50,\n                        help=""Batch save freq (Def: 50)."")\n    parser.add_argument(\'--slice_size\', type=int, default=16384)\n    parser.add_argument(\'--opt\', type=str, default=\'rmsprop\')\n    parser.add_argument(\'--l1_dec_epoch\', type=int, default=100)\n    parser.add_argument(\'--l1_weight\', type=float, default=100,\n                        help=\'L1 regularization weight (Def. 100). \')\n    parser.add_argument(\'--l1_dec_step\', type=float, default=1e-5,\n                        help=\'L1 regularization decay factor by batch \' \\\n                             \'(Def: 1e-5).\')\n    parser.add_argument(\'--g_lr\', type=float, default=0.00005, \n                        help=\'Generator learning rate (Def: 0.00005).\')\n    parser.add_argument(\'--d_lr\', type=float, default=0.00005, \n                        help=\'Discriminator learning rate (Def: 0.0005).\')\n    parser.add_argument(\'--preemph\', type=float, default=0.95,\n                        help=\'Wav preemphasis factor (Def: 0.95).\')\n    parser.add_argument(\'--max_samples\', type=int, default=None,\n                        help=\'Max num of samples to train (Def: None).\')\n    parser.add_argument(\'--eval_workers\', type=int, default=2)\n    parser.add_argument(\'--slice_workers\', type=int, default=1)\n    parser.add_argument(\'--num_workers\', type=int, default=1,\n                        help=\'DataLoader number of workers (Def: 1).\')\n    parser.add_argument(\'--no-cuda\', action=\'store_true\', default=False,\n                        help=\'Disable CUDA even if device is available\')\n    parser.add_argument(\'--random_scale\', type=float, nargs=\'+\', \n                        default=[1], help=\'Apply randomly a scaling factor\' \\\n                                          \'in list to the (clean, noisy) pair\')\n    parser.add_argument(\'--no_train_gen\', action=\'store_true\', default=False, \n                       help=\'Do NOT generate wav samples during training\')\n    parser.add_argument(\'--preemph_norm\', action=\'store_true\', default=False,\n                        help=\'Inverts old  norm + preemph order in data \' \\\n                        \'loading, so denorm has to respect this aswell\')\n    parser.add_argument(\'--wsegan\', action=\'store_true\', default=False)\n    parser.add_argument(\'--aewsegan\', action=\'store_true\', default=False)\n    parser.add_argument(\'--vanilla_gan\', action=\'store_true\', default=False)\n    parser.add_argument(\'--no_bias\', action=\'store_true\', default=False,\n                        help=\'Disable all biases in Generator\')\n    parser.add_argument(\'--n_fft\', type=int, default=2048)\n    parser.add_argument(\'--reg_loss\', type=str, default=\'l1_loss\',\n                        help=\'Regression loss (l1_loss or mse_loss) in the \'\n                             \'output of G (Def: l1_loss)\')\n\n    # Skip connections options for G\n    parser.add_argument(\'--skip_merge\', type=str, default=\'concat\')\n    parser.add_argument(\'--skip_type\', type=str, default=\'alpha\',\n                        help=\'Type of skip connection: \\n\' \\\n                        \'1) alpha: learn a vector of channels to \' \\\n                        \' multiply elementwise. \\n\' \\\n                        \'2) conv: learn conv kernels of size 11 to \' \\\n                        \' learn complex responses in the shuttle.\\n\' \\\n                        \'3) constant: with alpha value, set values to\' \\\n                        \' not learnable, just fixed.\\n(Def: alpha)\')\n    parser.add_argument(\'--skip_init\', type=str, default=\'one\',\n                        help=\'Way to init skip connections (Def: one)\')\n    parser.add_argument(\'--skip_kwidth\', type=int, default=11)\n\n    # Generator parameters\n    parser.add_argument(\'--gkwidth\', type=int, default=31)\n    parser.add_argument(\'--genc_fmaps\', type=int, nargs=\'+\',\n                        default=[64, 128, 256, 512, 1024],\n                        help=\'Number of G encoder feature maps, \' \\\n                             \'(Def: [64, 128, 256, 512, 1024]).\')\n    parser.add_argument(\'--genc_poolings\', type=int, nargs=\'+\',\n                        default=[4, 4, 4, 4, 4],\n                        help=\'G encoder poolings\')\n    parser.add_argument(\'--z_dim\', type=int, default=1024)\n    parser.add_argument(\'--gdec_fmaps\', type=int, nargs=\'+\',\n                        default=None)\n    parser.add_argument(\'--gdec_poolings\', type=int, nargs=\'+\',\n                        default=None, \n                        help=\'Optional dec poolings. Defaults to None \'\n                             \'so that encoder poolings are mirrored.\')\n    parser.add_argument(\'--gdec_kwidth\', type=int, \n                        default=None)\n    parser.add_argument(\'--gnorm_type\', type=str, default=None,\n                        help=\'Normalization to be used in G. Can \'\n                        \'be: (1) snorm, (2) bnorm or (3) none \'\n                        \'(Def: None).\')\n    parser.add_argument(\'--no_z\', action=\'store_true\', default=False)\n    parser.add_argument(\'--no_skip\', action=\'store_true\', default=False)\n    parser.add_argument(\'--pow_weight\', type=float, default=0.001)\n    parser.add_argument(\'--misalign_pair\', action=\'store_true\', default=False)\n    parser.add_argument(\'--interf_pair\', action=\'store_true\', default=False)\n\n    # Discriminator parameters\n    parser.add_argument(\'--denc_fmaps\', type=int, nargs=\'+\',\n                        default=[64, 128, 256, 512, 1024],\n                        help=\'Number of D encoder feature maps, \' \\\n                             \'(Def: [64, 128, 256, 512, 1024]\')\n    parser.add_argument(\'--dpool_type\', type=str, default=\'none\',\n                        help=\'conv/none/gmax/gavg (Def: none)\')\n    parser.add_argument(\'--dpool_slen\', type=int, default=16,\n                        help=\'Dimension of last conv D layer time axis\'\n                             \'prior to classifier real/fake (Def: 16)\')\n    parser.add_argument(\'--dkwidth\', type=int, default=None,\n                        help=\'Disc kwidth (Def: None), None is gkwidth.\')\n    parser.add_argument(\'--denc_poolings\', type=int, nargs=\'+\', \n                        default=[4, 4, 4, 4, 4],\n                        help=\'(Def: [4, 4, 4, 4, 4])\')\n    parser.add_argument(\'--dnorm_type\', type=str, default=\'bnorm\',\n                        help=\'Normalization to be used in D. Can \'\n                        \'be: (1) snorm, (2) bnorm or (3) none \'\n                        \'(Def: bnorm).\')\n    parser.add_argument(\'--phase_shift\', type=int, default=5)\n    parser.add_argument(\'--sinc_conv\', action=\'store_true\', default=False)\n\n    opts = parser.parse_args()\n    opts.bias = not opts.no_bias\n\n    if not os.path.exists(opts.save_path):\n        os.makedirs(opts.save_path)\n\n    # save opts\n    with open(os.path.join(opts.save_path, \'train.opts\'), \'w\') as cfg_f:\n        cfg_f.write(json.dumps(vars(opts), indent=2))\n\n    print(\'Parsed arguments: \', json.dumps(vars(opts), indent=2))\n    main(opts)\n'"
weightG_fmt_converter.py,2,"b""import torch\nimport os\nimport sys\n\nif len(sys.argv) < 2:\n    print('ERROR! Not enough input arguments.')\n    print('Usage: {} <weights ckpt file> .'.format(sys.argv[0]))\n\nckpt_file = sys.argv[1]\n\n# Converts old SEGAN-G weights namings\n# Encoder: gen_enc.i.conv.weight/bias (i-th layer) --> enc_blocks.i.conv.weight/bias\n# Decoder: gen_dec.i.conv.weight/bias (i-th layer) --> dec_blocks.i.deconv.weight/bias\n\nout_file = ckpt_file + '.v2'\n\n\nst_dict = torch.load(ckpt_file, \n                     map_location=lambda storage, loc: storage)\n\nnew_dict = {'state_dict':{}}\n# copy first level keys and values, but state_dict (weights per-se)\nfor k, v in st_dict.items():\n    if 'state_dict' in k:\n        continue\n    new_dict[k] = v\n\nst_dict = st_dict['state_dict']\n\nfor k, v in st_dict.items():\n    if 'gen_enc' in k:\n        nk = k.replace('gen_enc', 'enc_blocks')\n        print('{} -> {}'.format(k, nk))\n        new_dict['state_dict'][nk] = v\n    elif 'gen_dec' in k:\n        nk = k.replace('gen_dec', 'dec_blocks')\n        nk = nk.replace('conv', 'deconv')\n        print('{} -> {}'.format(k, nk))\n        new_dict['state_dict'][nk] = v\n    else:\n        print('Keeping {}'.format(k))\n        new_dict['state_dict'][k] = v\n\ntorch.save(new_dict, out_file)\n"""
segan/__init__.py,0,b'from .models import *\nfrom .datasets import *\nfrom .utils import *\n'
segan/utils.py,5,"b'from subprocess import run, PIPE\nfrom scipy.linalg import toeplitz\nfrom scipy.io import wavfile\nimport numba as nb\nfrom numba import jit, int32, float32\nimport soundfile as sf\nfrom scipy.signal import lfilter\nfrom scipy.interpolate import interp1d\nimport torch\nimport torch.nn.functional as F\nimport glob\nimport librosa\nimport numpy as np\nimport tempfile\nimport os\nimport re\n\n\ndef uttname2spkid(uttname):\n    spkid = uttname.split(\'_\')[0]\n    return spkid\n\ndef denormalize_wave_minmax(x):\n    return (65535. * x / 2) - 1 + 32767.\n\ndef make_divN(tensor, N, method=\'zeros\'):\n    # methods: zeros or reflect\n    # make tensor time dim divisible by N (for good decimation)\n    pad_num = (tensor.size(1) + N) - (tensor.size(1) % N) - tensor.size(1)\n    if method == \'zeros\':\n        pad = torch.zeros(tensor.size(0), pad_num, tensor.size(-1))\n        return torch.cat((tensor, pad), dim=1)\n    elif method == \'reflect\':\n        tensor = tensor.transpose(1, 2)\n        # using functional PyTorch pad\n        return F.pad(tensor, (0, pad_num), \'reflect\').transpose(1, 2)\n    else:\n        raise TypeError(\'Unrecognized make_divN pad method: \', method)\n\ndef composite_helper(args):\n    return eval_composite(*args)\n\nclass ComposeAdditive(object):\n\n    def __init__(self, additive):\n        self.additive = additive\n\n    def __call__(self, x):\n        return x, self.additive(x)\n\nclass Additive(object):\n\n    def __init__(self, noises_dir, snr_levels=[0, 5, 10], do_IRS=False):\n        self.noises_dir = noises_dir\n        self.snr_levels = snr_levels\n        self.do_IRS = do_IRS\n        # read noises in dir\n        noises = glob.glob(os.path.join(noises_dir, \'*.wav\'))\n        if len(noises) == 0:\n            raise ValueError(\'[!] No noises found in {}\'.format(noises_dir))\n        else:\n            print(\'[*] Found {} noise files\'.format(len(noises)))\n            self.noises = []\n            for n_i, npath in enumerate(noises, start=1):\n                #nwav = wavfile.read(npath)[1]\n                nwav = librosa.load(npath, sr=None)[0]\n                self.noises.append({\'file\':npath, \n                                    \'data\':nwav.astype(np.float32)})\n                log_noise_load = \'Loaded noise {:3d}/{:3d}: \' \\\n                                 \'{}\'.format(n_i, len(noises),\n                                             npath)\n                print(log_noise_load)\n        self.eps = 1e-22\n\n    def __call__(self, wav, srate=16000, nbits=16):\n        """""" Add noise to clean wav """"""\n        if isinstance(wav, torch.Tensor):\n            wav = wav.numpy()\n        noise_idx = np.random.choice(list(range(len(self.noises))), 1)\n        sel_noise = self.noises[np.asscalar(noise_idx)]\n        noise = sel_noise[\'data\']\n        snr = np.random.choice(self.snr_levels, 1)\n        # print(\'Applying SNR: {} dB\'.format(snr[0]))\n        if wav.ndim > 1:\n            wav = wav.reshape((-1,))\n        noisy, noise_bound = self.addnoise_asl(wav, noise, srate, \n                                               nbits, snr, \n                                               do_IRS=self.do_IRS)\n        # normalize to avoid clipping\n        if np.max(noisy) >= 1 or np.min(noisy) < -1:\n            small = 0.1\n            while np.max(noisy) >= 1 or np.min(noisy) < -1:\n                noisy = noisy / (1. + small)\n                small = small + 0.1\n        return torch.FloatTensor(noisy.astype(np.float32))\n\n\n    def addnoise_asl(self, clean, noise, srate, nbits, snr, do_IRS=False):\n        if do_IRS:\n            # Apply IRS filter simulating telephone \n            # handset BW [300, 3200] Hz\n            clean = self.apply_IRS(clean, srate, nbits)\n        Px, asl, c0 = self.asl_P56(clean, srate, nbits)\n        # Px is active speech level ms energy\n        # asl is active factor\n        # c0 is active speech level threshold\n        x = clean\n        x_len = x.shape[0]\n\n        noise_len = noise.shape[0]\n        if noise_len <= x_len:\n            print(\'Noise length: \', noise_len)\n            print(\'Speech length: \', x_len)\n            raise ValueError(\'Noise length has to be greater than speech \'\n                             \'length!\')\n        rand_start_limit = int(noise_len - x_len + 1)\n        rand_start = int(np.round((rand_start_limit - 1) * np.random.rand(1) \\\n                                  + 1))\n        noise_segment = noise[rand_start:rand_start + x_len]\n        noise_bounds = (rand_start, rand_start + x_len)\n\n        if do_IRS:\n            noise_segment = self.apply_IRS(noise_segment, srate, nbits)\n\n        Pn = np.dot(noise_segment.T, noise_segment) / x_len\n\n        # we need to scale the noise segment samples to obtain the \n        # desired SNR = 10 * log10( Px / ((sf ** 2) * Pn))\n        sf = np.sqrt(Px / Pn / (10 ** (snr / 10)))\n        noise_segment = noise_segment * sf\n    \n        noisy = x + noise_segment\n\n        return noisy, noise_bounds\n\n    def apply_IRS(self, data, srate, nbits):\n        """""" Apply telephone handset BW [300, 3200] Hz """"""\n        raise NotImplementedError(\'Under construction!\')\n        from pyfftw.interfaces import scipy_fftpack as fftw\n        n = data.shape[0]\n        # find next pow of 2 which is greater or eq to n\n        pow_of_2 = 2 ** (np.ceil(np.log2(n)))\n\n        align_filter_dB = np.array([[0, -200], [50, -40], [100, -20],\n                           [125, -12], [160, -6], [200, 0],\n                           [250, 4], [300, 6], [350, 8], [400, 10],\n                           [500, 11], [600, 12], [700, 12], [800, 12],\n                           [1000, 12], [1300, 12], [1600, 12], [2000, 12],\n                           [2500, 12], [3000, 12], [3250, 12], [3500, 4],\n                           [4000, -200], [5000, -200], [6300, -200], \n                           [8000, -200]]) \n        print(\'align filter dB shape: \', align_filter_dB.shape)\n        num_of_points, trivial = align_filter_dB.shape\n        overallGainFilter = interp1d(align_filter_dB[:, 0], align_filter[:, 1],\n                                     1000)\n\n        x = np.zeros((pow_of_2))\n        x[:data.shape[0]] = data\n\n        x_fft = fftw.fft(x, pow_of_2)\n\n        freq_resolution = srate / pow_of_2\n\n        factorDb = interp1d(align_filter_dB[:, 0],\n                            align_filter_dB[:, 1],\n                                           list(range(0, (pow_of_2 / 2) + 1) *\\\n                                                freq_resolution)) - \\\n                                           overallGainFilter\n        factor = 10 ** (factorDb / 20)\n\n        factor = [factor, np.fliplr(factor[1:(pow_of_2 / 2 + 1)])]\n        x_fft = x_fft * factor\n\n        y = fftw.ifft(x_fft, pow_of_2)\n\n        data_filtered = y[:n]\n        return data_filtered\n\n\n    def asl_P56(self, x, srate, nbits):\n        """""" ITU P.56 method B. """"""\n        T = 0.03 # time constant of smoothing in seconds\n        H = 0.2 # hangover time in seconds\n        M = 15.9\n\n        # margin in dB of the diff b/w threshold and active speech level\n        thres_no = nbits - 1 # num of thresholds, for 16 bits it\'s 15\n\n        I = np.ceil(srate * H) # hangover in samples\n        g = np.exp( -1 / (srate * T)) # smoothing factor in envelop detection\n        c = 2. ** (np.array(list(range(-15, (thres_no + 1) - 16))))\n        # array of thresholds from one quantizing level up to half the max\n        # code, at a step of 2. In case of 16bit: from 2^-15 to 0.5\n        a = np.zeros(c.shape[0]) # activity counter for each level thres\n        hang = np.ones(c.shape[0]) * I # hangover counter for each level thres\n\n        assert x.ndim == 1, x.shape\n        sq = np.dot(x, x) # long term level square energy of x\n        x_len = x.shape[0]\n\n        # use 2nd order IIR filter to detect envelope q\n        x_abs = np.abs(x)\n        p = lfilter(np.ones(1) - g, np.array([1, -g]), x_abs)\n        q = lfilter(np.ones(1) - g, np.array([1, -g]), p)\n\n        for k in range(x_len):\n            for j in range(thres_no):\n                if q[k] >= c[j]:\n                    a[j] = a[j] + 1\n                    hang[j] = 0\n                elif hang[j] < I:\n                    a[j] = a[j] + 1\n                    hang[j] = hang[j] + 1\n                else:\n                    break\n        asl = 0\n        asl_ms = 0\n        c0 = None\n        if a[0] == 0:\n            return asl_ms, asl, c0\n        else:\n            den = a[0] + self.eps\n            AdB1 = 10 * np.log10(sq / a[0] + self.eps)\n        \n        CdB1 = 20 * np.log10(c[0] + self.eps)\n        if AdB1 - CdB1 < M:\n            return asl_ms, asl, c0\n        AdB = np.zeros(c.shape[0])\n        CdB = np.zeros(c.shape[0])\n        Delta = np.zeros(c.shape[0])\n        AdB[0] = AdB1\n        CdB[0] = CdB1\n        Delta[0] = AdB1 - CdB1\n\n        for j in range(1, AdB.shape[0]):\n            AdB[j] = 10 * np.log10(sq / (a[j] + self.eps) + self.eps)\n            CdB[j] = 20 * np.log10(c[j] + self.eps)\n\n        for j in range(1, Delta.shape[0]):\n            if a[j] != 0:\n                Delta[j] = AdB[j] - CdB[j]\n                if Delta[j] <= M:\n                    # interpolate to find the asl\n                    asl_ms_log, cl0 = self.bin_interp(AdB[j],\n                                                      AdB[j - 1],\n                                                      CdB[j],\n                                                      CdB[j - 1],\n                                                      M, 0.5)\n                    asl_ms = 10 ** (asl_ms_log / 10)\n                    asl = (sq / x_len ) / asl_ms\n                    c0 = 10 ** (cl0 / 20)\n                    break\n        return asl_ms, asl, c0\n\n    def bin_interp(self, upcount, lwcount, upthr, lwthr, Margin, tol):\n        if tol < 0:\n            tol = -tol\n\n        # check if extreme counts are not already the true active value\n        iterno = 1\n        if np.abs(upcount - upthr - Margin) < tol:\n            asl_ms_log = lwcount\n            cc = lwthr\n            return asl_ms_log, cc\n        if np.abs(lwcount - lwthr - Margin) < tol:\n            asl_ms_log = lwcount\n            cc =lwthr\n            return asl_ms_log, cc\n\n        midcount = (upcount + lwcount) / 2\n        midthr = (upthr + lwthr) / 2\n        # repeats loop until diff falls inside tolerance (-tol <= diff <= tol)\n        while True:\n            diff = midcount - midthr - Margin\n            if np.abs(diff) <= tol:\n                break\n            # if tol is not met up to 20 iters, then relax tol by 10%\n            iterno += 1\n            if iterno > 20:\n                tol *= 1.1\n\n            if diff > tol:\n                midcount = (upcount + midcount) / 2\n                # upper and mid activities\n                midthr = (upthr + midthr) / 2\n                # ... and thresholds\n            elif diff < -tol:\n                # then new bounds are...\n                midcount = (midcount - lwcount) / 2\n                # middle and lower activities\n                midthr = (midthr + lwthr) / 2\n                # ... and thresholds\n        # since tolerance has been satisfied, midcount is selected as\n        # interpolated value with tol [dB] tolerance\n        asl_ms_log = midcount\n        cc = midthr\n        return asl_ms_log, cc\n\ndef eval_composite(clean_utt, Genh_utt, noisy_utt=None):\n    clean_utt = clean_utt.reshape(-1)\n    Genh_utt = Genh_utt.reshape(-1)\n    csig, cbak, covl, pesq, ssnr = CompositeEval(clean_utt,\n                                                 Genh_utt,\n                                                 True)\n    evals = {\'csig\':csig, \'cbak\':cbak, \'covl\':covl,\n             \'pesq\':pesq, \'ssnr\':ssnr}\n    if noisy_utt is not None:\n        noisy_utt = noisy_utt.reshape(-1)\n        csig, cbak, covl, \\\n        pesq, ssnr = CompositeEval(clean_utt,\n                                   noisy_utt,\n                                   True)\n        return evals, {\'csig\':csig, \'cbak\':cbak, \'covl\':covl,\n                       \'pesq\':pesq, \'ssnr\':ssnr}\n    else:\n        return evals\n\ndef PESQ(ref_wav, deg_wav):\n    # reference wav\n    # degraded wav\n\n    tfl = tempfile.NamedTemporaryFile()\n    ref_tfl = tfl.name + \'_ref.wav\'\n    deg_tfl = tfl.name + \'_deg.wav\'\n\n    #if ref_wav.max() <= 1:\n    #    ref_wav = np.array(denormalize_wave_minmax(ref_wav), dtype=np.int16)\n    #if deg_wav.max() <= 1:\n    #    deg_wav = np.array(denormalize_wave_minmax(deg_wav), dtype=np.int16)\n\t\n    #wavfile.write(ref_tfl, 16000, ref_wav)\n    #wavfile.write(deg_tfl, 16000, deg_wav)\n    sf.write(ref_tfl, ref_wav, 16000, subtype=\'PCM_16\')\n    sf.write(deg_tfl, deg_wav, 16000, subtype=\'PCM_16\')\n    \n    curr_dir = os.getcwd()\n    # Write both to tmp files and then eval with pesqmain\n    try:\n        p = run([\'pesqmain\'.format(curr_dir), \n                 ref_tfl, deg_tfl, \'+16000\', \'+wb\'],\n                stdout=PIPE, \n                encoding=\'ascii\')\n        res_line = p.stdout.split(\'\\n\')[-2]\n        results = re.split(\'\\s+\', res_line)\n        return results[-1]\n    except FileNotFoundError:\n        print(\'pesqmain not found! Please add it your PATH\')\n\n\ndef SSNR(ref_wav, deg_wav, srate=16000, eps=1e-10):\n    """""" Segmental Signal-to-Noise Ratio Objective Speech Quality Measure\n        This function implements the segmental signal-to-noise ratio\n        as defined in [1, p. 45] (see Equation 2.12).\n    """"""\n    clean_speech = ref_wav\n    processed_speech = deg_wav\n    clean_length = ref_wav.shape[0]\n    processed_length = deg_wav.shape[0]\n\n    \n    # scale both to have same dynamic range. Remove DC too.\n    dif = ref_wav - deg_wav\n    overall_snr = 10 * np.log10(np.sum(ref_wav ** 2) / (np.sum(dif ** 2) +\n                                                        10e-20))\n\n    # global variables\n    winlength = int(np.round(30 * srate / 1000)) # 30 msecs\n    skiprate = winlength // 4\n    MIN_SNR = -10\n    MAX_SNR = 35\n\n    # For each frame, calculate SSNR\n\n    num_frames = int(clean_length / skiprate - (winlength/skiprate))\n    start = 0\n    time = np.linspace(1, winlength, winlength) / (winlength + 1)\n    window = 0.5 * (1 - np.cos(2 * np.pi * time))\n    segmental_snr = []\n\n    for frame_count in range(int(num_frames)):\n        # (1) get the frames for the test and ref speech.\n        # Apply Hanning Window\n        clean_frame = clean_speech[start:start+winlength]\n        processed_frame = processed_speech[start:start+winlength]\n        clean_frame = clean_frame * window\n        processed_frame = processed_frame * window\n\n        # (2) Compute Segmental SNR\n        signal_energy = np.sum(clean_frame ** 2)\n        noise_energy = np.sum((clean_frame - processed_frame) ** 2)\n        segmental_snr.append(10 * np.log10(signal_energy / (noise_energy + eps)+ eps))\n        segmental_snr[-1] = max(segmental_snr[-1], MIN_SNR)\n        segmental_snr[-1] = min(segmental_snr[-1], MAX_SNR)\n        start += int(skiprate)\n    return overall_snr, segmental_snr\n\ndef CompositeEval(ref_wav, deg_wav, log_all=False):\n    # returns [sig, bak, ovl]\n    alpha = 0.95\n    len_ = min(ref_wav.shape[0], deg_wav.shape[0])\n    ref_wav = ref_wav[:len_]\n    ref_len = ref_wav.shape[0]\n    deg_wav = deg_wav[:len_]\n\n    # Compute WSS measure\n    wss_dist_vec = wss(ref_wav, deg_wav, 16000)\n    wss_dist_vec = sorted(wss_dist_vec, reverse=False)\n    wss_dist = np.mean(wss_dist_vec[:int(round(len(wss_dist_vec) * alpha))])\n\n    # Compute LLR measure\n    LLR_dist = llr(ref_wav, deg_wav, 16000)\n    LLR_dist = sorted(LLR_dist, reverse=False)\n    LLRs = LLR_dist\n    LLR_len = round(len(LLR_dist) * alpha)\n    llr_mean = np.mean(LLRs[:LLR_len])\n\n    # Compute the SSNR\n    snr_mean, segsnr_mean = SSNR(ref_wav, deg_wav, 16000)\n    segSNR = np.mean(segsnr_mean)\n\n    # Compute the PESQ\n    pesq_raw = PESQ(ref_wav, deg_wav)\n    if \'error!\' not in pesq_raw:\n        pesq_raw = float(pesq_raw)\n    else:\n        pesq_raw = -1.\n\n    def trim_mos(val):\n        return min(max(val, 1), 5)\n\n    Csig = 3.093 - 1.029 * llr_mean + 0.603 * pesq_raw - 0.009 * wss_dist\n    Csig = trim_mos(Csig)\n    Cbak = 1.634 + 0.478 * pesq_raw - 0.007 * wss_dist + 0.063 * segSNR\n    Cbak = trim_mos(Cbak)\n    Covl = 1.594 + 0.805 * pesq_raw - 0.512 * llr_mean - 0.007 * wss_dist\n    Covl = trim_mos(Covl)\n    if log_all:\n        return Csig, Cbak, Covl, pesq_raw, segSNR\n    else:\n        return Csig, Cbak, Covl\n\ndef wss(ref_wav, deg_wav, srate):\n    clean_speech = ref_wav\n    processed_speech = deg_wav\n    clean_length = ref_wav.shape[0]\n    processed_length = deg_wav.shape[0]\n\n    assert clean_length == processed_length, clean_length\n\n    winlength = round(30 * srate / 1000.) # 240 wlen in samples\n    skiprate = np.floor(winlength / 4)\n    max_freq = srate / 2\n    num_crit = 25 # num of critical bands\n\n    USE_FFT_SPECTRUM = 1\n    n_fft = int(2 ** np.ceil(np.log(2*winlength)/np.log(2)))\n    n_fftby2 = int(n_fft / 2)\n    Kmax = 20\n    Klocmax = 1\n\n    # Critical band filter definitions (Center frequency and BW in Hz)\n\n    cent_freq = [50., 120, 190, 260, 330, 400, 470, 540, 617.372,\n                 703.378, 798.717, 904.128, 1020.38, 1148.30, \n                 1288.72, 1442.54, 1610.70, 1794.16, 1993.93, \n                 2211.08, 2446.71, 2701.97, 2978.04, 3276.17,\n                 3597.63]\n    bandwidth = [70., 70, 70, 70, 70, 70, 70, 77.3724, 86.0056,\n                 95.3398, 105.411, 116.256, 127.914, 140.423, \n                 153.823, 168.154, 183.457, 199.776, 217.153, \n                 235.631, 255.255, 276.072, 298.126, 321.465,\n                 346.136]\n\n    bw_min = bandwidth[0] # min critical bandwidth\n\n    # set up critical band filters. Note here that Gaussianly shaped filters\n    # are used. Also, the sum of the filter weights are equivalent for each\n    # critical band filter. Filter less than -30 dB and set to zero.\n\n    min_factor = np.exp(-30. / (2 * 2.303)) # -30 dB point of filter\n\n    crit_filter = np.zeros((num_crit, n_fftby2))\n    all_f0 = []\n    for i in range(num_crit):\n        f0 = (cent_freq[i] / max_freq) * (n_fftby2)\n        all_f0.append(np.floor(f0))\n        bw = (bandwidth[i] / max_freq) * (n_fftby2)\n        norm_factor = np.log(bw_min) - np.log(bandwidth[i])\n        j = list(range(n_fftby2))\n        crit_filter[i, :] = np.exp(-11 * (((j - np.floor(f0)) / bw) ** 2) + \\\n                                   norm_factor)\n        crit_filter[i, :] = crit_filter[i, :] * (crit_filter[i, :] > \\\n                                                 min_factor)\n    # For each frame of input speech, compute Weighted Spectral Slope Measure\n\n    # num of frames\n    num_frames = int(clean_length / skiprate - (winlength / skiprate))\n    start = 0 # starting sample\n    time = np.linspace(1, winlength, winlength) / (winlength + 1)\n    window = 0.5 * (1 - np.cos(2 * np.pi * time))\n    distortion = []\n\n    for frame_count in range(num_frames):\n\n        # (1) Get the Frames for the test and reference speeech.\n        # Multiply by Hanning window.\n        clean_frame = clean_speech[start:start+winlength]\n        processed_frame = processed_speech[start:start+winlength]\n        clean_frame = clean_frame * window\n        processed_frame = processed_frame * window\n\n        # (2) Compuet Power Spectrum of clean and processed\n\n        clean_spec = (np.abs(np.fft.fft(clean_frame, n_fft)) ** 2)\n        processed_spec = (np.abs(np.fft.fft(processed_frame, n_fft)) ** 2)\n        clean_energy = [None] * num_crit\n        processed_energy = [None] * num_crit\n        # (3) Compute Filterbank output energies (in dB)\n        for i in range(num_crit):\n            clean_energy[i] = np.sum(clean_spec[:n_fftby2] * \\\n                                     crit_filter[i, :])\n            processed_energy[i] = np.sum(processed_spec[:n_fftby2] * \\\n                                         crit_filter[i, :])\n        clean_energy = np.array(clean_energy).reshape(-1, 1)\n        eps = np.ones((clean_energy.shape[0], 1)) * 1e-10\n        clean_energy = np.concatenate((clean_energy, eps), axis=1)\n        clean_energy = 10 * np.log10(np.max(clean_energy, axis=1))\n        processed_energy = np.array(processed_energy).reshape(-1, 1)\n        processed_energy = np.concatenate((processed_energy, eps), axis=1)\n        processed_energy = 10 * np.log10(np.max(processed_energy, axis=1))\n        # (4) Compute Spectral Shape (dB[i+1] - dB[i])\n\n        clean_slope = clean_energy[1:num_crit] - clean_energy[:num_crit-1]\n        processed_slope = processed_energy[1:num_crit] - \\\n                processed_energy[:num_crit-1]\n        # (5) Find the nearest peak locations in the spectra to each\n        # critical band. If the slope is negative, we search\n        # to the left. If positive, we search to the right.\n        clean_loc_peak = []\n        processed_loc_peak = []\n        for i in range(num_crit - 1):\n            if clean_slope[i] > 0:\n                # search to the right\n                n = i\n                while n < num_crit - 1 and clean_slope[n] > 0:\n                    n += 1\n                clean_loc_peak.append(clean_energy[n - 1])\n            else:\n                # search to the left\n                n = i\n                while n >= 0 and clean_slope[n] <= 0:\n                    n -= 1\n                clean_loc_peak.append(clean_energy[n + 1])\n            # find the peaks in the processed speech signal\n            if processed_slope[i] > 0:\n                n = i\n                while n < num_crit - 1 and processed_slope[n] > 0:\n                    n += 1\n                processed_loc_peak.append(processed_energy[n - 1])\n            else:\n                n = i\n                while n >= 0 and processed_slope[n] <= 0:\n                    n -= 1\n                processed_loc_peak.append(processed_energy[n + 1])\n        # (6) Compuet the WSS Measure for this frame. This includes\n        # determination of the weighting functino\n        dBMax_clean = max(clean_energy)\n        dBMax_processed = max(processed_energy)\n        # The weights are calculated by averaging individual\n        # weighting factors from the clean and processed frame.\n        # These weights W_clean and W_processed should range\n        # from 0 to 1 and place more emphasis on spectral \n        # peaks and less emphasis on slope differences in spectral\n        # valleys.  This procedure is described on page 1280 of\n        # Klatt\'s 1982 ICASSP paper.\n        clean_loc_peak = np.array(clean_loc_peak)\n        processed_loc_peak = np.array(processed_loc_peak)\n        Wmax_clean = Kmax / (Kmax + dBMax_clean - clean_energy[:num_crit-1])\n        Wlocmax_clean = Klocmax / (Klocmax + clean_loc_peak - \\\n                                   clean_energy[:num_crit-1])\n        W_clean = Wmax_clean * Wlocmax_clean\n        Wmax_processed = Kmax / (Kmax + dBMax_processed - \\\n                                processed_energy[:num_crit-1])\n        Wlocmax_processed = Klocmax / (Klocmax + processed_loc_peak - \\\n                                      processed_energy[:num_crit-1])\n        W_processed = Wmax_processed * Wlocmax_processed\n        W = (W_clean + W_processed) / 2\n        distortion.append(np.sum(W * (clean_slope[:num_crit - 1] - \\\n                                     processed_slope[:num_crit - 1]) ** 2))\n\n        # this normalization is not part of Klatt\'s paper, but helps\n        # to normalize the meaasure. Here we scale the measure by the sum of the\n        # weights\n        distortion[frame_count] = distortion[frame_count] / np.sum(W)\n        start += int(skiprate)\n    return distortion\n\ndef llr(ref_wav, deg_wav, srate):\n    clean_speech = ref_wav\n    processed_speech = deg_wav\n    clean_length = ref_wav.shape[0]\n    processed_length = deg_wav.shape[0]\n\n    assert clean_length == processed_length, clean_length\n\n    winlength = round(30 * srate / 1000.) # 240 wlen in samples\n    skiprate = np.floor(winlength / 4)\n    if srate < 10000:\n        # LPC analysis order\n        P = 10\n    else:\n        P = 16\n\n    # For each frame of input speech, calculate the Log Likelihood Ratio\n\n    num_frames = int(clean_length / skiprate - (winlength / skiprate))\n    start = 0\n    time = np.linspace(1, winlength, winlength) / (winlength + 1)\n    window = 0.5 * (1 - np.cos(2 * np.pi * time))\n    distortion = []\n\n    for frame_count in range(num_frames):\n\n        # (1) Get the Frames for the test and reference speeech.\n        # Multiply by Hanning window.\n        clean_frame = clean_speech[start:start+winlength]\n        processed_frame = processed_speech[start:start+winlength]\n        clean_frame = clean_frame * window\n        processed_frame = processed_frame * window\n        #\xc2\xa0(2) Get the autocorrelation logs and LPC params used\n        # to compute the LLR measure\n        R_clean, Ref_clean, A_clean = lpcoeff(clean_frame, P)\n        R_processed, Ref_processed, A_processed = lpcoeff(processed_frame, P)\n        A_clean = A_clean[None, :]\n        A_processed = A_processed[None, :]\n        #print(\'A_clean shape: \', A_clean.shape)\n        #print(\'toe(R_clean) shape: \', toeplitz(R_clean).shape)\n        #print(\'A_clean: \', A_clean)\n        #print(\'A_processed: \', A_processed)\n        #print(\'toe(R_clean): \', toeplitz(R_clean))\n        # (3) Compute the LLR measure\n        numerator = A_processed.dot(toeplitz(R_clean)).dot(A_processed.T)\n        #print(\'num_1: {}\'.format(A_processed.dot(toeplitz(R_clean))))\n        #print(\'num: \', numerator)\n        denominator = A_clean.dot(toeplitz(R_clean)).dot(A_clean.T)\n        #print(\'den: \', denominator)\n        #log_ = np.log(max(numerator / denominator, 10e-20))\n        #print(\'R_clean: \', R_clean)\n        #print(\'num: \', numerator)\n        #print(\'den: \', denominator)\n        #raise NotImplementedError\n        log_ = np.log(numerator / denominator)\n        #print(\'np.log({}/{}) = {}\'.format(numerator, denominator, log_))\n        distortion.append(np.squeeze(log_))\n        start += int(skiprate)\n    return np.array(distortion)\n\n#@nb.jit(\'UniTuple(float32[:], 3)(float32[:])\')#,nopython=True)\ndef lpcoeff(speech_frame, model_order):\n    \n    # (1) Compute Autocor lags\n    # max?\n    winlength = speech_frame.shape[0]\n    R = []\n    #R = [0] * (model_order + 1)\n    for k in range(model_order + 1):\n        first = speech_frame[:(winlength - k)]\n        second = speech_frame[k:winlength]\n        #raise NotImplementedError\n        R.append(np.sum(first * second))\n        #R[k] = np.sum( first * second)\n    # (2) Lev-Durbin\n    a = np.ones((model_order,))\n    E = np.zeros((model_order + 1,))\n    rcoeff = np.zeros((model_order,))\n    E[0] = R[0]\n    for i in range(model_order):\n        #print(\'-\' * 40)\n        #print(\'i: \', i)\n        if i == 0:\n            sum_term = 0\n        else:\n            a_past = a[:i]\n            #print(\'R[i:0:-1] = \', R[i:0:-1])\n            #print(\'a_past = \', a_past)\n            sum_term = np.sum(a_past * np.array(R[i:0:-1]))\n            #print(\'a_past size: \', a_past.shape)\n        #print(\'sum_term = {:.6f}\'.format(sum_term))\n        #print(\'E[i] =  {}\'.format(E[i]))\n        #print(\'R[i+1] = \', R[i+1])\n        rcoeff[i] = (R[i+1] - sum_term)/E[i]\n        #print(\'len(a) = \', len(a))\n        #print(\'len(rcoeff) = \', len(rcoeff))\n        #print(\'a[{}]={}\'.format(i, a[i]))\n        #print(\'rcoeff[{}]={}\'.format(i, rcoeff[i]))\n        a[i] = rcoeff[i]\n        if i > 0:\n            #print(\'a: \', a)\n            #print(\'a_past: \', a_past)\n            #print(\'a_past[:i] \', a_past[:i])\n            #print(\'a_past[::-1] \', a_past[::-1])\n            a[:i] = a_past[:i] - rcoeff[i] * a_past[::-1]\n        E[i+1] = (1-rcoeff[i]*rcoeff[i])*E[i]\n        #print(\'E[i+1]= \', E[i+1])\n    acorr = np.array(R, dtype=np.float32)\n    refcoeff = np.array(rcoeff, dtype=np.float32)\n    a = a * -1\n    lpparams = np.array([1] + list(a), dtype=np.float32)\n    acorr =np.array(acorr, dtype=np.float32)\n    refcoeff = np.array(refcoeff, dtype=np.float32)\n    lpparams = np.array(lpparams, dtype=np.float32)\n    #print(\'acorr shape: \', acorr.shape)\n    #print(\'refcoeff shape: \', refcoeff.shape)\n    #print(\'lpparams shape: \', lpparams.shape)\n    return acorr, refcoeff, lpparams\n\n'"
segan/datasets/__init__.py,0,b'from .se_dataset import *\nfrom .vc_dataset import *\n'
segan/datasets/se_dataset.py,13,"b'from __future__ import print_function\nimport torch\nfrom torch.utils.data.dataset import Dataset\nfrom torch.utils.data.dataloader import default_collate\nimport os\nimport glob\nimport json\nimport gzip\nimport pickle\nimport timeit\nimport scipy.io.wavfile as wavfile\nimport numpy as np\nimport multiprocessing as mp\nimport random\nimport librosa\nfrom ahoproc_tools.io import *\nfrom ahoproc_tools.interpolate import *\nimport h5py\n\n\ndef collate_fn(batch):\n    # first we have utt bname, then tensors\n    data_batch = []\n    uttname_batch = []\n    for sample in batch:\n        uttname_batch.append(sample[0])\n        data_batch.append(sample[1:])\n    data_batch = default_collate(data_batch)\n    return [uttname_batch] + data_batch\n\ndef slice_signal(signal, window_sizes, stride=0.5):\n    """""" Slice input signal\n\n        # Arguments\n            window_sizes: list with different sizes to be sliced\n            stride: fraction of sliding window per window size\n\n        # Returns\n            A list of numpy matrices, each one being of different window size\n    """"""\n    assert signal.ndim == 1, signal.ndim\n    n_samples = signal.shape[0]\n    slices = []\n    for window_size in window_sizes:\n        offset = int(window_size * stride)\n        slices.append([])\n        for beg_i in range(n_samples + offset, offset):\n            end_i = beg_i + offset\n            if end_i > n_samples:\n                # last slice is offset to past to fit full window\n                beg_i = n_samples - offset\n                end_i = n_samples\n            slice_ = signal[beg_i:end_i]\n            assert slice_.shape[0] == window_size, slice_.shape[0]\n            slices[-1].append(slice_)\n        slices[-1] = np.array(slices[-1], dtype=np.int32)\n    return slices\n\ndef slice_index_helper(args):\n    return slice_signal_index(*args)\n\ndef slice_signal_index(path, window_size, stride):\n    """""" Slice input signal into indexes (beg, end) each\n\n        # Arguments\n            window_size: size of each slice\n            stride: fraction of sliding window per window size\n\n        # Returns\n            A list of tuples (beg, end) sample indexes\n    """"""\n    signal, rate = librosa.load(path, 16000)\n    assert stride <= 1, stride\n    assert stride > 0, stride\n    assert signal.ndim == 1, signal.ndim\n    n_samples = signal.shape[0]\n    slices = []\n    offset = int(window_size * stride)\n    #for beg_i in range(0, n_samples - (offset), offset):\n    for beg_i in range(0, n_samples - window_size + 1, offset):\n        end_i = beg_i + window_size\n        #if end_i >= n_samples:\n            # last slice is offset to past to fit full window\n        #    beg_i = n_samples - window_size\n        #    end_i = n_samples\n        slice_ = (beg_i, end_i)\n        slices.append(slice_)\n    return slices\n\ndef abs_normalize_wave_minmax(x):\n    x = x.astype(np.int32)\n    imax = np.max(np.abs(x))\n    x_n = x / imax\n    return x_n \n\ndef abs_short_normalize_wave_minmax(x):\n    imax = 32767.\n    x_n = x / imax\n    return x_n \n\ndef dynamic_normalize_wave_minmax(x):\n    x = x.astype(np.int32)\n    imax = np.max(x)\n    imin = np.min(x)\n    x_n = (x - np.min(x)) / (float(imax) - float(imin))\n    return x_n * 2 - 1\n\ndef normalize_wave_minmax(x):\n    return (2./65535.) * (x - 32767.) + 1.\n\ndef pre_emphasize(x, coef=0.95):\n    if coef <= 0:\n        return x\n    x0 = np.reshape(x[0], (1,))\n    diff = x[1:] - coef * x[:-1]\n    concat = np.concatenate((x0, diff), axis=0)\n    return concat\n\ndef de_emphasize(y, coef=0.95):\n    if coef <= 0:\n        return y\n    x = np.zeros(y.shape[0], dtype=np.float32)\n    x[0] = y[0]\n    for n in range(1, y.shape[0], 1):\n        x[n] = coef * x[n - 1] + y[n]\n    return x\n\nclass SEDataset(Dataset):\n    """""" Speech enhancement dataset """"""\n    def __init__(self, clean_dir, noisy_dir, preemph, cache_dir=\'.\', \n                 split=\'train\', slice_size=2**14,\n                 stride = 0.5, max_samples=None, do_cache=False, verbose=False,\n                 slice_workers=2, preemph_norm=False,\n                 random_scale=[1]):\n        super(SEDataset, self).__init__()\n        print(\'Creating {} split out of data in {}\'.format(split, clean_dir))\n        self.clean_names = glob.glob(os.path.join(clean_dir, \'*.wav\'))\n        self.noisy_names = glob.glob(os.path.join(noisy_dir, \'*.wav\'))\n        print(\'Found {} clean names and {} noisy\'\n              \' names\'.format(len(self.clean_names), len(self.noisy_names)))\n        self.slice_workers = slice_workers\n        if len(self.clean_names) != len(self.noisy_names) or \\\n           len(self.clean_names) == 0:\n            raise ValueError(\'No wav data found! Check your data path please\')\n        if max_samples is not None:\n            assert isinstance(max_samples, int), type(max_samples)\n            self.clean_names = self.clean_names[:max_samples]\n            self.noisy_names = self.noisy_names[:max_samples]\n        # path to store pairs of wavs\n        self.cache_dir = cache_dir\n        self.slice_size = slice_size\n        self.stride = stride\n        self.split = split\n        self.verbose = verbose\n        self.preemph = preemph\n        # order is preemph + norm (rather than norm + preemph)\n        self.preemph_norm = preemph_norm\n        # random scaling list, selected per utterance\n        self.random_scale = random_scale\n        #self.read_wavs()\n        cache_path = cache_dir#os.path.join(cache_dir, \'{}_chunks.pkl\'.format(split))\n        #if os.path.exists(cache_path):\n        #    with open(cache_path ,\'rb\') as ch_f:\n        #        self.slicings = pickle.load(ch_f)\n        #else:\n        if not os.path.exists(cache_path):\n            os.makedirs(cache_path)\n        if not os.path.exists(os.path.join(cache_path,\n                                           \'{}_idx2slice.pkl\'.format(split))):\n            # make the slice indexes given slice_size and stride\n            self.prepare_slicing()\n            #with open(os.path.join(cache_path, \'{}_cache.cfg\'.format(split)), \'w\') as cfg_f:\n            #    cfg_f.write(json.dumps({\'num_slicings\':len(self.slicings)}))\n            with open(os.path.join(cache_path, \'{}_idx2slice.pkl\'.format(split)), \'wb\') as i2s_f:\n                pickle.dump(self.idx2slice, i2s_f)\n            #if do_cache:\n            for s_i, slicing in self.slicings.items():\n                with open(os.path.join(cache_path, \'{}_{}.pkl\'.format(split, s_i)), \'wb\') as ch_f:\n                    # store slicing results\n                    pickle.dump(slicing, ch_f)\n            self.num_samples = len(self.idx2slice)\n            self.slicings = None\n        else:\n            #with open(os.path.join(cache_path, \'{}_cache.cfg\'.format(split)), \'r\') as cfg_f:\n            #    self.num_samples = json.load(cfg_f)\n            with open(os.path.join(cache_path, \'{}_idx2slice.pkl\'.format(split)), \'rb\') as i2s_f:\n                self.idx2slice = pickle.load(i2s_f)\n            print(\'Loaded {} idx2slice items\'.format(len(self.idx2slice)))\n\n    def read_wav_file(self, wavfilename):\n        rate, wav = wavfile.read(wavfilename)\n        if self.preemph_norm:\n            wav = pre_emphasize(wav, self.preemph)\n            wav = normalize_wave_minmax(wav)\n        else:\n            wav = normalize_wave_minmax(wav)\n            wav = pre_emphasize(wav, self.preemph)\n        return rate, wav\n\n    def read_wavs(self):\n        #self.clean_wavs = []\n        self.clean_paths = []\n        #self.noisy_wavs = []\n        self.noisy_paths = []\n        clen = len(self.clean_names)\n        nlen = len(self.noisy_names)\n        assert clen == nlen, clen\n        if self.verbose:\n            print(\'< Reading {} wav files... >\'.format(clen))\n        beg_t = timeit.default_timer()\n        for i, (clean_name, noisy_name) in enumerate(zip(self.clean_names, self.noisy_names), start=1):\n            # print(\'Reading wav pair {}/{}\'.format(i, clen))\n            #c_rate, c_wav = self.read_wav_file(clean_name)\n            #if c_wav.shape[0] < self.slice_size:\n                # skip this wav as it is shorter than the window\n            #    continue\n            #if c_rate != 16e3:\n            #    raise ValueError(\'Sampling rate is supposed to be 16.000 Hz\')\n            #self.clean_wavs.append(c_wav)\n            self.clean_paths.append(clean_name)\n\n            #n_rate, n_wav = self.read_wav_file(noisy_name)\n            #self.noisy_wavs.append(n_wav)\n            self.noisy_paths.append(noisy_name)\n        end_t = timeit.default_timer()\n        if self.verbose:\n            print(\'> Loaded files in {} s <\'.format(end_t - beg_t))\n\n    def read_wavs_and_cache(self):\n        """""" Read in all clean and noisy wavs """"""\n        cache_path = os.path.join(self.cache_dir, \'cached_pair.pkl\')\n        try:\n            with open(cache_path) as f_in:\n                cache = pickle.load(f_in)\n                if self.verbose:\n                    print(\'Reading clean and wav pair from \', cache_path)\n                self.clean_wavs = cache[\'clean\']\n                self.noisy_wavs = cache[\'noisy\']\n        except IOError:\n            self.read_wavs()\n            cache = {\'noisy\':self.noisy_wavs, \'clean\':self.clean_wavs}\n            if not os.path.exists(self.cache_dir):\n                os.makedirs(self.cache_dir)\n            with open(cache_path, \'wb\') as f_out:\n                pickle.dump(cache, f_out)\n                if self.verbose:\n                    print(\'Cached clean and wav pair into \', cache_path)\n\n    def prepare_slicing(self):\n        """""" Make a dictionary containing, for every wav file, its\n            slices performed sequentially in steps of stride and\n            sized slice_size\n        """"""\n        slicings = {}\n        idx2slice = []\n        verbose = self.verbose\n        if verbose:\n            print(\'< Slicing all signals with window\'\n                  \' {} and stride {}... >\'.format(self.slice_size, self.stride))\n        beg_t = timeit.default_timer()\n        pool = mp.Pool(self.slice_workers)\n        clean_args = [(self.clean_names[i], self.slice_size, self.stride) for \\\n                      i in range(len(self.clean_names))]\n        c_slices = pool.map(slice_index_helper, clean_args)\n        noisy_args = [(self.noisy_names[i], self.slice_size, self.stride) for \\\n                      i in range(len(self.noisy_names))]\n        n_slices = pool.map(slice_index_helper, noisy_args)\n        if len(n_slices) != len(c_slices):\n            raise ValueError(\'n_slices and c_slices have different lengths:\'\n                             \'{} != {}\'.format(len(n_slices), len(c_slices)))\n        for w_i, (c_slice, n_slice) in enumerate(zip(c_slices, n_slices)):\n            c_path = self.clean_names[w_i]\n            n_path = self.noisy_names[w_i]\n            if w_i not in slicings:\n                slicings[w_i] = []\n            for t_i, (c_ss, n_ss) in enumerate(zip(c_slice, n_slice)):\n                if c_ss[1] - c_ss[0] < 1024:\n                    # decimate less than 4096 samples window\n                    continue\n                slicings[w_i].append({\'c_slice\':c_ss,\n                                      \'n_slice\':n_ss, \'c_path\':c_path,\n                                      \'n_path\':n_path,\n                                      \'slice_idx\':t_i})\n                idx2slice.append((w_i, t_i))\n        """"""\n        for w_i, (c_path, n_path) in enumerate(zip(self.clean_names,\n                                                   self.noisy_names)):\n            c_wav, rate = librosa.load(c_path)\n            n_wav, rate = librosa.load(n_path)\n            c_slices = slice_signal_index(c_wav, self.slice_size, self.stride)\n            n_slices = slice_signal_index(n_wav, self.slice_size, self.stride)\n            for c_slice, n_slice in zip(c_slices, n_slices):\n                if c_slice[1] - c_slice[0] < 4096:\n                    continue\n                if verbose:\n                    print(\'Id: {}, name: {}, c_slice: {}, n_slice: {}\'.format(w_i, self.clean_names[w_i], c_slice,\n                                                                              n_slice))\n                slicings.append({\'id\':w_i, \'c_slice\':c_slice,\n                                 \'n_slice\':n_slice,\n                                 \'c_path\':c_path,\n                                 \'n_path\':n_path})\n        """"""\n        self.slicings = slicings\n        self.idx2slice = idx2slice\n        end_t = timeit.default_timer()\n        if verbose:\n            print(\'Sliced all signals in {} s\'.format(end_t - beg_t))\n\n    def extract_slice(self, index):\n        # load slice\n        s_i, e_i = self.idx2slice[index]\n        #print(\'selected item: \', s_i, e_i)\n        slice_file = os.path.join(self.cache_dir,\n                                  \'{}_{}.pkl\'.format(self.split, s_i))\n        #print(\'reading slice file: \', slice_file)\n        with open(slice_file, \'rb\') as s_f:\n            slice_ = pickle.load(s_f)\n            #print(\'slice_: \', slice_)\n            slice_ = slice_[e_i]\n            c_slice_, n_slice_ = slice_[\'c_slice\'], slice_[\'n_slice\']\n            slice_idx = slice_[\'slice_idx\']\n            n_path = slice_[\'n_path\']\n            bname = os.path.splitext(os.path.basename(n_path))[0]\n            met_path = os.path.join(os.path.dirname(n_path), \n                                    bname + \'.met\')\n            ssnr = None\n            pesq = None\n            if os.path.exists(met_path):\n                metrics = json.load(open(met_path, \'r\'))\n                pesq = metrics[\'pesq\']\n                ssnr = metrics[\'ssnr\']\n            #c_signal, rate = librosa.load(slice_[\'c_path\'])\n            #n_signal, rate = librosa.load(slice_[\'n_path\'])\n            c_signal = self.read_wav_file(slice_[\'c_path\'])[1]\n            n_signal = self.read_wav_file(slice_[\'n_path\'])[1]\n            #c_signal = self.clean_wavs[idx_]\n            #n_signal = self.noisy_wavs[idx_]\n            c_slice = c_signal[c_slice_[0]:c_slice_[1]]\n            n_slice = n_signal[n_slice_[0]:n_slice_[1]]\n            if n_slice.shape[0] > c_slice.shape[0]:\n                n_slice = n_slice[:c_slice.shape[0]]\n            if c_slice.shape[0] > n_slice.shape[0]:\n                c_slice = c_slice[:n_slice.shape[0]]\n            #print(\'c_slice[0]: {} c_slice[1]: {}\'.format(c_slice_[0],\n            #                                             c_slice_[1]))\n            if c_slice.shape[0] < self.slice_size:\n                pad_t = np.zeros((self.slice_size - c_slice.shape[0],))\n                c_slice = np.concatenate((c_slice, pad_t))\n                n_slice = np.concatenate((n_slice, pad_t))\n            #print(\'c_slice shape: \', c_slice.shape)\n            #print(\'n_slice shape: \', n_slice.shape)\n            bname = os.path.splitext(os.path.basename(n_path))[0]\n            return c_slice, n_slice, pesq, ssnr, slice_idx, bname\n\n    def __getitem__(self, index):\n        c_slice, n_slice, pesq, ssnr, slice_idx, bname = self.extract_slice(index)\n        rscale = random.choice(self.random_scale)\n        if rscale != 1:\n            c_slice = rscale * c_slice\n            n_slice = rscale * n_slice\n        returns = [bname, torch.FloatTensor(c_slice), torch.FloatTensor(n_slice),\n                  slice_idx]\n        if pesq is not None:\n            returns.append(torch.FloatTensor([pesq]))\n        if ssnr is not None:\n            returns.append(torch.FloatTensor([ssnr]))\n        # print(\'idx: {} c_slice shape: {}\'.format(index, c_slice.shape))\n        return returns\n\n    def __len__(self):\n        return len(self.idx2slice)\n\nclass RandomChunkSEDataset(Dataset):\n    """""" Random Chunking Speech enhancement dataset """"""\n    def __init__(self, clean_dir, noisy_dir, preemph, \n                 split=\'train\', slice_size=2**14,\n                 max_samples=None, utt2spk=None, spk2idx=None):\n        super(RandomChunkSEDataset, self).__init__()\n        print(\'Creating {} split out of data in {}\'.format(split, clean_dir))\n        self.preemph = preemph\n        # file containing pointers: baename (no ext) --> spkid\n        self.utt2spk = utt2spk\n        # dict containing mapping spkid --> int idx\n        self.spk2idx = spk2idx\n        if self.utt2spk is not None and self.spk2idx is None:\n            raise ValueError(\'Please specify spk2idx too with utt2spk!\')\n        if utt2spk is not None:\n            self.read_utt2spk()\n        self.samples = {}\n        self.slice_size = slice_size\n        self.clean_names = glob.glob(os.path.join(clean_dir, \'*.wav\'))\n        for c_i, cname in enumerate(self.clean_names):\n            bname = os.path.basename(cname)\n            self.samples[c_i] = {\'clean\':cname,\n                                 \'noisy\':os.path.join(noisy_dir, bname)}\n\n    def read_utt2spk(self):\n        utt2spk = {}\n        with open(self.utt2spk, \'r\') as utt_f:\n            for line in utt_f:\n                line = line.rstrip().split(\'\\t\')\n                uttname = os.path.splitext(os.path.basename(line[0]))[0]\n                utt2spk[uttname] = line[1]\n        self.utt2spk = utt2spk\n\n    def read_wav_file(self, wavfilename):\n        #rate, wav = wavfile.read(wavfilename)\n        wav, rate = librosa.load(wavfilename, 16000)\n\n        #wav = abs_short_normalize_wave_minmax(wav)\n        wav = pre_emphasize(wav, self.preemph)\n        return rate, wav\n\n    def __getitem__(self, index):\n        sample = self.samples[index]\n        cpath = sample[\'clean\']\n        bname = os.path.splitext(os.path.basename(cpath))[0]\n        npath = sample[\'noisy\']\n        returns = [bname]\n        # slice them randomly\n        cwav = self.read_wav_file(cpath)[1]\n        nwav = self.read_wav_file(npath)[1]\n        min_L = min(cwav.shape[0], nwav.shape[0])\n        if self.slice_size > min_L:\n            slice_size = min_L\n        else:\n            slice_size = self.slice_size\n        slice_idx = random.randint(0, min_L - slice_size)\n        cslice = cwav[slice_idx:slice_idx + self.slice_size] \n        nslice = nwav[slice_idx:slice_idx + self.slice_size] \n        if min_L < self.slice_size:\n            c_pad_size = self.slice_size - cslice.shape[0]\n            n_pad_size = self.slice_size - nslice.shape[0]\n            c_pad_T = np.zeros(c_pad_size,)\n            n_pad_T = np.zeros(n_pad_size,)\n            # pad to desired size\n            cslice  = np.concatenate((cslice, c_pad_T), axis=0)\n            nslice  = np.concatenate((nslice, n_pad_T), axis=0)\n        returns += [torch.FloatTensor(cslice), \n                    torch.FloatTensor(nslice)]\n        if self.utt2spk is not None:\n            spk = self.utt2spk[bname]\n            spkidx = self.spk2idx[spk]\n            returns.append(torch.LongTensor([spkidx]))\n        return returns\n\n    def __len__(self):\n        return len(self.samples)\n\nclass RandomChunkSEF0Dataset(Dataset):\n    """""" Random Chunking Speech enhancement dataset loading\n        F0 curves from aco path rather than wavs """"""\n    def __init__(self, clean_dir, noisy_dir, preemph=0, \n                 split=\'train\', slice_size=2**14,\n                 max_samples=None):\n        super(RandomChunkSEF0Dataset, self).__init__()\n        print(\'Creating {} split out of data in {}\'.format(split, clean_dir))\n        self.preemph = preemph\n        # file containing pointers: baename (no ext) --> spkid\n        # dict containing mapping spkid --> int idx\n        self.samples = {}\n        self.slice_size = slice_size\n        self.clean_names = glob.glob(os.path.join(clean_dir, \'*.wav\'))\n        for c_i, cname in enumerate(self.clean_names):\n            bname = os.path.splitext(os.path.basename(cname))[0]\n            self.samples[c_i] = {\'clean\':cname,\n                                 \'noisy\':os.path.join(noisy_dir, bname) + \\\n                                 \'.lf0\'}\n\n    def read_wav_file(self, wavfilename):\n        rate, wav = wavfile.read(wavfilename)\n        wav = pre_emphasize(wav, self.preemph)\n        #wav = dynamic_normalize_wave_minmax(wav)\n        wav = abs_normalize_wave_minmax(wav)\n        return rate, wav\n\n    def __getitem__(self, index):\n        sample = self.samples[index]\n        cpath = sample[\'clean\']\n        bname = os.path.splitext(os.path.basename(cpath))[0]\n        npath = sample[\'noisy\']\n        returns = [bname]\n        # slice them randomly\n        cwav = self.read_wav_file(cpath)[1]\n        lf0 = read_aco_file(npath)\n        ilf0, uv = interpolation(lf0, -10000000000)\n        ilf0[ilf0 < -1000] = np.log(60)\n        # append zeros in the end to show EOS\n        ilf0 = np.concatenate((ilf0, np.zeros((1,))), axis=0)\n        uv = np.concatenate((uv, np.zeros((1,))), axis=0)\n        min_L = cwav.shape[0]\n        #min_L = lf0.shape[0] * 80\n        #print(\'cwav shape: \', cwav.shape)\n        cwav = cwav[:min_L]\n        #print(\'trimmed cwav shape: \', cwav.shape)\n        if self.slice_size > min_L:\n            slice_size = min_L\n        else:\n            slice_size = self.slice_size\n        slice_idx = random.randint(0, min_L - slice_size)\n        cslice = cwav[slice_idx:slice_idx + self.slice_size] \n        #print(\'slice_idx: \', slice_idx)\n        #print(\'slice_idx // 80: \', slice_idx // 80)\n        if slice_size < self.slice_size:\n            print(\'WARNING: cwav shape: \', cwav.shape[0])\n        lf0slice = np.zeros(((self.slice_size // 80) + 1,))\n        uvslice = np.zeros(((self.slice_size // 80) + 1,))\n        ilf0_s = ilf0[(slice_idx // 80):(slice_idx // 80) + \\\n                      (self.slice_size // 80) + 1]\n        uv_s = uv[(slice_idx // 80):(slice_idx // 80) + \\\n                  (self.slice_size // 80) + 1]\n        lf0slice[:ilf0_s.shape[0]] = ilf0_s\n        uvslice[:uv_s.shape[0]] = uv_s\n        if min_L < self.slice_size:\n            c_pad_size = self.slice_size - cslice.shape[0]\n            c_pad_T = np.zeros(c_pad_size,)\n            # pad to desired size\n            cslice  = np.concatenate((cslice, c_pad_T), axis=0)\n        returns += [torch.FloatTensor(cslice), \n                    torch.FloatTensor(lf0slice),\n                    torch.FloatTensor(uvslice)]\n        return returns\n\n    def __len__(self):\n        return len(self.samples)\n\nclass SEH5Dataset(Dataset):\n    """""" Speech enhancement dataset from H5 data file. \n        The pairs must be named (data, label), being each\n        one a dataset containing wav chunks (already chunked\n        to fixed size).\n    """"""\n    def __init__(self, data_root, split, preemph, \n                 verbose=False,\n                 preemph_norm=False,\n                 random_scale=[1]):\n        super().__init__()\n        self.data_root = data_root\n        self.split = split\n        self.preemph = preemph\n        self.verbose = verbose\n        self.random_scale = random_scale\n        h5_file = os.path.join(data_root, split + \'.h5\')\n        if not os.path.exists(h5_file):\n            raise FileNotFoundError(h5_file)\n        f = h5py.File(h5_file, \'r\')\n        ks = list(f.keys())\n        assert \'data\' in ks, ks\n        assert \'label\' in ks, ks\n        if verbose:\n            print(\'Found H5 file {} with {} samples\'.format(h5_file,\n                                                            f[\'data\'].shape[0]))\n        self.f = f\n\n    def __getitem__(self, index):\n        c_slice = self.f[\'data\'][index]\n        n_slice = self.f[\'label\'][index]\n        rscale = random.choice(self.random_scale)\n        if rscale != 1:\n            c_slice = rscale * c_slice\n            n_slice = rscale * n_slice\n        # uttname not known with H5\n        returns = [\'N/A\', torch.FloatTensor(c_slice).squeeze(-1), \n                   torch.FloatTensor(n_slice).squeeze(-1), 0]\n        return returns\n\n    def __len__(self):\n        return self.f[\'data\'].shape[0]\n\nif __name__ == \'__main__\':\n    #dset = SEDataset(\'../../data/clean_trainset\', \'../../data/noisy_trainset\', 0.95,\n    #                  cache_dir=None, max_samples=100, verbose=True)\n    #sample_0 = dset.__getitem__(0)\n    #print(\'sample_0: \', sample_0)\n\n    #dset = RandomChunkSEF0Dataset(\'../../data/silent/clean_trainset\',\n    #                              \'../../data/silent/lf0_trainset\', 0.)\n    #sample_0 = dset.__getitem__(0)\n    #print(\'len sample_0: \', len(sample_0))\n    dset = SEH5Dataset(\'../../data/widebandnet_h5/speaker1\', \'train\',\n                       0.95, verbose=True)\n    print(len(dset))\n'"
segan/datasets/vc_dataset.py,5,"b'import torch\nfrom torch.utils.data import Dataset\nfrom scipy.io import wavfile\nimport glob\nimport os\ntry:\n    from se_dataset import normalize_wave_minmax, pre_emphasize\nexcept ImportError:\n    from .se_dataset import normalize_wave_minmax, pre_emphasize\n\n\ndef varlen_wav_collate(batch):\n    src_maxlen = 0\n    trg_maxlen = 0\n    for sample in batch:\n        if len(sample) == 3:\n            _, src, trg = sample\n        else:\n            src, trg = sample\n        if src_maxlen < src.shape[0]:\n            src_maxlen = src.shape[0]\n        if trg_maxlen < trg.shape[0]:\n            trg_maxlen = trg.shape[0]\n    src_wav_b = torch.zeros(len(batch), \n                            src_maxlen)\n    trg_wav_b = torch.zeros(len(batch), \n                            trg_maxlen)\n    for bi, sample in enumerate(batch):\n        if len(sample) == 3:\n            _, src, trg = sample\n        else:\n            src, trg = sample\n        src_wav_b[bi, :src.shape[0]] = torch.FloatTensor(src)\n        trg_wav_b[bi, :trg.shape[0]] = torch.FloatTensor(trg)\n    return \'\', src_wav_b, trg_wav_b\n\nclass VCDataset(Dataset):\n    """"""\n    At the moment JUST ONE-TO-ONE SPEAKER MAPPING\n    """"""\n    # TODO: EXTEND TO MULTI SPK LOAD\n    def __init__(self, src_path, trg_path, preemph=0):\n        super().__init__()\n        self.src_path = src_path\n        self.trg_path = trg_path\n        self.preemph = preemph\n        src_files = glob.glob(os.path.join(src_path, \'*.wav\'))\n        trg_files = []\n        for src_file in src_files:\n            bname = os.path.basename(src_file)\n            trg_file = os.path.join(trg_path, bname)\n            assert os.path.exists(trg_file)\n            trg_files.append(trg_file)\n        self.src_files = src_files\n        self.trg_files = trg_files\n\n    def read_wav_file(self, wavfilename):\n        rate, wav = wavfile.read(wavfilename)\n        wav = normalize_wave_minmax(wav)\n        wav = pre_emphasize(wav, self.preemph)\n        return rate, wav\n\n    def __getitem__(self, index):\n        src_wav = self.read_wav_file(self.src_files[index])[1]\n        trg_wav = self.read_wav_file(self.trg_files[index])[1]\n        return src_wav, trg_wav\n\n    def __len__(self):\n        return len(self.src_files)\n\nif __name__ == \'__main__\':\n    dset = VCDataset(\'../../data/vc_data/trainset/VCC2SF1\',\n                     \'../../data/vc_data/trainset/VCC2TM1\')\n    print(len(dset))\n    print(dset.__getitem__(0))\n\n\n'"
segan/models/__init__.py,0,b'from .model import *\nfrom .core import *\nfrom .generator import *\nfrom .discriminator import *\n'
segan/models/core.py,18,"b""import torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\nfrom torch.nn.parameter import Parameter\nfrom torch.nn.modules import Module\nimport torch.nn.functional as F\nimport os\nimport math\nimport json\n\nclass Saver(object):\n\n    def __init__(self, model, save_path, max_ckpts=5, optimizer=None, prefix=''):\n        self.model = model\n        self.save_path = save_path\n        self.ckpt_path = os.path.join(save_path, '{}checkpoints'.format(prefix)) \n        self.max_ckpts = max_ckpts\n        self.optimizer = optimizer\n        self.prefix = prefix\n\n    def save(self, model_name, step, best_val=False):\n        save_path = self.save_path\n        if not os.path.exists(save_path):\n            os.makedirs(save_path)\n\n        ckpt_path = self.ckpt_path\n        if os.path.exists(ckpt_path):\n            with open(ckpt_path, 'r') as ckpt_f:\n                # read latest checkpoints\n                ckpts = json.load(ckpt_f)\n        else:\n            ckpts = {'latest':[], 'current':[]}\n\n        model_path = '{}-{}.ckpt'.format(model_name, step)\n        if best_val: \n            model_path = 'best_' + model_path\n        model_path = '{}{}'.format(self.prefix, model_path)\n        \n        # get rid of oldest ckpt, with is the frst one in list\n        latest = ckpts['latest']\n        if len(latest) > 0:\n            todel = latest[0]\n            if self.max_ckpts is not None:\n                if len(latest) > self.max_ckpts:\n                    try:\n                        print('Removing old ckpt {}'.format(os.path.join(save_path, \n                                                            'weights_' + todel)))\n                        os.remove(os.path.join(save_path, 'weights_' + todel))\n                        latest = latest[1:] \n                    except FileNotFoundError:\n                        print('ERROR: ckpt is not there?')\n\n        latest += [model_path]\n\n        ckpts['latest'] = latest\n        ckpts['current'] = model_path\n\n        with open(ckpt_path, 'w') as ckpt_f:\n            ckpt_f.write(json.dumps(ckpts, indent=2))\n\n        st_dict = {'step':step,\n                   'state_dict':self.model.state_dict()}\n\n        if self.optimizer is not None: \n            st_dict['optimizer'] = self.optimizer.state_dict()\n        # now actually save the model and its weights\n        #torch.save(self.model, os.path.join(save_path, model_path))\n        torch.save(st_dict, os.path.join(save_path, \n                                          'weights_' + \\\n                                           model_path))\n\n    def read_latest_checkpoint(self):\n        ckpt_path = self.ckpt_path\n        print('Reading latest checkpoint from {}...'.format(ckpt_path))\n        if not os.path.exists(ckpt_path):\n            print('[!] No checkpoint found in {}'.format(self.save_path))\n            return False\n        else:\n            with open(ckpt_path, 'r') as ckpt_f:\n                ckpts = json.load(ckpt_f)\n            curr_ckpt = ckpts['current'] \n            return curr_ckpt\n\n    #def load(self):\n    #    save_path = self.save_path\n    #    ckpt_path = self.ckpt_path\n    #    print('Reading latest checkpoint from {}...'.format(ckpt_path))\n    #    if not os.path.exists(ckpt_path):\n    #        raise FileNotFoundError('[!] Could not load model. Ckpt '\n    #                                '{} does not exist!'.format(ckpt_path))\n    #    with open(ckpt_path, 'r') as ckpt_f:\n    #        ckpts = json.load(ckpt_f)\n    #    curr_ckpt = ckpts['curent'] \n    #    st_dict = torch.load(os.path.join(save_path, curr_ckpt))\n    #    return \n\n    def load_weights(self):\n        save_path = self.save_path\n        curr_ckpt = self.read_latest_checkpoint()\n        if curr_ckpt is False:\n            if not os.path.exists(ckpt_path):\n                print('[!] No weights to be loaded')\n                return False\n        else:\n            st_dict = torch.load(os.path.join(save_path,\n                                              'weights_' + \\\n                                              curr_ckpt))\n            if 'state_dict' in st_dict:\n                # new saving mode\n                model_state = st_dict['state_dict']\n                self.model.load_state_dict(model_state)\n                if self.optimizer is not None and 'optimizer' in st_dict:\n                    self.optimizer.load_state_dict(st_dict['optimizer'])\n            else:\n                # legacy mode, only model was saved\n                self.model.load_state_dict(st_dict)\n            print('[*] Loaded weights')\n            return True\n\n    def load_pretrained_ckpt(self, ckpt_file, load_last=False, load_opt=True):\n        model_dict = self.model.state_dict() \n        st_dict = torch.load(ckpt_file, \n                             map_location=lambda storage, loc: storage)\n        if 'state_dict' in st_dict:\n            pt_dict = st_dict['state_dict']\n        else:\n            # legacy mode\n            pt_dict = st_dict\n        all_pt_keys = list(pt_dict.keys())\n        if not load_last:\n            # Get rid of last layer params (fc output in D)\n            allowed_keys = all_pt_keys[:-2]\n        else:\n            allowed_keys = all_pt_keys[:]\n        # Filter unnecessary keys from loaded ones and those not existing\n        pt_dict = {k: v for k, v in pt_dict.items() if k in model_dict and \\\n                   k in allowed_keys and v.size() == model_dict[k].size()}\n        print('Current Model keys: ', len(list(model_dict.keys())))\n        print('Loading Pt Model keys: ', len(list(pt_dict.keys())))\n        print('Loading matching keys: ', list(pt_dict.keys()))\n        if len(pt_dict.keys()) != len(model_dict.keys()):\n            print('WARNING: LOADING DIFFERENT NUM OF KEYS')\n        # overwrite entries in existing dict\n        model_dict.update(pt_dict)\n        # load the new state dict\n        self.model.load_state_dict(model_dict)\n        for k in model_dict.keys():\n            if k not in allowed_keys:\n                print('WARNING: {} weights not loaded from pt ckpt'.format(k))\n        if self.optimizer is not None and 'optimizer' in st_dict and load_opt:\n            self.optimizer.load_state_dict(st_dict['optimizer'])\n\n\nclass Model(nn.Module):\n\n    def __init__(self, name='BaseModel'):\n        super().__init__()\n        self.name = name\n        self.optim = None\n\n    def save(self, save_path, step, best_val=False, saver=None):\n        model_name = self.name\n\n        if not hasattr(self, 'saver') and saver is None:\n            self.saver = Saver(self, save_path,\n                               optimizer=self.optim,\n                               prefix=model_name + '-')\n\n        if saver is None:\n            self.saver.save(model_name, step, best_val=best_val)\n        else:\n            # save with specific saver\n            saver.save(model_name, step, best_val=best_val)\n\n    def load(self, save_path):\n        if os.path.isdir(save_path):\n            if not hasattr(self, 'saver'):\n                self.saver = Saver(self, save_path, \n                                   optimizer=self.optim,\n                                   prefix=model_name + '-')\n            self.saver.load_weights()\n        else:\n            print('Loading ckpt from ckpt: ', save_path)\n            # consider it as ckpt to load per-se\n            self.load_pretrained(save_path)\n\n    def load_pretrained(self, ckpt_path, load_last=False):\n        # tmp saver\n        saver = Saver(self, '.', optimizer=self.optim)\n        saver.load_pretrained_ckpt(ckpt_path, load_last)\n\n\n    def activation(self, name):\n        return getattr(nn, name)()\n\n    def parameters(self):\n        return filter(lambda p: p.requires_grad, super().parameters())\n\n\t# https://discuss.pytorch.org/t/how-do-i-check-the-number-of-parameters-of-a-model/4325/5\n    def get_n_params(self):\n        pp=0\n        for p in list(self.parameters()):\n            nn=1\n            for s in list(p.size()):\n                nn = nn*s\n            pp += nn\n        return pp \n\nclass LayerNorm(nn.Module):\n\n    def __init__(self, *args):\n        super().__init__()\n\n    def forward(self, activation):\n        if len(activation.size()) == 3:\n            ori_size = activation.size()\n            activation = activation.view(-1, activation.size(-1))\n        else:\n            ori_size = None\n        means = torch.mean(activation, dim=1, keepdim=True)\n        stds = torch.std(activation, dim=1, keepdim=True)\n        activation = (activation - means) / stds\n        if ori_size is not None:\n            activation = activation.view(ori_size)\n        return activation\n\n\nclass Conv1DResBlock(nn.Module):\n\n    def __init__(self, ninputs, fmaps, kwidth=3, \n                 dilations=[1, 2, 4, 8], stride=4, bias=True, \n                 transpose=False, act='prelu'):\n        super().__init__()\n        self.ninputs = ninputs\n        self.fmaps = fmaps\n        self.kwidth = kwidth\n        self.dilations = dilations\n        self.stride = stride\n        self.bias = bias\n        self.transpose = transpose\n        assert dilations[0] == 1, dilations[0]\n        assert len(dilations) > 1, len(dilations)\n        self.convs = nn.ModuleList()\n        self.acts = nn.ModuleList()\n        prev_in = ninputs\n        for n, d in enumerate(dilations):\n            if n == 0:\n                curr_stride = stride\n            else:\n                curr_stride = 1\n            if n == 0 or (n + 1) >= len(dilations):\n                # in the interfaces in/out it is different\n                curr_fmaps = fmaps\n            else:\n                curr_fmaps = fmaps // 4\n                # minimum is 1\n                curr_fmaps = max(curr_fmaps, 1)\n            if n == 0 and transpose:\n                p_ = (self.kwidth - 4)//2\n                op_ = 0\n                if p_ < 0:\n                    op_ = p_ * -1\n                    p_ = 0\n                self.convs.append(nn.ConvTranspose1d(prev_in, curr_fmaps, kwidth,\n                                                     stride=curr_stride,\n                                                     dilation=d, \n                                                     padding=p_,\n                                                     output_padding=op_,\n                                                     bias=bias))\n            else:\n                self.convs.append(nn.Conv1d(prev_in, curr_fmaps, kwidth,\n                                            stride=curr_stride,\n                                            dilation=d, \n                                            padding=0,\n                                            bias=bias))\n            self.acts.append(nn.PReLU(curr_fmaps))\n            prev_in = curr_fmaps\n\n    def forward(self, x):\n        h = x\n        res_act = None\n        for li, layer in enumerate(self.convs):\n            if self.stride > 1 and li == 0:\n                # add proper padding\n                pad_tuple = ((self.kwidth//2)-1, self.kwidth//2)\n            else:\n                # symmetric padding\n                p_ = ((self.kwidth - 1) * self.dilations[li]) // 2\n                pad_tuple = (p_, p_)\n            #print('Applying pad tupple: ', pad_tuple)\n            if not (self.transpose and li == 0):\n                h = F.pad(h, pad_tuple)\n            #print('Layer {}'.format(li))\n            #print('h padded: ', h.size())\n            h = layer(h)\n            h = self.acts[li](h)\n            if li == 0:\n                # keep the residual activation\n                res_act = h\n            #print('h min: ', h.min())\n            #print('h max: ', h.max())\n            #print('h conved size: ', h.size())\n        # add the residual activation in the output of the module\n        return h + res_act\n\ndef pos_code(chunk_pos, x):\n    # positional code\n    pos_dim = x.size(1)\n    chunk_size = x.size(2)\n    bsz = x.size(0)\n    pe = torch.zeros(x.size(0), chunk_size, pos_dim)\n    for n in range(bsz):\n        cpos = chunk_pos[n].item()\n        position = torch.arange(chunk_size * cpos,\n                                chunk_size * cpos + chunk_size)\n        position = position.unsqueeze(1)\n        div_term = torch.exp(torch.arange(0, pos_dim, 2) *\n            -(math.log(10000.0) / pos_dim))\n        pe[n, :, 0::2] = torch.sin(position * div_term)\n        pe[n, :, 1::2] = torch.cos(position * div_term)\n    pe = pe.transpose(1, 2)\n    if x.is_cuda:\n        pe = pe.to('cuda')\n    x = x + pe\n    return x\n\n"""
segan/models/discriminator.py,22,"b'import torch\nimport torch.nn as nn\nimport random\nimport torch.nn.utils as nnu\nimport torch.nn.functional as F\nfrom collections import OrderedDict\ntry:\n    from core import Model, LayerNorm\n    from modules import *\nexcept ImportError:\n    from .core import Model, LayerNorm\n    from .modules import *\n\n# BEWARE: PyTorch >= 0.4.1 REQUIRED\nfrom torch.nn.utils.spectral_norm import spectral_norm\n\n#class BiDiscriminator(Model):\n#    """""" Branched discriminator for input and conditioner """"""\n#    def __init__(self, fmaps, kwidth, activation,\n#                 bnorm=False, pooling=2, SND=False, \n#                 dropout=0):\n#        super().__init__(name=\'BiDiscriminator\')\n#        self.disc_in = nn.ModuleList()\n#        self.disc_cond = nn.ModuleList()\n#        for d_i, d_fmap in enumerate(fmaps):\n#            if d_i == 0:\n#                inp = 1\n#            else:\n#                inp = fmaps[d_i - 1]\n#            self.disc_in.append(DiscBlock(inp, kwidth, d_fmap,\n#                                          activation, bnorm,\n#                                          pooling, SND, dropout))\n#            self.disc_cond.append(DiscBlock(inp, kwidth, d_fmap,\n#                                            activation, bnorm,\n#                                            pooling, SND, dropout))\n#        self.bili = nn.Linear(8 * fmaps[-1], 8 * fmaps[-1], bias=True)\n#        if SND:\n#            self.bili = spectral_norm(self.bili)\n#\n#    def forward(self, x):\n#        x = torch.chunk(x, 2, dim=1)\n#        hin = x[0]\n#        hcond = x[1]\n#        # store intermediate activations\n#        int_act = {}\n#        for ii, (in_layer, cond_layer) in enumerate(zip(self.disc_in,\n#                                                        self.disc_cond)):\n#            hin = in_layer(hin)\n#            int_act[\'hin_{}\'.format(ii)] = hin\n#            hcond = cond_layer(hcond)\n#            int_act[\'hcond_{}\'.format(ii)] = hcond\n#        hin = hin.view(hin.size(0), -1)\n#        hcond = hcond.view(hin.size(0), -1)\n#        bilinear_h = self.bili(hcond)\n#        int_act[\'bilinear_h\'] = bilinear_h\n#        bilinear_out = torch.bmm(hin.unsqueeze(1),\n#                                 bilinear_h.unsqueeze(2)).squeeze(-1)\n#        norm1 = torch.norm(bilinear_h.data)\n#        norm2 = torch.norm(hin.data)\n#        bilinear_out = bilinear_out / max(norm1, norm2)\n#        int_act[\'logit\'] = bilinear_out\n#        #return F.sigmoid(bilinear_out), bilinear_h, hin, int_act\n#        return bilinear_out, bilinear_h, hin, int_act\n\nclass Discriminator(Model):\n    \n    def __init__(self, ninputs, fmaps,\n                 kwidth, poolings,\n                 pool_type=\'none\',\n                 pool_slen=None,\n                 norm_type=\'bnorm\',\n                 bias=True,\n                 phase_shift=None, \n                 sinc_conv=False):\n        super().__init__(name=\'Discriminator\')\n        # phase_shift randomly occurs within D layers\n        # as proposed in https://arxiv.org/pdf/1802.04208.pdf\n        # phase shift has to be specified as an integer\n        self.phase_shift = phase_shift\n        if phase_shift is not None:\n            assert isinstance(phase_shift, int), type(phase_shift)\n            assert phase_shift > 1, phase_shift\n        if pool_slen is None:\n            raise ValueError(\'Please specify D network pool seq len \'\n                             \'(pool_slen) in the end of the conv \'\n                             \'stack: [inp_len // (total_pooling_factor)]\')\n        ninp = ninputs\n        # SincNet as proposed in \n        # https://arxiv.org/abs/1808.00158\n        if sinc_conv:\n            # build sincnet module as first layer\n            self.sinc_conv = SincConv(fmaps[0] // 2,\n                                      251, 16e3, padding=\'SAME\')\n            inp = fmaps[0]\n            fmaps = fmaps[1:]\n        self.enc_blocks = nn.ModuleList()\n        for pi, (fmap, pool) in enumerate(zip(fmaps,\n                                              poolings),\n                                          start=1):\n            enc_block = GConv1DBlock(\n                ninp, fmap, kwidth, stride=pool,\n                bias=bias,\n                norm_type=norm_type\n            )\n            self.enc_blocks.append(enc_block)\n            ninp = fmap\n        self.pool_type = pool_type\n        if pool_type == \'none\':\n            # resize tensor to fit into FC directly\n            pool_slen *= fmaps[-1]\n            self.fc = nn.Sequential(\n                nn.Linear(pool_slen, 256),\n                nn.PReLU(256),\n                nn.Linear(256, 128),\n                nn.PReLU(128),\n                nn.Linear(128, 1)\n            )\n            if norm_type == \'snorm\':\n                torch.nn.utils.spectral_norm(self.fc[0])\n                torch.nn.utils.spectral_norm(self.fc[2])\n                torch.nn.utils.spectral_norm(self.fc[3])\n        elif pool_type == \'conv\':\n            self.pool_conv = nn.Conv1d(fmaps[-1], 1, 1)\n            self.fc = nn.Linear(pool_slen, 1)\n            if norm_type == \'snorm\':\n                torch.nn.utils.spectral_norm(self.pool_conv)\n                torch.nn.utils.spectral_norm(self.fc)\n        elif pool_type == \'gmax\':\n            self.gmax = nn.AdaptiveMaxPool1d(1)\n            self.fc = nn.Linear(fmaps[-1], 1, 1)\n            if norm_type == \'snorm\':\n                torch.nn.utils.spectral_norm(self.fc)\n        elif pool_type == \'gavg\':\n            self.gavg = nn.AdaptiveAvgPool1d(1)\n            self.fc = nn.Linear(fmaps[-1], 1, 1)\n            if norm_type == \'snorm\':\n                torch.nn.utils.spectral_norm(self.fc)\n        elif pool_type == \'mlp\':\n            self.mlp = nn.Sequential(\n                nn.Conv1d(fmaps[-1], fmaps[-1], 1),\n                nn.PReLU(fmaps[-1]),\n                nn.Conv1d(fmaps[-1], 1, 1)\n            )\n            if norm_type == \'snorm\':\n                torch.nn.utils.spectral_norm(self.mlp[0])\n                torch.nn.utils.spectral_norm(self.mlp[1])\n        else:\n            raise TypeError(\'Unrecognized pool type: \', pool_type)\n    \n    def forward(self, x):\n        h = x\n        if hasattr(self, \'sinc_conv\'):\n            h_l, h_r = torch.chunk(h, 2, dim=1)\n            h_l = self.sinc_conv(h_l)\n            h_r = self.sinc_conv(h_r)\n            h = torch.cat((h_l, h_r), dim=1)\n        # store intermediate activations\n        int_act = {}\n        for ii, layer in enumerate(self.enc_blocks):\n            if self.phase_shift is not None:\n                shift = random.randint(1, self.phase_shift)\n                # 0.5 chance of shifting right or left\n                right = random.random() > 0.5\n                # split tensor in time dim (dim 2)\n                if right:\n                    sp1 = h[:, :, :-shift]\n                    sp2 = h[:, :, -shift:]\n                    h = torch.cat((sp2, sp1), dim=2)\n                else:\n                    sp1 = h[:, :, :shift]\n                    sp2 = h[:, :, shift:]\n                    h = torch.cat((sp2, sp1), dim=2)\n            h = layer(h)\n            int_act[\'h_{}\'.format(ii)] = h\n        if self.pool_type == \'conv\':\n            h = self.pool_conv(h)\n            h = h.view(h.size(0), -1)\n            int_act[\'avg_conv_h\'] = h\n            y = self.fc(h)\n        elif self.pool_type == \'none\':\n            h = h.view(h.size(0), -1)\n            y = self.fc(h)\n        elif self.pool_type == \'gmax\':\n            h = self.gmax(h)\n            h = h.view(h.size(0), -1)\n            y = self.fc(h)\n        elif self.pool_type == \'gavg\':\n            h = self.gavg(h)\n            h = h.view(h.size(0), -1)\n            y = self.fc(h)\n        elif self.pool_type == \'mlp\':\n            y = self.mlp(h)\n        int_act[\'logit\'] = y\n        return y, int_act\n\n\nif __name__ == \'__main__\':\n    # pool_slen = 16 because we have input len 16384\n    # and we perform 5 pooling layers of 4, so 16384 // (4 ** 5) = 16\n    disc = Discriminator(2, [64, 128, 256, 512, 1024],\n                         31, [4] * 5, pool_type=\'none\',\n                         pool_slen=16)\n    print(disc)\n    print(\'Num params: \', disc.get_n_params())\n    x = torch.randn(1, 2, 16384)\n    y, _ = disc(x)\n    print(y)\n    print(\'x size: {} -> y size: {}\'.format(x.size(), y.size()))\n'"
segan/models/generator.py,25,"b'import torch\nfrom torch.autograd import Variable\nimport torch.nn.functional as F\nimport torch.nn.utils as nnu\nimport torch.nn as nn\nimport random\nimport numpy as np\ntry:\n    from core import *\n    from modules import *\nexcept ImportError:\n    from .core import *\n    from .modules import *\n\n# BEWARE: PyTorch >= 0.4.1 REQUIRED\nfrom torch.nn.utils.spectral_norm import spectral_norm\n\nclass GSkip(nn.Module):\n\n    def __init__(self, skip_type, size, skip_init, skip_dropout=0,\n                 merge_mode=\'sum\', kwidth=11, bias=True):\n        # skip_init only applies to alpha skips\n        super().__init__()\n        self.merge_mode = merge_mode\n        if skip_type == \'alpha\' or skip_type == \'constant\':\n            if skip_init == \'zero\':\n                alpha_ = torch.zeros(size)\n            elif skip_init == \'randn\':\n                alpha_ = torch.randn(size)\n            elif skip_init == \'one\':\n                alpha_ = torch.ones(size)\n            else:\n                raise TypeError(\'Unrecognized alpha init scheme: \', \n                                skip_init)\n            #if cuda:\n            #    alpha_ = alpha_.cuda()\n            if skip_type == \'alpha\':\n                self.skip_k = nn.Parameter(alpha_.view(1, -1, 1))\n            else:\n                # constant, not learnable\n                self.skip_k = nn.Parameter(alpha_.view(1, -1, 1))\n                self.skip_k.requires_grad = False\n        elif skip_type == \'conv\':\n            if kwidth > 1:\n                pad = kwidth // 2\n            else:\n                pad = 0\n            self.skip_k = nn.Conv1d(size, size, kwidth, stride=1,\n                                    padding=pad, bias=bias)\n        else:\n            raise TypeError(\'Unrecognized GSkip scheme: \', skip_type)\n        self.skip_type = skip_type\n        if skip_dropout > 0:\n            self.skip_dropout = nn.Dropout(skip_dropout)\n\n    def __repr__(self):\n        if self.skip_type == \'alpha\':\n            return self._get_name() + \'(Alpha(1))\'\n        elif self.skip_type == \'constant\':\n            return self._get_name() + \'(Constant(1))\'\n        else:\n            return super().__repr__()\n\n    def forward(self, hj, hi):\n        if self.skip_type == \'conv\':\n            sk_h = self.skip_k(hj)\n        else:\n            skip_k = self.skip_k.repeat(hj.size(0), 1, hj.size(2))\n            sk_h =  skip_k * hj\n        if hasattr(self, \'skip_dropout\'):\n            sk_h = self.skip_dropout(sk_h)\n        if self.merge_mode == \'sum\':\n            # merge with input hi on current layer\n            return sk_h + hi\n        elif self.merge_mode == \'concat\':\n            return torch.cat((hi, sk_h), dim=1)\n        else:\n            raise TypeError(\'Unrecognized skip merge mode: \', self.merge_mode)\n\nclass Generator(Model):\n\n    def __init__(self, ninputs, fmaps,\n                 kwidth, poolings, \n                 dec_fmaps=None,\n                 dec_kwidth=None,\n                 dec_poolings=None,\n                 z_dim=None,\n                 no_z=False,\n                 skip=True,\n                 bias=False,\n                 skip_init=\'one\',\n                 skip_dropout=0,\n                 skip_type=\'alpha\',\n                 norm_type=None,\n                 skip_merge=\'sum\',\n                 skip_kwidth=11,\n                 name=\'Generator\'):\n        super().__init__(name=name)\n        self.skip = skip\n        self.bias = bias\n        self.no_z = no_z\n        self.z_dim = z_dim\n        self.enc_blocks = nn.ModuleList()\n        assert isinstance(fmaps, list), type(fmaps)\n        assert isinstance(poolings, list), type(poolings)\n        if isinstance(kwidth, int): \n            kwidth = [kwidth] * len(fmaps)\n        assert isinstance(kwidth, list), type(kwidth)\n        skips = {}\n        ninp = ninputs\n        for pi, (fmap, pool, kw) in enumerate(zip(fmaps, poolings, kwidth),\n                                              start=1):\n            if skip and pi < len(fmaps):\n                # Make a skip connection for all but last hidden layer\n                gskip = GSkip(skip_type, fmap,\n                              skip_init,\n                              skip_dropout,\n                              merge_mode=skip_merge,\n                              kwidth=skip_kwidth,\n                              bias=bias)\n                l_i = pi - 1\n                skips[l_i] = {\'alpha\':gskip}\n                setattr(self, \'alpha_{}\'.format(l_i), skips[l_i][\'alpha\'])\n            enc_block = GConv1DBlock(\n                ninp, fmap, kw, stride=pool, bias=bias,\n                norm_type=norm_type\n            )\n            self.enc_blocks.append(enc_block)\n            ninp = fmap\n\n        self.skips = skips\n        if not no_z and z_dim is None:\n            z_dim = fmaps[-1]\n        if not no_z:\n            ninp += z_dim\n        # Ensure we have fmaps, poolings and kwidth ready to decode\n        if dec_fmaps is None:\n            dec_fmaps = fmaps[::-1][1:] + [1]\n        else:\n            assert isinstance(dec_fmaps, list), type(dec_fmaps)\n        if dec_poolings is None:\n            dec_poolings = poolings[:]\n        else:\n            assert isinstance(dec_poolings, list), type(dec_poolings)\n        self.dec_poolings = dec_poolings\n        if dec_kwidth is None:\n            dec_kwidth = kwidth[:]\n        else:\n            if isinstance(dec_kwidth, int): \n                dec_kwidth = [dec_kwidth] * len(dec_fmaps)\n        assert isinstance(dec_kwidth, list), type(dec_kwidth)\n        # Build the decoder\n        self.dec_blocks = nn.ModuleList()\n        for pi, (fmap, pool, kw) in enumerate(zip(dec_fmaps, dec_poolings, \n                                                  dec_kwidth),\n                                              start=1):\n            if skip and pi > 1 and pool > 1:\n                if skip_merge == \'concat\':\n                    ninp *= 2\n\n            if pi >= len(dec_fmaps):\n                act = \'Tanh\'\n            else:\n                act = None\n            if pool > 1:\n                dec_block = GDeconv1DBlock(\n                    ninp, fmap, kw, stride=pool,\n                    norm_type=norm_type, bias=bias,\n                    act=act\n                )\n            else:\n                dec_block = GConv1DBlock(\n                    ninp, fmap, kw, stride=1, \n                    bias=bias,\n                    norm_type=norm_type\n                )\n            self.dec_blocks.append(dec_block)\n            ninp = fmap\n\n    def forward(self, x, z=None, ret_hid=False):\n        hall = {}\n        hi = x\n        skips = self.skips\n        for l_i, enc_layer in enumerate(self.enc_blocks):\n            hi, linear_hi = enc_layer(hi, True)\n            #print(\'ENC {} hi size: {}\'.format(l_i, hi.size()))\n                    #print(\'Adding skip[{}]={}, alpha={}\'.format(l_i,\n                    #                                            hi.size(),\n                    #                                            hi.size(1)))\n            if self.skip and l_i < (len(self.enc_blocks) - 1):\n                skips[l_i][\'tensor\'] = linear_hi\n            if ret_hid:\n                hall[\'enc_{}\'.format(l_i)] = hi\n        if not self.no_z:\n            if z is None:\n                # make z \n                z = torch.randn(hi.size(0), self.z_dim, *hi.size()[2:])\n                if hi.is_cuda:\n                    z = z.to(\'cuda\')\n            if len(z.size()) != len(hi.size()):\n                raise ValueError(\'len(z.size) {} != len(hi.size) {}\'\n                                 \'\'.format(len(z.size()), len(hi.size())))\n            if not hasattr(self, \'z\'):\n                self.z = z\n            hi = torch.cat((z, hi), dim=1)\n            if ret_hid:\n                hall[\'enc_zc\'] = hi\n        else:\n            z = None\n        enc_layer_idx = len(self.enc_blocks) - 1\n        for l_i, dec_layer in enumerate(self.dec_blocks):\n            if self.skip and enc_layer_idx in self.skips and \\\n            self.dec_poolings[l_i] > 1:\n                skip_conn = skips[enc_layer_idx]\n                #hi = self.skip_merge(skip_conn, hi)\n                #print(\'Merging  hi {} with skip {} of hj {}\'.format(hi.size(),\n                #                                                    l_i,\n                #                                                    skip_conn[\'tensor\'].size()))\n                hi = skip_conn[\'alpha\'](skip_conn[\'tensor\'], hi)\n            #print(\'DEC in size after skip and z_all: \', hi.size())\n            #print(\'decoding layer {} with input {}\'.format(l_i, hi.size()))\n            hi = dec_layer(hi)\n            #print(\'decoding layer {} output {}\'.format(l_i, hi.size()))\n            enc_layer_idx -= 1\n            if ret_hid:\n                hall[\'dec_{}\'.format(l_i)] = hi\n        if ret_hid:\n            return hi, hall\n        else:\n            return hi\n\nclass Generator1D(Model):\n\n    def __init__(self, ninputs, enc_fmaps, kwidth,\n                 activations, lnorm=False, dropout=0.,\n                 pooling=2, z_dim=256, z_all=False,\n                 skip=True, skip_blacklist=[],\n                 dec_activations=None, cuda=False,\n                 bias=False, aal=False, wd=0.,\n                 skip_init=\'one\', skip_dropout=0.,\n                 no_tanh=False, aal_out=False,\n                 rnn_core=False, linterp=False,\n                 mlpconv=False, dec_kwidth=None,\n                 no_z=False,\n                 skip_type=\'alpha\', \n                 num_spks=None, multilayer_out=False,\n                 skip_merge=\'sum\', snorm=False,\n                 convblock=False, post_skip=False,\n                 pos_code=False, satt=False,\n                 dec_fmaps=None, up_poolings=None,\n                 post_proc=False, out_gate=False, \n                 linterp_mode=\'linear\', hidden_comb=False, \n                 big_out_filter=False, z_std=1,\n                 freeze_enc=False, skip_kwidth=11,\n                 pad_type=\'constant\'):\n        # if num_spks is specified, do onehot coditioners in dec stages\n        # subract_mean: from output signal, get rif of mean by windows\n        # multilayer_out: add some convs in between gblocks in decoder\n        super().__init__(name=\'Generator1D\')\n        self.dec_kwidth = dec_kwidth\n        self.skip_kwidth = skip_kwidth\n        self.skip = skip\n        self.skip_init = skip_init\n        self.skip_dropout = skip_dropout\n        self.snorm = snorm\n        self.z_dim = z_dim\n        self.z_all = z_all\n        self.pos_code = pos_code\n        self.post_skip = post_skip\n        self.big_out_filter = big_out_filter\n        self.satt = satt\n        self.post_proc = post_proc\n        self.pad_type = pad_type\n        self.onehot = num_spks is not None\n        if self.onehot:\n            assert num_spks > 0\n        self.num_spks = num_spks\n        # do not place any z\n        self.no_z = no_z\n        self.do_cuda = cuda\n        self.wd = wd\n        self.no_tanh = no_tanh\n        self.skip_blacklist = skip_blacklist\n        self.z_std = z_std\n        self.freeze_enc = freeze_enc\n        self.gen_enc = nn.ModuleList()\n        if aal or aal_out:\n            # Make cheby1 filter to include into pytorch conv blocks\n            from scipy.signal import cheby1, dlti, dimpulse\n            system = dlti(*cheby1(8, 0.05, 0.8 / pooling))\n            tout, yout = dimpulse(system)\n            filter_h = yout[0]\n        if aal:\n            self.filter_h = filter_h\n        else:\n            self.filter_h = None\n\n        if dec_kwidth is None:\n            dec_kwidth = kwidth\n\n        if isinstance(activations, str):\n            if activations != \'glu\':\n                activations = getattr(nn, activations)()\n        if not isinstance(activations, list):\n            activations = [activations] * len(enc_fmaps)\n        if not isinstance(pooling, list) or len(pooling) == 1: \n            pooling = [pooling] * len(enc_fmaps)\n        skips = {}\n        # Build Encoder\n        for layer_idx, (fmaps, pool, act) in enumerate(zip(enc_fmaps, \n                                                           pooling,\n                                                           activations)):\n            if layer_idx == 0:\n                inp = ninputs\n            else:\n                inp = enc_fmaps[layer_idx - 1]\n            if self.skip and layer_idx < (len(enc_fmaps) - 1):\n                if layer_idx not in self.skip_blacklist:\n                    l_i = layer_idx\n                    gskip = GSkip(skip_type, fmaps,\n                                  skip_init,\n                                  skip_dropout,\n                                  merge_mode=skip_merge,\n                                  cuda=self.do_cuda,\n                                  kwidth=self.skip_kwidth)\n                    skips[l_i] = {\'alpha\':gskip}\n                    setattr(self, \'alpha_{}\'.format(l_i), skips[l_i][\'alpha\'])\n            self.gen_enc.append(GBlock(inp, fmaps, kwidth, act,\n                                       padding=None, lnorm=lnorm, \n                                       dropout=dropout, pooling=pool,\n                                       enc=True, bias=bias, \n                                       aal_h=self.filter_h,\n                                       snorm=snorm, convblock=convblock,\n                                       satt=self.satt,\n                                       pad_type=pad_type))\n        self.skips = skips\n        dec_inp = enc_fmaps[-1]\n        if dec_fmaps is None:\n            if mlpconv:\n                dec_fmaps = enc_fmaps[:-1][::-1] + [16, 8, 1]\n                print(dec_fmaps)\n                up_poolings = [pooling] * (len(dec_fmaps) - 2) + [1] * 3\n                add_activations = [nn.PReLU(16), nn.PReLU(8), nn.PReLU(1)]\n                raise NotImplementedError(\'MLPconv is not useful and should be\'\n                                          \' deleted\')\n            else:\n                dec_fmaps = enc_fmaps[:-1][::-1] + [1]\n                up_poolings = pooling[::-1]\n                #up_poolings = [pooling] * len(dec_fmaps)\n            print(\'up_poolings: \', up_poolings)\n            self.up_poolings = up_poolings\n        else:\n            assert up_poolings is not None\n            self.up_poolings = up_poolings\n        if rnn_core:\n            self.z_all = False\n            z_all = False\n            # place a bidirectional RNN layer in the core to condition\n            # everything to everything AND Z will be the init state of it\n            self.rnn_core = nn.LSTM(dec_inp, dec_inp // 2, bidirectional=True,\n                                    batch_first=True)\n        else:\n            if no_z:\n                all_z = False\n            else:\n                dec_inp += z_dim\n        #print(dec_fmaps)\n        # Build Decoder\n        self.gen_dec = nn.ModuleList()\n\n        if dec_activations is None:\n            # assign same activations as in Encoder\n            dec_activations = [activations[0]] * len(dec_fmaps)\n        else:\n            if mlpconv:\n                dec_activations = dec_activations[:-1]\n                dec_activations += add_activations\n        \n        enc_layer_idx = len(enc_fmaps) - 1\n        for layer_idx, (fmaps, act) in enumerate(zip(dec_fmaps, \n                                                     dec_activations)):\n            if skip and layer_idx > 0 and enc_layer_idx not in skip_blacklist \\\n                and up_poolings[layer_idx] > 1: \n                if skip_merge == \'concat\':\n                    dec_inp *= 2\n                print(\'Added skip conn input of enc idx: {} and size:\'\n                      \' {}\'.format(enc_layer_idx, dec_inp))\n\n            if z_all and layer_idx > 0:\n                dec_inp += z_dim\n\n            if self.onehot:\n                dec_inp += self.num_spks\n\n            if layer_idx >= len(dec_fmaps) - 1:\n                if self.no_tanh:\n                    act = None\n                else:\n                    act = nn.Tanh()\n                lnorm = False\n                dropout = 0\n            if up_poolings[layer_idx] > 1:\n                pooling = up_poolings[layer_idx]\n                self.gen_dec.append(GBlock(dec_inp,\n                                           fmaps, dec_kwidth, act, \n                                           padding=0, \n                                           lnorm=lnorm,\n                                           dropout=dropout, pooling=pooling, \n                                           enc=False,\n                                           bias=bias,\n                                           linterp=linterp, \n                                           linterp_mode=linterp_mode,\n                                           convblock=convblock, \n                                           comb=hidden_comb,\n                                           pad_type=pad_type))\n            else:\n                self.gen_dec.append(GBlock(dec_inp,\n                                           fmaps, dec_kwidth, act, \n                                           lnorm=lnorm,\n                                           dropout=dropout, pooling=1,\n                                           padding=0,#kwidth//2,\n                                           enc=True,\n                                           bias=bias,\n                                           convblock=convblock,\n                                           pad_type=pad_type))\n            dec_inp = fmaps\n        if aal_out:\n            # make AAL filter to put in output\n            self.aal_out = nn.Conv1d(1, 1, filter_h.shape[0] + 1,\n                                     stride=1, \n                                     padding=filter_h.shape[0] // 2,\n                                     bias=False)\n            print(\'filter_h shape: \', filter_h.shape)\n            # apply AAL weights, reshaping impulse response to match\n            # in channels and out channels\n            aal_t = torch.FloatTensor(filter_h).view(1, 1, -1)\n            aal_t = torch.cat((aal_t, torch.zeros(1, 1, 1)), dim=-1)\n            self.aal_out.weight.data = aal_t\n            print(\'aal_t size: \', aal_t.size())\n\n        if post_proc:\n            self.comb_net = PostProcessingCombNet(1, 512)\n        if out_gate:\n            self.out_gate = OutGate(1, 1)\n        if big_out_filter:\n            self.out_filter = nn.Conv1d(1, 1, 513, padding=513//2)\n\n        \n\n    def forward(self, x, z=None, ret_hid=False, spkid=None, \n                slice_idx=0, att_weight=0):\n        if self.num_spks is not None and spkid is None:\n            raise ValueError(\'Please specify spk ID to network to \'\n                             \'build OH identifier in decoder\')\n\n        hall = {}\n        hi = x\n        skips = self.skips\n        for l_i, enc_layer in enumerate(self.gen_enc):\n            hi, linear_hi = enc_layer(hi, att_weight=att_weight)\n            #print(\'ENC {} hi size: {}\'.format(l_i, hi.size()))\n                    #print(\'Adding skip[{}]={}, alpha={}\'.format(l_i,\n                    #                                            hi.size(),\n                    #                                            hi.size(1)))\n            if self.skip and l_i < (len(self.gen_enc) - 1):\n                if l_i not in self.skip_blacklist:\n                    if self.post_skip:\n                        skips[l_i][\'tensor\'] = hi\n                    else:\n                        skips[l_i][\'tensor\'] = linear_hi\n            if ret_hid:\n                hall[\'enc_{}\'.format(l_i)] = hi\n        if hasattr(self, \'rnn_core\'):\n            self.z_all = False\n            if z is None:\n                # make z as initial RNN state forward and backward\n                # (2 directions)\n                if self.no_z:\n                    # MAKE DETERMINISTIC ZERO\n                    h0 = Variable(torch.zeros(2, hi.size(0), hi.size(1)//2))\n                else:\n                    h0 = Variable(self.z_std * torch.randn(2, \n                                                           hi.size(0), \n                                                           hi.size(1)//2))\n                c0 = Variable(torch.zeros(2, hi.size(0), hi.size(1)//2))\n                if self.do_cuda:\n                    h0 = h0.cuda()\n                    c0 = c0.cuda()\n                z = (h0, c0)\n                if not hasattr(self, \'z\'):\n                    self.z = z\n            # Conv --> RNN\n            hi = hi.transpose(1, 2)\n            hi, state = self.rnn_core(hi, z)\n            # RNN --> Conv\n            hi = hi.transpose(1, 2)\n        else:\n            if not self.no_z:\n                if z is None:\n                    # make z \n                    z = Variable(self.z_std * torch.randn(hi.size(0), self.z_dim,\n                                                         *hi.size()[2:]))\n                if len(z.size()) != len(hi.size()):\n                    raise ValueError(\'len(z.size) {} != len(hi.size) {}\'\n                                     \'\'.format(len(z.size()), len(hi.size())))\n                if self.do_cuda:\n                    z = z.cuda()\n                if not hasattr(self, \'z\'):\n                    self.z = z\n                #print(\'Concating z {} and hi {}\'.format(z.size(),\n                #                                        hi.size()))\n                hi = torch.cat((z, hi), dim=1)\n                if ret_hid:\n                    hall[\'enc_zc\'] = hi\n            else:\n                z = None\n            if self.pos_code:\n                hi = pos_code(slice_idx, hi)\n        # Cut gradient flow in Encoder?\n        if self.freeze_enc:\n            hi = hi.detach()\n        #print(\'Concated hi|z size: \', hi.size())\n        enc_layer_idx = len(self.gen_enc) - 1\n        z_up = z\n        if self.onehot:\n            # make one hot identifier batch\n            spk_oh = Variable(torch.zeros(spkid.size(0), \n                                          self.num_spks))\n            for bidx in range(spkid.size(0)):\n                if len(spkid.size()) == 3:\n                    spk_id = spkid[bidx, 0].cpu().data[0]\n                else:\n                    spk_id = spkid[bidx].cpu().data[0]\n                spk_oh[bidx, spk_id] = 1\n            spk_oh = spk_oh.view(spk_oh.size(0), -1, 1)\n            if self.do_cuda:\n                spk_oh = spk_oh.cuda()\n            # Now one-hot is [B, SPKS, 1] ready to be \n            # repeated to [B, SPKS, T] depending on layer\n        for l_i, dec_layer in enumerate(self.gen_dec):\n            if self.skip and enc_layer_idx in self.skips and \\\n            self.up_poolings[l_i] > 1:\n                skip_conn = skips[enc_layer_idx]\n                #hi = self.skip_merge(skip_conn, hi)\n                #print(\'Merging  hi {} with skip {} of hj {}\'.format(hi.size(),\n                #                                                    l_i,\n                #                                                    skip_conn[\'tensor\'].size()))\n                hi = skip_conn[\'alpha\'](skip_conn[\'tensor\'], hi)\n            if l_i > 0 and self.z_all:\n                # concat z in every layer\n                z_up = torch.cat((z_up, z_up), dim=2)\n                hi = torch.cat((hi, z_up), dim=1)\n            if self.onehot:\n                # repeat one-hot in time to adjust to concat\n                spk_oh_r = spk_oh.repeat(1, 1, hi.size(-1))\n                # concat in depth (channels)\n                hi = torch.cat((hi, spk_oh_r), dim=1)\n            #print(\'DEC in size after skip and z_all: \', hi.size())\n            #print(\'decoding layer {} with input {}\'.format(l_i, hi.size()))\n            hi, _ = dec_layer(hi, att_weight=att_weight)\n            #print(\'decoding layer {} output {}\'.format(l_i, hi.size()))\n            enc_layer_idx -= 1\n            if ret_hid:\n                hall[\'dec_{}\'.format(l_i)] = hi\n        if hasattr(self, \'aal_out\'):\n            hi = self.aal_out(hi)\n        if hasattr(self, \'comb_net\'):\n            hi = F.tanh(self.comb_net(hi))\n        if hasattr(self, \'out_gate\'):\n            hi = self.out_gate(hi)\n        if hasattr(self, \'out_filter\'):\n            hi = self.out_filter(hi)\n        # normalize G output in range within [-1, 1]\n        #hi = self.batch_minmax_norm(hi)\n        if ret_hid:\n            return hi, hall\n        else:\n            return hi\n\n    def batch_minmax_norm(self, x, out_min=-1, out_max=1):\n        mins = torch.min(x, dim=2)[0]\n        maxs = torch.max(x, dim=2)[0]\n        R = (out_max - out_min) / (maxs - mins)\n        R = R.unsqueeze(1)\n        #print(\'R size: \', R.size())\n        #print(\'x size: \', x.size())\n        #print(\'mins size: \', mins.size())\n        x = R * (x - mins.unsqueeze(1)) + out_min\n        #print(\'norm x size: \', x.size())\n        return x\n\n    def skip_merge(self, skip_conn, hi):\n        # TODO: DEPRECATED WITH NEW SKIP SCHEME\n        raise NotImplementedError\n        hj = skip_conn[\'tensor\']\n        alpha = skip_conn[\'alpha\'].view(1, -1, 1)\n        alpha = alpha.repeat(hj.size(0), 1, hj.size(2))\n        #print(\'hi: \', hi.size())\n        #print(\'hj: \', hj.size())\n        #print(\'alpha: \', alpha.size())\n        #print(\'alpha: \', alpha)\n        if \'dropout\' in skip_conn:\n            alpha = skip_conn[\'dropout\'](alpha)\n            #print(\'alpha: \', alpha)\n        return hi + alpha * hj\n        \nif __name__ == \'__main__\':\n    """"""\n    G = Generator1D(1, [64, 128, 256, 512, 1024], \n                    31, \n                    \'ReLU\',\n                    lnorm=False, \n                    pooling=4,\n                    z_dim=1024,\n                    skip_init=\'randn\',\n                    skip_type=\'alpha\',\n                    skip_blacklist=[],\n                    bias=False, cuda=False,\n                    rnn_core=False, linterp=False,\n                    dec_kwidth=31)\n    """"""\n    G = Generator(1, [64, 128, 256, 512, 1024],\n                  kwidth=31,\n                  poolings=[4, 4, 4, 4, 4], no_z=True)\n    print(G)\n    print(\'G num params: \', G.get_n_params())\n    x = torch.randn(1, 1, 16384)\n    y, hall = G(x, ret_hid=True)\n    print(y)\n    print(x.size())\n    print(y.size())\n    #import matplotlib\n    #matplotlib.use(\'Agg\')\n    #import matplotlib.pyplot as plt\n    #plt.imshow(hall[\'att\'].data[0, :, :].numpy())\n    #plt.savefig(\'att_test.png\', dpi=200)\n'"
segan/models/model.py,38,"b'import torch\nimport torch.nn as nn\nfrom random import shuffle\nimport torch.optim as optim\nimport torch.nn.functional as F\nimport torchvision.utils as vutils\nfrom torch.optim import lr_scheduler\nfrom ..datasets import *\nfrom ..utils import *\nfrom .ops import *\nfrom scipy.io import wavfile\nimport multiprocessing as mp\nimport numpy as np\nimport timeit\nimport random\nfrom random import shuffle\nfrom tensorboardX import SummaryWriter\nfrom .generator import *\nfrom .discriminator import *\nfrom .core import *\nimport json\nimport os\nfrom torch import autograd\nfrom scipy import signal\n\n\n# custom weights initialization called on netG and netD\ndef weights_init(m):\n    classname = m.__class__.__name__\n    if classname.find(\'Conv1DResBlock\') != -1:\n        print(\'Initializing weights of convresblock to 0.0, 0.02\')\n        for k, p in m.named_parameters():\n            if \'weight\' in k and \'conv\' in k:\n                p.data.normal_(0.0, 0.02)\n    elif classname.find(\'Conv1d\') != -1:\n        print(\'Initialzing weight to 0.0, 0.02 for module: \', m)\n        m.weight.data.normal_(0.0, 0.02)\n        if hasattr(m, \'bias\') and m.bias is not None:\n            print(\'bias to 0 for module: \', m)\n            m.bias.data.fill_(0)\n    elif classname.find(\'Linear\') != -1:\n        print(\'Initializing FC weight to xavier uniform\')\n        nn.init.xavier_uniform_(m.weight.data)\n\ndef wsegan_weights_init(m):\n    classname = m.__class__.__name__\n    if classname.find(\'Conv1DResBlock\') != -1:\n        print(\'Initializing weights of convresblock to 0.0, 0.02\')\n        for k, p in m.named_parameters():\n            if \'weight\' in k and \'conv\' in k:\n                nn.init.xavier_uniform_(p.data)\n    elif classname.find(\'Conv1d\') != -1:\n        print(\'Initialzing weight to XU for module: \', m)\n        nn.init.xavier_uniform_(m.weight.data)\n    elif classname.find(\'ConvTranspose1d\') != -1:\n        print(\'Initialzing weight to XU for module: \', m)\n        nn.init.xavier_uniform_(m.weight.data)\n    elif classname.find(\'Linear\') != -1:\n        print(\'Initializing FC weight to XU\')\n        nn.init.xavier_uniform_(m.weight.data)\n\ndef z_dropout(m):\n    classname = m.__class__.__name__\n    if classname.find(\'Dropout\') != -1:\n        # let it active\n        m.train()\n    else:\n        m.eval()\n\n\nclass SEGAN(Model):\n\n    def __init__(self, opts, name=\'SEGAN\',\n                 generator=None,\n                 discriminator=None):\n        super(SEGAN, self).__init__(name)\n        self.save_path = opts.save_path\n        self.preemph = opts.preemph\n        self.reg_loss = getattr(F, opts.reg_loss)\n        if generator is None:\n            # Build G and D\n            self.G = Generator(1,\n                               opts.genc_fmaps,\n                               opts.gkwidth,\n                               opts.genc_poolings,\n                               opts.gdec_fmaps,\n                               opts.gdec_kwidth,\n                               opts.gdec_poolings,\n                               z_dim=opts.z_dim,\n                               no_z=opts.no_z,\n                               skip=(not opts.no_skip),\n                               bias=opts.bias,\n                               skip_init=opts.skip_init,\n                               skip_type=opts.skip_type,\n                               skip_merge=opts.skip_merge,\n                               skip_kwidth=opts.skip_kwidth)\n        else:\n            self.G = generator\n        self.G.apply(weights_init)\n        print(\'Generator: \', self.G)\n\n        if discriminator is None:\n            dkwidth = opts.gkwidth if opts.dkwidth is None else opts.dkwidth\n            self.D = Discriminator(2, opts.denc_fmaps, dkwidth,\n                                   poolings=opts.denc_poolings,\n                                   pool_type=opts.dpool_type,\n                                   pool_slen=opts.dpool_slen, \n                                   norm_type=opts.dnorm_type,\n                                   phase_shift=opts.phase_shift,\n                                   sinc_conv=opts.sinc_conv)\n        else:\n            self.D = discriminator\n        self.D.apply(weights_init)\n        print(\'Discriminator: \', self.D)\n\n    def generate(self, inwav, z = None, device=\'cpu\'):\n        self.G.eval()\n        N = 16384\n        x = np.zeros((1, 1, N))\n        c_res = None\n        slice_idx = torch.zeros(1)\n        for beg_i in range(0, inwav.shape[2], N):\n            if inwav.shape[2] - beg_i < N:\n                length = inwav.shape[2] - beg_i\n                pad = N - length\n            else:\n                length = N\n                pad = 0\n            if pad  > 0:\n                x[0, 0] = torch.cat((inwav[0, 0, beg_i:beg_i + length],\n                                    torch.zeros(pad).to(device)), dim=0)\n            else:\n                x[0, 0] = inwav[0, 0, beg_i:beg_i + length]\n            #x = torch.FloatTensor(x)\n            if isinstance(x, np.ndarray):\n                x = torch.FloatTensor(x)\n            x = x.to(device)\n            canvas_w, hall = self.infer_G(x, z=z, ret_hid=True)\n            nums = []\n            for k in hall.keys():\n                if \'enc\' in k and \'zc\' not in k:\n                    nums.append(int(k.split(\'_\')[1]))\n            g_c = hall[\'enc_{}\'.format(max(nums))]\n            if z is None and hasattr(self.G, \'z\'):\n                # if z was created inside G as first inference\n                z = self.G.z\n            if pad > 0:\n                canvas_w = canvas_w[0, 0, :-pad]\n            canvas_w = canvas_w.data.cpu().numpy().squeeze()\n            if c_res is None:\n                c_res = canvas_w\n            else:\n                c_res = np.concatenate((c_res, canvas_w))\n            slice_idx += 1\n        # de-emph\n        c_res = de_emphasize(c_res, self.preemph)\n        return c_res, g_c\n\n    def discriminate(self, cwav, nwav):\n        self.D.eval()\n        d_in = torch.cat((cwav, nwav), dim=1)\n        d_veredict, _ = self.D(d_in)\n        return d_veredict\n\n    def infer_G(self, nwav, cwav=None, z=None, ret_hid=False):\n        if ret_hid:\n            Genh, hall = self.G(nwav, z=z, ret_hid=ret_hid)\n            return Genh, hall\n        else:\n            Genh = self.G(nwav, z=z, ret_hid=ret_hid)\n            return Genh\n\n    def infer_D(self, x_, ref):\n        D_in = torch.cat((x_, ref), dim=1)\n        return self.D(D_in)\n\n    def gen_train_samples(self, clean_samples, noisy_samples, z_sample, \n                          iteration=None):\n        if z_sample is not None:\n            canvas_w = self.infer_G(noisy_samples, clean_samples, z=z_sample)\n        else:\n            canvas_w = self.infer_G(noisy_samples, clean_samples)\n        sample_dif = noisy_samples - clean_samples\n        # sample wavs\n        for m in range(noisy_samples.size(0)):\n            m_canvas = de_emphasize(canvas_w[m,\n                                             0].cpu().data.numpy(),\n                                    self.preemph)\n            print(\'w{} max: {} min: {}\'.format(m,\n                                               m_canvas.max(),\n                                               m_canvas.min()))\n            wavfile.write(os.path.join(self.save_path,\n                                       \'sample_{}-\'\n                                       \'{}.wav\'.format(iteration,\n                                                       m)),\n                          int(16e3), m_canvas)\n            m_clean = de_emphasize(clean_samples[m,\n                                                 0].cpu().data.numpy(),\n                                   self.preemph)\n            m_noisy = de_emphasize(noisy_samples[m,\n                                                 0].cpu().data.numpy(),\n                                   self.preemph)\n            m_dif = de_emphasize(sample_dif[m,\n                                            0].cpu().data.numpy(),\n                                 self.preemph)\n            m_gtruth_path = os.path.join(self.save_path,\n                                         \'gtruth_{}.wav\'.format(m))\n            if not os.path.exists(m_gtruth_path):\n                wavfile.write(os.path.join(self.save_path,\n                                           \'gtruth_{}.wav\'.format(m)),\n                              int(16e3), m_clean)\n                wavfile.write(os.path.join(self.save_path,\n                                           \'noisy_{}.wav\'.format(m)),\n                              int(16e3), m_noisy)\n                wavfile.write(os.path.join(self.save_path,\n                                           \'dif_{}.wav\'.format(m)),\n                              int(16e3), m_dif)\n\n    def build_optimizers(self, opts):\n        if opts.opt == \'rmsprop\':\n            Gopt = optim.RMSprop(self.G.parameters(), lr=opts.g_lr)\n            Dopt = optim.RMSprop(self.D.parameters(), lr=opts.d_lr)\n        elif opts.opt == \'adam\':\n            Gopt = optim.Adam(self.G.parameters(), lr=opts.g_lr, betas=(0, 0.9))\n            Dopt = optim.Adam(self.D.parameters(), lr=opts.d_lr, betas=(0, 0.9))\n        else:\n            raise ValueError(\'Unrecognized optimizer {}\'.format(opts.opt))\n        return Gopt, Dopt\n\n    def train(self, opts, dloader, criterion, l1_init, l1_dec_step,\n              l1_dec_epoch, log_freq, va_dloader=None,\n              device=\'cpu\'):\n        """""" Train the SEGAN """"""\n\n        # create writer\n        self.writer = SummaryWriter(os.path.join(self.save_path, \'train\'))\n\n        # Build the optimizers\n        Gopt, Dopt = self.build_optimizers(opts)\n\n        # attach opts to models so that they are saved altogether in ckpts\n        self.G.optim = Gopt\n        self.D.optim = Dopt\n        \n        # Build savers for end of epoch, storing up to 3 epochs each\n        eoe_g_saver = Saver(self.G, opts.save_path, max_ckpts=3,\n                            optimizer=self.G.optim, prefix=\'EOE_G-\')\n        eoe_d_saver = Saver(self.D, opts.save_path, max_ckpts=3,\n                            optimizer=self.D.optim, prefix=\'EOE_D-\')\n        num_batches = len(dloader) \n        l1_weight = l1_init\n        iteration = 1\n        timings = []\n        evals = {}\n        noisy_evals = {}\n        noisy_samples = None\n        clean_samples = None\n        z_sample = None\n        patience = opts.patience\n        best_val_obj = 0\n        # acumulator for exponential avg of valid curve\n        acum_val_obj = 0\n        # make label tensor\n        label = torch.ones(opts.batch_size)\n        label = label.to(device)\n\n        for epoch in range(1, opts.epoch + 1):\n            beg_t = timeit.default_timer()\n            self.G.train()\n            self.D.train()\n            for bidx, batch in enumerate(dloader, start=1):\n                if epoch >= l1_dec_epoch:\n                    if l1_weight > 0:\n                        l1_weight -= l1_dec_step\n                        # ensure it is 0 if it goes < 0\n                        l1_weight = max(0, l1_weight)\n                sample = batch\n                if len(sample) == 4:\n                    uttname, clean, noisy, slice_idx = batch\n                else:\n                    raise ValueError(\'Returned {} elements per \'\n                                     \'sample?\'.format(len(sample)))\n                clean = clean.unsqueeze(1)\n                noisy = noisy.unsqueeze(1)\n                label.resize_(clean.size(0)).fill_(1)\n                clean = clean.to(device)\n                noisy = noisy.to(device)\n                if noisy_samples is None:\n                    noisy_samples = noisy[:20, :, :].contiguous()\n                    clean_samples = clean[:20, :, :].contiguous()\n                # (1) D real update\n                Dopt.zero_grad()\n                total_d_fake_loss = 0\n                total_d_real_loss = 0\n                Genh = self.infer_G(noisy, clean)\n                lab = label\n                d_real, _ = self.infer_D(clean, noisy)\n                d_real_loss = criterion(d_real.view(-1), lab)\n                d_real_loss.backward()\n                total_d_real_loss += d_real_loss\n                \n                # (2) D fake update\n                d_fake, _ = self.infer_D(Genh.detach(), noisy)\n                lab = label.fill_(0)\n                d_fake_loss = criterion(d_fake.view(-1), lab)\n                d_fake_loss.backward()\n                total_d_fake_loss += d_fake_loss\n                Dopt.step()\n\n                d_loss = d_fake_loss + d_real_loss \n\n                # (3) G real update\n                Gopt.zero_grad()\n                lab = label.fill_(1)\n                d_fake_, _ = self.infer_D(Genh, noisy)\n                g_adv_loss = criterion(d_fake_.view(-1), lab)\n                #g_l1_loss = l1_weight * F.l1_loss(Genh, clean)\n                g_l1_loss = l1_weight * self.reg_loss(Genh, clean)\n                g_loss = g_adv_loss + g_l1_loss\n                g_loss.backward()\n                Gopt.step()\n                end_t = timeit.default_timer()\n                timings.append(end_t - beg_t)\n                beg_t = timeit.default_timer()\n                if z_sample is None and not self.G.no_z:\n                    # capture sample now that we know shape after first\n                    # inference\n                    z_sample = self.G.z[:20, :, :].contiguous()\n                    print(\'z_sample size: \', z_sample.size())\n                    z_sample = z_sample.to(device)\n                if bidx % log_freq == 0 or bidx >= len(dloader):\n                    d_real_loss_v = d_real_loss.cpu().item()\n                    d_fake_loss_v = d_fake_loss.cpu().item()\n                    g_adv_loss_v = g_adv_loss.cpu().item()\n                    g_l1_loss_v = g_l1_loss.cpu().item()\n                    log = \'(Iter {}) Batch {}/{} (Epoch {}) d_real:{:.4f}, \' \\\n                          \'d_fake:{:.4f}, \'.format(iteration, bidx,\n                                                   len(dloader), epoch,\n                                                   d_real_loss_v,\n                                                   d_fake_loss_v)\n                    log += \'g_adv:{:.4f}, g_l1:{:.4f} \' \\\n                           \'l1_w: {:.2f}, \'\\\n                           \'btime: {:.4f} s, mbtime: {:.4f} s\' \\\n                           \'\'.format(g_adv_loss_v,\n                                     g_l1_loss_v,\n                                     l1_weight, \n                                     timings[-1],\n                                     np.mean(timings))\n                    print(log)\n                    self.writer.add_scalar(\'D_real\', d_real_loss_v,\n                                           iteration)\n                    self.writer.add_scalar(\'D_fake\', d_fake_loss_v,\n                                           iteration)\n                    self.writer.add_scalar(\'G_adv\', g_adv_loss_v,\n                                           iteration)\n                    self.writer.add_scalar(\'G_l1\', g_l1_loss_v,\n                                           iteration)\n                    self.writer.add_histogram(\'D_fake__hist\', d_fake_.cpu().data,\n                                              iteration, bins=\'sturges\')\n                    self.writer.add_histogram(\'D_fake_hist\', d_fake.cpu().data,\n                                              iteration, bins=\'sturges\')\n                    self.writer.add_histogram(\'D_real_hist\', d_real.cpu().data,\n                                              iteration, bins=\'sturges\')\n                    self.writer.add_histogram(\'Gz\', Genh.cpu().data,\n                                              iteration, bins=\'sturges\')\n                    self.writer.add_histogram(\'clean\', clean.cpu().data,\n                                              iteration, bins=\'sturges\')\n                    self.writer.add_histogram(\'noisy\', noisy.cpu().data,\n                                              iteration, bins=\'sturges\')\n                    # get D and G weights and plot their norms by layer and\n                    # global\n                    def model_weights_norm(model, total_name):\n                        total_GW_norm = 0\n                        for k, v in model.named_parameters():\n                            if \'weight\' in k:\n                                W = v.data\n                                W_norm = torch.norm(W)\n                                self.writer.add_scalar(\'{}_Wnorm\'.format(k),\n                                                       W_norm,\n                                                       iteration)\n                                total_GW_norm += W_norm\n                        self.writer.add_scalar(\'{}_Wnorm\'.format(total_name),\n                                               total_GW_norm,\n                                               iteration)\n                    model_weights_norm(self.G, \'Gtotal\')\n                    model_weights_norm(self.D, \'Dtotal\')\n                    if not opts.no_train_gen:\n                        #canvas_w = self.G(noisy_samples, z=z_sample)\n                        self.gen_train_samples(clean_samples, noisy_samples,\n                                               z_sample,\n                                               iteration=iteration)\n                iteration += 1\n\n            if va_dloader is not None:\n                if len(noisy_evals) == 0:\n                    evals_, noisy_evals_ = self.evaluate(opts, va_dloader, \n                                                         log_freq, do_noisy=True)\n                    for k, v in noisy_evals_.items():\n                        if k not in noisy_evals:\n                            noisy_evals[k] = []\n                        noisy_evals[k] += v\n                        self.writer.add_scalar(\'noisy-{}\'.format(k), \n                                               noisy_evals[k][-1], epoch)\n                else:\n                    evals_ = self.evaluate(opts, va_dloader, \n                                           log_freq, do_noisy=False)\n                for k, v in evals_.items():\n                    if k not in evals:\n                        evals[k] = []\n                    evals[k] += v\n                    self.writer.add_scalar(\'Genh-{}\'.format(k), \n                                           evals[k][-1], epoch)\n                val_obj = evals[\'covl\'][-1] + evals[\'pesq\'][-1] + \\\n                        evals[\'ssnr\'][-1]\n                self.writer.add_scalar(\'Genh-val_obj\',\n                                       val_obj, epoch)\n                if val_obj > best_val_obj:\n                    print(\'Val obj (COVL + SSNR + PESQ) improved \'\n                          \'{} -> {}\'.format(best_val_obj,\n                                            val_obj))\n                    best_val_obj = val_obj\n                    patience = opts.patience\n                    # save models with true valid curve is minimum\n                    self.G.save(self.save_path, iteration, True)\n                    self.D.save(self.save_path, iteration, True)\n                else:\n                    patience -= 1\n                    print(\'Val loss did not improve. Patience\'\n                          \'{}/{}\'.format(patience,\n                                         opts.patience))\n                    if patience <= 0:\n                        print(\'STOPPING SEGAN TRAIN: OUT OF PATIENCE.\')\n                        break\n\n            # save models in end of epoch with EOE savers\n            self.G.save(self.save_path, iteration, saver=eoe_g_saver)\n            self.D.save(self.save_path, iteration, saver=eoe_d_saver)\n\n\n    def evaluate(self, opts, dloader, log_freq, do_noisy=False,\n                 max_samples=1, device=\'cpu\'):\n        """""" Objective evaluation with PESQ, SSNR, COVL, CBAK and CSIG """"""\n        self.G.eval()\n        self.D.eval()\n        evals = {\'pesq\':[], \'ssnr\':[], \'csig\':[],\n                 \'cbak\':[], \'covl\':[]}\n        pesqs = []\n        ssnrs = []\n        if do_noisy:\n            noisy_evals = {\'pesq\':[], \'ssnr\':[], \'csig\':[],\n                           \'cbak\':[], \'covl\':[]}\n            npesqs = []\n            nssnrs = []\n        if not hasattr(self, \'pool\'):\n            self.pool = mp.Pool(opts.eval_workers)\n        total_s = 0\n        timings = []\n        with torch.no_grad():\n            # going over dataset ONCE\n            for bidx, batch in enumerate(dloader, start=1):\n                sample = batch\n                if len(sample) == 4:\n                    uttname, clean, noisy, slice_idx = batch\n                else:\n                    raise ValueError(\'Returned {} elements per \'\n                                     \'sample?\'.format(len(sample)))\n                clean = clean\n                noisy = noisy.unsqueeze(1)\n                clean = clean.to(device)\n                noisy = noisy.to(device)\n                Genh = self.infer_G(noisy).squeeze(1)\n                clean_npy = clean.cpu().data.numpy()\n                Genh_npy = Genh.cpu().data.numpy()\n                clean_npy = np.apply_along_axis(de_emphasize, 0, clean_npy,\n                                                self.preemph)\n                Genh_npy = np.apply_along_axis(de_emphasize, 0, Genh_npy,\n                                                self.preemph)\n                beg_t = timeit.default_timer()\n                if do_noisy:\n                    noisy_npy = noisy.cpu().data.numpy()\n                    noisy_npy = np.apply_along_axis(de_emphasize, 0, noisy_npy,\n                                                    self.preemph)\n                    args = [(clean_npy[i], Genh_npy[i], noisy_npy[i]) for i in \\\n                            range(clean.size(0))]\n                else:\n                    args = [(clean_npy[i], Genh_npy[i], None) for i in \\\n                            range(clean.size(0))]\n                map_ret = self.pool.map(composite_helper, args)\n                end_t = timeit.default_timer()\n                print(\'Time to process eval with {} samples \' \\\n                      \': {} s\'.format(clean.size(0), end_t - beg_t))\n                if bidx >= max_samples:\n                    break\n\n            def fill_ret_dict(ret_dict, in_dict):\n                for k, v in in_dict.items():\n                    ret_dict[k].append(v)\n\n            if do_noisy:\n                for eval_, noisy_eval_ in map_ret:\n                    fill_ret_dict(evals, eval_)\n                    fill_ret_dict(noisy_evals, noisy_eval_)\n                return evals, noisy_evals\n            else:\n                for eval_ in map_ret:\n                    fill_ret_dict(evals, eval_)\n                return evals\n\nclass WSEGAN(SEGAN):\n\n    def __init__(self, opts, name=\'WSEGAN\',\n                 generator=None,\n                 discriminator=None):\n        self.lbd = 1\n        self.critic_iters = 1\n        self.misalign_pair = opts.misalign_pair\n        self.interf_pair = opts.interf_pair\n        self.pow_weight = opts.pow_weight\n        self.vanilla_gan = opts.vanilla_gan\n        self.n_fft = opts.n_fft\n        super(WSEGAN, self).__init__(opts, name, \n                                     None, None)\n        self.G.apply(wsegan_weights_init)\n        self.D.apply(wsegan_weights_init)\n\n    def sample_dloader(self, dloader, device=\'cpu\'):\n        sample = next(dloader.__iter__())\n        batch = sample\n        uttname, clean, noisy, slice_idx = batch\n        clean = clean.unsqueeze(1)\n        noisy = noisy.unsqueeze(1)\n        clean = clean.to(device)\n        noisy = noisy.to(device)\n        slice_idx = slice_idx.to(device)\n        return uttname, clean, noisy, slice_idx\n\n    def infer_G(self, nwav, cwav=None, z=None, ret_hid=False):\n        Genh = self.G(nwav, z=z, ret_hid=ret_hid)\n        return Genh\n\n    def train(self, opts, dloader, criterion, l1_init, l1_dec_step,\n              l1_dec_epoch, log_freq, va_dloader=None, device=\'cpu\'):\n\n        """""" Train the SEGAN """"""\n        # create writer\n        self.writer = SummaryWriter(os.path.join(opts.save_path, \'train\'))\n\n        # Build the optimizers\n        Gopt, Dopt = self.build_optimizers(opts)\n\n        # attach opts to models so that they are saved altogether in ckpts\n        self.G.optim = Gopt\n        self.D.optim = Dopt\n        \n        # Build savers for end of epoch, storing up to 3 epochs each\n        eoe_g_saver = Saver(self.G, opts.save_path, max_ckpts=3,\n                            optimizer=self.G.optim, prefix=\'EOE_G-\')\n        eoe_d_saver = Saver(self.D, opts.save_path, max_ckpts=3,\n                            optimizer=self.D.optim, prefix=\'EOE_D-\')\n        num_batches = len(dloader) \n        l1_weight = l1_init\n        iteration = 1\n        timings = []\n        evals = {}\n        noisy_evals = {}\n        noisy_samples = None\n        clean_samples = None\n        z_sample = None\n        patience = opts.patience\n        best_val_obj = np.inf\n\n        for iteration in range(1, opts.epoch * len(dloader) + 1):\n            beg_t = timeit.default_timer()\n            uttname, clean, noisy, slice_idx = self.sample_dloader(dloader,\n                                                                   device)\n            bsz = clean.size(0)\n            # grads\n            Dopt.zero_grad()\n            D_in = torch.cat((clean, noisy), dim=1)\n            d_real, _ = self.infer_D(clean, noisy)\n            rl_lab = torch.ones(d_real.size()).cuda()\n            if self.vanilla_gan:\n                cost = F.binary_cross_entropy_with_logits\n            else:\n                cost = F.mse_loss\n            d_real_loss = cost(d_real, rl_lab)\n            Genh = self.infer_G(noisy, clean)\n            fake = Genh.detach()\n            d_fake, _ = self.infer_D(fake, noisy)\n            fk_lab = torch.zeros(d_fake.size()).cuda()\n            \n            d_fake_loss = cost(d_fake, fk_lab)\n\n            d_weight = 0.5 # count only d_fake and d_real\n            d_loss = d_fake_loss + d_real_loss\n\n            if self.misalign_pair:\n                clean_shuf = list(torch.chunk(clean, clean.size(0), dim=0))\n                shuffle(clean_shuf)\n                clean_shuf = torch.cat(clean_shuf, dim=0)\n                d_fake_shuf, _ = self.infer_D(clean, clean_shuf)\n                d_fake_shuf_loss = cost(d_fake_shuf, fk_lab)\n                d_weight = 1 / 3 # count 3 components now\n                d_loss += d_fake_shuf_loss\n\n            if self.interf_pair:\n                # put interferring squared signals with random amplitude and\n                # freq as fake signals mixed with clean data\n                # TODO: Beware with hard-coded values! possibly improve this\n                freqs = [250, 1000, 4000]\n                amps = [0.01, 0.05, 0.1, 1]\n                bsz = clean.size(0)\n                squares = []\n                t = np.linspace(0, 2, 32000)\n                for _ in range(bsz):\n                    f_ = random.choice(freqs)\n                    a_ = random.choice(amps)\n                    sq = a_ * signal.square(2 * np.pi * f_ * t)\n                    sq = sq[:clean.size(-1)].reshape((1, -1))\n                    squares.append(torch.FloatTensor(sq))\n                squares = torch.cat(squares, dim=0).unsqueeze(1)\n                if clean.is_cuda:\n                    squares = squares.to(\'cuda\')\n                interf = clean + squares\n                d_fake_inter, _ = self.infer_D(interf, noisy)\n                d_fake_inter_loss = cost(d_fake_inter, fk_lab)\n                d_weight = 1 / 4 # count 4 components in d loss now\n                d_loss += d_fake_inter_loss\n\n            d_loss = d_weight * d_loss\n            d_loss.backward()\n            Dopt.step()\n\n            Gopt.zero_grad()\n            d_fake_, _ = self.infer_D(Genh, noisy)\n            g_adv_loss = cost(d_fake_, torch.ones(d_fake_.size()).cuda())\n\n            # POWER Loss -----------------------------------\n            # make stft of gtruth\n            clean_stft = torch.stft(clean.squeeze(1), \n                                    n_fft=min(clean.size(-1), self.n_fft), \n                                    hop_length=160,\n                                    win_length=320,\n                                    normalized=True)\n            clean_mod = torch.norm(clean_stft, 2, dim=3)\n            clean_mod_pow = 10 * torch.log10(clean_mod ** 2 + 10e-20)\n            Genh_stft = torch.stft(Genh.squeeze(1), \n                                   n_fft=min(Genh.size(-1), self.n_fft),\n                                   hop_length=160, \n                                   win_length=320, normalized=True)\n            Genh_mod = torch.norm(Genh_stft, 2, dim=3)\n            Genh_mod_pow = 10 * torch.log10(Genh_mod ** 2 + 10e-20)\n            pow_loss = self.pow_weight * F.l1_loss(Genh_mod_pow, clean_mod_pow)\n            G_cost = g_adv_loss + pow_loss\n            if l1_weight > 0:\n                # look for additive files to build batch mask\n                mask = torch.zeros(bsz, 1, Genh.size(2))\n                if opts.cuda:\n                    mask = mask.to(\'cuda\')\n                for utt_i, uttn in enumerate(uttname):\n                    if \'additive\' in uttn:\n                        mask[utt_i, 0, :] = 1.\n                den_loss = l1_weight * F.l1_loss(Genh * mask,\n                                                 clean * mask)\n                G_cost += den_loss\n            else:\n                den_loss = torch.zeros(1)\n            G_cost.backward()\n            Gopt.step()\n            end_t = timeit.default_timer()\n            timings.append(end_t - beg_t)\n            beg_t = timeit.default_timer()\n            if noisy_samples is None:\n                noisy_samples = noisy[:20, :, :].contiguous()\n                clean_samples = clean[:20, :, :].contiguous()\n            if z_sample is None and not self.G.no_z:\n                # capture sample now that we know shape after first\n                # inference\n                z_sample = self.G.z[:20, :, :].contiguous()\n                print(\'z_sample size: \', z_sample.size())\n                z_sample = z_sample.to(device)\n            if iteration % log_freq == 0:\n                log = \'Iter {}/{} ({} bpe) d_loss:{:.4f}, \' \\\n                      \'g_loss: {:.4f}, pow_loss: {:.4f}, \' \\\n                      \'den_loss: {:.4f} \' \\\n                      \'\'.format(iteration,\n                                len(dloader) * opts.epoch,\n                                len(dloader),\n                                d_loss.item(),\n                                G_cost.item(),\n                                pow_loss.item(),\n                                den_loss.item())\n\n                log += \'btime: {:.4f} s, mbtime: {:.4f} s\' \\\n                       \'\'.format(timings[-1],\n                                 np.mean(timings))\n                print(log)\n                self.writer.add_scalar(\'D_loss\', d_loss.item(),\n                                       iteration)\n                self.writer.add_scalar(\'G_loss\', G_cost.item(),\n                                       iteration)\n                self.writer.add_scalar(\'G_adv_loss\', g_adv_loss.item(),\n                                       iteration)\n                self.writer.add_scalar(\'G_pow_loss\', pow_loss.item(),\n                                       iteration)\n                self.writer.add_histogram(\'clean_mod_pow\',\n                                          clean_mod_pow.cpu().data,\n                                          iteration,\n                                          bins=\'sturges\')\n                self.writer.add_histogram(\'Genh_mod_pow\',\n                                          Genh_mod_pow.cpu().data,\n                                          iteration,\n                                          bins=\'sturges\')\n                self.writer.add_histogram(\'Gz\', Genh.cpu().data,\n                                          iteration, bins=\'sturges\')\n                self.writer.add_histogram(\'clean\', clean.cpu().data,\n                                          iteration, bins=\'sturges\')\n                self.writer.add_histogram(\'noisy\', noisy.cpu().data,\n                                          iteration, bins=\'sturges\')\n                if hasattr(self.G, \'skips\'):\n                    for skip_id, alpha in self.G.skips.items():\n                        skip = alpha[\'alpha\']\n                        if skip.skip_type == \'alpha\':\n                            self.writer.add_histogram(\'skip_alpha_{}\'.format(skip_id),\n                                                      skip.skip_k.data,\n                                                      iteration, \n                                                      bins=\'sturges\')\n                # get D and G weights and plot their norms by layer and global\n                def model_weights_norm(model, total_name):\n                    total_GW_norm = 0\n                    for k, v in model.named_parameters():\n                        if \'weight\' in k:\n                            W = v.data\n                            W_norm = torch.norm(W)\n                            self.writer.add_scalar(\'{}_Wnorm\'.format(k),\n                                                   W_norm,\n                                                   iteration)\n                            total_GW_norm += W_norm\n                    self.writer.add_scalar(\'{}_Wnorm\'.format(total_name),\n                                           total_GW_norm,\n                                           iteration)\n                model_weights_norm(self.G, \'Gtotal\')\n                model_weights_norm(self.D, \'Dtotal\')\n                if not opts.no_train_gen:\n                    self.gen_train_samples(clean_samples, noisy_samples,\n                                           z_sample,\n                                           iteration=iteration)\n                # BEWARE: There is no evaluation in Whisper SEGAN (WSEGAN)\n                # TODO: Perhaps add some MCD/F0 RMSE metric\n            if iteration % len(dloader) == 0:\n                # save models in end of epoch with EOE savers\n                self.G.save(self.save_path, iteration, saver=eoe_g_saver)\n                self.D.save(self.save_path, iteration, saver=eoe_d_saver)\n\n    def generate(self, inwav, z = None):\n        # simplified inference without chunking\n        #if self.z_dropout:\n        #    self.G.apply(z_dropout)\n        #else:\n        self.G.eval()\n        ori_len = inwav.size(2)\n        p_wav = make_divN(inwav.transpose(1, 2), 1024).transpose(1, 2)\n        c_res, hall = self.infer_G(p_wav, z=z, ret_hid=True)\n        c_res = c_res[0, 0, :ori_len].cpu().data.numpy()\n        c_res = de_emphasize(c_res, self.preemph)\n        return c_res, hall\n\n\nclass AEWSEGAN(WSEGAN):\n\n    """""" Auto-Encoder model """"""\n\n    def __init__(self, opts, name=\'AEWSEGAN\',\n                 generator=None,\n                 discriminator=None):\n        super().__init__(opts, name=name, generator=generator,\n                         discriminator=discriminator)\n        # delete discriminator\n        self.D = None\n\n    def train(self, opts, dloader, criterion, l1_init, l1_dec_step,\n              l1_dec_epoch, log_freq, va_dloader=None, device=\'cpu\'):\n\n        """""" Train the SEGAN """"""\n        # create writer\n        self.writer = SummaryWriter(os.path.join(opts.save_path, \'train\'))\n        if opts.opt == \'rmsprop\':\n            Gopt = optim.RMSprop(self.G.parameters(), lr=opts.g_lr)\n        elif opts.opt == \'adam\':\n            Gopt = optim.Adam(self.G.parameters(), lr=opts.g_lr, betas=(0.5,\n                                                                        0.9))\n        else:\n            raise ValueError(\'Unrecognized optimizer {}\'.format(opts.opt))\n\n        # attach opts to models so that they are saved altogether in ckpts\n        self.G.optim = Gopt\n        \n        # Build savers for end of epoch, storing up to 3 epochs each\n        eoe_g_saver = Saver(self.G, opts.save_path, max_ckpts=3,\n                            optimizer=self.G.optim, prefix=\'EOE_G-\')\n        num_batches = len(dloader) \n        l2_weight = l1_init\n        iteration = 1\n        timings = []\n        evals = {}\n        noisy_evals = {}\n        noisy_samples = None\n        clean_samples = None\n        z_sample = None\n        patience = opts.patience\n        best_val_obj = np.inf\n        # acumulator for exponential avg of valid curve\n        acum_val_obj = 0\n        G = self.G\n\n        for iteration in range(1, opts.epoch * len(dloader) + 1):\n            beg_t = timeit.default_timer()\n            uttname, clean, noisy, slice_idx = self.sample_dloader(dloader,\n                                                                   device)\n            bsz = clean.size(0)\n            Genh = self.infer_G(noisy, clean)\n            Gopt.zero_grad()\n            if self.l1_loss:\n                loss = F.l1_loss(Genh, clean)\n            else:\n                loss = F.mse_loss(Genh, clean)\n            loss.backward()\n            Gopt.step()\n            end_t = timeit.default_timer()\n            timings.append(end_t - beg_t)\n            beg_t = timeit.default_timer()\n            if noisy_samples is None:\n                noisy_samples = noisy[:20, :, :].contiguous()\n                clean_samples = clean[:20, :, :].contiguous()\n            if z_sample is None and not G.no_z:\n                # capture sample now that we know shape after first\n                # inference\n                z_sample = G.z[:20, :, :].contiguous()\n                print(\'z_sample size: \', z_sample.size())\n                z_sample = z_sample.to(device)\n            if iteration % log_freq == 0:\n                # POWER Loss (not used to backward) -----------------------------------\n                # make stft of gtruth\n                clean_stft = torch.stft(clean.squeeze(1), \n                                        n_fft=min(clean.size(-1), self.n_fft), \n                                        hop_length=160,\n                                        win_length=320,\n                                        normalized=True)\n                clean_mod = torch.norm(clean_stft, 2, dim=3)\n                clean_mod_pow = 10 * torch.log10(clean_mod ** 2 + 10e-20)\n                Genh_stft = torch.stft(Genh.detach().squeeze(1), \n                                       n_fft=min(Genh.size(-1), self.n_fft),\n                                       hop_length=160, \n                                       win_length=320, normalized=True)\n                Genh_mod = torch.norm(Genh_stft, 2, dim=3)\n                Genh_mod_pow = 10 * torch.log10(Genh_mod ** 2 + 10e-20)\n                pow_loss = F.l1_loss(Genh_mod_pow, clean_mod_pow)\n                log = \'Iter {}/{} ({} bpe) g_l2_loss:{:.4f}, \' \\\n                      \'pow_loss: {:.4f}, \' \\\n                      \'\'.format(iteration,\n                                len(dloader) * opts.epoch,\n                                len(dloader),\n                                loss.item(),\n                                pow_loss.item())\n\n                log += \'btime: {:.4f} s, mbtime: {:.4f} s\' \\\n                       \'\'.format(timings[-1],\n                                 np.mean(timings))\n                print(log)\n                self.writer.add_scalar(\'g_l2/l1_loss\', loss.item(),\n                                       iteration)\n                self.writer.add_scalar(\'G_pow_loss\', pow_loss.item(),\n                                       iteration)\n                self.writer.add_histogram(\'clean_mod_pow\',\n                                          clean_mod_pow.cpu().data,\n                                          iteration,\n                                          bins=\'sturges\')\n                self.writer.add_histogram(\'Genh_mod_pow\',\n                                          Genh_mod_pow.cpu().data,\n                                          iteration,\n                                          bins=\'sturges\')\n                self.writer.add_histogram(\'Gz\', Genh.cpu().data,\n                                          iteration, bins=\'sturges\')\n                self.writer.add_histogram(\'clean\', clean.cpu().data,\n                                          iteration, bins=\'sturges\')\n                self.writer.add_histogram(\'noisy\', noisy.cpu().data,\n                                          iteration, bins=\'sturges\')\n                if hasattr(G, \'skips\'):\n                    for skip_id, alpha in G.skips.items():\n                        skip = alpha[\'alpha\']\n                        if skip.skip_type == \'alpha\':\n                            self.writer.add_histogram(\'skip_alpha_{}\'.format(skip_id),\n                                                      skip.skip_k.data,\n                                                      iteration, \n                                                      bins=\'sturges\')\n                # get D and G weights and plot their norms by layer and global\n                def model_weights_norm(model, total_name):\n                    total_GW_norm = 0\n                    for k, v in model.named_parameters():\n                        if \'weight\' in k:\n                            W = v.data\n                            W_norm = torch.norm(W)\n                            self.writer.add_scalar(\'{}_Wnorm\'.format(k),\n                                                   W_norm,\n                                                   iteration)\n                            total_GW_norm += W_norm\n                    self.writer.add_scalar(\'{}_Wnorm\'.format(total_name),\n                                           total_GW_norm,\n                                           iteration)\n                #model_weights_norm(G, \'Gtotal\')\n                #model_weights_norm(D, \'Dtotal\')\n                if not opts.no_train_gen:\n                    #canvas_w = self.G(noisy_samples, z=z_sample)\n                    self.gen_train_samples(clean_samples, noisy_samples,\n                                           z_sample,\n                                           iteration=iteration)\n                if va_dloader is not None:\n                    if len(noisy_evals) == 0:\n                        sd, nsd = self.evaluate(opts, va_dloader,\n                                                log_freq, do_noisy=True)\n                        self.writer.add_scalar(\'noisy_SD\',\n                                               nsd, iteration)\n                    else:\n                        sd = self.evaluate(opts, va_dloader, \n                                           log_freq, do_noisy=False)\n                    self.writer.add_scalar(\'Genh_SD\',\n                                           sd, iteration)\n                    print(\'Eval SD: {:.3f} dB, NSD: {:.3f} dB\'.format(sd, nsd))\n                    if sd < best_val_obj:\n                        self.G.save(self.save_path, iteration, True)\n                        best_val_obj = sd\n            if iteration % len(dloader) == 0:\n                # save models in end of epoch with EOE savers\n                self.G.save(self.save_path, iteration, saver=eoe_g_saver)\n'"
segan/models/modules.py,23,"b'import torch\nimport torch.nn as nn\nimport math\nimport torch.nn.functional as F\nfrom torch.nn.utils.spectral_norm import spectral_norm\nimport numpy as np\n\n\ndef build_norm_layer(norm_type, param=None, num_feats=None):\n    if norm_type == \'bnorm\':\n        return nn.BatchNorm1d(num_feats)\n    elif norm_type == \'snorm\':\n        spectral_norm(param)\n        return None\n    elif norm_type is None:\n        return None\n    else:\n        raise TypeError(\'Unrecognized norm type: \', norm_type)\n\nclass ResBlock1D(nn.Module):\n\n    def __init__(self, num_inputs, hidden_size,\n                 kwidth, dilation=1, bias=True, norm_type=None,\n                 hid_act=nn.ReLU(inplace=True),\n                 out_act=None,\n                 skip_init=0):\n        super().__init__()\n        # first conv level to expand/compress features\n        self.entry_conv = nn.Conv1d(num_inputs, hidden_size, 1, bias=bias)\n        self.entry_norm = build_norm_layer(norm_type, self.entry_conv, hidden_size)\n        self.entry_act = hid_act\n        # second conv level to exploit temporal structure\n        self.mid_conv = nn.Conv1d(hidden_size, hidden_size, kwidth,\n                                  dilation=dilation, bias=bias)\n        self.mid_norm = build_norm_layer(norm_type, self.mid_conv, hidden_size)\n        self.mid_act = hid_act\n        # third conv level to expand/compress features back\n        self.exit_conv = nn.Conv1d(hidden_size, num_inputs, 1, bias=bias)\n        self.exit_norm = build_norm_layer(norm_type, self.exit_conv, num_inputs)\n        if out_act is None:\n            out_act = hid_act\n        self.exit_act = out_act\n        self.kwidth = kwidth\n        self.dilation = dilation\n        self.skip_alpha = nn.Parameter(torch.FloatTensor([skip_init]))\n\n    def forward_norm(self, x, norm_layer):\n        if norm_layer is not None:\n            return norm_layer(x)\n        else:\n            return x\n\n    def forward(self, x):\n        # entry level\n        h = self.entry_conv(x)\n        h = self.forward_norm(h, self.entry_norm)\n        h = self.entry_act(h)\n        # mid level\n        # first padding\n        kw_2 = self.kwidth // 2\n        P = kw_2 + kw_2 * (self.dilation - 1)\n        h_p = F.pad(h, (P, P), mode=\'reflect\')\n        h = self.mid_conv(h_p)\n        h = self.forward_norm(h, self.mid_norm)\n        h = self.mid_act(h)\n        # exit level\n        h = self.exit_conv(h)\n        h = self.forward_norm(h, self.exit_norm)\n        # skip connection + exit_act\n        y = self.exit_act(self.skip_alpha * x + h)\n        return y\n\nclass GConv1DBlock(nn.Module):\n\n    def __init__(self, ninp, fmaps,\n                 kwidth, stride=1, \n                 bias=True, norm_type=None):\n        super().__init__()\n        self.conv = nn.Conv1d(ninp, fmaps, kwidth, stride=stride, bias=bias)\n        self.norm = build_norm_layer(norm_type, self.conv, fmaps)\n        self.act = nn.PReLU(fmaps, init=0)\n        self.kwidth = kwidth\n        self.stride = stride\n\n    def forward_norm(self, x, norm_layer):\n        if norm_layer is not None:\n            return norm_layer(x)\n        else:\n            return x\n\n    def forward(self, x, ret_linear=False):\n        if self.stride > 1:\n            P = (self.kwidth // 2 - 1,\n                 self.kwidth // 2)\n        else:\n            P = (self.kwidth // 2,\n                 self.kwidth // 2)\n        x_p = F.pad(x, P, mode=\'reflect\')\n        a = self.conv(x_p)\n        a = self.forward_norm(a, self.norm)\n        h = self.act(a)\n        if ret_linear:\n            return h, a\n        else:\n            return h\n\nclass GDeconv1DBlock(nn.Module):\n\n    def __init__(self, ninp, fmaps,\n                 kwidth, stride=4, \n                 bias=True,\n                 norm_type=None,\n                 act=None):\n        super().__init__()\n        pad = max(0, (stride - kwidth)//-2)\n        self.deconv = nn.ConvTranspose1d(ninp, fmaps,\n                                         kwidth, \n                                         stride=stride,\n                                         padding=pad)\n        self.norm = build_norm_layer(norm_type, self.deconv,\n                                     fmaps)\n        if act is not None:\n            self.act = getattr(nn, act)()\n        else:\n            self.act = nn.PReLU(fmaps, init=0)\n        self.kwidth = kwidth\n        self.stride = stride\n\n    def forward_norm(self, x, norm_layer):\n        if norm_layer is not None:\n            return norm_layer(x)\n        else:\n            return x\n\n    def forward(self, x):\n        h = self.deconv(x)\n        if self.kwidth % 2 != 0:\n            h = h[:, :, :-1]\n        h = self.forward_norm(h, self.norm)\n        h = self.act(h)\n        return h\n\nclass ResARModule(nn.Module):\n\n    def __init__(self, ninp, fmaps,\n                 res_fmaps,\n                 kwidth, dilation,\n                 bias=True,\n                 norm_type=None,\n                 act=None):\n        super().__init__()\n        self.dil_conv = nn.Conv1d(ninp, fmaps,\n                                  kwidth, dilation=dilation,\n                                  bias=bias)\n        if act is not None:\n            self.act = getattr(nn, act)()\n        else:\n            self.act = nn.PReLU(fmaps, init=0)\n        self.dil_norm = build_norm_layer(norm_type, self.dil_conv,\n                                         fmaps)\n        self.kwidth = kwidth\n        self.dilation = dilation\n        # skip 1x1 convolution\n        self.conv_1x1_skip = nn.Conv1d(fmaps, ninp, 1, bias=bias)\n        self.conv_1x1_skip_norm = build_norm_layer(norm_type, \n                                                   self.conv_1x1_skip,\n                                                   ninp)\n        # residual 1x1 convolution\n        self.conv_1x1_res = nn.Conv1d(fmaps, res_fmaps, 1, bias=bias)\n        self.conv_1x1_res_norm = build_norm_layer(norm_type, \n                                                  self.conv_1x1_res,\n                                                  res_fmaps)\n\n    def forward_norm(self, x, norm_layer):\n        if norm_layer is not None:\n            return norm_layer(x)\n        else:\n            return x\n\n    def forward(self, x):\n        kw__1 = self.kwidth - 1\n        P = kw__1 + kw__1 * (self.dilation - 1)\n        # causal padding\n        x_p = F.pad(x, (P, 0))\n        # dilated conv\n        h = self.dil_conv(x_p)\n        # normalization if applies\n        h = self.forward_norm(h, self.dil_norm)\n        # activation\n        h = self.act(h)\n        a = h\n        # conv 1x1 to make residual connection\n        h = self.conv_1x1_skip(h)\n        # normalization if applies\n        h = self.forward_norm(h, self.conv_1x1_skip_norm)\n        # return with skip connection\n        y = x + h\n        # also return res connection (going to further net point directly)\n        sh = self.conv_1x1_res(a)\n        sh = self.forward_norm(sh, self.conv_1x1_res_norm)\n        return y, sh\n\n# SincNet conv layer\ndef flip(x, dim):\n    xsize = x.size()\n    dim = x.dim() + dim if dim < 0 else dim\n    x = x.contiguous()\n    x = x.view(-1, *xsize[dim:])\n    x = x.view(x.size(0), x.size(1), -1)[:, getattr(torch.arange(x.size(1)-1, \n                      -1, -1), (\'cpu\',\'cuda\')[x.is_cuda])().long(), :]\n    return x.view(xsize)\n\n\ndef sinc(band,t_right, cuda=False):\n    y_right= torch.sin(2*math.pi*band*t_right)/(2*math.pi*band*t_right)\n    y_left= flip(y_right,0)\n\n    ones = torch.ones(1)\n    if cuda:\n        ones = ones.to(\'cuda\')\n    y=torch.cat([y_left, ones, y_right])\n\n    return y\n    \n    \n# Modified from https://github.com/mravanelli/SincNet\nclass SincConv(nn.Module):\n\n    def __init__(self, N_filt, Filt_dim, fs,\n                 padding=\'VALID\'):\n        super(SincConv, self).__init__()\n\n        # Mel Initialization of the filterbanks\n        low_freq_mel = 80\n        high_freq_mel = (2595 * np.log10(1 + (fs / 2) \\\n                                         / 700))  # Convert Hz to Mel\n        mel_points = np.linspace(low_freq_mel, high_freq_mel, \n                                 N_filt)  # Equally spaced in Mel scale\n        f_cos = (700 * (10 ** (mel_points / 2595) - 1)) # Convert Mel to Hz\n        b1 = np.roll(f_cos, 1)\n        b2 = np.roll(f_cos, -1)\n        b1[0] = 30\n        b2[-1] = (fs / 2) - 100\n                \n        self.freq_scale=fs * 1.0\n        self.filt_b1 = nn.Parameter(torch.from_numpy(b1/self.freq_scale))\n        self.filt_band = nn.Parameter(torch.from_numpy((b2-b1)/self.freq_scale))\n\n        self.N_filt = N_filt\n        self.Filt_dim = Filt_dim\n        self.fs = fs\n        self.padding = padding\n        \n    def forward(self, x):\n        cuda = x.is_cuda\n        filters=torch.zeros((self.N_filt, self.Filt_dim))\n        N=self.Filt_dim\n        t_right=torch.linspace(1, (N - 1) / 2, \n                               steps=int((N - 1) / 2)) / self.fs\n        if cuda:\n            filters = filters.to(\'cuda\')\n            t_right = t_right.to(\'cuda\')\n        \n        min_freq=50.0;\n        min_band=50.0;\n        filt_beg_freq = torch.abs(self.filt_b1) + min_freq / self.freq_scale\n        filt_end_freq = filt_beg_freq + (torch.abs(self.filt_band) + \\\n                                         min_band / self.freq_scale)\n        n = torch.linspace(0, N, steps = N)\n        # Filter window (hamming)\n        window=(0.54 - 0.46 * torch.cos(2 * math.pi * n / N)).float()\n        if cuda:\n            window = window.to(\'cuda\')\n        for i in range(self.N_filt):\n            low_pass1 = 2 * filt_beg_freq[i].float()* \\\n                    sinc(filt_beg_freq[i].float() * self.freq_scale, \n                         t_right, cuda)\n            low_pass2 = 2 * filt_end_freq[i].float()* \\\n                    sinc(filt_end_freq[i].float() * self.freq_scale, \n                         t_right, cuda)\n            band_pass=(low_pass2 - low_pass1)\n            band_pass=band_pass/torch.max(band_pass)\n            if cuda:\n                band_pass = band_pass.to(\'cuda\')\n\n            filters[i,:]=band_pass * window\n        if self.padding == \'SAME\':\n            x_p = F.pad(x, (self.Filt_dim // 2,\n                            self.Filt_dim // 2), mode=\'reflect\')\n        else:\n            x_p = x\n        out = F.conv1d(x_p, filters.view(self.N_filt, 1, self.Filt_dim))\n        return out\n\nclass CombFilter(nn.Module):\n\n    def __init__(self, ninputs, fmaps, L):\n        super().__init__()\n        self.L = L\n        self.filt = nn.Conv1d(ninputs, fmaps, 2, dilation=L, bias=False)\n        r_init_weight = torch.ones(ninputs * fmaps, 2)\n        r_init_weight[:, 0] = torch.rand(r_init_weight.size(0))\n        self.filt.weight.data = r_init_weight.view(fmaps, ninputs, 2)\n\n    def forward(self, x):\n        x_p = F.pad(x, (self.L, 0))\n        y = self.filt(x_p)\n        return y\n\nclass PostProcessingCombNet(nn.Module):\n\n    def __init__(self, ninputs, fmaps, L=[4, 8, 16, 32]):\n        super().__init__()\n        filts = nn.ModuleList()\n        for l in L:\n            filt = CombFilter(ninputs, fmaps//len(L), l)\n            filts.append(filt)\n        self.filts = filts\n        self.W = nn.Linear(fmaps, 1, bias=False)\n\n    def forward(self, x):\n        hs = []\n        for filt in self.filts:\n            h = filt(x)\n            hs.append(h)\n            #print(\'Comb h: \', h.size())\n        hs = torch.cat(hs, dim=1)\n        #print(\'hs size: \', hs.size())\n        y = self.W(hs.transpose(1, 2)).transpose(1, 2)\n        return y\n\n\nif __name__ == \'__main__\':\n    """"""\n    import matplotlib\n    import matplotlib.pyplot as plt\n    import numpy as np\n    # 800 samples @ 16kHz is 50ms\n    T = 800\n    # n = 20 z time-samples per frame\n    n = 20\n    zgen = ZGen(n, T // n, \n                z_amp=0.5)\n    all_z = None\n    for t in range(0, 200, 5):\n        time_idx = torch.LongTensor([t])\n        z_ten = zgen(time_idx)\n        print(z_ten.size())\n        z_ten = z_ten.squeeze()\n        if all_z is None:\n            all_z = z_ten\n        else:\n            all_z = np.concatenate((all_z, z_ten), axis=1)\n    N = 20\n    for k in range(N):\n        plt.subplot(N, 1, k + 1)\n        plt.plot(all_z[k, :], label=k)\n        plt.ylabel(k)\n    plt.show()\n\n    # ResBlock\n    resblock = ResBlock1D(40, 100, 5, dilation=8)\n    print(resblock)\n    z = z_ten.unsqueeze(0)\n    print(\'Z size: \', z.size())\n    y = resblock(z)\n    print(\'Y size: \', y.size())\n\n    x = torch.randn(1, 1, 16) \n    deconv = GDeconv1DBlock(1, 1, 31)\n    y = deconv(x)\n    print(\'x: {} -> y: {} deconv\'.format(x.size(),\n                                         y.size()))\n    conv = GConv1DBlock(1, 1, 31, stride=4)\n    z = conv(y)\n    print(\'y: {} -> z: {} conv\'.format(y.size(),\n                                       z.size()))\n    """"""\n    x = torch.randn(1, 1, 16384)\n    sincnet = SincConv(1024, 251, 16000, padding=\'SAME\')\n    y = sincnet(x)\n    print(\'y size: \', y.size())\n\n\n\n'"
segan/models/ops.py,34,"b""import torch\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nfrom ahoproc_tools.io import *\nfrom ahoproc_tools.interpolate import *\nimport multiprocessing as mp\nfrom scipy.io import wavfile\nimport tempfile\nimport timeit\nimport glob\nimport os\n\nimport torch\nfrom torch.optim.optimizer import Optimizer, required\n\nfrom torch.autograd import Variable\nimport torch.nn.functional as F\nfrom torch import nn\nfrom torch import Tensor\nfrom torch.nn import Parameter\n\n\ndef get_grads(model):\n    grads = None\n    for i, (k, param) in enumerate(dict(model.named_parameters()).items()):\n        if param.grad is None:\n            print('WARNING getting grads: {} param grad is None'.format(k))\n            continue\n        if grads is None:\n            grads = param.grad.cpu().data.view((-1, ))\n        else:\n            grads = torch.cat((grads, param.grad.cpu().data.view((-1,))), dim=0)\n    return grads\n\ndef make_optimizer(otype, params, lr, step_lr=None, lr_gammma=None,\n                   adam_beta1=0.7, weight_decay=0.):\n    if otype == 'rmsprop':\n        opt = optim.RMSprop(params, lr=lr, \n                            weight_decay=weight_decay)\n    else:\n        opt = optim.Adam(params, lr=lr,\n                         betas=(adam_beta1, 0.9),\n                         weight_decay=weight_decay)\n    if step_lr is not None:\n        sched = lr_scheduler.StepLR(opt, step_lr, lr_gamma)\n    else:\n        sched = None\n    return opt, sched\n\n\ndef KLD(mean_p, std_p, mean_g, std_g):\n    # assumping 2 normal distributions with respective mean and stds\n    # log(var_g / var_p) + (var_p + (mean_p - mean_g)^2)/( 2*var_g) - 0.5\n    var_p = std_p ** 2\n    var_g = std_g ** 2\n    num = var_p + (mean_p - mean_g) ** 2\n    #print('mean_g: ', mean_g)\n    #print('mean_p: ', mean_p)\n    #print('std_g: ', std_g)\n    #print('std_p: ', std_p)\n    #print('var_g: ', var_g)\n    #print('var_p: ', var_p)\n    return torch.log(std_g / std_p + 1e-22) +  (num / (2 * var_g + 1e-22)) - 0.5 \n\ndef compute_MAE(v_lf0, v_ref_lf0, mask):\n    #if len(v_lf0.size()) == 2:\n    #    v_lf0 = v_lf0.view(-1)\n    #    v_ref_lf0 = v_ref_lf0.view(-1)\n    #return torch.mean(torch.abs(torch.exp(v_lf0) - torch.exp(v_ref_lf0)))\n    print(mask.size())\n    print(v_lf0.size())\n    print(v_ref_lf0.size())\n    if mask.size(1) > v_lf0.size(1):\n        mask = mask[:, :v_lf0.size(1)]\n        v_ref_lf0 = v_ref_lf0[:, :v_lf0.size(1)]\n    if mask.size(1) < v_lf0.size(1):\n        v_lf0 = v_lf0[:, :mask.size(1)]\n    abs_dif = torch.abs(torch.exp(v_lf0) - torch.exp(v_ref_lf0)) * mask\n    return torch.sum(abs_dif, dim=1) / torch.sum(mask, dim=1)\n\ndef compute_accuracy(uv, ref_uv):\n    if ref_uv.size(1) > uv.size(1):\n        ref_uv = ref_uv[:, :uv.size(1)]\n    return torch.mean(uv.eq(ref_uv.view_as(uv)).float().cpu(), dim=1)\n\ndef convert_wav(wav):\n    # denorm and store wav to tmp file\n    f = tempfile.NamedTemporaryFile(delete=False)\n    fname = f.name\n    ii16 = np.iinfo(np.int16)\n    wav = wav * ii16.min\n    wav = wav.astype(np.int16)\n    wavfile.write(f, 16000, wav)\n    #print('stored wav in file: ', fname)\n    # convert gwav to aco feats\n    aco_name = wav2aco(fname)\n    if os.path.exists(aco_name + '.lf0'):\n        lf0 = read_aco_file(aco_name + '.lf0', (-1, 1))\n        ilf0, uv =  interpolation(lf0, -10000000000)\n        return ilf0, uv, fname\n    else:\n        # ahocoder can be random\n        return None, None, None\n\ndef select_voiced(params):\n    lf0, uv, ref_lf0, ref_uv  = params\n    # first mask out unvoiced values from uvs\n    mask = uv * ref_uv\n    if np.sum(mask) == 0:\n        return [], []\n    v_lf0 = lf0[np.where(mask > 0)]\n    v_ref_lf0 = ref_lf0[np.where(mask > 0)]\n    return v_lf0, v_ref_lf0\n\nclass F0Evaluator(object):\n\n    def __init__(self, f0_gtruth_dir=None,  num_proc=30, cuda=False):\n        self.f0_gtruth_dir = f0_gtruth_dir\n        self.pool = mp.Pool(num_proc)\n        self.cuda = cuda\n        # load lf0 groundtruth curves from f0_gtruth_dir\n        if f0_gtruth_dir is not None:\n            raise NotImplementedError\n            # TODO: finish calling these dicts\n            self.utt2lf0 = {}\n            self.utt2uv = {}\n            lf0_fnames = glob.glob(os.path.join(f0_gtruth_dir, '*.lf0'))\n            for l_i, lf0_fname in enumerate(lf0_fnames, start=1):\n                print('Loading {}/{} lf0 file from {}...'.format(l_i,\n                                                                 len(lf0_fnames),\n                                                                 self.f0_gtruth_dir),\n                     end='\\r')\n                bname = os.path.splitext(os.path.basename(lf0_fname))[0]\n                glf0 = read_aco_file(lf0_fname, (-1, 1))\n                ilf0, uv = interpolation(glf0, -10000000000)\n                self.utt2lf0[bname] = ilf0\n                self.utt2uv[bname] = uv\n            print('')\n\n\n    def compute_KLD(self, v_lf0, v_ref_lf0, mask):\n        #if len(v_lf0.size()) == 2:\n        #    v_lf0 = v_lf0.view(-1)\n        #    v_ref_lf0 = v_ref_lf0.view(-1)\n        print('mask size: ', mask.size())\n        #print('seq_mask size: ', seq_mask.size())\n        means_p = []\n        stds_p = []\n        means_g = []\n        stds_g = []\n        for n in range(v_lf0.size(0)):\n            v_n_lf0 = v_lf0[n]\n            #mask_ = mask[n][:v_n_lf0.size(0)]\n            v_ref_n_lf0 = v_ref_lf0[n]\n            means_p.append(torch.mean(v_n_lf0))#[mask_ > 0]))\n            stds_p.append(torch.std(v_n_lf0))#[mask_ > 0]))\n            means_g.append(torch.mean(v_ref_n_lf0))#[mask_ > 0]))\n            stds_g.append(torch.std(v_ref_n_lf0))#[mask_ > 0]))\n        mean_p = torch.FloatTensor(means_p)\n        std_p = torch.FloatTensor(stds_p)\n        mean_g = torch.FloatTensor(means_g)\n        std_g = torch.FloatTensor(stds_g)\n        #mean_p = torch.mean(v_lf0 * mask * seq_mask, dim=1)\n        #std_p = torch.std(v_lf0 * mask * seq_mask, dim=1)\n        #mean_g = torch.mean(v_ref_lf0 * mask * seq_mask, dim=1)\n        #std_g = torch.std(v_ref_lf0 * mask * seq_maskk, dim=1)\n        return KLD(mean_p, std_p, mean_g, std_g), (std_p, std_g)\n\n    def aco_eval(self, lf0_path, ref_lf0_path):\n        lf0 = read_aco_file(lf0_path)\n        ref_lf0 = read_aco_file(ref_lf0_path)\n        lf0 = lf0[:ref_lf0.shape[0]]\n        lf0, uv =  interpolation(lf0, -10000000000)\n        ref_lf0, ref_uv =  interpolation(ref_lf0, -10000000000)\n        lf0 = torch.FloatTensor(lf0).unsqueeze(0)\n        uv = torch.FloatTensor(uv.astype(np.float32)).unsqueeze(0)\n        ref_lf0 = torch.FloatTensor(ref_lf0).unsqueeze(0)\n        ref_uv = torch.FloatTensor(ref_uv.astype(np.float32)).unsqueeze(0)\n        mask = ref_uv\n        kld, stds = self.compute_KLD(lf0, ref_lf0, mask)\n        mae = compute_MAE(lf0, ref_lf0, mask)\n        acc = compute_accuracy(uv, ref_uv)\n        p_std = stds[0]\n        kld = kld[p_std > 0]\n        total_kld = kld\n        total_mae = mae\n        total_acc = acc\n        return total_kld, total_mae, total_acc, torch.mean(mask, dim=1)\n\n    def __call__(self, wavs, ref_wavs=None, seqlens=None):\n        # TODO: atm ref_wavs MUST be specified\n        assert ref_wavs is not None\n        # ref_wavs: can be preloaded through f0 gruth dir or\n        #\xc2\xa0computed on the fly passing them here\n        #\xc2\xa0wavs: numpy array of wavs of size [batch, wav_len]\n        assert len(wavs.shape) == 2, len(wavs.shape)\n        if ref_wavs is not None:\n            assert wavs.shape == ref_wavs.shape, ref_wavs.shape\n        num_wavs = wavs.shape[0]\n        beg_t = timeit.default_timer()\n        results = self.pool.map(convert_wav, wavs)\n        ref_results = self.pool.map(convert_wav, ref_wavs)\n        end_t = timeit.default_timer()\n        uvs = []\n        ref_uvs = []\n        ilf0s = []\n        ref_ilf0s = []\n        conversion_args = []\n        for bidx in range(num_wavs):\n            ilf0, uv, fname = results[bidx]\n            ref_ilf0, ref_uv, \\\n            ref_fname = ref_results[bidx]\n            if fname is None or ref_fname is None:\n                continue\n            # remove tmp files\n            os.remove(ref_fname)\n            os.remove(ref_fname + '.fv')\n            os.remove(ref_fname + '.lf0')\n            os.remove(ref_fname + '.cc')\n            os.remove(fname)\n            os.remove(fname + '.fv')\n            os.remove(fname + '.lf0')\n            os.remove(fname + '.cc')\n            ref_uvs.append(ref_uv.tolist())\n            uvs.append(uv.tolist())\n            ref_ilf0s.append(ref_ilf0.tolist())\n            ilf0s.append(ilf0.tolist())\n        uvs = torch.FloatTensor(uvs).squeeze(-1)\n        ref_uvs = torch.FloatTensor(ref_uvs).squeeze(-1)\n        ilf0s = torch.FloatTensor(ilf0s).squeeze(-1)\n        ref_ilf0s = torch.FloatTensor(ref_ilf0s).squeeze(-1)\n        if self.cuda:\n            uvs = uvs.cuda()\n            ref_uvs = ref_uvs.cuda()\n            ilf0s = ilf0s.cuda()\n            ref_ilf0s = ref_ilf0s.cuda()\n        #mask = uvs * ref_uvs\n        mask = ref_uvs\n        seq_mask = None\n        if seqlens is not None:\n            seq_mask = []\n            for s_i, slen in enumerate(seqlens):\n                curr_slen = ilf0s.size(-1)\n                diff_slen = curr_slen - slen\n                seq_mask.append([1] * slen + [0] * diff_slen)\n            seq_mask = torch.FloatTensor(seq_mask)\n        #voiced_chunks = self.pool.map(select_voiced, conversion_args)\n        kld, stds = self.compute_KLD(ilf0s, ref_ilf0s, mask)#, seq_mask)\n        mae = compute_MAE(ilf0s, ref_ilf0s, mask)#, seq_mask)\n        acc = compute_accuracy(uvs, ref_uvs)#, seq_mask)\n        # filter kld with std vals of 0 predicted\n        p_std = stds[0]\n        kld = kld[p_std > 0]\n        total_kld = kld\n        total_mae = mae\n        total_acc = acc\n        #total_kld = kld.mean()\n        #total_mae = mae.mean()\n        #total_acc = acc.mean()\n        return total_kld, total_mae, total_acc\n\n\n"""
segan/models/spectral_norm.py,7,"b'import torch\nfrom torch.optim.optimizer import Optimizer, required\n\nfrom torch.autograd import Variable\nimport torch.nn.functional as F\nfrom torch import nn\nfrom torch import Tensor\nfrom torch.nn import Parameter\n\ndef l2normalize(v, eps=1e-12):\n    return v / (v.norm() + eps)\n\nclass SpectralNorm(nn.Module):\n    def __init__(self, module, name=\'weight\', power_iterations=1):\n        super(SpectralNorm, self).__init__()\n        self.module = module\n        self.name = name\n        self.power_iterations = power_iterations\n        if not self._made_params():\n            self._make_params()\n\n    def _update_u_v(self):\n        u = getattr(self.module, self.name + ""_u"")\n        v = getattr(self.module, self.name + ""_v"")\n        w = getattr(self.module, self.name + ""_bar"")\n\n        height = w.data.shape[0]\n        for _ in range(self.power_iterations):\n            v.data = l2normalize(torch.mv(torch.t(w.view(height,-1).data), u.data))\n            u.data = l2normalize(torch.mv(w.view(height,-1).data, v.data))\n\n        # sigma = torch.dot(u.data, torch.mv(w.view(height,-1).data, v.data))\n        sigma = u.dot(w.view(height, -1).mv(v))\n        setattr(self.module, self.name, w / sigma.expand_as(w))\n\n    def _made_params(self):\n        try:\n            u = getattr(self.module, self.name + ""_u"")\n            v = getattr(self.module, self.name + ""_v"")\n            w = getattr(self.module, self.name + ""_bar"")\n            return True\n        except AttributeError:\n            return False\n\n\n    def _make_params(self):\n        w = getattr(self.module, self.name)\n\n        height = w.data.shape[0]\n        width = w.view(height, -1).data.shape[1]\n\n        u = Parameter(w.data.new(height).normal_(0, 1), requires_grad=False)\n        v = Parameter(w.data.new(width).normal_(0, 1), requires_grad=False)\n        u.data = l2normalize(u.data)\n        v.data = l2normalize(v.data)\n        w_bar = Parameter(w.data)\n\n        del self.module._parameters[self.name]\n\n        self.module.register_parameter(self.name + ""_u"", u)\n        self.module.register_parameter(self.name + ""_v"", v)\n        self.module.register_parameter(self.name + ""_bar"", w_bar)\n\n\n    def forward(self, *args):\n        self._update_u_v()\n        return self.module.forward(*args)\n\n'"
