file_path,api_count,code
__init__.py,0,"b'from .models.inception_resnet_v1 import InceptionResnetV1\nfrom .models.mtcnn import MTCNN, PNet, RNet, ONet, prewhiten, fixed_image_standardization\nfrom .models.utils.detect_face import extract_face\nfrom .models.utils import training\n'"
setup.py,3,"b'import setuptools, os\n\nPACKAGE_NAME = \'facenet-pytorch\'\nVERSION = \'2.2.9\'\nAUTHOR = \'Tim Esler\'\nEMAIL = \'tim.esler@gmail.com\'\nDESCRIPTION = \'Pretrained Pytorch face detection and recognition models\'\nGITHUB_URL = \'https://github.com/timesler/facenet-pytorch\'\n\nparent_dir = os.path.dirname(os.path.realpath(__file__))\nimport_name = os.path.basename(parent_dir)\n\nwith open(\'{}/README.md\'.format(parent_dir), \'r\') as f:\n    long_description = f.read()\n\nsetuptools.setup(\n    name=PACKAGE_NAME,\n    version=VERSION,\n    author=AUTHOR,\n    author_email=EMAIL,\n    description=DESCRIPTION,\n    long_description=long_description,\n    long_description_content_type=\'text/markdown\',\n    url=GITHUB_URL,\n    packages=[\n        \'facenet_pytorch\',\n        \'facenet_pytorch.models\',\n        \'facenet_pytorch.models.utils\',\n        \'facenet_pytorch.data\',\n    ],\n    package_dir={\'facenet_pytorch\':\'.\'},\n    package_data={\'\': [\'*net.pt\']},\n    classifiers=[\n        ""Programming Language :: Python :: 3"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: OS Independent"",\n    ],\n    install_requires=[\n        \'numpy\',\n        \'requests\',\n    ],\n)\n'"
models/inception_resnet_v1.py,11,"b'import torch\nfrom torch import nn\nfrom torch.nn import functional as F\nimport requests\nfrom requests.adapters import HTTPAdapter\nimport os\n\n\nclass BasicConv2d(nn.Module):\n\n    def __init__(self, in_planes, out_planes, kernel_size, stride, padding=0):\n        super().__init__()\n        self.conv = nn.Conv2d(\n            in_planes, out_planes,\n            kernel_size=kernel_size, stride=stride,\n            padding=padding, bias=False\n        ) # verify bias false\n        self.bn = nn.BatchNorm2d(\n            out_planes,\n            eps=0.001, # value found in tensorflow\n            momentum=0.1, # default pytorch value\n            affine=True\n        )\n        self.relu = nn.ReLU(inplace=False)\n\n    def forward(self, x):\n        x = self.conv(x)\n        x = self.bn(x)\n        x = self.relu(x)\n        return x\n\n\nclass Block35(nn.Module):\n\n    def __init__(self, scale=1.0):\n        super().__init__()\n\n        self.scale = scale\n\n        self.branch0 = BasicConv2d(256, 32, kernel_size=1, stride=1)\n\n        self.branch1 = nn.Sequential(\n            BasicConv2d(256, 32, kernel_size=1, stride=1),\n            BasicConv2d(32, 32, kernel_size=3, stride=1, padding=1)\n        )\n\n        self.branch2 = nn.Sequential(\n            BasicConv2d(256, 32, kernel_size=1, stride=1),\n            BasicConv2d(32, 32, kernel_size=3, stride=1, padding=1),\n            BasicConv2d(32, 32, kernel_size=3, stride=1, padding=1)\n        )\n\n        self.conv2d = nn.Conv2d(96, 256, kernel_size=1, stride=1)\n        self.relu = nn.ReLU(inplace=False)\n\n    def forward(self, x):\n        x0 = self.branch0(x)\n        x1 = self.branch1(x)\n        x2 = self.branch2(x)\n        out = torch.cat((x0, x1, x2), 1)\n        out = self.conv2d(out)\n        out = out * self.scale + x\n        out = self.relu(out)\n        return out\n\n\nclass Block17(nn.Module):\n\n    def __init__(self, scale=1.0):\n        super().__init__()\n\n        self.scale = scale\n\n        self.branch0 = BasicConv2d(896, 128, kernel_size=1, stride=1)\n\n        self.branch1 = nn.Sequential(\n            BasicConv2d(896, 128, kernel_size=1, stride=1),\n            BasicConv2d(128, 128, kernel_size=(1,7), stride=1, padding=(0,3)),\n            BasicConv2d(128, 128, kernel_size=(7,1), stride=1, padding=(3,0))\n        )\n\n        self.conv2d = nn.Conv2d(256, 896, kernel_size=1, stride=1)\n        self.relu = nn.ReLU(inplace=False)\n\n    def forward(self, x):\n        x0 = self.branch0(x)\n        x1 = self.branch1(x)\n        out = torch.cat((x0, x1), 1)\n        out = self.conv2d(out)\n        out = out * self.scale + x\n        out = self.relu(out)\n        return out\n\n\nclass Block8(nn.Module):\n\n    def __init__(self, scale=1.0, noReLU=False):\n        super().__init__()\n\n        self.scale = scale\n        self.noReLU = noReLU\n\n        self.branch0 = BasicConv2d(1792, 192, kernel_size=1, stride=1)\n\n        self.branch1 = nn.Sequential(\n            BasicConv2d(1792, 192, kernel_size=1, stride=1),\n            BasicConv2d(192, 192, kernel_size=(1,3), stride=1, padding=(0,1)),\n            BasicConv2d(192, 192, kernel_size=(3,1), stride=1, padding=(1,0))\n        )\n\n        self.conv2d = nn.Conv2d(384, 1792, kernel_size=1, stride=1)\n        if not self.noReLU:\n            self.relu = nn.ReLU(inplace=False)\n\n    def forward(self, x):\n        x0 = self.branch0(x)\n        x1 = self.branch1(x)\n        out = torch.cat((x0, x1), 1)\n        out = self.conv2d(out)\n        out = out * self.scale + x\n        if not self.noReLU:\n            out = self.relu(out)\n        return out\n\n\nclass Mixed_6a(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n\n        self.branch0 = BasicConv2d(256, 384, kernel_size=3, stride=2)\n\n        self.branch1 = nn.Sequential(\n            BasicConv2d(256, 192, kernel_size=1, stride=1),\n            BasicConv2d(192, 192, kernel_size=3, stride=1, padding=1),\n            BasicConv2d(192, 256, kernel_size=3, stride=2)\n        )\n\n        self.branch2 = nn.MaxPool2d(3, stride=2)\n\n    def forward(self, x):\n        x0 = self.branch0(x)\n        x1 = self.branch1(x)\n        x2 = self.branch2(x)\n        out = torch.cat((x0, x1, x2), 1)\n        return out\n\n\nclass Mixed_7a(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n\n        self.branch0 = nn.Sequential(\n            BasicConv2d(896, 256, kernel_size=1, stride=1),\n            BasicConv2d(256, 384, kernel_size=3, stride=2)\n        )\n\n        self.branch1 = nn.Sequential(\n            BasicConv2d(896, 256, kernel_size=1, stride=1),\n            BasicConv2d(256, 256, kernel_size=3, stride=2)\n        )\n\n        self.branch2 = nn.Sequential(\n            BasicConv2d(896, 256, kernel_size=1, stride=1),\n            BasicConv2d(256, 256, kernel_size=3, stride=1, padding=1),\n            BasicConv2d(256, 256, kernel_size=3, stride=2)\n        )\n\n        self.branch3 = nn.MaxPool2d(3, stride=2)\n\n    def forward(self, x):\n        x0 = self.branch0(x)\n        x1 = self.branch1(x)\n        x2 = self.branch2(x)\n        x3 = self.branch3(x)\n        out = torch.cat((x0, x1, x2, x3), 1)\n        return out\n\n\nclass InceptionResnetV1(nn.Module):\n    """"""Inception Resnet V1 model with optional loading of pretrained weights.\n\n    Model parameters can be loaded based on pretraining on the VGGFace2 or CASIA-Webface\n    datasets. Pretrained state_dicts are automatically downloaded on model instantiation if\n    requested and cached in the torch cache. Subsequent instantiations use the cache rather than\n    redownloading.\n\n    Keyword Arguments:\n        pretrained {str} -- Optional pretraining dataset. Either \'vggface2\' or \'casia-webface\'.\n            (default: {None})\n        classify {bool} -- Whether the model should output classification probabilities or feature\n            embeddings. (default: {False})\n        num_classes {int} -- Number of output classes. If \'pretrained\' is set and num_classes not\n            equal to that used for the pretrained model, the final linear layer will be randomly\n            initialized. (default: {None})\n        dropout_prob {float} -- Dropout probability. (default: {0.6})\n    """"""\n    def __init__(self, pretrained=None, classify=False, num_classes=None, dropout_prob=0.6, device=None):\n        super().__init__()\n\n        # Set simple attributes\n        self.pretrained = pretrained\n        self.classify = classify\n        self.num_classes = num_classes\n\n        if pretrained == \'vggface2\':\n            tmp_classes = 8631\n        elif pretrained == \'casia-webface\':\n            tmp_classes = 10575\n        elif pretrained is None and self.num_classes is None:\n            raise Exception(\'At least one of ""pretrained"" or ""num_classes"" must be specified\')\n        else:\n            tmp_classes = self.num_classes\n\n\n        # Define layers\n        self.conv2d_1a = BasicConv2d(3, 32, kernel_size=3, stride=2)\n        self.conv2d_2a = BasicConv2d(32, 32, kernel_size=3, stride=1)\n        self.conv2d_2b = BasicConv2d(32, 64, kernel_size=3, stride=1, padding=1)\n        self.maxpool_3a = nn.MaxPool2d(3, stride=2)\n        self.conv2d_3b = BasicConv2d(64, 80, kernel_size=1, stride=1)\n        self.conv2d_4a = BasicConv2d(80, 192, kernel_size=3, stride=1)\n        self.conv2d_4b = BasicConv2d(192, 256, kernel_size=3, stride=2)\n        self.repeat_1 = nn.Sequential(\n            Block35(scale=0.17),\n            Block35(scale=0.17),\n            Block35(scale=0.17),\n            Block35(scale=0.17),\n            Block35(scale=0.17),\n        )\n        self.mixed_6a = Mixed_6a()\n        self.repeat_2 = nn.Sequential(\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n            Block17(scale=0.10),\n        )\n        self.mixed_7a = Mixed_7a()\n        self.repeat_3 = nn.Sequential(\n            Block8(scale=0.20),\n            Block8(scale=0.20),\n            Block8(scale=0.20),\n            Block8(scale=0.20),\n            Block8(scale=0.20),\n        )\n        self.block8 = Block8(noReLU=True)\n        self.avgpool_1a = nn.AdaptiveAvgPool2d(1)\n        self.dropout = nn.Dropout(dropout_prob)\n        self.last_linear = nn.Linear(1792, 512, bias=False)\n        self.last_bn = nn.BatchNorm1d(512, eps=0.001, momentum=0.1, affine=True)\n        self.logits = nn.Linear(512, tmp_classes)\n\n        if pretrained is not None:\n            load_weights(self, pretrained)\n\n        if self.num_classes is not None:\n            self.logits = nn.Linear(512, self.num_classes)\n\n        self.device = torch.device(\'cpu\')\n        if device is not None:\n            self.device = device\n            self.to(device)\n\n    def forward(self, x):\n        """"""Calculate embeddings or logits given a batch of input image tensors.\n\n        Arguments:\n            x {torch.tensor} -- Batch of image tensors representing faces.\n\n        Returns:\n            torch.tensor -- Batch of embedding vectors or multinomial logits.\n        """"""\n        x = self.conv2d_1a(x)\n        x = self.conv2d_2a(x)\n        x = self.conv2d_2b(x)\n        x = self.maxpool_3a(x)\n        x = self.conv2d_3b(x)\n        x = self.conv2d_4a(x)\n        x = self.conv2d_4b(x)\n        x = self.repeat_1(x)\n        x = self.mixed_6a(x)\n        x = self.repeat_2(x)\n        x = self.mixed_7a(x)\n        x = self.repeat_3(x)\n        x = self.block8(x)\n        x = self.avgpool_1a(x)\n        x = self.dropout(x)\n        x = self.last_linear(x.view(x.shape[0], -1))\n        x = self.last_bn(x)\n        if self.classify:\n            x = self.logits(x)\n        else:\n            x = F.normalize(x, p=2, dim=1)\n        return x\n\n\ndef load_weights(mdl, name):\n    """"""Download pretrained state_dict and load into model.\n\n    Arguments:\n        mdl {torch.nn.Module} -- Pytorch model.\n        name {str} -- Name of dataset that was used to generate pretrained state_dict.\n\n    Raises:\n        ValueError: If \'pretrained\' not equal to \'vggface2\' or \'casia-webface\'.\n    """"""\n    if name == \'vggface2\':\n        features_path = \'https://drive.google.com/uc?export=download&id=1cWLH_hPns8kSfMz9kKl9PsG5aNV2VSMn\'\n        logits_path = \'https://drive.google.com/uc?export=download&id=1mAie3nzZeno9UIzFXvmVZrDG3kwML46X\'\n    elif name == \'casia-webface\':\n        features_path = \'https://drive.google.com/uc?export=download&id=1LSHHee_IQj5W3vjBcRyVaALv4py1XaGy\'\n        logits_path = \'https://drive.google.com/uc?export=download&id=1QrhPgn1bGlDxAil2uc07ctunCQoDnCzT\'\n    else:\n        raise ValueError(\'Pretrained models only exist for ""vggface2"" and ""casia-webface""\')\n\n    model_dir = os.path.join(get_torch_home(), \'checkpoints\')\n    os.makedirs(model_dir, exist_ok=True)\n\n    state_dict = {}\n    for i, path in enumerate([features_path, logits_path]):\n        cached_file = os.path.join(model_dir, \'{}_{}.pt\'.format(name, path[-10:]))\n        if not os.path.exists(cached_file):\n            print(\'Downloading parameters ({}/2)\'.format(i+1))\n            s = requests.Session()\n            s.mount(\'https://\', HTTPAdapter(max_retries=10))\n            r = s.get(path, allow_redirects=True)\n            with open(cached_file, \'wb\') as f:\n                f.write(r.content)\n        state_dict.update(torch.load(cached_file))\n\n    mdl.load_state_dict(state_dict)\n\n\ndef get_torch_home():\n    torch_home = os.path.expanduser(\n        os.getenv(\n            \'TORCH_HOME\',\n            os.path.join(os.getenv(\'XDG_CACHE_HOME\', \'~/.cache\'), \'torch\')\n        )\n    )\n    return torch_home\n'"
models/mtcnn.py,9,"b'import torch\nfrom torch import nn\nimport numpy as np\nimport os\n\nfrom .utils.detect_face import detect_face, extract_face\n\n\nclass PNet(nn.Module):\n    """"""MTCNN PNet.\n    \n    Keyword Arguments:\n        pretrained {bool} -- Whether or not to load saved pretrained weights (default: {True})\n    """"""\n\n    def __init__(self, pretrained=True):\n        super().__init__()\n\n        self.conv1 = nn.Conv2d(3, 10, kernel_size=3)\n        self.prelu1 = nn.PReLU(10)\n        self.pool1 = nn.MaxPool2d(2, 2, ceil_mode=True)\n        self.conv2 = nn.Conv2d(10, 16, kernel_size=3)\n        self.prelu2 = nn.PReLU(16)\n        self.conv3 = nn.Conv2d(16, 32, kernel_size=3)\n        self.prelu3 = nn.PReLU(32)\n        self.conv4_1 = nn.Conv2d(32, 2, kernel_size=1)\n        self.softmax4_1 = nn.Softmax(dim=1)\n        self.conv4_2 = nn.Conv2d(32, 4, kernel_size=1)\n\n        self.training = False\n\n        if pretrained:\n            state_dict_path = os.path.join(os.path.dirname(__file__), \'../data/pnet.pt\')\n            state_dict = torch.load(state_dict_path)\n            self.load_state_dict(state_dict)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.prelu1(x)\n        x = self.pool1(x)\n        x = self.conv2(x)\n        x = self.prelu2(x)\n        x = self.conv3(x)\n        x = self.prelu3(x)\n        a = self.conv4_1(x)\n        a = self.softmax4_1(a)\n        b = self.conv4_2(x)\n        return b, a\n\n\nclass RNet(nn.Module):\n    """"""MTCNN RNet.\n    \n    Keyword Arguments:\n        pretrained {bool} -- Whether or not to load saved pretrained weights (default: {True})\n    """"""\n\n    def __init__(self, pretrained=True):\n        super().__init__()\n\n        self.conv1 = nn.Conv2d(3, 28, kernel_size=3)\n        self.prelu1 = nn.PReLU(28)\n        self.pool1 = nn.MaxPool2d(3, 2, ceil_mode=True)\n        self.conv2 = nn.Conv2d(28, 48, kernel_size=3)\n        self.prelu2 = nn.PReLU(48)\n        self.pool2 = nn.MaxPool2d(3, 2, ceil_mode=True)\n        self.conv3 = nn.Conv2d(48, 64, kernel_size=2)\n        self.prelu3 = nn.PReLU(64)\n        self.dense4 = nn.Linear(576, 128)\n        self.prelu4 = nn.PReLU(128)\n        self.dense5_1 = nn.Linear(128, 2)\n        self.softmax5_1 = nn.Softmax(dim=1)\n        self.dense5_2 = nn.Linear(128, 4)\n\n        self.training = False\n\n        if pretrained:\n            state_dict_path = os.path.join(os.path.dirname(__file__), \'../data/rnet.pt\')\n            state_dict = torch.load(state_dict_path)\n            self.load_state_dict(state_dict)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.prelu1(x)\n        x = self.pool1(x)\n        x = self.conv2(x)\n        x = self.prelu2(x)\n        x = self.pool2(x)\n        x = self.conv3(x)\n        x = self.prelu3(x)\n        x = x.permute(0, 3, 2, 1).contiguous()\n        x = self.dense4(x.view(x.shape[0], -1))\n        x = self.prelu4(x)\n        a = self.dense5_1(x)\n        a = self.softmax5_1(a)\n        b = self.dense5_2(x)\n        return b, a\n\n\nclass ONet(nn.Module):\n    """"""MTCNN ONet.\n    \n    Keyword Arguments:\n        pretrained {bool} -- Whether or not to load saved pretrained weights (default: {True})\n    """"""\n\n    def __init__(self, pretrained=True):\n        super().__init__()\n\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3)\n        self.prelu1 = nn.PReLU(32)\n        self.pool1 = nn.MaxPool2d(3, 2, ceil_mode=True)\n        self.conv2 = nn.Conv2d(32, 64, kernel_size=3)\n        self.prelu2 = nn.PReLU(64)\n        self.pool2 = nn.MaxPool2d(3, 2, ceil_mode=True)\n        self.conv3 = nn.Conv2d(64, 64, kernel_size=3)\n        self.prelu3 = nn.PReLU(64)\n        self.pool3 = nn.MaxPool2d(2, 2, ceil_mode=True)\n        self.conv4 = nn.Conv2d(64, 128, kernel_size=2)\n        self.prelu4 = nn.PReLU(128)\n        self.dense5 = nn.Linear(1152, 256)\n        self.prelu5 = nn.PReLU(256)\n        self.dense6_1 = nn.Linear(256, 2)\n        self.softmax6_1 = nn.Softmax(dim=1)\n        self.dense6_2 = nn.Linear(256, 4)\n        self.dense6_3 = nn.Linear(256, 10)\n\n        self.training = False\n\n        if pretrained:\n            state_dict_path = os.path.join(os.path.dirname(__file__), \'../data/onet.pt\')\n            state_dict = torch.load(state_dict_path)\n            self.load_state_dict(state_dict)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.prelu1(x)\n        x = self.pool1(x)\n        x = self.conv2(x)\n        x = self.prelu2(x)\n        x = self.pool2(x)\n        x = self.conv3(x)\n        x = self.prelu3(x)\n        x = self.pool3(x)\n        x = self.conv4(x)\n        x = self.prelu4(x)\n        x = x.permute(0, 3, 2, 1).contiguous()\n        x = self.dense5(x.view(x.shape[0], -1))\n        x = self.prelu5(x)\n        a = self.dense6_1(x)\n        a = self.softmax6_1(a)\n        b = self.dense6_2(x)\n        c = self.dense6_3(x)\n        return b, c, a\n\n\nclass MTCNN(nn.Module):\n    """"""MTCNN face detection module.\n\n    This class loads pretrained P-, R-, and O-nets and returns images cropped to include the face\n    only, given raw input images of one of the following types:\n        - PIL image or list of PIL images\n        - numpy.ndarray (uint8) representing either a single image (3D) or a batch of images (4D).\n    Cropped faces can optionally be saved to file\n    also.\n    \n    Keyword Arguments:\n        image_size {int} -- Output image size in pixels. The image will be square. (default: {160})\n        margin {int} -- Margin to add to bounding box, in terms of pixels in the final image. \n            Note that the application of the margin differs slightly from the davidsandberg/facenet\n            repo, which applies the margin to the original image before resizing, making the margin\n            dependent on the original image size (this is a bug in davidsandberg/facenet).\n            (default: {0})\n        min_face_size {int} -- Minimum face size to search for. (default: {20})\n        thresholds {list} -- MTCNN face detection thresholds (default: {[0.6, 0.7, 0.7]})\n        factor {float} -- Factor used to create a scaling pyramid of face sizes. (default: {0.709})\n        post_process {bool} -- Whether or not to post process images tensors before returning.\n            (default: {True})\n        select_largest {bool} -- If True, if multiple faces are detected, the largest is returned.\n            If False, the face with the highest detection probability is returned.\n            (default: {True})\n        keep_all {bool} -- If True, all detected faces are returned, in the order dictated by the\n            select_largest parameter. If a save_path is specified, the first face is saved to that\n            path and the remaining faces are saved to <save_path>1, <save_path>2 etc.\n        device {torch.device} -- The device on which to run neural net passes. Image tensors and\n            models are copied to this device before running forward passes. (default: {None})\n    """"""\n\n    def __init__(\n        self, image_size=160, margin=0, min_face_size=20,\n        thresholds=[0.6, 0.7, 0.7], factor=0.709, post_process=True,\n        select_largest=True, keep_all=False, device=None\n    ):\n        super().__init__()\n\n        self.image_size = image_size\n        self.margin = margin\n        self.min_face_size = min_face_size\n        self.thresholds = thresholds\n        self.factor = factor\n        self.post_process = post_process\n        self.select_largest = select_largest\n        self.keep_all = keep_all\n\n        self.pnet = PNet()\n        self.rnet = RNet()\n        self.onet = ONet()\n\n        self.device = torch.device(\'cpu\')\n        if device is not None:\n            self.device = device\n            self.to(device)\n\n    def forward(self, img, save_path=None, return_prob=False):\n        """"""Run MTCNN face detection on a PIL image or numpy array. This method performs both\n        detection and extraction of faces, returning tensors representing detected faces rather\n        than the bounding boxes. To access bounding boxes, see the MTCNN.detect() method below.\n        \n        Arguments:\n            img {PIL.Image, np.ndarray, or list} -- A PIL image, np.ndarray, or list.\n        \n        Keyword Arguments:\n            save_path {str} -- An optional save path for the cropped image. Note that when\n                self.post_process=True, although the returned tensor is post processed, the saved\n                face image is not, so it is a true representation of the face in the input image.\n                If `img` is a list of images, `save_path` should be a list of equal length.\n                (default: {None})\n            return_prob {bool} -- Whether or not to return the detection probability.\n                (default: {False})\n        \n        Returns:\n            Union[torch.Tensor, tuple(torch.tensor, float)] -- If detected, cropped image of a face\n                with dimensions 3 x image_size x image_size. Optionally, the probability that a\n                face was detected. If self.keep_all is True, n detected faces are returned in an\n                n x 3 x image_size x image_size tensor with an optional list of detection\n                probabilities. If `img` is a list of images, the item(s) returned have an extra \n                dimension (batch) as the first dimension.\n\n        Example:\n        >>> from facenet_pytorch import MTCNN\n        >>> mtcnn = MTCNN()\n        >>> face_tensor, prob = mtcnn(img, save_path=\'face.png\', return_prob=True)\n        """"""\n\n        # Detect faces\n        with torch.no_grad():\n            batch_boxes, batch_probs = self.detect(img)\n\n        # Determine if a batch or single image was passed\n        batch_mode = True\n        if not isinstance(img, (list, tuple)) and not (isinstance(img, np.ndarray) and len(img.shape) == 4):\n            img = [img]\n            batch_boxes = [batch_boxes]\n            batch_probs = [batch_probs]\n            batch_mode = False\n\n        # Parse save path(s)\n        if save_path is not None:\n            if isinstance(save_path, str):\n                save_path = [save_path]\n        else:\n            save_path = [None for _ in range(len(img))]\n        \n        # Process all bounding boxes and probabilities\n        faces, probs = [], []\n        for im, box_im, prob_im, path_im in zip(img, batch_boxes, batch_probs, save_path):\n            if box_im is None:\n                faces.append(None)\n                probs.append([None] if self.keep_all else None)\n                continue\n\n            if not self.keep_all:\n                box_im = box_im[[0]]\n\n            faces_im = []\n            for i, box in enumerate(box_im):\n                face_path = path_im\n                if path_im is not None and i > 0:\n                    save_name, ext = os.path.splitext(path_im)\n                    face_path = save_name + \'_\' + str(i + 1) + ext\n\n                face = extract_face(im, box, self.image_size, self.margin, face_path)\n                if self.post_process:\n                    face = fixed_image_standardization(face)\n                faces_im.append(face)\n\n            if self.keep_all:\n                faces_im = torch.stack(faces_im)\n            else:\n                faces_im = faces_im[0]\n                prob_im = prob_im[0]\n            \n            faces.append(faces_im)\n            probs.append(prob_im)\n    \n        if not batch_mode:\n            faces = faces[0]\n            probs = probs[0]\n\n        if return_prob:\n            return faces, probs\n        else:\n            return faces\n\n    def detect(self, img, landmarks=False):\n        """"""Detect all faces in PIL image and return bounding boxes and optional facial landmarks.\n\n        This method is used by the forward method and is also useful for face detection tasks\n        that require lower-level handling of bounding boxes and facial landmarks (e.g., face\n        tracking). The functionality of the forward function can be emulated by using this method\n        followed by the extract_face() function.\n        \n        Arguments:\n            img {PIL.Image, np.ndarray, or list} -- A PIL image or a list of PIL images.\n\n        Keyword Arguments:\n            landmarks {bool} -- Whether to return facial landmarks in addition to bounding boxes.\n                (default: {False})\n        \n        Returns:\n            tuple(numpy.ndarray, list) -- For N detected faces, a tuple containing an\n                Nx4 array of bounding boxes and a length N list of detection probabilities.\n                Returned boxes will be sorted in descending order by detection probability if\n                self.select_largest=False, otherwise the largest face will be returned first.\n                If `img` is a list of images, the items returned have an extra dimension\n                (batch) as the first dimension. Optionally, a third item, the facial landmarks,\n                are returned if `landmarks=True`.\n\n        Example:\n        >>> from PIL import Image, ImageDraw\n        >>> from facenet_pytorch import MTCNN, extract_face\n        >>> mtcnn = MTCNN(keep_all=True)\n        >>> boxes, probs, points = mtcnn.detect(img, landmarks=True)\n        >>> # Draw boxes and save faces\n        >>> img_draw = img.copy()\n        >>> draw = ImageDraw.Draw(img_draw)\n        >>> for i, (box, point) in enumerate(zip(boxes, points)):\n        ...     draw.rectangle(box.tolist(), width=5)\n        ...     for p in point:\n        ...         draw.rectangle((p - 10).tolist() + (p + 10).tolist(), width=10)\n        ...     extract_face(img, box, save_path=\'detected_face_{}.png\'.format(i))\n        >>> img_draw.save(\'annotated_faces.png\')\n        """"""\n\n        with torch.no_grad():\n            batch_boxes, batch_points = detect_face(\n                img, self.min_face_size,\n                self.pnet, self.rnet, self.onet,\n                self.thresholds, self.factor,\n                self.device\n            )\n\n        boxes, probs, points = [], [], []\n        for box, point in zip(batch_boxes, batch_points):\n            box = np.array(box)\n            point = np.array(point)\n            if len(box) == 0:\n                boxes.append(None)\n                probs.append([None])\n                points.append(None)\n            elif self.select_largest:\n                box_order = np.argsort((box[:, 2] - box[:, 0]) * (box[:, 3] - box[:, 1]))[::-1]\n                box = box[box_order]\n                point = point[box_order]\n                boxes.append(box[:, :4])\n                probs.append(box[:, 4])\n                points.append(point)\n            else:\n                boxes.append(box[:, :4])\n                probs.append(box[:, 4])\n                points.append(point)\n        boxes = np.array(boxes)\n        probs = np.array(probs)\n        points = np.array(points)\n\n        if not isinstance(img, (list, tuple)) and not (isinstance(img, np.ndarray) and len(img.shape) == 4):\n            boxes = boxes[0]\n            probs = probs[0]\n            points = points[0]\n\n        if landmarks:\n            return boxes, probs, points\n\n        return boxes, probs\n\n\ndef fixed_image_standardization(image_tensor):\n    processed_tensor = (image_tensor - 127.5) / 128.0\n    return processed_tensor\n\ndef prewhiten(x):\n    mean = x.mean()\n    std = x.std()\n    std_adj = std.clamp(min=1.0/(float(x.numel())**0.5))\n    y = (x - mean) / std_adj\n    return y\n'"
tests/perf_test.py,2,"b'from facenet_pytorch import MTCNN, training\nimport torch\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader, RandomSampler\nfrom tqdm import tqdm\nimport time\n\n\ndef main():\n    device = \'cuda\' if torch.cuda.is_available() else \'cpu\'\n    print(f\'Running on device ""{device}""\')\n\n    mtcnn = MTCNN(device=device)\n\n    batch_size = 32\n\n    # Generate data loader\n    ds = datasets.ImageFolder(\n        root=\'data/test_images/\',\n        transform=transforms.Resize((512, 512))\n    )\n    dl = DataLoader(\n        dataset=ds,\n        num_workers=4,\n        collate_fn=training.collate_pil,\n        batch_size=batch_size,\n        sampler=RandomSampler(ds, replacement=True, num_samples=960),\n    )\n\n    start = time.time()\n    faces = []\n    for x, _ in tqdm(dl):\n        faces.extend(mtcnn(x))\n    elapsed = time.time() - start\n    print(f\'Elapsed: {elapsed} | EPS: {len(dl) * batch_size / elapsed}\')\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tests/travis_test.py,9,"b'""""""\nThe following code is intended to be run only by travis for continuius intengration and testing\npurposes. For implementation examples see notebooks in the examples folder.\n""""""\n\nfrom PIL import Image, ImageDraw\nimport torch\nfrom torch.utils.data import DataLoader\nfrom torchvision import transforms, datasets\nimport numpy as np\nimport pandas as pd\nfrom time import time\nimport sys, os\nimport glob\n\nfrom models.mtcnn import MTCNN, fixed_image_standardization\nfrom models.inception_resnet_v1 import InceptionResnetV1, get_torch_home\n\n\n#### CLEAR ALL OUTPUT FILES ####\n\n# checkpoints = glob.glob(os.path.join(get_torch_home(), \'checkpoints/*\'))\n# for c in checkpoints:\n#     print(\'Removing {}\'.format(c))\n#     os.remove(c)\n\ncrop_files = glob.glob(\'data/test_images_aligned/**/*.png\')\nfor c in crop_files:\n    print(\'Removing {}\'.format(c))\n    os.remove(c)\n\n\n#### TEST EXAMPLE IPYNB\'S ####\n\nos.system(\'jupyter nbconvert --to script --stdout examples/infer.ipynb examples/finetune.ipynb > examples/tmptest.py\')\nos.chdir(\'examples\')\nimport examples.tmptest\nos.chdir(\'..\')\n\n\n#### TEST MTCNN ####\n\ndef get_image(path, trans):\n    img = Image.open(path)\n    img = trans(img)\n    return img\n\ntrans = transforms.Compose([\n    transforms.Resize(512)\n])\n\ntrans_cropped = transforms.Compose([\n    np.float32,\n    transforms.ToTensor(),\n    fixed_image_standardization\n])\n\ndataset = datasets.ImageFolder(\'data/test_images\', transform=trans)\ndataset.idx_to_class = {k: v for v, k in dataset.class_to_idx.items()}\nloader = DataLoader(dataset, collate_fn=lambda x: x[0])\n\nmtcnn_pt = MTCNN(device=torch.device(\'cpu\'))\n\nnames = []\naligned = []\naligned_fromfile = []\nfor img, idx in loader:\n    name = dataset.idx_to_class[idx]\n    start = time()\n    img_align = mtcnn_pt(img, save_path=\'data/test_images_aligned/{}/1.png\'.format(name))\n    print(\'MTCNN time: {:6f} seconds\'.format(time() - start))\n\n    if img_align is not None:\n        names.append(name)\n        aligned.append(img_align)\n        aligned_fromfile.append(get_image(\'data/test_images_aligned/{}/1.png\'.format(name), trans_cropped))\n\naligned = torch.stack(aligned)\naligned_fromfile = torch.stack(aligned_fromfile)\n\n\n#### TEST EMBEDDINGS ####\n\nexpected = [\n    [\n        [0.000000, 1.482895, 0.886342, 1.438450, 1.437583],\n        [1.482895, 0.000000, 1.345686, 1.029880, 1.061939],\n        [0.886342, 1.345686, 0.000000, 1.363125, 1.338803],\n        [1.438450, 1.029880, 1.363125, 0.000000, 1.066040],\n        [1.437583, 1.061939, 1.338803, 1.066040, 0.000000]\n    ],\n    [\n        [0.000000, 1.430769, 0.992931, 1.414197, 1.329544],\n        [1.430769, 0.000000, 1.253911, 1.144899, 1.079755],\n        [0.992931, 1.253911, 0.000000, 1.358875, 1.337322],\n        [1.414197, 1.144899, 1.358875, 0.000000, 1.204118],\n        [1.329544, 1.079755, 1.337322, 1.204118, 0.000000]\n    ]\n]\n\nfor i, ds in enumerate([\'vggface2\', \'casia-webface\']):\n    resnet_pt = InceptionResnetV1(pretrained=ds).eval()\n\n    start = time()\n    embs = resnet_pt(aligned)\n    print(\'\\nResnet time: {:6f} seconds\\n\'.format(time() - start))\n\n    embs_fromfile = resnet_pt(aligned_fromfile)\n\n    dists = [[(emb - e).norm().item() for e in embs] for emb in embs]\n    dists_fromfile = [[(emb - e).norm().item() for e in embs_fromfile] for emb in embs_fromfile]\n\n    print(\'\\nOutput:\')\n    print(pd.DataFrame(dists, columns=names, index=names))\n    print(\'\\nOutput (from file):\')\n    print(pd.DataFrame(dists_fromfile, columns=names, index=names))\n    print(\'\\nExpected:\')\n    print(pd.DataFrame(expected[i], columns=names, index=names))\n\n    total_error = (torch.tensor(dists) - torch.tensor(expected[i])).norm()\n    total_error_fromfile = (torch.tensor(dists_fromfile) - torch.tensor(expected[i])).norm()\n\n    print(\'\\nTotal error: {}, {}\'.format(total_error, total_error_fromfile))\n\n    if sys.platform != \'win32\':\n        assert total_error < 1e-4\n        assert total_error_fromfile < 1e-4\n\n\n#### TEST CLASSIFICATION ####\n\nresnet_pt = InceptionResnetV1(pretrained=ds, classify=True).eval()\nprob = resnet_pt(aligned)\n\n\n#### MULTI-FACE TEST ####\n\nmtcnn = MTCNN(keep_all=True)\nimg = Image.open(\'data/multiface.jpg\')\nboxes, probs = mtcnn.detect(img)\n\ndraw = ImageDraw.Draw(img)\nfor i, box in enumerate(boxes):\n    draw.rectangle(box.tolist())\n\nmtcnn(img, save_path=\'data/tmp.png\')\n\n\n#### MTCNN TYPES TEST ####\n\nimg = Image.open(\'data/multiface.jpg\')\n\nmtcnn = MTCNN(keep_all=True)\nboxes_ref, _ = mtcnn.detect(img)\n_ = mtcnn(img)\n\nmtcnn = MTCNN(keep_all=True).double()\nboxes_test, _ = mtcnn.detect(img)\n_ = mtcnn(img)\n\nbox_diff = boxes_ref[np.argsort(boxes_ref[:,1])] - boxes_test[np.argsort(boxes_test[:,1])]\ntotal_error = np.sum(np.abs(box_diff))\nprint(\'\\nfp64 Total box error: {}\'.format(total_error))\n\nassert total_error < 1e-2\n\n\n# half is not supported on CPUs, only GPUs\nif torch.cuda.is_available():\n\n    mtcnn = MTCNN(keep_all=True, device=\'cuda\').half()\n    boxes_test, _ = mtcnn.detect(img)\n    _ = mtcnn(img)\n\n    box_diff = boxes_ref[np.argsort(boxes_ref[:,1])] - boxes_test[np.argsort(boxes_test[:,1])]\n    print(\'fp16 Total box error: {}\'.format(np.sum(np.abs(box_diff))))\n\n    # test new automatic multi precision to compare\n    if hasattr(torch.cuda, \'amp\'):\n        with torch.cuda.amp.autocast():\n            mtcnn = MTCNN(keep_all=True, device=\'cuda\')\n            boxes_test, _ = mtcnn.detect(img)\n            _ = mtcnn(img)\n\n        box_diff = boxes_ref[np.argsort(boxes_ref[:,1])] - boxes_test[np.argsort(boxes_test[:,1])]\n        print(\'AMP total box error: {}\'.format(np.sum(np.abs(box_diff))))\n\n            \n#### MULTI-IMAGE TEST ####\n\nmtcnn = MTCNN(keep_all=True)\nimg = [\n    Image.open(\'data/multiface.jpg\'),\n    Image.open(\'data/multiface.jpg\')\n]\nbatch_boxes, batch_probs = mtcnn.detect(img)\n\nmtcnn(img, save_path=[\'data/tmp1.png\', \'data/tmp1.png\'])\ntmp_files = glob.glob(\'data/tmp*\')\nfor f in tmp_files:\n    os.remove(f)\n\n\n#### NO-FACE TEST ####\n\nimg = Image.new(\'RGB\', (512, 512))\nmtcnn(img)\nmtcnn(img, return_prob=True)\n'"
models/utils/detect_face.py,21,"b'import torch\nfrom torch.nn.functional import interpolate\nfrom torchvision.transforms import functional as F\nfrom torchvision.ops.boxes import batched_nms\nimport cv2\nfrom PIL import Image\nimport numpy as np\nimport os\n\n\ndef detect_face(imgs, minsize, pnet, rnet, onet, threshold, factor, device):\n    if isinstance(imgs, (np.ndarray, torch.Tensor)):\n        imgs = torch.as_tensor(imgs, device=device)\n        if len(imgs.shape) == 3:\n            imgs = imgs.unsqueeze(0)\n    else:\n        if not isinstance(imgs, (list, tuple)):\n            imgs = [imgs]\n        if any(img.size != imgs[0].size for img in imgs):\n            raise Exception(""MTCNN batch processing only compatible with equal-dimension images."")\n        imgs = np.stack([np.uint8(img) for img in imgs])\n\n    imgs = torch.as_tensor(imgs, device=device)\n\n    model_dtype = next(pnet.parameters()).dtype\n    imgs = imgs.permute(0, 3, 1, 2).type(model_dtype)\n\n    batch_size = len(imgs)\n    h, w = imgs.shape[2:4]\n    m = 12.0 / minsize\n    minl = min(h, w)\n    minl = minl * m\n\n    # Create scale pyramid\n    scale_i = m\n    scales = []\n    while minl >= 12:\n        scales.append(scale_i)\n        scale_i = scale_i * factor\n        minl = minl * factor\n\n    # First stage\n    boxes = []\n    image_inds = []\n    all_inds = []\n    all_i = 0\n    for scale in scales:\n        im_data = imresample(imgs, (int(h * scale + 1), int(w * scale + 1)))\n        im_data = (im_data - 127.5) * 0.0078125\n        reg, probs = pnet(im_data)\n    \n        boxes_scale, image_inds_scale = generateBoundingBox(reg, probs[:, 1], scale, threshold[0])\n        boxes.append(boxes_scale)\n        image_inds.append(image_inds_scale)\n        all_inds.append(all_i + image_inds_scale)\n        all_i += batch_size\n\n    boxes = torch.cat(boxes, dim=0)\n    image_inds = torch.cat(image_inds, dim=0).cpu()\n    all_inds = torch.cat(all_inds, dim=0)\n\n    # NMS within each scale + image\n    pick = batched_nms(boxes[:, :4], boxes[:, 4], all_inds, 0.5)\n    boxes, image_inds = boxes[pick], image_inds[pick]\n    \n    # NMS within each image\n    pick = batched_nms(boxes[:, :4], boxes[:, 4], image_inds, 0.7)\n    boxes, image_inds = boxes[pick], image_inds[pick]\n\n    regw = boxes[:, 2] - boxes[:, 0]\n    regh = boxes[:, 3] - boxes[:, 1]\n    qq1 = boxes[:, 0] + boxes[:, 5] * regw\n    qq2 = boxes[:, 1] + boxes[:, 6] * regh\n    qq3 = boxes[:, 2] + boxes[:, 7] * regw\n    qq4 = boxes[:, 3] + boxes[:, 8] * regh\n    boxes = torch.stack([qq1, qq2, qq3, qq4, boxes[:, 4]]).permute(1, 0)\n    boxes = rerec(boxes)\n    y, ey, x, ex = pad(boxes, w, h)\n    \n    # Second stage\n    if len(boxes) > 0:\n        im_data = []\n        for k in range(len(y)):\n            if ey[k] > (y[k] - 1) and ex[k] > (x[k] - 1):\n                img_k = imgs[image_inds[k], :, (y[k] - 1):ey[k], (x[k] - 1):ex[k]].unsqueeze(0)\n                im_data.append(imresample(img_k, (24, 24)))\n        im_data = torch.cat(im_data, dim=0)\n        im_data = (im_data - 127.5) * 0.0078125\n        out = rnet(im_data)\n\n        out0 = out[0].permute(1, 0)\n        out1 = out[1].permute(1, 0)\n        score = out1[1, :]\n        ipass = score > threshold[1]\n        boxes = torch.cat((boxes[ipass, :4], score[ipass].unsqueeze(1)), dim=1)\n        image_inds = image_inds[ipass]\n        mv = out0[:, ipass].permute(1, 0)\n\n        # NMS within each image\n        pick = batched_nms(boxes[:, :4], boxes[:, 4], image_inds, 0.7)\n        boxes, image_inds, mv = boxes[pick], image_inds[pick], mv[pick]\n        boxes = bbreg(boxes, mv)\n        boxes = rerec(boxes)\n\n    # Third stage\n    points = torch.zeros(0, 5, 2, device=device)\n    if len(boxes) > 0:\n        y, ey, x, ex = pad(boxes, w, h)\n        im_data = []\n        for k in range(len(y)):\n            if ey[k] > (y[k] - 1) and ex[k] > (x[k] - 1):\n                img_k = imgs[image_inds[k], :, (y[k] - 1):ey[k], (x[k] - 1):ex[k]].unsqueeze(0)\n                im_data.append(imresample(img_k, (48, 48)))\n        im_data = torch.cat(im_data, dim=0)\n        im_data = (im_data - 127.5) * 0.0078125\n        out = onet(im_data)\n\n        out0 = out[0].permute(1, 0)\n        out1 = out[1].permute(1, 0)\n        out2 = out[2].permute(1, 0)\n        score = out2[1, :]\n        points = out1\n        ipass = score > threshold[2]\n        points = points[:, ipass]\n        boxes = torch.cat((boxes[ipass, :4], score[ipass].unsqueeze(1)), dim=1)\n        image_inds = image_inds[ipass]\n        mv = out0[:, ipass].permute(1, 0)\n\n        w_i = boxes[:, 2] - boxes[:, 0] + 1\n        h_i = boxes[:, 3] - boxes[:, 1] + 1\n        points_x = w_i.repeat(5, 1) * points[:5, :] + boxes[:, 0].repeat(5, 1) - 1\n        points_y = h_i.repeat(5, 1) * points[5:10, :] + boxes[:, 1].repeat(5, 1) - 1\n        points = torch.stack((points_x, points_y)).permute(2, 1, 0)\n        boxes = bbreg(boxes, mv)\n\n        # NMS within each image using ""Min"" strategy\n        # pick = batched_nms(boxes[:, :4], boxes[:, 4], image_inds, 0.7)\n        pick = batched_nms_numpy(boxes[:, :4], boxes[:, 4], image_inds, 0.7, \'Min\')\n        boxes, image_inds, points = boxes[pick], image_inds[pick], points[pick]\n\n    boxes = boxes.cpu().numpy()\n    points = points.cpu().numpy()\n\n    batch_boxes = []\n    batch_points = []\n    for b_i in range(batch_size):\n        b_i_inds = np.where(image_inds == b_i)\n        batch_boxes.append(boxes[b_i_inds].copy())\n        batch_points.append(points[b_i_inds].copy())\n\n    batch_boxes, batch_points = np.array(batch_boxes), np.array(batch_points)\n\n    return batch_boxes, batch_points\n\n\ndef bbreg(boundingbox, reg):\n    if reg.shape[1] == 1:\n        reg = torch.reshape(reg, (reg.shape[2], reg.shape[3]))\n\n    w = boundingbox[:, 2] - boundingbox[:, 0] + 1\n    h = boundingbox[:, 3] - boundingbox[:, 1] + 1\n    b1 = boundingbox[:, 0] + reg[:, 0] * w\n    b2 = boundingbox[:, 1] + reg[:, 1] * h\n    b3 = boundingbox[:, 2] + reg[:, 2] * w\n    b4 = boundingbox[:, 3] + reg[:, 3] * h\n    boundingbox[:, :4] = torch.stack([b1, b2, b3, b4]).permute(1, 0)\n\n    return boundingbox\n\n\ndef generateBoundingBox(reg, probs, scale, thresh):\n    stride = 2\n    cellsize = 12\n\n    reg = reg.permute(1, 0, 2, 3)\n\n    mask = probs >= thresh\n    mask_inds = mask.nonzero()\n    image_inds = mask_inds[:, 0]\n    score = probs[mask]\n    reg = reg[:, mask].permute(1, 0)\n    bb = mask_inds[:, 1:].type(reg.dtype).flip(1)\n    q1 = ((stride * bb + 1) / scale).floor()\n    q2 = ((stride * bb + cellsize - 1 + 1) / scale).floor()\n    boundingbox = torch.cat([q1, q2, score.unsqueeze(1), reg], dim=1)\n    return boundingbox, image_inds\n\n\ndef nms_numpy(boxes, scores, threshold, method):\n    if boxes.size == 0:\n        return np.empty((0, 3))\n\n    x1 = boxes[:, 0].copy()\n    y1 = boxes[:, 1].copy()\n    x2 = boxes[:, 2].copy()\n    y2 = boxes[:, 3].copy()\n    s = scores\n    area = (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    I = np.argsort(s)\n    pick = np.zeros_like(s, dtype=np.int16)\n    counter = 0\n    while I.size > 0:\n        i = I[-1]\n        pick[counter] = i\n        counter += 1\n        idx = I[0:-1]\n\n        xx1 = np.maximum(x1[i], x1[idx]).copy()\n        yy1 = np.maximum(y1[i], y1[idx]).copy()\n        xx2 = np.minimum(x2[i], x2[idx]).copy()\n        yy2 = np.minimum(y2[i], y2[idx]).copy()\n\n        w = np.maximum(0.0, xx2 - xx1 + 1).copy()\n        h = np.maximum(0.0, yy2 - yy1 + 1).copy()\n\n        inter = w * h\n        if method is ""Min"":\n            o = inter / np.minimum(area[i], area[idx])\n        else:\n            o = inter / (area[i] + area[idx] - inter)\n        I = I[np.where(o <= threshold)]\n\n    pick = pick[:counter].copy()\n    return pick\n\n\ndef batched_nms_numpy(boxes, scores, idxs, threshold, method):\n    device = boxes.device\n    if boxes.numel() == 0:\n        return torch.empty((0,), dtype=torch.int64, device=device)\n    # strategy: in order to perform NMS independently per class.\n    # we add an offset to all the boxes. The offset is dependent\n    # only on the class idx, and is large enough so that boxes\n    # from different classes do not overlap\n    max_coordinate = boxes.max()\n    offsets = idxs.to(boxes) * (max_coordinate + 1)\n    boxes_for_nms = boxes + offsets[:, None]\n    boxes_for_nms = boxes_for_nms.cpu().numpy()\n    scores = scores.cpu().numpy()\n    keep = nms_numpy(boxes_for_nms, scores, threshold, method)\n    return torch.as_tensor(keep, dtype=torch.long, device=device)\n\n\ndef pad(boxes, w, h):\n    boxes = boxes.trunc().int().cpu().numpy()\n    x = boxes[:, 0]\n    y = boxes[:, 1]\n    ex = boxes[:, 2]\n    ey = boxes[:, 3]\n\n    x[x < 1] = 1\n    y[y < 1] = 1\n    ex[ex > w] = w\n    ey[ey > h] = h\n\n    return y, ey, x, ex\n\n\ndef rerec(bboxA):\n    h = bboxA[:, 3] - bboxA[:, 1]\n    w = bboxA[:, 2] - bboxA[:, 0]\n    \n    l = torch.max(w, h)\n    bboxA[:, 0] = bboxA[:, 0] + w * 0.5 - l * 0.5\n    bboxA[:, 1] = bboxA[:, 1] + h * 0.5 - l * 0.5\n    bboxA[:, 2:4] = bboxA[:, :2] + l.repeat(2, 1).permute(1, 0)\n\n    return bboxA\n\n\ndef imresample(img, sz):\n    im_data = interpolate(img, size=sz, mode=""area"")\n    return im_data\n\n\ndef crop_resize(img, box, image_size):\n    if isinstance(img, np.ndarray):\n        out = cv2.resize(\n            img[box[1]:box[3], box[0]:box[2]],\n            (image_size, image_size),\n            interpolation=cv2.INTER_AREA\n        ).copy()\n    else:\n        out = img.crop(box).copy().resize((image_size, image_size), Image.BILINEAR)\n    return out\n\n\ndef save_img(img, path):\n    if isinstance(img, np.ndarray):\n        cv2.imwrite(path, cv2.cvtColor(img, cv2.COLOR_RGB2BGR))\n    else:\n        img.save(path)\n\n\ndef get_size(img):\n    if isinstance(img, np.ndarray):\n        return img.shape[1::-1]\n    else:\n        return img.size\n\n\ndef extract_face(img, box, image_size=160, margin=0, save_path=None):\n    """"""Extract face + margin from PIL Image given bounding box.\n    \n    Arguments:\n        img {PIL.Image} -- A PIL Image.\n        box {numpy.ndarray} -- Four-element bounding box.\n        image_size {int} -- Output image size in pixels. The image will be square.\n        margin {int} -- Margin to add to bounding box, in terms of pixels in the final image. \n            Note that the application of the margin differs slightly from the davidsandberg/facenet\n            repo, which applies the margin to the original image before resizing, making the margin\n            dependent on the original image size.\n        save_path {str} -- Save path for extracted face image. (default: {None})\n    \n    Returns:\n        torch.tensor -- tensor representing the extracted face.\n    """"""\n    margin = [\n        margin * (box[2] - box[0]) / (image_size - margin),\n        margin * (box[3] - box[1]) / (image_size - margin),\n    ]\n    raw_image_size = get_size(img)\n    box = [\n        int(max(box[0] - margin[0] / 2, 0)),\n        int(max(box[1] - margin[1] / 2, 0)),\n        int(min(box[2] + margin[0] / 2, raw_image_size[0])),\n        int(min(box[3] + margin[1] / 2, raw_image_size[1])),\n    ]\n\n    face = crop_resize(img, box, image_size)\n\n    if save_path is not None:\n        os.makedirs(os.path.dirname(save_path) + ""/"", exist_ok=True)\n        save_img(face, save_path)\n\n    face = F.to_tensor(np.float32(face))\n\n    return face\n'"
models/utils/tensorflow2pytorch.py,34,"b'import tensorflow as tf\nimport torch\nimport json\nimport os, sys\n\nfrom dependencies.facenet.src import facenet\nfrom dependencies.facenet.src.models import inception_resnet_v1 as tf_mdl\nfrom dependencies.facenet.src.align import detect_face\n\nfrom models.inception_resnet_v1 import InceptionResnetV1\nfrom models.mtcnn import PNet, RNet, ONet\n\n\ndef import_tf_params(tf_mdl_dir, sess):\n    """"""Import tensorflow model from save directory.\n    \n    Arguments:\n        tf_mdl_dir {str} -- Location of protobuf, checkpoint, meta files.\n        sess {tensorflow.Session} -- Tensorflow session object.\n    \n    Returns:\n        (list, list, list) -- Tuple of lists containing the layer names,\n            parameter arrays as numpy ndarrays, parameter shapes.\n    """"""\n    print(\'\\nLoading tensorflow model\\n\')\n    if callable(tf_mdl_dir):\n        tf_mdl_dir(sess)\n    else:\n        facenet.load_model(tf_mdl_dir)\n\n    print(\'\\nGetting model weights\\n\')\n    tf_layers = tf.trainable_variables()\n    tf_params = sess.run(tf_layers)\n\n    tf_shapes = [p.shape for p in tf_params]\n    tf_layers = [l.name for l in tf_layers]\n\n    if not callable(tf_mdl_dir):\n        path = os.path.join(tf_mdl_dir, \'layer_description.json\')\n    else:\n        path = \'data/layer_description.json\'\n    with open(path, \'w\') as f:\n        json.dump({l: s for l, s in zip(tf_layers, tf_shapes)}, f)\n\n    return tf_layers, tf_params, tf_shapes\n\n\ndef get_layer_indices(layer_lookup, tf_layers):\n    """"""Giving a lookup of model layer attribute names and tensorflow variable names,\n    find matching parameters.\n    \n    Arguments:\n        layer_lookup {dict} -- Dictionary mapping pytorch attribute names to (partial)\n            tensorflow variable names. Expects dict of the form {\'attr\': [\'tf_name\', ...]}\n            where the \'...\'s are ignored.\n        tf_layers {list} -- List of tensorflow variable names.\n    \n    Returns:\n        list -- The input dictionary with the list of matching inds appended to each item.\n    """"""\n    layer_inds = {}\n    for name, value in layer_lookup.items():\n        layer_inds[name] = value + [[i for i, n in enumerate(tf_layers) if value[0] in n]]\n    return layer_inds\n\n\ndef load_tf_batchNorm(weights, layer):\n    """"""Load tensorflow weights into nn.BatchNorm object.\n    \n    Arguments:\n        weights {list} -- Tensorflow parameters.\n        layer {torch.nn.Module} -- nn.BatchNorm.\n    """"""\n    layer.bias.data = torch.tensor(weights[0]).view(layer.bias.data.shape)\n    layer.weight.data = torch.ones_like(layer.weight.data)\n    layer.running_mean = torch.tensor(weights[1]).view(layer.running_mean.shape)\n    layer.running_var = torch.tensor(weights[2]).view(layer.running_var.shape)\n\n\ndef load_tf_conv2d(weights, layer, transpose=False):\n    """"""Load tensorflow weights into nn.Conv2d object.\n    \n    Arguments:\n        weights {list} -- Tensorflow parameters.\n        layer {torch.nn.Module} -- nn.Conv2d.\n    """"""\n    if isinstance(weights, list):\n        if len(weights) == 2:\n            layer.bias.data = (\n                torch.tensor(weights[1])\n                    .view(layer.bias.data.shape)\n            )\n        weights = weights[0]\n    \n    if transpose:\n        dim_order = (3, 2, 1, 0)\n    else:\n        dim_order = (3, 2, 0, 1)\n\n    layer.weight.data = (\n        torch.tensor(weights)\n            .permute(dim_order)\n            .view(layer.weight.data.shape)\n    )\n\n\ndef load_tf_conv2d_trans(weights, layer):\n    return load_tf_conv2d(weights, layer, transpose=True)\n\n\ndef load_tf_basicConv2d(weights, layer):\n    """"""Load tensorflow weights into grouped Conv2d+BatchNorm object.\n    \n    Arguments:\n        weights {list} -- Tensorflow parameters.\n        layer {torch.nn.Module} -- Object containing Conv2d+BatchNorm.\n    """"""\n    load_tf_conv2d(weights[0], layer.conv)\n    load_tf_batchNorm(weights[1:], layer.bn)\n\n\ndef load_tf_linear(weights, layer):\n    """"""Load tensorflow weights into nn.Linear object.\n    \n    Arguments:\n        weights {list} -- Tensorflow parameters.\n        layer {torch.nn.Module} -- nn.Linear.\n    """"""\n    if isinstance(weights, list):\n        if len(weights) == 2:\n            layer.bias.data = (\n                torch.tensor(weights[1])\n                    .view(layer.bias.data.shape)\n            )\n        weights = weights[0]\n    layer.weight.data = (\n        torch.tensor(weights)\n            .transpose(-1, 0)\n            .view(layer.weight.data.shape)\n    )\n\n\n# High-level parameter-loading functions:\n\ndef load_tf_block35(weights, layer):\n    load_tf_basicConv2d(weights[:4], layer.branch0)\n    load_tf_basicConv2d(weights[4:8], layer.branch1[0])\n    load_tf_basicConv2d(weights[8:12], layer.branch1[1])\n    load_tf_basicConv2d(weights[12:16], layer.branch2[0])\n    load_tf_basicConv2d(weights[16:20], layer.branch2[1])\n    load_tf_basicConv2d(weights[20:24], layer.branch2[2])\n    load_tf_conv2d(weights[24:26], layer.conv2d)\n\n\ndef load_tf_block17_8(weights, layer):\n    load_tf_basicConv2d(weights[:4], layer.branch0)\n    load_tf_basicConv2d(weights[4:8], layer.branch1[0])\n    load_tf_basicConv2d(weights[8:12], layer.branch1[1])\n    load_tf_basicConv2d(weights[12:16], layer.branch1[2])\n    load_tf_conv2d(weights[16:18], layer.conv2d)\n\n\ndef load_tf_mixed6a(weights, layer):\n    if len(weights) != 16:\n        raise ValueError(f\'Number of weight arrays ({len(weights)}) not equal to 16\')\n    load_tf_basicConv2d(weights[:4], layer.branch0)\n    load_tf_basicConv2d(weights[4:8], layer.branch1[0])\n    load_tf_basicConv2d(weights[8:12], layer.branch1[1])\n    load_tf_basicConv2d(weights[12:16], layer.branch1[2])\n\n\ndef load_tf_mixed7a(weights, layer):\n    if len(weights) != 28:\n        raise ValueError(f\'Number of weight arrays ({len(weights)}) not equal to 28\')\n    load_tf_basicConv2d(weights[:4], layer.branch0[0])\n    load_tf_basicConv2d(weights[4:8], layer.branch0[1])\n    load_tf_basicConv2d(weights[8:12], layer.branch1[0])\n    load_tf_basicConv2d(weights[12:16], layer.branch1[1])\n    load_tf_basicConv2d(weights[16:20], layer.branch2[0])\n    load_tf_basicConv2d(weights[20:24], layer.branch2[1])\n    load_tf_basicConv2d(weights[24:28], layer.branch2[2])\n\n\ndef load_tf_repeats(weights, layer, rptlen, subfun):\n    if len(weights) % rptlen != 0:\n        raise ValueError(f\'Number of weight arrays ({len(weights)}) not divisible by {rptlen}\')\n    weights_split = [weights[i:i+rptlen] for i in range(0, len(weights), rptlen)]\n    for i, w in enumerate(weights_split):\n        subfun(w, getattr(layer, str(i)))\n\n\ndef load_tf_repeat_1(weights, layer):\n    load_tf_repeats(weights, layer, 26, load_tf_block35)\n\n\ndef load_tf_repeat_2(weights, layer):\n    load_tf_repeats(weights, layer, 18, load_tf_block17_8)\n\n\ndef load_tf_repeat_3(weights, layer):\n    load_tf_repeats(weights, layer, 18, load_tf_block17_8)\n\n\ndef test_loaded_params(mdl, tf_params, tf_layers):\n    """"""Check each parameter in a pytorch model for an equivalent parameter\n    in a list of tensorflow variables.\n    \n    Arguments:\n        mdl {torch.nn.Module} -- Pytorch model.\n        tf_params {list} -- List of ndarrays representing tensorflow variables.\n        tf_layers {list} -- Corresponding list of tensorflow variable names.\n    """"""\n    tf_means = torch.stack([torch.tensor(p).mean() for p in tf_params])\n    for name, param in mdl.named_parameters():\n        pt_mean = param.data.mean()\n        matching_inds = ((tf_means - pt_mean).abs() < 1e-8).nonzero()\n        print(f\'{name} equivalent to {[tf_layers[i] for i in matching_inds]}\')\n\n\ndef compare_model_outputs(pt_mdl, sess, test_data):\n    """"""Given some testing data, compare the output of pytorch and tensorflow models.\n    \n    Arguments:\n        pt_mdl {torch.nn.Module} -- Pytorch model.\n        sess {tensorflow.Session} -- Tensorflow session object.\n        test_data {torch.Tensor} -- Pytorch tensor.\n    """"""\n    print(\'\\nPassing test data through TF model\\n\')\n    if isinstance(sess, tf.Session):\n        images_placeholder = tf.get_default_graph().get_tensor_by_name(""input:0"")\n        phase_train_placeholder = tf.get_default_graph().get_tensor_by_name(""phase_train:0"")\n        embeddings = tf.get_default_graph().get_tensor_by_name(""embeddings:0"")\n        feed_dict = {images_placeholder: test_data.numpy(), phase_train_placeholder: False}\n        tf_output = torch.tensor(sess.run(embeddings, feed_dict=feed_dict))\n    else:\n        tf_output = sess(test_data)\n\n    print(tf_output)\n\n    print(\'\\nPassing test data through PT model\\n\')\n    pt_output = pt_mdl(test_data.permute(0, 3, 1, 2))\n    print(pt_output)\n\n    distance = (tf_output - pt_output).norm()\n    print(f\'\\nDistance {distance}\\n\')\n\n\ndef compare_mtcnn(pt_mdl, tf_fun, sess, ind, test_data):\n    tf_mdls = tf_fun(sess)\n    tf_mdl = tf_mdls[ind]\n\n    print(\'\\nPassing test data through TF model\\n\')\n    tf_output = tf_mdl(test_data.numpy())\n    tf_output = [torch.tensor(out) for out in tf_output]\n    print(\'\\n\'.join([str(o.view(-1)[:10]) for o in tf_output]))\n\n    print(\'\\nPassing test data through PT model\\n\')\n    with torch.no_grad():\n        pt_output = pt_mdl(test_data.permute(0, 3, 2, 1))\n    pt_output = [torch.tensor(out) for out in pt_output]\n    for i in range(len(pt_output)):\n        if len(pt_output[i].shape) == 4:\n            pt_output[i] = pt_output[i].permute(0, 3, 2, 1).contiguous()\n    print(\'\\n\'.join([str(o.view(-1)[:10]) for o in pt_output]))\n\n    distance = [(tf_o - pt_o).norm() for tf_o, pt_o in zip(tf_output, pt_output)]\n    print(f\'\\nDistance {distance}\\n\')\n\n\ndef load_tf_model_weights(mdl, layer_lookup, tf_mdl_dir, is_resnet=True, arg_num=None):\n    """"""Load tensorflow parameters into a pytorch model.\n    \n    Arguments:\n        mdl {torch.nn.Module} -- Pytorch model.\n        layer_lookup {[type]} -- Dictionary mapping pytorch attribute names to (partial)\n            tensorflow variable names, and a function suitable for loading weights.\n            Expects dict of the form {\'attr\': [\'tf_name\', function]}. \n        tf_mdl_dir {str} -- Location of protobuf, checkpoint, meta files.\n    """"""\n    tf.reset_default_graph()\n    with tf.Session() as sess:\n        tf_layers, tf_params, tf_shapes = import_tf_params(tf_mdl_dir, sess)\n        layer_info = get_layer_indices(layer_lookup, tf_layers)\n\n        for layer_name, info in layer_info.items():\n            print(f\'Loading {info[0]}/* into {layer_name}\')\n            weights = [tf_params[i] for i in info[2]]\n            layer = getattr(mdl, layer_name)\n            info[1](weights, layer)\n\n        test_loaded_params(mdl, tf_params, tf_layers)\n\n        if is_resnet:\n            compare_model_outputs(mdl, sess, torch.randn(5, 160, 160, 3).detach())\n\n\ndef tensorflow2pytorch():\n    lookup_inception_resnet_v1 = {\n        \'conv2d_1a\': [\'InceptionResnetV1/Conv2d_1a_3x3\', load_tf_basicConv2d],\n        \'conv2d_2a\': [\'InceptionResnetV1/Conv2d_2a_3x3\', load_tf_basicConv2d],\n        \'conv2d_2b\': [\'InceptionResnetV1/Conv2d_2b_3x3\', load_tf_basicConv2d],\n        \'conv2d_3b\': [\'InceptionResnetV1/Conv2d_3b_1x1\', load_tf_basicConv2d],\n        \'conv2d_4a\': [\'InceptionResnetV1/Conv2d_4a_3x3\', load_tf_basicConv2d],\n        \'conv2d_4b\': [\'InceptionResnetV1/Conv2d_4b_3x3\', load_tf_basicConv2d],\n        \'repeat_1\': [\'InceptionResnetV1/Repeat/block35\', load_tf_repeat_1],\n        \'mixed_6a\': [\'InceptionResnetV1/Mixed_6a\', load_tf_mixed6a],\n        \'repeat_2\': [\'InceptionResnetV1/Repeat_1/block17\', load_tf_repeat_2],\n        \'mixed_7a\': [\'InceptionResnetV1/Mixed_7a\', load_tf_mixed7a],\n        \'repeat_3\': [\'InceptionResnetV1/Repeat_2/block8\', load_tf_repeat_3],\n        \'block8\': [\'InceptionResnetV1/Block8\', load_tf_block17_8],\n        \'last_linear\': [\'InceptionResnetV1/Bottleneck/weights\', load_tf_linear],\n        \'last_bn\': [\'InceptionResnetV1/Bottleneck/BatchNorm\', load_tf_batchNorm],\n        \'logits\': [\'Logits\', load_tf_linear],\n    }\n\n    print(\'\\nLoad VGGFace2-trained weights and save\\n\')\n    mdl = InceptionResnetV1(num_classes=8631).eval()\n    tf_mdl_dir = \'data/20180402-114759\'\n    data_name = \'vggface2\'\n    load_tf_model_weights(mdl, lookup_inception_resnet_v1, tf_mdl_dir)\n    state_dict = mdl.state_dict()\n    torch.save(state_dict, f\'{tf_mdl_dir}-{data_name}.pt\')    \n    torch.save(\n        {\n            \'logits.weight\': state_dict[\'logits.weight\'],\n            \'logits.bias\': state_dict[\'logits.bias\'],\n        },\n        f\'{tf_mdl_dir}-{data_name}-logits.pt\'\n    )\n    state_dict.pop(\'logits.weight\')\n    state_dict.pop(\'logits.bias\')\n    torch.save(state_dict, f\'{tf_mdl_dir}-{data_name}-features.pt\')\n    \n    print(\'\\nLoad CASIA-Webface-trained weights and save\\n\')\n    mdl = InceptionResnetV1(num_classes=10575).eval()\n    tf_mdl_dir = \'data/20180408-102900\'\n    data_name = \'casia-webface\'\n    load_tf_model_weights(mdl, lookup_inception_resnet_v1, tf_mdl_dir)\n    state_dict = mdl.state_dict()\n    torch.save(state_dict, f\'{tf_mdl_dir}-{data_name}.pt\')    \n    torch.save(\n        {\n            \'logits.weight\': state_dict[\'logits.weight\'],\n            \'logits.bias\': state_dict[\'logits.bias\'],\n        },\n        f\'{tf_mdl_dir}-{data_name}-logits.pt\'\n    )\n    state_dict.pop(\'logits.weight\')\n    state_dict.pop(\'logits.bias\')\n    torch.save(state_dict, f\'{tf_mdl_dir}-{data_name}-features.pt\')\n    \n    lookup_pnet = {\n        \'conv1\': [\'pnet/conv1\', load_tf_conv2d_trans],\n        \'prelu1\': [\'pnet/PReLU1\', load_tf_linear],\n        \'conv2\': [\'pnet/conv2\', load_tf_conv2d_trans],\n        \'prelu2\': [\'pnet/PReLU2\', load_tf_linear],\n        \'conv3\': [\'pnet/conv3\', load_tf_conv2d_trans],\n        \'prelu3\': [\'pnet/PReLU3\', load_tf_linear],\n        \'conv4_1\': [\'pnet/conv4-1\', load_tf_conv2d_trans],\n        \'conv4_2\': [\'pnet/conv4-2\', load_tf_conv2d_trans],\n    }\n    lookup_rnet = {\n        \'conv1\': [\'rnet/conv1\', load_tf_conv2d_trans],\n        \'prelu1\': [\'rnet/prelu1\', load_tf_linear],\n        \'conv2\': [\'rnet/conv2\', load_tf_conv2d_trans],\n        \'prelu2\': [\'rnet/prelu2\', load_tf_linear],\n        \'conv3\': [\'rnet/conv3\', load_tf_conv2d_trans],\n        \'prelu3\': [\'rnet/prelu3\', load_tf_linear],\n        \'dense4\': [\'rnet/conv4\', load_tf_linear],\n        \'prelu4\': [\'rnet/prelu4\', load_tf_linear],\n        \'dense5_1\': [\'rnet/conv5-1\', load_tf_linear],\n        \'dense5_2\': [\'rnet/conv5-2\', load_tf_linear],\n    }\n    lookup_onet = {\n        \'conv1\': [\'onet/conv1\', load_tf_conv2d_trans],\n        \'prelu1\': [\'onet/prelu1\', load_tf_linear],\n        \'conv2\': [\'onet/conv2\', load_tf_conv2d_trans],\n        \'prelu2\': [\'onet/prelu2\', load_tf_linear],\n        \'conv3\': [\'onet/conv3\', load_tf_conv2d_trans],\n        \'prelu3\': [\'onet/prelu3\', load_tf_linear],\n        \'conv4\': [\'onet/conv4\', load_tf_conv2d_trans],\n        \'prelu4\': [\'onet/prelu4\', load_tf_linear],\n        \'dense5\': [\'onet/conv5\', load_tf_linear],\n        \'prelu5\': [\'onet/prelu5\', load_tf_linear],\n        \'dense6_1\': [\'onet/conv6-1\', load_tf_linear],\n        \'dense6_2\': [\'onet/conv6-2\', load_tf_linear],\n        \'dense6_3\': [\'onet/conv6-3\', load_tf_linear],\n    }\n\n    print(\'\\nLoad PNet weights and save\\n\')\n    tf_mdl_dir = lambda sess: detect_face.create_mtcnn(sess, None)\n    mdl = PNet()\n    data_name = \'pnet\'\n    load_tf_model_weights(mdl, lookup_pnet, tf_mdl_dir, is_resnet=False, arg_num=0)\n    torch.save(mdl.state_dict(), f\'data/{data_name}.pt\')\n    tf.reset_default_graph()\n    with tf.Session() as sess:\n        compare_mtcnn(mdl, tf_mdl_dir, sess, 0, torch.randn(1, 256, 256, 3).detach())\n\n    print(\'\\nLoad RNet weights and save\\n\')\n    mdl = RNet()\n    data_name = \'rnet\'\n    load_tf_model_weights(mdl, lookup_rnet, tf_mdl_dir, is_resnet=False, arg_num=1)\n    torch.save(mdl.state_dict(), f\'data/{data_name}.pt\')\n    tf.reset_default_graph()\n    with tf.Session() as sess:\n        compare_mtcnn(mdl, tf_mdl_dir, sess, 1, torch.randn(1, 24, 24, 3).detach())\n\n    print(\'\\nLoad ONet weights and save\\n\')\n    mdl = ONet()\n    data_name = \'onet\'\n    load_tf_model_weights(mdl, lookup_onet, tf_mdl_dir, is_resnet=False, arg_num=2)\n    torch.save(mdl.state_dict(), f\'data/{data_name}.pt\')\n    tf.reset_default_graph()\n    with tf.Session() as sess:\n        compare_mtcnn(mdl, tf_mdl_dir, sess, 2, torch.randn(1, 48, 48, 3).detach())\n'"
models/utils/training.py,9,"b'import torch\nimport numpy as np\nimport time\n\n\nclass Logger(object):\n\n    def __init__(self, mode, length, calculate_mean=False):\n        self.mode = mode\n        self.length = length\n        self.calculate_mean = calculate_mean\n        if self.calculate_mean:\n            self.fn = lambda x, i: x / (i + 1)\n        else:\n            self.fn = lambda x, i: x\n\n    def __call__(self, loss, metrics, i):\n        track_str = \'\\r{} | {:5d}/{:<5d}| \'.format(self.mode, i + 1, self.length)\n        loss_str = \'loss: {:9.4f} | \'.format(self.fn(loss, i))\n        metric_str = \' | \'.join(\'{}: {:9.4f}\'.format(k, self.fn(v, i)) for k, v in metrics.items())\n        print(track_str + loss_str + metric_str + \'   \', end=\'\')\n        if i + 1 == self.length:\n            print(\'\')\n\n\nclass BatchTimer(object):\n    """"""Batch timing class.\n    Use this class for tracking training and testing time/rate per batch or per sample.\n    \n    Keyword Arguments:\n        rate {bool} -- Whether to report a rate (batches or samples per second) or a time (seconds\n            per batch or sample). (default: {True})\n        per_sample {bool} -- Whether to report times or rates per sample or per batch.\n            (default: {True})\n    """"""\n\n    def __init__(self, rate=True, per_sample=True):\n        self.start = time.time()\n        self.end = None\n        self.rate = rate\n        self.per_sample = per_sample\n\n    def __call__(self, y_pred, y):\n        self.end = time.time()\n        elapsed = self.end - self.start\n        self.start = self.end\n        self.end = None\n\n        if self.per_sample:\n            elapsed /= len(y_pred)\n        if self.rate:\n            elapsed = 1 / elapsed\n\n        return torch.tensor(elapsed)\n\n\ndef accuracy(logits, y):\n    _, preds = torch.max(logits, 1)\n    return (preds == y).float().mean()\n\n\ndef pass_epoch(\n    model, loss_fn, loader, optimizer=None, scheduler=None,\n    batch_metrics={\'time\': BatchTimer()}, show_running=True,\n    device=\'cpu\', writer=None\n):\n    """"""Train or evaluate over a data epoch.\n    \n    Arguments:\n        model {torch.nn.Module} -- Pytorch model.\n        loss_fn {callable} -- A function to compute (scalar) loss.\n        loader {torch.utils.data.DataLoader} -- A pytorch data loader.\n    \n    Keyword Arguments:\n        optimizer {torch.optim.Optimizer} -- A pytorch optimizer.\n        scheduler {torch.optim.lr_scheduler._LRScheduler} -- LR scheduler (default: {None})\n        batch_metrics {dict} -- Dictionary of metric functions to call on each batch. The default\n            is a simple timer. A progressive average of these metrics, along with the average\n            loss, is printed every batch. (default: {{\'time\': iter_timer()}})\n        show_running {bool} -- Whether or not to print losses and metrics for the current batch\n            or rolling averages. (default: {False})\n        device {str or torch.device} -- Device for pytorch to use. (default: {\'cpu\'})\n        writer {torch.utils.tensorboard.SummaryWriter} -- Tensorboard SummaryWriter. (default: {None})\n    \n    Returns:\n        tuple(torch.Tensor, dict) -- A tuple of the average loss and a dictionary of average\n            metric values across the epoch.\n    """"""\n    \n    mode = \'Train\' if model.training else \'Valid\'\n    logger = Logger(mode, length=len(loader), calculate_mean=show_running)\n    loss = 0\n    metrics = {}\n\n    for i_batch, (x, y) in enumerate(loader):\n        x = x.to(device)\n        y = y.to(device)\n        y_pred = model(x)\n        loss_batch = loss_fn(y_pred, y)\n\n        if model.training:\n            loss_batch.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n\n        metrics_batch = {}\n        for metric_name, metric_fn in batch_metrics.items():\n            metrics_batch[metric_name] = metric_fn(y_pred, y).detach().cpu()\n            metrics[metric_name] = metrics.get(metric_name, 0) + metrics_batch[metric_name]\n            \n        if writer is not None and model.training:\n            if writer.iteration % writer.interval == 0:\n                writer.add_scalars(\'loss\', {mode: loss_batch.detach().cpu()}, writer.iteration)\n                for metric_name, metric_batch in metrics_batch.items():\n                    writer.add_scalars(metric_name, {mode: metric_batch}, writer.iteration)\n            writer.iteration += 1\n        \n        loss_batch = loss_batch.detach().cpu()\n        loss += loss_batch\n        if show_running:\n            logger(loss, metrics, i_batch)\n        else:\n            logger(loss_batch, metrics_batch, i_batch)\n    \n    if model.training and scheduler is not None:\n        scheduler.step()\n\n    loss = loss / (i_batch + 1)\n    metrics = {k: v / (i_batch + 1) for k, v in metrics.items()}\n            \n    if writer is not None and not model.training:\n        writer.add_scalars(\'loss\', {mode: loss.detach()}, writer.iteration)\n        for metric_name, metric in metrics.items():\n            writer.add_scalars(metric_name, {mode: metric})\n\n    return loss, metrics\n\n\ndef collate_pil(x): \n    out_x, out_y = [], [] \n    for xx, yy in x: \n        out_x.append(xx) \n        out_y.append(yy) \n    return out_x, out_y \n'"
