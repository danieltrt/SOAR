file_path,api_count,code
setup.py,0,"b""import sys\nfrom setuptools import setup\n\nsetup(\n    name='wavelets_pytorch',\n    version='0.1',\n    author='Tom Runia',\n    author_email='tomrunia@gmail.com',\n    url='https://github.com/tomrunia/PyTorchWavelets',\n    description='Wavelet Transform in PyTorch',\n    long_description='Fast CPU/CUDA implementation of the Continuous Wavelet Transform in PyTorch.',\n    license='MIT',\n    packages=['wavelets_pytorch'],\n    scripts=[]\n)"""
examples/__init__.py,0,"b'# MIT License\n#\n# Copyright (c) 2017 Tom Runia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function'"
examples/benchmark.py,3,"b'# MIT License\n# \n# Copyright (c) 2018 Tom Runia\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport time\nimport numpy as np\n\nfrom wavelets_pytorch.transform import WaveletTransform\nfrom wavelets_pytorch.transform import WaveletTransformTorch\n\n######################################\n\nfps = 20\ndt  = 1.0/fps\ndj  = 0.125\nunbias = False\nt_min = 0\n\nbatch_sizes = np.asarray([1,8,16,32,64,128,256,512], np.int32)\ndurations = np.asarray([5,10,25,50,100], np.int32)\nsignal_lengths = durations*fps\n\nnum_runs = 5\n\nruntimes_scipy = np.zeros((len(batch_sizes), len(signal_lengths), num_runs), np.float32)\nruntimes_torch = np.zeros((len(batch_sizes), len(signal_lengths), num_runs), np.float32)\n\nfor batch_ind, batch_size in enumerate(batch_sizes):\n\n    for length_ind, t_max in enumerate(durations):\n\n        t = np.linspace(t_min, t_max, (t_max-t_min)*fps)\n        print(\'#\'*60)\n        print(\'Benchmarking | BatchSize = {}, SignalLength = {}\'.format(batch_size, signal_lengths[length_ind]))\n\n        for run_ind in range(num_runs):\n\n            random_frequencies = np.random.uniform(-0.5, 4.0, size=batch_size)\n            batch = np.asarray([np.sin(2*np.pi*f*t) for f in random_frequencies])\n\n            # Perform batch computation of SciPy implementation\n            t_start = time.time()\n            wa = WaveletTransform(dt, dj, unbias=unbias)\n            power = wa.power(batch)\n            runtimes_scipy[batch_ind,length_ind,run_ind] = time.time() - t_start\n            #print(""  Run {}/{} | SciPy: {:.2f}s"".format(run_ind+1, num_runs, runtimes[batch_ind,length_ind,run_ind,0]))\n\n            # Perform batch computation of Torch implementation\n            t_start = time.time()\n            wa = WaveletTransformTorch(dt, dj, unbias=unbias)\n            power = wa.power(batch)\n            runtimes_torch[batch_ind,length_ind,run_ind] = time.time() - t_start\n            #print(""  Run {}/{} | Torch: {:.2f}s"".format(run_ind+1, num_runs, runtimes[batch_ind,length_ind,run_ind,1]))\n\n        avg_scipy = np.mean(runtimes_scipy[batch_ind,length_ind,:])\n        avg_torch = np.mean(runtimes_torch[batch_ind,length_ind,:])\n        print(\'  Average SciPy: {:.2f}s\'.format(avg_scipy))\n        print(\'  Average Torch: {:.2f}s\'.format(avg_torch))\n\nnp.save(\'./runtimes_scipy.npy\', runtimes_scipy)\nnp.save(\'./runtimes_torch.npy\', runtimes_torch)\n'"
examples/plot.py,0,"b'# MIT License\n# \n# Copyright (c) 2018 Tom Runia\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n\ndef plot_scalogram(power, scales, t, normalize_columns=True, cmap=None, ax=None, scale_legend=True):\n    """"""\n    Plot the wavelet power spectrum (scalogram).\n\n    :param power: np.ndarray, CWT power spectrum of shape [n_scales,signal_length]\n    :param scales: np.ndarray, scale distribution of shape [n_scales]\n    :param t: np.ndarray, temporal range of shape [signal_length]\n    :param normalize_columns: boolean, whether to normalize spectrum per timestep\n    :param cmap: matplotlib cmap, please refer to their documentation\n    :param ax: matplotlib axis object, if None creates a new subplot\n    :param scale_legend: boolean, whether to include scale legend on the right\n    :return: ax, matplotlib axis object that contains the scalogram\n    """"""\n\n    if not cmap: cmap = plt.get_cmap(""PuBu_r"")\n    if ax is None: fig, ax = plt.subplots()\n    if normalize_columns: power = power/np.max(power, axis=0)\n\n    T, S = np.meshgrid(t, scales)\n    cnt = ax.contourf(T, S, power, 100, cmap=cmap)\n\n    # Fix for saving as PDF (aliasing)\n    for c in cnt.collections:\n        c.set_edgecolor(""face"")\n\n    ax.set_yscale(\'log\')\n    ax.set_ylabel(""Scale (Log Scale)"")\n    ax.set_xlabel(""Time (s)"")\n    ax.set_title(""Wavelet Power Spectrum"")\n\n    if scale_legend:\n        def format_axes_label(x, pos):\n            return ""{:.2f}"".format(x)\n        divider = make_axes_locatable(ax)\n        cax = divider.append_axes(""right"", size=""5%"", pad=0.05)\n        plt.colorbar(cnt, cax=cax, ticks=[np.min(power), 0, np.max(power)],\n                     format=ticker.FuncFormatter(format_axes_label))\n\n    return ax'"
examples/plot_comparison.py,4,"b'# MIT License\n# \n# Copyright (c) 2018 Tom Runia\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom wavelets_pytorch.wavelets import Morlet, Ricker, DOG\nfrom wavelets_pytorch.transform import WaveletTransform, WaveletTransformTorch\nfrom examples.plot import plot_scalogram\n\n""""""\nExample script to plot SciPy and PyTorch implementation outputs side-to-side.\n""""""\n\nfps = 20\ndt  = 1.0/fps\ndj  = 0.125\nunbias = False\nbatch_size = 32\nwavelet = Morlet(w0=6)\n\nt_min = 0\nt_max = 10\nt = np.linspace(t_min, t_max, (t_max-t_min)*fps)\n\n######################################\n# Generating batch of random sinusoidals\n\nrandom_frequencies = np.random.uniform(0.5, 4.0, size=batch_size)\nbatch  = np.asarray([np.sin(2*np.pi*f*t) for f in random_frequencies])\nbatch += np.random.normal(0, 0.2, batch.shape)  # Gaussian noise\n\n######################################\n# Performing wavelet transform\n\nwa = WaveletTransform(dt, dj, wavelet, unbias=unbias)\nwa_torch = WaveletTransformTorch(dt, dj, wavelet, unbias=unbias, cuda=True)\n\npower = wa.power(batch)\npower_torch = wa_torch.power(batch)\n\n######################################\n# Plotting\n\nfig, ax = plt.subplots(1, 3, figsize=(12,3))\nax = ax.flatten()\nax[0].plot(t, batch[0])\nax[0].set_title(r\'$f(t) = \\sin(2\\pi \\cdot f t) + \\mathcal{N}(\\mu,\\,\\sigma^{2})$\')\nax[0].set_xlabel(\'Time (s)\')\n\n# Plot scalogram for SciPy implementation\nplot_scalogram(power[0], wa.fourier_periods, t, ax=ax[1], scale_legend=False)\nax[1].axhline(1.0 / random_frequencies[0], lw=1, color=\'k\')\nax[1].set_title(\'Scalogram (SciPy)\'.format(1.0/random_frequencies[0]))\n\n# Plot scalogram for PyTorch implementation\nplot_scalogram(power_torch[0], wa_torch.fourier_periods, t, ax=ax[2])\nax[2].axhline(1.0 / random_frequencies[0], lw=1, color=\'k\')\nax[2].set_title(\'Scalogram (Torch)\'.format(1.0/random_frequencies[0]))\nax[2].set_ylabel(\'\')\nax[2].set_yticks([])\n\nplt.tight_layout()\nplt.show()'"
examples/simple_example.py,5,"b'# MIT License\n#\n# Copyright (c) 2018 Tom Runia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nfrom wavelets_pytorch.transform import WaveletTransform        # SciPy version\nfrom wavelets_pytorch.transform import WaveletTransformTorch   # PyTorch version\n\nfrom wavelets_pytorch.wavelets import Morlet, Ricker\n\n""""""\nExample script to demonstrate the CWT on a batch of random sinusoidal signals. \nWe compare both the SciPy implementation and the PyTorch implementation. \n""""""\n\ndt = 0.1               # sampling frequency\ndj = 0.125             # scale distribution parameter\nbatch_size = 32        # how many signals to process in parallel\ncuda = True            # enable GPU\n\nt = np.linspace(0., 10., int(10./dt))\n\n# Both use a complex and real wavelet\nfor wavelet in [Morlet(), Ricker()]:\n\n    # Sinusoidals with random frequency\n    frequencies = np.random.uniform(-0.5, 2.0, size=batch_size)\n    batch = np.asarray([np.sin(2*np.pi*f*t) for f in frequencies])\n\n    # Initialize wavelet filter banks (scipy and torch implementation)\n    wa_scipy = WaveletTransform(dt, dj, wavelet)\n    wa_torch = WaveletTransformTorch(dt, dj, wavelet, cuda=cuda)\n\n    # Performing wavelet transform (and compute scalogram)\n    cwt_scipy = wa_scipy.cwt(batch)\n    cwt_torch = wa_torch.cwt(batch)\n\n    print(cwt_scipy.shape)\n    print(cwt_torch.shape)\n\n    # For plotting, see the examples/plot.py function.\n    # ...'"
wavelets_pytorch/__init__.py,0,"b'# MIT License\n#\n# Copyright (c) 2017 Tom Runia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function'"
wavelets_pytorch/network.py,5,"b'# MIT License\n# \n# Copyright (c) 2018 Tom Runia\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-16\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\n\n\nclass TorchFilterBank(nn.Module):\n\n    def __init__(self, filters=None, cuda=True):\n        """"""\n        Temporal filter bank in PyTorch storing a collection of nn.Conv1d filters.\n        When cuda=True, the convolutions are performed on the GPU. If initialized with\n        filters=None, the set_filters() method has to be called before actual running\n        the convolutions.\n\n        :param filters: list, collection of variable sized 1D filters (default: [])\n        :param cuda: boolean, whether to run on GPU or not (default: True)\n        """"""\n        super(TorchFilterBank, self).__init__()\n        self._cuda = cuda\n        self._filters = [] if not filters else self.set_filters(filters)\n\n    def forward(self, x):\n        """"""\n        Takes a batch of signals and convoles each signal with all elements in the filter\n        bank. After convoling the entire filter bank, the method returns a tensor of\n        shape [N,N_scales,1/2,T] where the 1/2 number of channels depends on whether\n        the filter bank is composed of real or complex filters. If the filters are\n        complex the 2 channels represent [real, imag] parts.\n\n        :param x: torch.Variable, batch of input signals of shape [N,1,T]\n        :return: torch.Variable, batch of outputs of size [N,N_scales,1/2,T]\n        """"""\n\n        if not self._filters:\n            raise ValueError(\'PyTorch filters not initialized. Please call set_filters() first.\')\n            return None\n        results = [None]*len(self._filters)\n        for ind, conv in enumerate(self._filters):\n            results[ind] = conv(x)\n        results = torch.stack(results)     # [n_scales,n_batch,2,t]\n        results = results.permute(1,0,2,3) # [n_batch,n_scales,2,t]\n        return results\n\n    def set_filters(self, filters, padding_type=\'SAME\'):\n        """"""\n        Given a list of temporal 1D filters of variable size, this method creates a\n        list of nn.conv1d objects that collectively form the filter bank.\n\n        :param filters: list, collection of filters each a np.ndarray\n        :param padding_type: str, should be SAME or VALID\n        :return:\n        """"""\n\n        assert isinstance(filters, list)\n        assert padding_type in [\'SAME\', \'VALID\']\n\n        self._filters = [None]*len(filters)\n        for ind, filt in enumerate(filters):\n\n            assert filt.dtype in (np.float32, np.float64, np.complex64, np.complex128)\n\n            if np.iscomplex(filt).any():\n                chn_out = 2\n                filt_weights = np.asarray([np.real(filt), np.imag(filt)], np.float32)\n            else:\n                chn_out = 1\n                filt_weights = filt.astype(np.float32)[None,:]\n\n            filt_weights = np.expand_dims(filt_weights, 1)  # append chn_in dimension\n            filt_size = filt_weights.shape[-1]              # filter length\n            padding = self._get_padding(padding_type, filt_size)\n\n            conv = nn.Conv1d(1, chn_out, kernel_size=filt_size, padding=padding, bias=False)\n            conv.weight.data = torch.from_numpy(filt_weights)\n            conv.weight.requires_grad_(False)\n\n            if self._cuda: conv.cuda()\n            self._filters[ind] = conv\n\n    @staticmethod\n    def _get_padding(padding_type, kernel_size):\n        assert isinstance(kernel_size, int)\n        assert padding_type in [\'SAME\', \'VALID\']\n        if padding_type == \'SAME\':\n            return (kernel_size - 1) // 2\n        return 0'"
wavelets_pytorch/transform.py,6,"b'# MIT License\n#\n# Copyright (c) 2018 Tom Runia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Tom Runia\n# Date Created: 2018-04-15\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport six\nfrom abc import ABCMeta, abstractmethod\n\nimport numpy as np\nimport scipy.signal\nimport scipy.optimize\n\nimport torch\nfrom torch.autograd import Variable\n\nfrom wavelets_pytorch.wavelets import Morlet\nfrom wavelets_pytorch.network import TorchFilterBank\n\n##########################################################################################\n\n@six.add_metaclass(ABCMeta)\nclass WaveletTransformBase(object):\n    """"""\n\n    Base class for the Continuous Wavelet Transform as described in:\n        ""Torrence & Combo, A Practical Guide to Wavelet Analysis (BAMS, 1998)""\n\n    This class is a abstract super class for child classes:\n        WaveletTransform      => implements CWT in SciPy\n        WaveletTransformTorch => implements CWT in PyTorch\n\n    For a more detailed explanation of the parameters, the original code serves as reference:\n        https://github.com/aaren/wavelets/blob/master/wavelets/transform.py#L145\n\n    """"""\n\n    def __init__(self, dt=1.0, dj=0.125, wavelet=Morlet(), unbias=False):\n        """"""\n        :param dt: float, sample spacing\n        :param dj: float, scale distribution parameter\n        :param wavelet: wavelet object, see \'wavelets.py\'\n        :param unbias: boolean, whether to unbias the power spectrum\n        """"""\n        self._dt = dt\n        self._dj = dj\n        self._wavelet = wavelet\n        self._unbias = unbias\n        self._scale_minimum = self.compute_minimum_scale()\n        self._signal_length = None  # initialize on first call\n        self._scales  = None        # initialize on first call\n        self._filters = None        # initialize on first call\n\n    @abstractmethod\n    def cwt(self, x):\n        raise NotImplementedError\n\n    def _build_filters(self):\n        """"""\n        Determines the optimal scale distribution (see. Torrence & Combo, Eq. 9-10),\n        and then initializes the filter bank consisting of rescaled versions\n        of the mother wavelet. Also includes normalization. Code is based on:\n        https://github.com/aaren/wavelets/blob/master/wavelets/transform.py#L88\n        """"""\n        self._scale_minimum = self.compute_minimum_scale()\n        self._scales = self.compute_optimal_scales()\n\n        self._filters = [None]*len(self.scales)\n        for scale_idx, scale in enumerate(self._scales):\n            # Number of points needed to capture wavelet\n            M = 10 * scale / self.dt\n            # Times to use, centred at zero\n            t = np.arange((-M + 1) / 2., (M + 1) / 2.) * self.dt\n            if len(t) % 2 == 0: t = t[0:-1]  # requires odd filter size\n            # Sample wavelet and normalise\n            norm = (self.dt / scale) ** .5\n            self._filters[scale_idx] = norm * self.wavelet(t, scale)\n\n    def compute_optimal_scales(self):\n        """"""\n        Determines the optimal scale distribution (see. Torrence & Combo, Eq. 9-10).\n        :return: np.ndarray, collection of scales\n        """"""\n        if self.signal_length is None:\n            raise ValueError(\'Please specify signal_length before computing optimal scales.\')\n        J = int((1 / self.dj) * np.log2(self.signal_length * self.dt / self._scale_minimum))\n        scales = self._scale_minimum * 2 ** (self.dj * np.arange(0, J + 1))\n        return scales\n\n    def compute_minimum_scale(self):\n        """"""\n        Choose s0 so that the equivalent Fourier period is 2 * dt.\n        See Torrence & Combo Sections 3f and 3h.\n        :return: float, minimum scale level\n        """"""\n        dt = self.dt\n        def func_to_solve(s):\n            return self.fourier_period(s) - 2 * dt\n        return scipy.optimize.fsolve(func_to_solve, 1)[0]\n\n    def power(self, x):\n        """"""\n        Performs CWT and converts to a power spectrum (scalogram).\n        See Torrence & Combo, Section 4d.\n        :param x: np.ndarray, batch of input signals of shape [n_batch,signal_length]\n        :return: np.ndarray, scalogram for each signal [n_batch,n_scales,signal_length]\n        """"""\n        if self.unbias:\n            return (np.abs(self.cwt(x)).T ** 2 / self.scales).T\n        else:\n            return np.abs(self.cwt(x)) ** 2\n\n    @property\n    def dt(self):\n        return self._dt\n\n    @dt.setter\n    def dt(self, value):\n        # Needs to recompute scale distribution and filters\n        self._dt = value\n        self._build_filters()\n\n    @property\n    def signal_length(self):\n        return self._signal_length\n\n    @signal_length.setter\n    def signal_length(self, value):\n        # Needs to recompute scale distribution and filters\n        self._signal_length = value\n        self._build_filters()\n\n    @property\n    def wavelet(self):\n        return self._wavelet\n\n    @property\n    def fourier_period(self):\n        """""" Return a function that calculates the equivalent Fourier. """"""\n        return getattr(self.wavelet, \'fourier_period\')\n\n    @property\n    def scale_from_period(self):\n        """""" Return a function that calculates the wavelet scale from the fourier period """"""\n        return getattr(self.wavelet, \'scale_from_period\')\n\n    @property\n    def fourier_periods(self):\n        """""" Return the equivalent Fourier periods for the scales used. """"""\n        assert self._scales is not None, \'Wavelet scales are not initialized.\'\n        return self.fourier_period(self.scales)\n\n    @property\n    def fourier_frequencies(self):\n        """""" Return the equivalent frequencies. """"""\n        return np.reciprocal(self.fourier_periods)\n\n    @property\n    def scales(self):\n        return self._scales\n\n    @property\n    def dj(self):\n        return self._dj\n\n    @property\n    def wavelet(self):\n        return self._wavelet\n\n    @property\n    def unbias(self):\n        return self._unbias\n\n    @property\n    def complex_wavelet(self):\n        return np.iscomplexobj(self._filters[0])\n\n    @property\n    def output_dtype(self):\n        return np.complex128 if self.complex_wavelet else np.float64\n\n##########################################################################################\n\nclass WaveletTransform(WaveletTransformBase):\n\n    def __init__(self, dt=1.0, dj=0.125, wavelet=Morlet(), unbias=False):\n        """"""\n        This is SciPy version of the CWT filter bank. Main work for this filter bank\n        is performed by the convolution implementated in \'scipy.signal.convolve\'\n\n        :param dt: float, sample spacing\n        :param dj: float, scale distribution parameter\n        :param wavelet: wavelet object, see \'wavelets.py\'\n        :param unbias: boolean, whether to unbias the power spectrum\n        """"""\n        super(WaveletTransform,self).__init__(dt, dj, wavelet, unbias)\n\n    def cwt(self, x):\n        """"""\n        Implements the continuous wavelet transform on a batch of signals. All signals\n        in the batch must have the same length, otherwise manual zero padding has to be\n        applied. On the first call, the signal length is used to determines the optimal\n        scale distribution and uses this for initialization of the wavelet filter bank.\n        If there is only one example in the batch the batch dimension is squeezed.\n\n        :param x: np.ndarray, batch of signals of shape [n_batch,signal_length]\n        :return: np.ndarray, CWT for each signal in the batch [n_batch,n_scales,signal_length]\n        """"""\n\n        # Append batch dimension\n        if x.ndim == 1:\n            x = x[None,:]\n\n        num_examples  = x.shape[0]\n        signal_length = x.shape[-1]\n\n        if signal_length != self.signal_length or not self._filters:\n            # First call initializtion, or change in signal length. Note that calling\n            # this also determines the optimal scales and initialized the filter bank.\n            self.signal_length = signal_length\n\n        # Wavelets can be complex so output is complex (np.float64 or np.complex128)\n        cwt = np.zeros((num_examples, len(self.scales), x.shape[-1]), self.output_dtype)\n        for example_idx in range(num_examples):\n            cwt[example_idx] = self._compute_single(x[example_idx])\n\n        # Squeeze batch dimension if single example\n        if num_examples == 1:\n            cwt = cwt.squeeze(0)\n        return cwt\n\n    def _compute_single(self, x):\n        assert x.ndim == 1, \'Input signal must have single dimension.\'\n        output = np.zeros((len(self.scales), len(x)), self.output_dtype)\n        for scale_idx, filt in enumerate(self._filters):\n            output[scale_idx,:] = scipy.signal.convolve(x, filt, mode=\'same\')\n        return output\n\n##########################################################################################\n\nclass WaveletTransformTorch(WaveletTransformBase):\n\n    def __init__(self, dt=1.0, dj=0.125, wavelet=Morlet(), unbias=False, cuda=True):\n        """"""\n        This is PyTorch version of the CWT filter bank. Main work for this filter bank\n        is performed by the convolution implementated in \'torch.nn.Conv1d\'. Actual\n        convolutions are performed by the helper class defined in \'network.py\' which\n        implements a \'torch.nn.module\' that contains the convolution filters.\n\n        :param dt: float, sample spacing\n        :param dj: float, scale distribution parameter\n        :param wavelet: wavelet object, see \'wavelets.py\'\n        :param unbias: boolean, whether to unbias the power spectrum\n        :param cuda: boolean, whether to run convolutions on the GPU\n        """"""\n        super(WaveletTransformTorch, self).__init__(dt, dj, wavelet, unbias)\n        self._cuda = cuda\n        self._extractor = TorchFilterBank(self._filters, cuda)\n\n    def cwt(self, x):\n        """"""\n        Implements the continuous wavelet transform on a batch of signals. All signals\n        in the batch must have the same length, otherwise manual zero padding has to be\n        applied. On the first call, the signal length is used to determines the optimal\n        scale distribution and uses this for initialization of the wavelet filter bank.\n        If there is only one example in the batch the batch dimension is squeezed.\n\n        :param x: np.ndarray, batch of signals of shape [n_batch,signal_length]\n        :return: np.ndarray, CWT for each signal in the batch [n_batch,n_scales,signal_length]\n        """"""\n\n        if x.ndim == 1:\n            # Append batch_size and chn_in dimensions\n            # [signal_length] => [n_batch,1,signal_length]\n            x = x[None,None,:]\n        elif x.ndim == 2:\n            # Just append chn_in dimension\n            # [n_batch,signal_length] => [n_batch,1,signal_length]\n            x = x[:,None,:]\n\n        num_examples  = x.shape[0]\n        signal_length = x.shape[-1]\n\n        if signal_length != self.signal_length or not self._filters:\n            # First call initializtion, or change in signal length. Note that calling\n            # this also determines the optimal scales and initialized the filter bank.\n            self.signal_length = signal_length\n\n        # Move to GPU and perform CWT computation\n        x = torch.from_numpy(x).type(torch.FloatTensor)\n        x.requires_grad_(requires_grad=False)\n\n        if self._cuda: x = x.cuda()\n        cwt = self._extractor(x)\n\n        # Move back to CPU\n        cwt = cwt.detach()\n        if self._cuda:  cwt = cwt.cpu()\n        cwt = cwt.numpy()\n\n        if self.complex_wavelet:\n            # Combine real and imag parts, returns object of shape\n            # [n_batch,n_scales,signal_length] of type np.complex128\n            cwt = (cwt[:,:,0,:] + cwt[:,:,1,:]*1j).astype(self.output_dtype)\n        else:\n            # Just squeeze the chn_out dimension (=1) to obtain an object of shape\n            # [n_batch,n_scales,signal_length] of type np.float64\n            cwt = np.squeeze(cwt, 2).astype(self.output_dtype)\n\n        # Squeeze batch dimension if single example\n        if num_examples == 1:\n            cwt = cwt.squeeze(0)\n        return cwt\n\n    @property\n    def dt(self):\n        return self._dt\n\n    @dt.setter\n    def dt(self, value):\n        super(WaveletTransformTorch, self.__class__).dt.fset(self, value)\n        self._extractor.set_filters(self._filters)\n\n    @property\n    def signal_length(self):\n        return self._signal_length\n\n    @signal_length.setter\n    def signal_length(self, value):\n        super(WaveletTransformTorch, self.__class__).signal_length.fset(self, value)\n        self._extractor.set_filters(self._filters)'"
wavelets_pytorch/wavelets.py,0,"b'# MIT License\n#\n# Copyright (c) 2018 Tom Runia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to conditions.\n#\n# Author: Aaron O\'Leary (dev@aaren.me)\n# Date Created: 2016-02-28\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport scipy\nimport scipy.signal\nimport scipy.optimize\nimport scipy.special\nfrom scipy.misc import factorial\n\n__all__ = [\'Morlet\', \'Paul\', \'DOG\', \'Ricker\', \'Marr\', \'Mexican_hat\']\n\n\nclass Morlet(object):\n    def __init__(self, w0=6):\n        """"""w0 is the nondimensional frequency constant. If this is\n        set too low then the wavelet does not sample very well: a\n        value over 5 should be ok; Terrence and Compo set it to 6.\n        """"""\n        self.w0 = w0\n        if w0 == 6:\n            # value of C_d from TC98\n            self.C_d = 0.776\n\n    def __call__(self, *args, **kwargs):\n        return self.time(*args, **kwargs)\n\n    def time(self, t, s=1.0, complete=True):\n        """"""\n        Complex Morlet wavelet, centred at zero.\n\n        Parameters\n        ----------\n        t : float\n            Time. If s is not specified, this can be used as the\n            non-dimensional time t/s.\n        s : float\n            Scaling factor. Default is 1.\n        complete : bool\n            Whether to use the complete or the standard version.\n\n        Returns\n        -------\n        out : complex\n            Value of the Morlet wavelet at the given time\n\n        See Also\n        --------\n        scipy.signal.gausspulse\n\n        Notes\n        -----\n        The standard version::\n\n            pi**-0.25 * exp(1j*w*x) * exp(-0.5*(x**2))\n\n        This commonly used wavelet is often referred to simply as the\n        Morlet wavelet.  Note that this simplified version can cause\n        admissibility problems at low values of `w`.\n\n        The complete version::\n\n            pi**-0.25 * (exp(1j*w*x) - exp(-0.5*(w**2))) * exp(-0.5*(x**2))\n\n        The complete version of the Morlet wavelet, with a correction\n        term to improve admissibility. For `w` greater than 5, the\n        correction term is negligible.\n\n        Note that the energy of the return wavelet is not normalised\n        according to `s`.\n\n        The fundamental frequency of this wavelet in Hz is given\n        by ``f = 2*s*w*r / M`` where r is the sampling rate.\n\n        """"""\n        w = self.w0\n\n        x = t / s\n\n        output = np.exp(1j * w * x)\n\n        if complete:\n            output -= np.exp(-0.5 * (w ** 2))\n\n        output *= np.exp(-0.5 * (x ** 2)) * np.pi ** (-0.25)\n\n        return output\n\n    # Fourier wavelengths\n    def fourier_period(self, s):\n        """"""Equivalent Fourier period of Morlet""""""\n        return 4 * np.pi * s / (self.w0 + (2 + self.w0 ** 2) ** .5)\n\n    def scale_from_period(self, period):\n        """"""\n        Compute the scale from the fourier period.\n        Returns the scale\n        """"""\n        # Solve 4 * np.pi * scale / (w0 + (2 + w0 ** 2) ** .5)\n        #  for s to obtain this formula\n        coeff = np.sqrt(self.w0 * self.w0 + 2)\n        return (period * (coeff + self.w0)) / (4. * np.pi)\n\n    # Frequency representation\n    def frequency(self, w, s=1.0):\n        """"""Frequency representation of Morlet.\n\n        Parameters\n        ----------\n        w : float\n            Angular frequency. If `s` is not specified, i.e. set to 1,\n            this can be used as the non-dimensional angular\n            frequency w * s.\n        s : float\n            Scaling factor. Default is 1.\n\n        Returns\n        -------\n        out : complex\n            Value of the Morlet wavelet at the given frequency\n        """"""\n        x = w * s\n        # Heaviside mock\n        Hw = np.array(w)\n        Hw[w <= 0] = 0\n        Hw[w > 0] = 1\n        return np.pi ** -.25 * Hw * np.exp((-(x - self.w0) ** 2) / 2)\n\n    def coi(self, s):\n        """"""The e folding time for the autocorrelation of wavelet\n        power at each scale, i.e. the timescale over which an edge\n        effect decays by a factor of 1/e^2.\n\n        This can be worked out analytically by solving\n\n            |Y_0(T)|^2 / |Y_0(0)|^2 = 1 / e^2\n        """"""\n        return 2 ** .5 * s\n\n\nclass Paul(object):\n    def __init__(self, m=4):\n        """"""Initialise a Paul wavelet function of order `m`.\n        """"""\n        self.m = m\n\n    def __call__(self, *args, **kwargs):\n        return self.time(*args, **kwargs)\n\n    def time(self, t, s=1.0):\n        """"""\n        Complex Paul wavelet, centred at zero.\n\n        Parameters\n        ----------\n        t : float\n            Time. If `s` is not specified, i.e. set to 1, this can be\n            used as the non-dimensional time t/s.\n        s : float\n            Scaling factor. Default is 1.\n\n        Returns\n        -------\n        out : complex\n            Value of the Paul wavelet at the given time\n\n        The Paul wavelet is defined (in time) as::\n\n            (2 ** m * i ** m * m!) / (pi * (2 * m)!) \\\n                    * (1 - i * t / s) ** -(m + 1)\n\n        """"""\n        m = self.m\n        x = t / s\n\n        const = (2 ** m * 1j ** m * factorial(m)) \\\n            / (np.pi * factorial(2 * m)) ** .5\n        functional_form = (1 - 1j * x) ** -(m + 1)\n\n        output = const * functional_form\n\n        return output\n\n    # Fourier wavelengths\n    def fourier_period(self, s):\n        """"""Equivalent Fourier period of Paul""""""\n        return 4 * np.pi * s / (2 * self.m + 1)\n\n    def scale_from_period(self, period):\n        raise NotImplementedError()\n\n    # Frequency representation\n    def frequency(self, w, s=1.0):\n        """"""Frequency representation of Paul.\n\n        Parameters\n        ----------\n        w : float\n            Angular frequency. If `s` is not specified, i.e. set to 1,\n            this can be used as the non-dimensional angular\n            frequency w * s.\n        s : float\n            Scaling factor. Default is 1.\n\n        Returns\n        -------\n        out : complex\n            Value of the Paul wavelet at the given frequency\n\n        """"""\n        m = self.m\n        x = w * s\n        # Heaviside mock\n        Hw = 0.5 * (np.sign(x) + 1)\n\n        # prefactor\n        const = 2 ** m / (m * factorial(2 * m - 1)) ** .5\n\n        functional_form = Hw * (x) ** m * np.exp(-x)\n\n        output = const * functional_form\n\n        return output\n\n    def coi(self, s):\n        """"""The e folding time for the autocorrelation of wavelet\n        power at each scale, i.e. the timescale over which an edge\n        effect decays by a factor of 1/e^2.\n\n        This can be worked out analytically by solving\n\n            |Y_0(T)|^2 / |Y_0(0)|^2 = 1 / e^2\n        """"""\n        return s / 2 ** .5\n\n\nclass DOG(object):\n    def __init__(self, m=2):\n        """"""Initialise a Derivative of Gaussian wavelet of order `m`.""""""\n        if m == 2:\n            # value of C_d from TC98\n            self.C_d = 3.541\n        elif m == 6:\n            self.C_d = 1.966\n        else:\n            pass\n        self.m = m\n\n    def __call__(self, *args, **kwargs):\n        return self.time(*args, **kwargs)\n\n    def time(self, t, s=1.0):\n        """"""\n        Return a Derivative of Gaussian wavelet,\n\n        When m = 2, this is also known as the ""Mexican hat"", ""Marr""\n        or ""Ricker"" wavelet.\n\n        It models the function::\n\n            ``A d^m/dx^m exp(-x^2 / 2)``,\n\n        where ``A = (-1)^(m+1) / (gamma(m + 1/2))^.5``\n        and   ``x = t / s``.\n\n        Note that the energy of the return wavelet is not normalised\n        according to `s`.\n\n        Parameters\n        ----------\n        t : float\n            Time. If `s` is not specified, this can be used as the\n            non-dimensional time t/s.\n        s : scalar\n            Width parameter of the wavelet.\n\n        Returns\n        -------\n        out : float\n            Value of the DOG wavelet at the given time\n\n        Notes\n        -----\n        The derivative of the Gaussian has a polynomial representation:\n\n        from http://en.wikipedia.org/wiki/Gaussian_function:\n\n        ""Mathematically, the derivatives of the Gaussian function can be\n        represented using Hermite functions. The n-th derivative of the\n        Gaussian is the Gaussian function itself multiplied by the n-th\n        Hermite polynomial, up to scale.""\n\n        http://en.wikipedia.org/wiki/Hermite_polynomial\n\n        Here, we want the \'probabilists\' Hermite polynomial (He_n),\n        which is computed by scipy.special.hermitenorm\n\n        """"""\n        x = t / s\n        m = self.m\n\n        # compute the Hermite polynomial (used to evaluate the\n        # derivative of a Gaussian)\n        He_n = scipy.special.hermitenorm(m)\n        gamma = scipy.special.gamma\n\n        const = (-1) ** (m + 1) / gamma(m + 0.5) ** .5\n        function = He_n(x) * np.exp(-x ** 2 / 2)\n\n        return const * function\n\n    def fourier_period(self, s):\n        """"""Equivalent Fourier period of derivative of Gaussian""""""\n        return 2 * np.pi * s / (self.m + 0.5) ** .5\n\n    def scale_from_period(self, period):\n        raise NotImplementedError()\n\n    def frequency(self, w, s=1.0):\n        """"""Frequency representation of derivative of Gaussian.\n\n        Parameters\n        ----------\n        w : float\n            Angular frequency. If `s` is not specified, i.e. set to 1,\n            this can be used as the non-dimensional angular\n            frequency w * s.\n        s : float\n            Scaling factor. Default is 1.\n\n        Returns\n        -------\n        out : complex\n            Value of the derivative of Gaussian wavelet at the\n            given time\n        """"""\n        m = self.m\n        x = s * w\n        gamma = scipy.special.gamma\n        const = -1j ** m / gamma(m + 0.5) ** .5\n        function = x ** m * np.exp(-x ** 2 / 2)\n        return const * function\n\n    def coi(self, s):\n        """"""The e folding time for the autocorrelation of wavelet\n        power at each scale, i.e. the timescale over which an edge\n        effect decays by a factor of 1/e^2.\n\n        This can be worked out analytically by solving\n\n            |Y_0(T)|^2 / |Y_0(0)|^2 = 1 / e^2\n        """"""\n        return 2 ** .5 * s\n\n\nclass Ricker(DOG):\n    def __init__(self):\n        """"""The Ricker, aka Marr / Mexican Hat, wavelet is a\n        derivative of Gaussian order 2.\n        """"""\n        DOG.__init__(self, m=2)\n        # value of C_d from TC98\n        self.C_d = 3.541\n\n\n# aliases for DOG2\nMarr = Ricker\nMexican_hat = Ricker'"
