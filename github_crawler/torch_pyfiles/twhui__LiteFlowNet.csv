file_path,api_count,code
python/classify.py,0,"b'#!/usr/bin/env python\n""""""\nclassify.py is an out-of-the-box image classifer callable from the command line.\n\nBy default it configures and runs the Caffe reference ImageNet model.\n""""""\nimport numpy as np\nimport os\nimport sys\nimport argparse\nimport glob\nimport time\n\nimport caffe\n\n\ndef main(argv):\n    pycaffe_dir = os.path.dirname(__file__)\n\n    parser = argparse.ArgumentParser()\n    # Required arguments: input and output files.\n    parser.add_argument(\n        ""input_file"",\n        help=""Input image, directory, or npy.""\n    )\n    parser.add_argument(\n        ""output_file"",\n        help=""Output npy filename.""\n    )\n    # Optional arguments.\n    parser.add_argument(\n        ""--model_def"",\n        default=os.path.join(pycaffe_dir,\n                ""../models/bvlc_reference_caffenet/deploy.prototxt""),\n        help=""Model definition file.""\n    )\n    parser.add_argument(\n        ""--pretrained_model"",\n        default=os.path.join(pycaffe_dir,\n                ""../models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel""),\n        help=""Trained model weights file.""\n    )\n    parser.add_argument(\n        ""--gpu"",\n        action=\'store_true\',\n        help=""Switch for gpu computation.""\n    )\n    parser.add_argument(\n        ""--center_only"",\n        action=\'store_true\',\n        help=""Switch for prediction from center crop alone instead of "" +\n             ""averaging predictions across crops (default).""\n    )\n    parser.add_argument(\n        ""--images_dim"",\n        default=\'256,256\',\n        help=""Canonical \'height,width\' dimensions of input images.""\n    )\n    parser.add_argument(\n        ""--mean_file"",\n        default=os.path.join(pycaffe_dir,\n                             \'caffe/imagenet/ilsvrc_2012_mean.npy\'),\n        help=""Data set image mean of [Channels x Height x Width] dimensions "" +\n             ""(numpy array). Set to \'\' for no mean subtraction.""\n    )\n    parser.add_argument(\n        ""--input_scale"",\n        type=float,\n        help=""Multiply input features by this scale to finish preprocessing.""\n    )\n    parser.add_argument(\n        ""--raw_scale"",\n        type=float,\n        default=255.0,\n        help=""Multiply raw input by this scale before preprocessing.""\n    )\n    parser.add_argument(\n        ""--channel_swap"",\n        default=\'2,1,0\',\n        help=""Order to permute input channels. The default converts "" +\n             ""RGB -> BGR since BGR is the Caffe default by way of OpenCV.""\n    )\n    parser.add_argument(\n        ""--ext"",\n        default=\'jpg\',\n        help=""Image file extension to take as input when a directory "" +\n             ""is given as the input file.""\n    )\n    args = parser.parse_args()\n\n    image_dims = [int(s) for s in args.images_dim.split(\',\')]\n\n    mean, channel_swap = None, None\n    if args.mean_file:\n        mean = np.load(args.mean_file)\n    if args.channel_swap:\n        channel_swap = [int(s) for s in args.channel_swap.split(\',\')]\n\n    if args.gpu:\n        caffe.set_mode_gpu()\n        print(""GPU mode"")\n    else:\n        caffe.set_mode_cpu()\n        print(""CPU mode"")\n\n    # Make classifier.\n    classifier = caffe.Classifier(args.model_def, args.pretrained_model,\n            image_dims=image_dims, mean=mean,\n            input_scale=args.input_scale, raw_scale=args.raw_scale,\n            channel_swap=channel_swap)\n\n    # Load numpy array (.npy), directory glob (*.jpg), or image file.\n    args.input_file = os.path.expanduser(args.input_file)\n    if args.input_file.endswith(\'npy\'):\n        print(""Loading file: %s"" % args.input_file)\n        inputs = np.load(args.input_file)\n    elif os.path.isdir(args.input_file):\n        print(""Loading folder: %s"" % args.input_file)\n        inputs =[caffe.io.load_image(im_f)\n                 for im_f in glob.glob(args.input_file + \'/*.\' + args.ext)]\n    else:\n        print(""Loading file: %s"" % args.input_file)\n        inputs = [caffe.io.load_image(args.input_file)]\n\n    print(""Classifying %d inputs."" % len(inputs))\n\n    # Classify.\n    start = time.time()\n    predictions = classifier.predict(inputs, not args.center_only)\n    print(""Done in %.2f s."" % (time.time() - start))\n\n    # Save\n    print(""Saving results into %s"" % args.output_file)\n    np.save(args.output_file, predictions)\n\n\nif __name__ == \'__main__\':\n    main(sys.argv)\n'"
python/detect.py,0,"b'#!/usr/bin/env python\n""""""\ndetector.py is an out-of-the-box windowed detector\ncallable from the command line.\n\nBy default it configures and runs the Caffe reference ImageNet model.\nNote that this model was trained for image classification and not detection,\nand finetuning for detection can be expected to improve results.\n\nThe selective_search_ijcv_with_python code required for the selective search\nproposal mode is available at\n    https://github.com/sergeyk/selective_search_ijcv_with_python\n\nTODO:\n- batch up image filenames as well: don\'t want to load all of them into memory\n- come up with a batching scheme that preserved order / keeps a unique ID\n""""""\nimport numpy as np\nimport pandas as pd\nimport os\nimport argparse\nimport time\n\nimport caffe\n\nCROP_MODES = [\'list\', \'selective_search\']\nCOORD_COLS = [\'ymin\', \'xmin\', \'ymax\', \'xmax\']\n\n\ndef main(argv):\n    pycaffe_dir = os.path.dirname(__file__)\n\n    parser = argparse.ArgumentParser()\n    # Required arguments: input and output.\n    parser.add_argument(\n        ""input_file"",\n        help=""Input txt/csv filename. If .txt, must be list of filenames.\\\n        If .csv, must be comma-separated file with header\\\n        \'filename, xmin, ymin, xmax, ymax\'""\n    )\n    parser.add_argument(\n        ""output_file"",\n        help=""Output h5/csv filename. Format depends on extension.""\n    )\n    # Optional arguments.\n    parser.add_argument(\n        ""--model_def"",\n        default=os.path.join(pycaffe_dir,\n                ""../models/bvlc_reference_caffenet/deploy.prototxt""),\n        help=""Model definition file.""\n    )\n    parser.add_argument(\n        ""--pretrained_model"",\n        default=os.path.join(pycaffe_dir,\n                ""../models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel""),\n        help=""Trained model weights file.""\n    )\n    parser.add_argument(\n        ""--crop_mode"",\n        default=""selective_search"",\n        choices=CROP_MODES,\n        help=""How to generate windows for detection.""\n    )\n    parser.add_argument(\n        ""--gpu"",\n        action=\'store_true\',\n        help=""Switch for gpu computation.""\n    )\n    parser.add_argument(\n        ""--mean_file"",\n        default=os.path.join(pycaffe_dir,\n                             \'caffe/imagenet/ilsvrc_2012_mean.npy\'),\n        help=""Data set image mean of H x W x K dimensions (numpy array). "" +\n             ""Set to \'\' for no mean subtraction.""\n    )\n    parser.add_argument(\n        ""--input_scale"",\n        type=float,\n        help=""Multiply input features by this scale to finish preprocessing.""\n    )\n    parser.add_argument(\n        ""--raw_scale"",\n        type=float,\n        default=255.0,\n        help=""Multiply raw input by this scale before preprocessing.""\n    )\n    parser.add_argument(\n        ""--channel_swap"",\n        default=\'2,1,0\',\n        help=""Order to permute input channels. The default converts "" +\n             ""RGB -> BGR since BGR is the Caffe default by way of OpenCV.""\n\n    )\n    parser.add_argument(\n        ""--context_pad"",\n        type=int,\n        default=\'16\',\n        help=""Amount of surrounding context to collect in input window.""\n    )\n    args = parser.parse_args()\n\n    mean, channel_swap = None, None\n    if args.mean_file:\n        mean = np.load(args.mean_file)\n        if mean.shape[1:] != (1, 1):\n            mean = mean.mean(1).mean(1)\n    if args.channel_swap:\n        channel_swap = [int(s) for s in args.channel_swap.split(\',\')]\n\n    if args.gpu:\n        caffe.set_mode_gpu()\n        print(""GPU mode"")\n    else:\n        caffe.set_mode_cpu()\n        print(""CPU mode"")\n\n    # Make detector.\n    detector = caffe.Detector(args.model_def, args.pretrained_model, mean=mean,\n            input_scale=args.input_scale, raw_scale=args.raw_scale,\n            channel_swap=channel_swap,\n            context_pad=args.context_pad)\n\n    # Load input.\n    t = time.time()\n    print(""Loading input..."")\n    if args.input_file.lower().endswith(\'txt\'):\n        with open(args.input_file) as f:\n            inputs = [_.strip() for _ in f.readlines()]\n    elif args.input_file.lower().endswith(\'csv\'):\n        inputs = pd.read_csv(args.input_file, sep=\',\', dtype={\'filename\': str})\n        inputs.set_index(\'filename\', inplace=True)\n    else:\n        raise Exception(""Unknown input file type: not in txt or csv."")\n\n    # Detect.\n    if args.crop_mode == \'list\':\n        # Unpack sequence of (image filename, windows).\n        images_windows = [\n            (ix, inputs.iloc[np.where(inputs.index == ix)][COORD_COLS].values)\n            for ix in inputs.index.unique()\n        ]\n        detections = detector.detect_windows(images_windows)\n    else:\n        detections = detector.detect_selective_search(inputs)\n    print(""Processed {} windows in {:.3f} s."".format(len(detections),\n                                                     time.time() - t))\n\n    # Collect into dataframe with labeled fields.\n    df = pd.DataFrame(detections)\n    df.set_index(\'filename\', inplace=True)\n    df[COORD_COLS] = pd.DataFrame(\n        data=np.vstack(df[\'window\']), index=df.index, columns=COORD_COLS)\n    del(df[\'window\'])\n\n    # Save results.\n    t = time.time()\n    if args.output_file.lower().endswith(\'csv\'):\n        # csv\n        # Enumerate the class probabilities.\n        class_cols = [\'class{}\'.format(x) for x in range(NUM_OUTPUT)]\n        df[class_cols] = pd.DataFrame(\n            data=np.vstack(df[\'feat\']), index=df.index, columns=class_cols)\n        df.to_csv(args.output_file, cols=COORD_COLS + class_cols)\n    else:\n        # h5\n        df.to_hdf(args.output_file, \'df\', mode=\'w\')\n    print(""Saved to {} in {:.3f} s."".format(args.output_file,\n                                            time.time() - t))\n\n\nif __name__ == ""__main__"":\n    import sys\n    main(sys.argv)\n'"
python/draw_net.py,0,"b'#!/usr/bin/env python\n""""""\nDraw a graph of the net architecture.\n""""""\nfrom argparse import ArgumentParser, ArgumentDefaultsHelpFormatter\nfrom google.protobuf import text_format\n\nimport caffe\nimport caffe.draw\nfrom caffe.proto import caffe_pb2\n\n\ndef parse_args():\n    """"""Parse input arguments\n    """"""\n\n    parser = ArgumentParser(description=__doc__,\n                            formatter_class=ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument(\'input_net_proto_file\',\n                        help=\'Input network prototxt file\')\n    parser.add_argument(\'output_image_file\',\n                        help=\'Output image file\')\n    parser.add_argument(\'--rankdir\',\n                        help=(\'One of TB (top-bottom, i.e., vertical), \'\n                              \'RL (right-left, i.e., horizontal), or another \'\n                              \'valid dot option; see \'\n                              \'http://www.graphviz.org/doc/info/\'\n                              \'attrs.html#k:rankdir\'),\n                        default=\'LR\')\n\n    args = parser.parse_args()\n    return args\n\n\ndef main():\n    args = parse_args()\n    net = caffe_pb2.NetParameter()\n    text_format.Merge(open(args.input_net_proto_file).read(), net)\n    print(\'Drawing net to %s\' % args.output_image_file)\n    caffe.draw.draw_net_to_file(net, args.output_image_file, args.rankdir)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
scripts/copy_notebook.py,0,"b'#!/usr/bin/env python\n""""""\nTakes as arguments:\n1. the path to a JSON file (such as an IPython notebook).\n2. the path to output file\n\nIf \'metadata\' dict in the JSON file contains \'include_in_docs\': true,\nthen copies the file to output file, appending the \'metadata\' property\nas YAML front-matter, adding the field \'category\' with value \'notebook\'.\n""""""\nimport os\nimport sys\nimport json\n\nfilename = sys.argv[1]\noutput_filename = sys.argv[2]\ncontent = json.load(open(filename))\n\nif \'include_in_docs\' in content[\'metadata\'] and content[\'metadata\'][\'include_in_docs\']:\n    yaml_frontmatter = [\'---\']\n    for key, val in content[\'metadata\'].iteritems():\n        if key == \'example_name\':\n            key = \'title\'\n            if val == \'\':\n                val = os.path.basename(filename)\n        yaml_frontmatter.append(\'{}: {}\'.format(key, val))\n    yaml_frontmatter += [\'category: notebook\']\n    yaml_frontmatter += [\'original_path: \' + filename]\n\n    with open(output_filename, \'w\') as fo:\n        fo.write(\'\\n\'.join(yaml_frontmatter + [\'---\']) + \'\\n\')\n        fo.write(open(filename).read())\n'"
scripts/cpp_lint.py,0,"b'#!/usr/bin/python2\n#\n# Copyright (c) 2009 Google Inc. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#    * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following disclaimer\n# in the documentation and/or other materials provided with the\n# distribution.\n#    * Neither the name of Google Inc. nor the names of its\n# contributors may be used to endorse or promote products derived from\n# this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n""""""Does google-lint on c++ files.\n\nThe goal of this script is to identify places in the code that *may*\nbe in non-compliance with google style.  It does not attempt to fix\nup these problems -- the point is to educate.  It does also not\nattempt to find all problems, or to ensure that everything it does\nfind is legitimately a problem.\n\nIn particular, we can get very confused by /* and // inside strings!\nWe do a small hack, which is to ignore //\'s with ""\'s after them on the\nsame line, but it is far from perfect (in either direction).\n""""""\n\nimport codecs\nimport copy\nimport getopt\nimport math  # for log\nimport os\nimport re\nimport sre_compile\nimport string\nimport sys\nimport unicodedata\n\n\n_USAGE = """"""\nSyntax: cpp_lint.py [--verbose=#] [--output=vs7] [--filter=-x,+y,...]\n                   [--counting=total|toplevel|detailed] [--root=subdir]\n                   [--linelength=digits]\n        <file> [file] ...\n\n  The style guidelines this tries to follow are those in\n    http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\n\n  Every problem is given a confidence score from 1-5, with 5 meaning we are\n  certain of the problem, and 1 meaning it could be a legitimate construct.\n  This will miss some errors, and is not a substitute for a code review.\n\n  To suppress false-positive errors of a certain category, add a\n  \'NOLINT(category)\' comment to the line.  NOLINT or NOLINT(*)\n  suppresses errors of all categories on that line.\n\n  The files passed in will be linted; at least one file must be provided.\n  Default linted extensions are .cc, .cpp, .cu, .cuh and .h.  Change the\n  extensions with the --extensions flag.\n\n  Flags:\n\n    output=vs7\n      By default, the output is formatted to ease emacs parsing.  Visual Studio\n      compatible output (vs7) may also be used.  Other formats are unsupported.\n\n    verbose=#\n      Specify a number 0-5 to restrict errors to certain verbosity levels.\n\n    filter=-x,+y,...\n      Specify a comma-separated list of category-filters to apply: only\n      error messages whose category names pass the filters will be printed.\n      (Category names are printed with the message and look like\n      ""[whitespace/indent]"".)  Filters are evaluated left to right.\n      ""-FOO"" and ""FOO"" means ""do not print categories that start with FOO"".\n      ""+FOO"" means ""do print categories that start with FOO"".\n\n      Examples: --filter=-whitespace,+whitespace/braces\n                --filter=whitespace,runtime/printf,+runtime/printf_format\n                --filter=-,+build/include_what_you_use\n\n      To see a list of all the categories used in cpplint, pass no arg:\n         --filter=\n\n    counting=total|toplevel|detailed\n      The total number of errors found is always printed. If\n      \'toplevel\' is provided, then the count of errors in each of\n      the top-level categories like \'build\' and \'whitespace\' will\n      also be printed. If \'detailed\' is provided, then a count\n      is provided for each category like \'build/class\'.\n\n    root=subdir\n      The root directory used for deriving header guard CPP variable.\n      By default, the header guard CPP variable is calculated as the relative\n      path to the directory that contains .git, .hg, or .svn.  When this flag\n      is specified, the relative path is calculated from the specified\n      directory. If the specified directory does not exist, this flag is\n      ignored.\n\n      Examples:\n        Assuing that src/.git exists, the header guard CPP variables for\n        src/chrome/browser/ui/browser.h are:\n\n        No flag => CHROME_BROWSER_UI_BROWSER_H_\n        --root=chrome => BROWSER_UI_BROWSER_H_\n        --root=chrome/browser => UI_BROWSER_H_\n\n    linelength=digits\n      This is the allowed line length for the project. The default value is\n      80 characters.\n\n      Examples:\n        --linelength=120\n\n    extensions=extension,extension,...\n      The allowed file extensions that cpplint will check\n\n      Examples:\n        --extensions=hpp,cpp\n""""""\n\n# We categorize each error message we print.  Here are the categories.\n# We want an explicit list so we can list them all in cpplint --filter=.\n# If you add a new error message with a new category, add it to the list\n# here!  cpplint_unittest.py should tell you if you forget to do this.\n_ERROR_CATEGORIES = [\n  \'build/class\',\n  \'build/deprecated\',\n  \'build/endif_comment\',\n  \'build/explicit_make_pair\',\n  \'build/forward_decl\',\n  \'build/header_guard\',\n  \'build/include\',\n  \'build/include_alpha\',\n  \'build/include_dir\',\n  \'build/include_order\',\n  \'build/include_what_you_use\',\n  \'build/namespaces\',\n  \'build/printf_format\',\n  \'build/storage_class\',\n  \'caffe/alt_fn\',\n  \'caffe/data_layer_setup\',\n  \'caffe/random_fn\',\n  \'legal/copyright\',\n  \'readability/alt_tokens\',\n  \'readability/braces\',\n  \'readability/casting\',\n  \'readability/check\',\n  \'readability/constructors\',\n  \'readability/fn_size\',\n  \'readability/function\',\n  \'readability/multiline_comment\',\n  \'readability/multiline_string\',\n  \'readability/namespace\',\n  \'readability/nolint\',\n  \'readability/nul\',\n  \'readability/streams\',\n  \'readability/todo\',\n  \'readability/utf8\',\n  \'runtime/arrays\',\n  \'runtime/casting\',\n  \'runtime/explicit\',\n  \'runtime/int\',\n  \'runtime/init\',\n  \'runtime/invalid_increment\',\n  \'runtime/member_string_references\',\n  \'runtime/memset\',\n  \'runtime/operator\',\n  \'runtime/printf\',\n  \'runtime/printf_format\',\n  \'runtime/references\',\n  \'runtime/string\',\n  \'runtime/threadsafe_fn\',\n  \'runtime/vlog\',\n  \'whitespace/blank_line\',\n  \'whitespace/braces\',\n  \'whitespace/comma\',\n  \'whitespace/comments\',\n  \'whitespace/empty_conditional_body\',\n  \'whitespace/empty_loop_body\',\n  \'whitespace/end_of_line\',\n  \'whitespace/ending_newline\',\n  \'whitespace/forcolon\',\n  \'whitespace/indent\',\n  \'whitespace/line_length\',\n  \'whitespace/newline\',\n  \'whitespace/operators\',\n  \'whitespace/parens\',\n  \'whitespace/semicolon\',\n  \'whitespace/tab\',\n  \'whitespace/todo\'\n  ]\n\n# The default state of the category filter. This is overrided by the --filter=\n# flag. By default all errors are on, so only add here categories that should be\n# off by default (i.e., categories that must be enabled by the --filter= flags).\n# All entries here should start with a \'-\' or \'+\', as in the --filter= flag.\n_DEFAULT_FILTERS = [\n  \'-build/include_dir\',\n  \'-readability/todo\',\n  ]\n\n# We used to check for high-bit characters, but after much discussion we\n# decided those were OK, as long as they were in UTF-8 and didn\'t represent\n# hard-coded international strings, which belong in a separate i18n file.\n\n\n# C++ headers\n_CPP_HEADERS = frozenset([\n    # Legacy\n    \'algobase.h\',\n    \'algo.h\',\n    \'alloc.h\',\n    \'builtinbuf.h\',\n    \'bvector.h\',\n    \'complex.h\',\n    \'defalloc.h\',\n    \'deque.h\',\n    \'editbuf.h\',\n    \'fstream.h\',\n    \'function.h\',\n    \'hash_map\',\n    \'hash_map.h\',\n    \'hash_set\',\n    \'hash_set.h\',\n    \'hashtable.h\',\n    \'heap.h\',\n    \'indstream.h\',\n    \'iomanip.h\',\n    \'iostream.h\',\n    \'istream.h\',\n    \'iterator.h\',\n    \'list.h\',\n    \'map.h\',\n    \'multimap.h\',\n    \'multiset.h\',\n    \'ostream.h\',\n    \'pair.h\',\n    \'parsestream.h\',\n    \'pfstream.h\',\n    \'procbuf.h\',\n    \'pthread_alloc\',\n    \'pthread_alloc.h\',\n    \'rope\',\n    \'rope.h\',\n    \'ropeimpl.h\',\n    \'set.h\',\n    \'slist\',\n    \'slist.h\',\n    \'stack.h\',\n    \'stdiostream.h\',\n    \'stl_alloc.h\',\n    \'stl_relops.h\',\n    \'streambuf.h\',\n    \'stream.h\',\n    \'strfile.h\',\n    \'strstream.h\',\n    \'tempbuf.h\',\n    \'tree.h\',\n    \'type_traits.h\',\n    \'vector.h\',\n    # 17.6.1.2 C++ library headers\n    \'algorithm\',\n    \'array\',\n    \'atomic\',\n    \'bitset\',\n    \'chrono\',\n    \'codecvt\',\n    \'complex\',\n    \'condition_variable\',\n    \'deque\',\n    \'exception\',\n    \'forward_list\',\n    \'fstream\',\n    \'functional\',\n    \'future\',\n    \'initializer_list\',\n    \'iomanip\',\n    \'ios\',\n    \'iosfwd\',\n    \'iostream\',\n    \'istream\',\n    \'iterator\',\n    \'limits\',\n    \'list\',\n    \'locale\',\n    \'map\',\n    \'memory\',\n    \'mutex\',\n    \'new\',\n    \'numeric\',\n    \'ostream\',\n    \'queue\',\n    \'random\',\n    \'ratio\',\n    \'regex\',\n    \'set\',\n    \'sstream\',\n    \'stack\',\n    \'stdexcept\',\n    \'streambuf\',\n    \'string\',\n    \'strstream\',\n    \'system_error\',\n    \'thread\',\n    \'tuple\',\n    \'typeindex\',\n    \'typeinfo\',\n    \'type_traits\',\n    \'unordered_map\',\n    \'unordered_set\',\n    \'utility\',\n    \'valarray\',\n    \'vector\',\n    # 17.6.1.2 C++ headers for C library facilities\n    \'cassert\',\n    \'ccomplex\',\n    \'cctype\',\n    \'cerrno\',\n    \'cfenv\',\n    \'cfloat\',\n    \'cinttypes\',\n    \'ciso646\',\n    \'climits\',\n    \'clocale\',\n    \'cmath\',\n    \'csetjmp\',\n    \'csignal\',\n    \'cstdalign\',\n    \'cstdarg\',\n    \'cstdbool\',\n    \'cstddef\',\n    \'cstdint\',\n    \'cstdio\',\n    \'cstdlib\',\n    \'cstring\',\n    \'ctgmath\',\n    \'ctime\',\n    \'cuchar\',\n    \'cwchar\',\n    \'cwctype\',\n    ])\n\n# Assertion macros.  These are defined in base/logging.h and\n# testing/base/gunit.h.  Note that the _M versions need to come first\n# for substring matching to work.\n_CHECK_MACROS = [\n    \'DCHECK\', \'CHECK\',\n    \'EXPECT_TRUE_M\', \'EXPECT_TRUE\',\n    \'ASSERT_TRUE_M\', \'ASSERT_TRUE\',\n    \'EXPECT_FALSE_M\', \'EXPECT_FALSE\',\n    \'ASSERT_FALSE_M\', \'ASSERT_FALSE\',\n    ]\n\n# Replacement macros for CHECK/DCHECK/EXPECT_TRUE/EXPECT_FALSE\n_CHECK_REPLACEMENT = dict([(m, {}) for m in _CHECK_MACROS])\n\nfor op, replacement in [(\'==\', \'EQ\'), (\'!=\', \'NE\'),\n                        (\'>=\', \'GE\'), (\'>\', \'GT\'),\n                        (\'<=\', \'LE\'), (\'<\', \'LT\')]:\n  _CHECK_REPLACEMENT[\'DCHECK\'][op] = \'DCHECK_%s\' % replacement\n  _CHECK_REPLACEMENT[\'CHECK\'][op] = \'CHECK_%s\' % replacement\n  _CHECK_REPLACEMENT[\'EXPECT_TRUE\'][op] = \'EXPECT_%s\' % replacement\n  _CHECK_REPLACEMENT[\'ASSERT_TRUE\'][op] = \'ASSERT_%s\' % replacement\n  _CHECK_REPLACEMENT[\'EXPECT_TRUE_M\'][op] = \'EXPECT_%s_M\' % replacement\n  _CHECK_REPLACEMENT[\'ASSERT_TRUE_M\'][op] = \'ASSERT_%s_M\' % replacement\n\nfor op, inv_replacement in [(\'==\', \'NE\'), (\'!=\', \'EQ\'),\n                            (\'>=\', \'LT\'), (\'>\', \'LE\'),\n                            (\'<=\', \'GT\'), (\'<\', \'GE\')]:\n  _CHECK_REPLACEMENT[\'EXPECT_FALSE\'][op] = \'EXPECT_%s\' % inv_replacement\n  _CHECK_REPLACEMENT[\'ASSERT_FALSE\'][op] = \'ASSERT_%s\' % inv_replacement\n  _CHECK_REPLACEMENT[\'EXPECT_FALSE_M\'][op] = \'EXPECT_%s_M\' % inv_replacement\n  _CHECK_REPLACEMENT[\'ASSERT_FALSE_M\'][op] = \'ASSERT_%s_M\' % inv_replacement\n\n# Alternative tokens and their replacements.  For full list, see section 2.5\n# Alternative tokens [lex.digraph] in the C++ standard.\n#\n# Digraphs (such as \'%:\') are not included here since it\'s a mess to\n# match those on a word boundary.\n_ALT_TOKEN_REPLACEMENT = {\n    \'and\': \'&&\',\n    \'bitor\': \'|\',\n    \'or\': \'||\',\n    \'xor\': \'^\',\n    \'compl\': \'~\',\n    \'bitand\': \'&\',\n    \'and_eq\': \'&=\',\n    \'or_eq\': \'|=\',\n    \'xor_eq\': \'^=\',\n    \'not\': \'!\',\n    \'not_eq\': \'!=\'\n    }\n\n# Compile regular expression that matches all the above keywords.  The ""[ =()]""\n# bit is meant to avoid matching these keywords outside of boolean expressions.\n#\n# False positives include C-style multi-line comments and multi-line strings\n# but those have always been troublesome for cpplint.\n_ALT_TOKEN_REPLACEMENT_PATTERN = re.compile(\n    r\'[ =()](\' + (\'|\'.join(_ALT_TOKEN_REPLACEMENT.keys())) + r\')(?=[ (]|$)\')\n\n\n# These constants define types of headers for use with\n# _IncludeState.CheckNextIncludeOrder().\n_C_SYS_HEADER = 1\n_CPP_SYS_HEADER = 2\n_LIKELY_MY_HEADER = 3\n_POSSIBLE_MY_HEADER = 4\n_OTHER_HEADER = 5\n\n# These constants define the current inline assembly state\n_NO_ASM = 0       # Outside of inline assembly block\n_INSIDE_ASM = 1   # Inside inline assembly block\n_END_ASM = 2      # Last line of inline assembly block\n_BLOCK_ASM = 3    # The whole block is an inline assembly block\n\n# Match start of assembly blocks\n_MATCH_ASM = re.compile(r\'^\\s*(?:asm|_asm|__asm|__asm__)\'\n                        r\'(?:\\s+(volatile|__volatile__))?\'\n                        r\'\\s*[{(]\')\n\n\n_regexp_compile_cache = {}\n\n# Finds occurrences of NOLINT[_NEXT_LINE] or NOLINT[_NEXT_LINE](...).\n_RE_SUPPRESSION = re.compile(r\'\\bNOLINT(_NEXT_LINE)?\\b(\\([^)]*\\))?\')\n\n# {str, set(int)}: a map from error categories to sets of linenumbers\n# on which those errors are expected and should be suppressed.\n_error_suppressions = {}\n\n# Finds Copyright.\n_RE_COPYRIGHT = re.compile(r\'Copyright\')\n\n# The root directory used for deriving header guard CPP variable.\n# This is set by --root flag.\n_root = None\n\n# The allowed line length of files.\n# This is set by --linelength flag.\n_line_length = 80\n\n# The allowed extensions for file names\n# This is set by --extensions flag.\n_valid_extensions = set([\'cc\', \'h\', \'cpp\', \'hpp\', \'cu\', \'cuh\'])\n\ndef ParseNolintSuppressions(filename, raw_line, linenum, error):\n  """"""Updates the global list of error-suppressions.\n\n  Parses any NOLINT comments on the current line, updating the global\n  error_suppressions store.  Reports an error if the NOLINT comment\n  was malformed.\n\n  Args:\n    filename: str, the name of the input file.\n    raw_line: str, the line of input text, with comments.\n    linenum: int, the number of the current line.\n    error: function, an error handler.\n  """"""\n  # FIXME(adonovan): ""NOLINT("" is misparsed as NOLINT(*).\n  matched = _RE_SUPPRESSION.search(raw_line)\n  if matched:\n    if matched.group(1) == \'_NEXT_LINE\':\n      linenum += 1\n    category = matched.group(2)\n    if category in (None, \'(*)\'):  # => ""suppress all""\n      _error_suppressions.setdefault(None, set()).add(linenum)\n    else:\n      if category.startswith(\'(\') and category.endswith(\')\'):\n        category = category[1:-1]\n        if category in _ERROR_CATEGORIES:\n          _error_suppressions.setdefault(category, set()).add(linenum)\n        else:\n          error(filename, linenum, \'readability/nolint\', 5,\n                \'Unknown NOLINT error category: %s\' % category)\n\n\ndef ResetNolintSuppressions():\n  ""Resets the set of NOLINT suppressions to empty.""\n  _error_suppressions.clear()\n\n\ndef IsErrorSuppressedByNolint(category, linenum):\n  """"""Returns true if the specified error category is suppressed on this line.\n\n  Consults the global error_suppressions map populated by\n  ParseNolintSuppressions/ResetNolintSuppressions.\n\n  Args:\n    category: str, the category of the error.\n    linenum: int, the current line number.\n  Returns:\n    bool, True iff the error should be suppressed due to a NOLINT comment.\n  """"""\n  return (linenum in _error_suppressions.get(category, set()) or\n          linenum in _error_suppressions.get(None, set()))\n\ndef Match(pattern, s):\n  """"""Matches the string with the pattern, caching the compiled regexp.""""""\n  # The regexp compilation caching is inlined in both Match and Search for\n  # performance reasons; factoring it out into a separate function turns out\n  # to be noticeably expensive.\n  if pattern not in _regexp_compile_cache:\n    _regexp_compile_cache[pattern] = sre_compile.compile(pattern)\n  return _regexp_compile_cache[pattern].match(s)\n\n\ndef ReplaceAll(pattern, rep, s):\n  """"""Replaces instances of pattern in a string with a replacement.\n\n  The compiled regex is kept in a cache shared by Match and Search.\n\n  Args:\n    pattern: regex pattern\n    rep: replacement text\n    s: search string\n\n  Returns:\n    string with replacements made (or original string if no replacements)\n  """"""\n  if pattern not in _regexp_compile_cache:\n    _regexp_compile_cache[pattern] = sre_compile.compile(pattern)\n  return _regexp_compile_cache[pattern].sub(rep, s)\n\n\ndef Search(pattern, s):\n  """"""Searches the string for the pattern, caching the compiled regexp.""""""\n  if pattern not in _regexp_compile_cache:\n    _regexp_compile_cache[pattern] = sre_compile.compile(pattern)\n  return _regexp_compile_cache[pattern].search(s)\n\n\nclass _IncludeState(dict):\n  """"""Tracks line numbers for includes, and the order in which includes appear.\n\n  As a dict, an _IncludeState object serves as a mapping between include\n  filename and line number on which that file was included.\n\n  Call CheckNextIncludeOrder() once for each header in the file, passing\n  in the type constants defined above. Calls in an illegal order will\n  raise an _IncludeError with an appropriate error message.\n\n  """"""\n  # self._section will move monotonically through this set. If it ever\n  # needs to move backwards, CheckNextIncludeOrder will raise an error.\n  _INITIAL_SECTION = 0\n  _MY_H_SECTION = 1\n  _C_SECTION = 2\n  _CPP_SECTION = 3\n  _OTHER_H_SECTION = 4\n\n  _TYPE_NAMES = {\n      _C_SYS_HEADER: \'C system header\',\n      _CPP_SYS_HEADER: \'C++ system header\',\n      _LIKELY_MY_HEADER: \'header this file implements\',\n      _POSSIBLE_MY_HEADER: \'header this file may implement\',\n      _OTHER_HEADER: \'other header\',\n      }\n  _SECTION_NAMES = {\n      _INITIAL_SECTION: ""... nothing. (This can\'t be an error.)"",\n      _MY_H_SECTION: \'a header this file implements\',\n      _C_SECTION: \'C system header\',\n      _CPP_SECTION: \'C++ system header\',\n      _OTHER_H_SECTION: \'other header\',\n      }\n\n  def __init__(self):\n    dict.__init__(self)\n    self.ResetSection()\n\n  def ResetSection(self):\n    # The name of the current section.\n    self._section = self._INITIAL_SECTION\n    # The path of last found header.\n    self._last_header = \'\'\n\n  def SetLastHeader(self, header_path):\n    self._last_header = header_path\n\n  def CanonicalizeAlphabeticalOrder(self, header_path):\n    """"""Returns a path canonicalized for alphabetical comparison.\n\n    - replaces ""-"" with ""_"" so they both cmp the same.\n    - removes \'-inl\' since we don\'t require them to be after the main header.\n    - lowercase everything, just in case.\n\n    Args:\n      header_path: Path to be canonicalized.\n\n    Returns:\n      Canonicalized path.\n    """"""\n    return header_path.replace(\'-inl.h\', \'.h\').replace(\'-\', \'_\').lower()\n\n  def IsInAlphabeticalOrder(self, clean_lines, linenum, header_path):\n    """"""Check if a header is in alphabetical order with the previous header.\n\n    Args:\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      header_path: Canonicalized header to be checked.\n\n    Returns:\n      Returns true if the header is in alphabetical order.\n    """"""\n    # If previous section is different from current section, _last_header will\n    # be reset to empty string, so it\'s always less than current header.\n    #\n    # If previous line was a blank line, assume that the headers are\n    # intentionally sorted the way they are.\n    if (self._last_header > header_path and\n        not Match(r\'^\\s*$\', clean_lines.elided[linenum - 1])):\n      return False\n    return True\n\n  def CheckNextIncludeOrder(self, header_type):\n    """"""Returns a non-empty error message if the next header is out of order.\n\n    This function also updates the internal state to be ready to check\n    the next include.\n\n    Args:\n      header_type: One of the _XXX_HEADER constants defined above.\n\n    Returns:\n      The empty string if the header is in the right order, or an\n      error message describing what\'s wrong.\n\n    """"""\n    error_message = (\'Found %s after %s\' %\n                     (self._TYPE_NAMES[header_type],\n                      self._SECTION_NAMES[self._section]))\n\n    last_section = self._section\n\n    if header_type == _C_SYS_HEADER:\n      if self._section <= self._C_SECTION:\n        self._section = self._C_SECTION\n      else:\n        self._last_header = \'\'\n        return error_message\n    elif header_type == _CPP_SYS_HEADER:\n      if self._section <= self._CPP_SECTION:\n        self._section = self._CPP_SECTION\n      else:\n        self._last_header = \'\'\n        return error_message\n    elif header_type == _LIKELY_MY_HEADER:\n      if self._section <= self._MY_H_SECTION:\n        self._section = self._MY_H_SECTION\n      else:\n        self._section = self._OTHER_H_SECTION\n    elif header_type == _POSSIBLE_MY_HEADER:\n      if self._section <= self._MY_H_SECTION:\n        self._section = self._MY_H_SECTION\n      else:\n        # This will always be the fallback because we\'re not sure\n        # enough that the header is associated with this file.\n        self._section = self._OTHER_H_SECTION\n    else:\n      assert header_type == _OTHER_HEADER\n      self._section = self._OTHER_H_SECTION\n\n    if last_section != self._section:\n      self._last_header = \'\'\n\n    return \'\'\n\n\nclass _CppLintState(object):\n  """"""Maintains module-wide state..""""""\n\n  def __init__(self):\n    self.verbose_level = 1  # global setting.\n    self.error_count = 0    # global count of reported errors\n    # filters to apply when emitting error messages\n    self.filters = _DEFAULT_FILTERS[:]\n    self.counting = \'total\'  # In what way are we counting errors?\n    self.errors_by_category = {}  # string to int dict storing error counts\n\n    # output format:\n    # ""emacs"" - format that emacs can parse (default)\n    # ""vs7"" - format that Microsoft Visual Studio 7 can parse\n    self.output_format = \'emacs\'\n\n  def SetOutputFormat(self, output_format):\n    """"""Sets the output format for errors.""""""\n    self.output_format = output_format\n\n  def SetVerboseLevel(self, level):\n    """"""Sets the module\'s verbosity, and returns the previous setting.""""""\n    last_verbose_level = self.verbose_level\n    self.verbose_level = level\n    return last_verbose_level\n\n  def SetCountingStyle(self, counting_style):\n    """"""Sets the module\'s counting options.""""""\n    self.counting = counting_style\n\n  def SetFilters(self, filters):\n    """"""Sets the error-message filters.\n\n    These filters are applied when deciding whether to emit a given\n    error message.\n\n    Args:\n      filters: A string of comma-separated filters (eg ""+whitespace/indent"").\n               Each filter should start with + or -; else we die.\n\n    Raises:\n      ValueError: The comma-separated filters did not all start with \'+\' or \'-\'.\n                  E.g. ""-,+whitespace,-whitespace/indent,whitespace/badfilter""\n    """"""\n    # Default filters always have less priority than the flag ones.\n    self.filters = _DEFAULT_FILTERS[:]\n    for filt in filters.split(\',\'):\n      clean_filt = filt.strip()\n      if clean_filt:\n        self.filters.append(clean_filt)\n    for filt in self.filters:\n      if not (filt.startswith(\'+\') or filt.startswith(\'-\')):\n        raise ValueError(\'Every filter in --filters must start with + or -\'\n                         \' (%s does not)\' % filt)\n\n  def ResetErrorCounts(self):\n    """"""Sets the module\'s error statistic back to zero.""""""\n    self.error_count = 0\n    self.errors_by_category = {}\n\n  def IncrementErrorCount(self, category):\n    """"""Bumps the module\'s error statistic.""""""\n    self.error_count += 1\n    if self.counting in (\'toplevel\', \'detailed\'):\n      if self.counting != \'detailed\':\n        category = category.split(\'/\')[0]\n      if category not in self.errors_by_category:\n        self.errors_by_category[category] = 0\n      self.errors_by_category[category] += 1\n\n  def PrintErrorCounts(self):\n    """"""Print a summary of errors by category, and the total.""""""\n    for category, count in self.errors_by_category.iteritems():\n      sys.stderr.write(\'Category \\\'%s\\\' errors found: %d\\n\' %\n                       (category, count))\n    sys.stderr.write(\'Total errors found: %d\\n\' % self.error_count)\n\n_cpplint_state = _CppLintState()\n\n\ndef _OutputFormat():\n  """"""Gets the module\'s output format.""""""\n  return _cpplint_state.output_format\n\n\ndef _SetOutputFormat(output_format):\n  """"""Sets the module\'s output format.""""""\n  _cpplint_state.SetOutputFormat(output_format)\n\n\ndef _VerboseLevel():\n  """"""Returns the module\'s verbosity setting.""""""\n  return _cpplint_state.verbose_level\n\n\ndef _SetVerboseLevel(level):\n  """"""Sets the module\'s verbosity, and returns the previous setting.""""""\n  return _cpplint_state.SetVerboseLevel(level)\n\n\ndef _SetCountingStyle(level):\n  """"""Sets the module\'s counting options.""""""\n  _cpplint_state.SetCountingStyle(level)\n\n\ndef _Filters():\n  """"""Returns the module\'s list of output filters, as a list.""""""\n  return _cpplint_state.filters\n\n\ndef _SetFilters(filters):\n  """"""Sets the module\'s error-message filters.\n\n  These filters are applied when deciding whether to emit a given\n  error message.\n\n  Args:\n    filters: A string of comma-separated filters (eg ""whitespace/indent"").\n             Each filter should start with + or -; else we die.\n  """"""\n  _cpplint_state.SetFilters(filters)\n\n\nclass _FunctionState(object):\n  """"""Tracks current function name and the number of lines in its body.""""""\n\n  _NORMAL_TRIGGER = 250  # for --v=0, 500 for --v=1, etc.\n  _TEST_TRIGGER = 400    # about 50% more than _NORMAL_TRIGGER.\n\n  def __init__(self):\n    self.in_a_function = False\n    self.lines_in_function = 0\n    self.current_function = \'\'\n\n  def Begin(self, function_name):\n    """"""Start analyzing function body.\n\n    Args:\n      function_name: The name of the function being tracked.\n    """"""\n    self.in_a_function = True\n    self.lines_in_function = 0\n    self.current_function = function_name\n\n  def Count(self):\n    """"""Count line in current function body.""""""\n    if self.in_a_function:\n      self.lines_in_function += 1\n\n  def Check(self, error, filename, linenum):\n    """"""Report if too many lines in function body.\n\n    Args:\n      error: The function to call with any errors found.\n      filename: The name of the current file.\n      linenum: The number of the line to check.\n    """"""\n    if Match(r\'T(EST|est)\', self.current_function):\n      base_trigger = self._TEST_TRIGGER\n    else:\n      base_trigger = self._NORMAL_TRIGGER\n    trigger = base_trigger * 2**_VerboseLevel()\n\n    if self.lines_in_function > trigger:\n      error_level = int(math.log(self.lines_in_function / base_trigger, 2))\n      # 50 => 0, 100 => 1, 200 => 2, 400 => 3, 800 => 4, 1600 => 5, ...\n      if error_level > 5:\n        error_level = 5\n      error(filename, linenum, \'readability/fn_size\', error_level,\n            \'Small and focused functions are preferred:\'\n            \' %s has %d non-comment lines\'\n            \' (error triggered by exceeding %d lines).\'  % (\n                self.current_function, self.lines_in_function, trigger))\n\n  def End(self):\n    """"""Stop analyzing function body.""""""\n    self.in_a_function = False\n\n\nclass _IncludeError(Exception):\n  """"""Indicates a problem with the include order in a file.""""""\n  pass\n\n\nclass FileInfo:\n  """"""Provides utility functions for filenames.\n\n  FileInfo provides easy access to the components of a file\'s path\n  relative to the project root.\n  """"""\n\n  def __init__(self, filename):\n    self._filename = filename\n\n  def FullName(self):\n    """"""Make Windows paths like Unix.""""""\n    return os.path.abspath(self._filename).replace(\'\\\\\', \'/\')\n\n  def RepositoryName(self):\n    """"""FullName after removing the local path to the repository.\n\n    If we have a real absolute path name here we can try to do something smart:\n    detecting the root of the checkout and truncating /path/to/checkout from\n    the name so that we get header guards that don\'t include things like\n    ""C:\\Documents and Settings\\..."" or ""/home/username/..."" in them and thus\n    people on different computers who have checked the source out to different\n    locations won\'t see bogus errors.\n    """"""\n    fullname = self.FullName()\n\n    if os.path.exists(fullname):\n      project_dir = os.path.dirname(fullname)\n\n      if os.path.exists(os.path.join(project_dir, "".svn"")):\n        # If there\'s a .svn file in the current directory, we recursively look\n        # up the directory tree for the top of the SVN checkout\n        root_dir = project_dir\n        one_up_dir = os.path.dirname(root_dir)\n        while os.path.exists(os.path.join(one_up_dir, "".svn"")):\n          root_dir = os.path.dirname(root_dir)\n          one_up_dir = os.path.dirname(one_up_dir)\n\n        prefix = os.path.commonprefix([root_dir, project_dir])\n        return fullname[len(prefix) + 1:]\n\n      # Not SVN <= 1.6? Try to find a git, hg, or svn top level directory by\n      # searching up from the current path.\n      root_dir = os.path.dirname(fullname)\n      while (root_dir != os.path.dirname(root_dir) and\n             not os.path.exists(os.path.join(root_dir, "".git"")) and\n             not os.path.exists(os.path.join(root_dir, "".hg"")) and\n             not os.path.exists(os.path.join(root_dir, "".svn""))):\n        root_dir = os.path.dirname(root_dir)\n\n      if (os.path.exists(os.path.join(root_dir, "".git"")) or\n          os.path.exists(os.path.join(root_dir, "".hg"")) or\n          os.path.exists(os.path.join(root_dir, "".svn""))):\n        prefix = os.path.commonprefix([root_dir, project_dir])\n        return fullname[len(prefix) + 1:]\n\n    # Don\'t know what to do; header guard warnings may be wrong...\n    return fullname\n\n  def Split(self):\n    """"""Splits the file into the directory, basename, and extension.\n\n    For \'chrome/browser/browser.cc\', Split() would\n    return (\'chrome/browser\', \'browser\', \'.cc\')\n\n    Returns:\n      A tuple of (directory, basename, extension).\n    """"""\n\n    googlename = self.RepositoryName()\n    project, rest = os.path.split(googlename)\n    return (project,) + os.path.splitext(rest)\n\n  def BaseName(self):\n    """"""File base name - text after the final slash, before the final period.""""""\n    return self.Split()[1]\n\n  def Extension(self):\n    """"""File extension - text following the final period.""""""\n    return self.Split()[2]\n\n  def NoExtension(self):\n    """"""File has no source file extension.""""""\n    return \'/\'.join(self.Split()[0:2])\n\n  def IsSource(self):\n    """"""File has a source file extension.""""""\n    return self.Extension()[1:] in (\'c\', \'cc\', \'cpp\', \'cxx\')\n\n\ndef _ShouldPrintError(category, confidence, linenum):\n  """"""If confidence >= verbose, category passes filter and is not suppressed.""""""\n\n  # There are three ways we might decide not to print an error message:\n  # a ""NOLINT(category)"" comment appears in the source,\n  # the verbosity level isn\'t high enough, or the filters filter it out.\n  if IsErrorSuppressedByNolint(category, linenum):\n    return False\n  if confidence < _cpplint_state.verbose_level:\n    return False\n\n  is_filtered = False\n  for one_filter in _Filters():\n    if one_filter.startswith(\'-\'):\n      if category.startswith(one_filter[1:]):\n        is_filtered = True\n    elif one_filter.startswith(\'+\'):\n      if category.startswith(one_filter[1:]):\n        is_filtered = False\n    else:\n      assert False  # should have been checked for in SetFilter.\n  if is_filtered:\n    return False\n\n  return True\n\n\ndef Error(filename, linenum, category, confidence, message):\n  """"""Logs the fact we\'ve found a lint error.\n\n  We log where the error was found, and also our confidence in the error,\n  that is, how certain we are this is a legitimate style regression, and\n  not a misidentification or a use that\'s sometimes justified.\n\n  False positives can be suppressed by the use of\n  ""cpplint(category)""  comments on the offending line.  These are\n  parsed into _error_suppressions.\n\n  Args:\n    filename: The name of the file containing the error.\n    linenum: The number of the line containing the error.\n    category: A string used to describe the ""category"" this bug\n      falls under: ""whitespace"", say, or ""runtime"".  Categories\n      may have a hierarchy separated by slashes: ""whitespace/indent"".\n    confidence: A number from 1-5 representing a confidence score for\n      the error, with 5 meaning that we are certain of the problem,\n      and 1 meaning that it could be a legitimate construct.\n    message: The error message.\n  """"""\n  if _ShouldPrintError(category, confidence, linenum):\n    _cpplint_state.IncrementErrorCount(category)\n    if _cpplint_state.output_format == \'vs7\':\n      sys.stderr.write(\'%s(%s):  %s  [%s] [%d]\\n\' % (\n          filename, linenum, message, category, confidence))\n    elif _cpplint_state.output_format == \'eclipse\':\n      sys.stderr.write(\'%s:%s: warning: %s  [%s] [%d]\\n\' % (\n          filename, linenum, message, category, confidence))\n    else:\n      sys.stderr.write(\'%s:%s:  %s  [%s] [%d]\\n\' % (\n          filename, linenum, message, category, confidence))\n\n\n# Matches standard C++ escape sequences per 2.13.2.3 of the C++ standard.\n_RE_PATTERN_CLEANSE_LINE_ESCAPES = re.compile(\n    r\'\\\\([abfnrtv?""\\\\\\\']|\\d+|x[0-9a-fA-F]+)\')\n# Matches strings.  Escape codes should already be removed by ESCAPES.\n_RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES = re.compile(r\'""[^""]*""\')\n# Matches characters.  Escape codes should already be removed by ESCAPES.\n_RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES = re.compile(r""\'.\'"")\n# Matches multi-line C++ comments.\n# This RE is a little bit more complicated than one might expect, because we\n# have to take care of space removals tools so we can handle comments inside\n# statements better.\n# The current rule is: We only clear spaces from both sides when we\'re at the\n# end of the line. Otherwise, we try to remove spaces from the right side,\n# if this doesn\'t work we try on left side but only if there\'s a non-character\n# on the right.\n_RE_PATTERN_CLEANSE_LINE_C_COMMENTS = re.compile(\n    r""""""(\\s*/\\*.*\\*/\\s*$|\n            /\\*.*\\*/\\s+|\n         \\s+/\\*.*\\*/(?=\\W)|\n            /\\*.*\\*/)"""""", re.VERBOSE)\n\n\ndef IsCppString(line):\n  """"""Does line terminate so, that the next symbol is in string constant.\n\n  This function does not consider single-line nor multi-line comments.\n\n  Args:\n    line: is a partial line of code starting from the 0..n.\n\n  Returns:\n    True, if next character appended to \'line\' is inside a\n    string constant.\n  """"""\n\n  line = line.replace(r\'\\\\\', \'XX\')  # after this, \\\\"" does not match to \\""\n  return ((line.count(\'""\') - line.count(r\'\\""\') - line.count(""\'\\""\'"")) & 1) == 1\n\n\ndef CleanseRawStrings(raw_lines):\n  """"""Removes C++11 raw strings from lines.\n\n    Before:\n      static const char kData[] = R""(\n          multi-line string\n          )"";\n\n    After:\n      static const char kData[] = """"\n          (replaced by blank line)\n          """";\n\n  Args:\n    raw_lines: list of raw lines.\n\n  Returns:\n    list of lines with C++11 raw strings replaced by empty strings.\n  """"""\n\n  delimiter = None\n  lines_without_raw_strings = []\n  for line in raw_lines:\n    if delimiter:\n      # Inside a raw string, look for the end\n      end = line.find(delimiter)\n      if end >= 0:\n        # Found the end of the string, match leading space for this\n        # line and resume copying the original lines, and also insert\n        # a """" on the last line.\n        leading_space = Match(r\'^(\\s*)\\S\', line)\n        line = leading_space.group(1) + \'""""\' + line[end + len(delimiter):]\n        delimiter = None\n      else:\n        # Haven\'t found the end yet, append a blank line.\n        line = \'\'\n\n    else:\n      # Look for beginning of a raw string.\n      # See 2.14.15 [lex.string] for syntax.\n      matched = Match(r\'^(.*)\\b(?:R|u8R|uR|UR|LR)""([^\\s\\\\()]*)\\((.*)$\', line)\n      if matched:\n        delimiter = \')\' + matched.group(2) + \'""\'\n\n        end = matched.group(3).find(delimiter)\n        if end >= 0:\n          # Raw string ended on same line\n          line = (matched.group(1) + \'""""\' +\n                  matched.group(3)[end + len(delimiter):])\n          delimiter = None\n        else:\n          # Start of a multi-line raw string\n          line = matched.group(1) + \'""""\'\n\n    lines_without_raw_strings.append(line)\n\n  # TODO(unknown): if delimiter is not None here, we might want to\n  # emit a warning for unterminated string.\n  return lines_without_raw_strings\n\n\ndef FindNextMultiLineCommentStart(lines, lineix):\n  """"""Find the beginning marker for a multiline comment.""""""\n  while lineix < len(lines):\n    if lines[lineix].strip().startswith(\'/*\'):\n      # Only return this marker if the comment goes beyond this line\n      if lines[lineix].strip().find(\'*/\', 2) < 0:\n        return lineix\n    lineix += 1\n  return len(lines)\n\n\ndef FindNextMultiLineCommentEnd(lines, lineix):\n  """"""We are inside a comment, find the end marker.""""""\n  while lineix < len(lines):\n    if lines[lineix].strip().endswith(\'*/\'):\n      return lineix\n    lineix += 1\n  return len(lines)\n\n\ndef RemoveMultiLineCommentsFromRange(lines, begin, end):\n  """"""Clears a range of lines for multi-line comments.""""""\n  # Having // dummy comments makes the lines non-empty, so we will not get\n  # unnecessary blank line warnings later in the code.\n  for i in range(begin, end):\n    lines[i] = \'// dummy\'\n\n\ndef RemoveMultiLineComments(filename, lines, error):\n  """"""Removes multiline (c-style) comments from lines.""""""\n  lineix = 0\n  while lineix < len(lines):\n    lineix_begin = FindNextMultiLineCommentStart(lines, lineix)\n    if lineix_begin >= len(lines):\n      return\n    lineix_end = FindNextMultiLineCommentEnd(lines, lineix_begin)\n    if lineix_end >= len(lines):\n      error(filename, lineix_begin + 1, \'readability/multiline_comment\', 5,\n            \'Could not find end of multi-line comment\')\n      return\n    RemoveMultiLineCommentsFromRange(lines, lineix_begin, lineix_end + 1)\n    lineix = lineix_end + 1\n\n\ndef CleanseComments(line):\n  """"""Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  """"""\n  commentpos = line.find(\'//\')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub(\'\', line)\n\n\nclass CleansedLines(object):\n  """"""Holds 3 copies of all lines with different preprocessing applied to them.\n\n  1) elided member contains lines without strings and comments,\n  2) lines member contains lines without comments, and\n  3) raw_lines member contains all the lines without processing.\n  All these three members are of <type \'list\'>, and of the same length.\n  """"""\n\n  def __init__(self, lines):\n    self.elided = []\n    self.lines = []\n    self.raw_lines = lines\n    self.num_lines = len(lines)\n    self.lines_without_raw_strings = CleanseRawStrings(lines)\n    for linenum in range(len(self.lines_without_raw_strings)):\n      self.lines.append(CleanseComments(\n          self.lines_without_raw_strings[linenum]))\n      elided = self._CollapseStrings(self.lines_without_raw_strings[linenum])\n      self.elided.append(CleanseComments(elided))\n\n  def NumLines(self):\n    """"""Returns the number of lines represented.""""""\n    return self.num_lines\n\n  @staticmethod\n  def _CollapseStrings(elided):\n    """"""Collapses strings and chars on a line to simple """" or \'\' blocks.\n\n    We nix strings first so we\'re not fooled by text like \'""http://""\'\n\n    Args:\n      elided: The line being processed.\n\n    Returns:\n      The line with collapsed strings.\n    """"""\n    if not _RE_PATTERN_INCLUDE.match(elided):\n      # Remove escaped characters first to make quote/single quote collapsing\n      # basic.  Things that look like escaped characters shouldn\'t occur\n      # outside of strings and chars.\n      elided = _RE_PATTERN_CLEANSE_LINE_ESCAPES.sub(\'\', elided)\n      elided = _RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES.sub(""\'\'"", elided)\n      elided = _RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES.sub(\'""""\', elided)\n    return elided\n\n\ndef FindEndOfExpressionInLine(line, startpos, depth, startchar, endchar):\n  """"""Find the position just after the matching endchar.\n\n  Args:\n    line: a CleansedLines line.\n    startpos: start searching at this position.\n    depth: nesting level at startpos.\n    startchar: expression opening character.\n    endchar: expression closing character.\n\n  Returns:\n    On finding matching endchar: (index just after matching endchar, 0)\n    Otherwise: (-1, new depth at end of this line)\n  """"""\n  for i in xrange(startpos, len(line)):\n    if line[i] == startchar:\n      depth += 1\n    elif line[i] == endchar:\n      depth -= 1\n      if depth == 0:\n        return (i + 1, 0)\n  return (-1, depth)\n\n\ndef CloseExpression(clean_lines, linenum, pos):\n  """"""If input points to ( or { or [ or <, finds the position that closes it.\n\n  If lines[linenum][pos] points to a \'(\' or \'{\' or \'[\' or \'<\', finds the\n  linenum/pos that correspond to the closing of the expression.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    pos: A position on the line.\n\n  Returns:\n    A tuple (line, linenum, pos) pointer *past* the closing brace, or\n    (line, len(lines), -1) if we never find a close.  Note we ignore\n    strings and comments when matching; and the line we return is the\n    \'cleansed\' line at linenum.\n  """"""\n\n  line = clean_lines.elided[linenum]\n  startchar = line[pos]\n  if startchar not in \'({[<\':\n    return (line, clean_lines.NumLines(), -1)\n  if startchar == \'(\': endchar = \')\'\n  if startchar == \'[\': endchar = \']\'\n  if startchar == \'{\': endchar = \'}\'\n  if startchar == \'<\': endchar = \'>\'\n\n  # Check first line\n  (end_pos, num_open) = FindEndOfExpressionInLine(\n      line, pos, 0, startchar, endchar)\n  if end_pos > -1:\n    return (line, linenum, end_pos)\n\n  # Continue scanning forward\n  while linenum < clean_lines.NumLines() - 1:\n    linenum += 1\n    line = clean_lines.elided[linenum]\n    (end_pos, num_open) = FindEndOfExpressionInLine(\n        line, 0, num_open, startchar, endchar)\n    if end_pos > -1:\n      return (line, linenum, end_pos)\n\n  # Did not find endchar before end of file, give up\n  return (line, clean_lines.NumLines(), -1)\n\n\ndef FindStartOfExpressionInLine(line, endpos, depth, startchar, endchar):\n  """"""Find position at the matching startchar.\n\n  This is almost the reverse of FindEndOfExpressionInLine, but note\n  that the input position and returned position differs by 1.\n\n  Args:\n    line: a CleansedLines line.\n    endpos: start searching at this position.\n    depth: nesting level at endpos.\n    startchar: expression opening character.\n    endchar: expression closing character.\n\n  Returns:\n    On finding matching startchar: (index at matching startchar, 0)\n    Otherwise: (-1, new depth at beginning of this line)\n  """"""\n  for i in xrange(endpos, -1, -1):\n    if line[i] == endchar:\n      depth += 1\n    elif line[i] == startchar:\n      depth -= 1\n      if depth == 0:\n        return (i, 0)\n  return (-1, depth)\n\n\ndef ReverseCloseExpression(clean_lines, linenum, pos):\n  """"""If input points to ) or } or ] or >, finds the position that opens it.\n\n  If lines[linenum][pos] points to a \')\' or \'}\' or \']\' or \'>\', finds the\n  linenum/pos that correspond to the opening of the expression.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    pos: A position on the line.\n\n  Returns:\n    A tuple (line, linenum, pos) pointer *at* the opening brace, or\n    (line, 0, -1) if we never find the matching opening brace.  Note\n    we ignore strings and comments when matching; and the line we\n    return is the \'cleansed\' line at linenum.\n  """"""\n  line = clean_lines.elided[linenum]\n  endchar = line[pos]\n  if endchar not in \')}]>\':\n    return (line, 0, -1)\n  if endchar == \')\': startchar = \'(\'\n  if endchar == \']\': startchar = \'[\'\n  if endchar == \'}\': startchar = \'{\'\n  if endchar == \'>\': startchar = \'<\'\n\n  # Check last line\n  (start_pos, num_open) = FindStartOfExpressionInLine(\n      line, pos, 0, startchar, endchar)\n  if start_pos > -1:\n    return (line, linenum, start_pos)\n\n  # Continue scanning backward\n  while linenum > 0:\n    linenum -= 1\n    line = clean_lines.elided[linenum]\n    (start_pos, num_open) = FindStartOfExpressionInLine(\n        line, len(line) - 1, num_open, startchar, endchar)\n    if start_pos > -1:\n      return (line, linenum, start_pos)\n\n  # Did not find startchar before beginning of file, give up\n  return (line, 0, -1)\n\n\ndef CheckForCopyright(filename, lines, error):\n  """"""Logs an error if a Copyright message appears at the top of the file.""""""\n\n  # We\'ll check up to line 10. Don\'t forget there\'s a\n  # dummy line at the front.\n  for line in xrange(1, min(len(lines), 11)):\n    if _RE_COPYRIGHT.search(lines[line], re.I):\n      error(filename, 0, \'legal/copyright\', 5,\n            \'Copyright message found.  \'\n            \'You should not include a copyright line.\')\n\n\ndef GetHeaderGuardCPPVariable(filename):\n  """"""Returns the CPP variable that should be used as a header guard.\n\n  Args:\n    filename: The name of a C++ header file.\n\n  Returns:\n    The CPP variable that should be used as a header guard in the\n    named file.\n\n  """"""\n\n  # Restores original filename in case that cpplint is invoked from Emacs\'s\n  # flymake.\n  filename = re.sub(r\'_flymake\\.h$\', \'.h\', filename)\n  filename = re.sub(r\'/\\.flymake/([^/]*)$\', r\'/\\1\', filename)\n\n  fileinfo = FileInfo(filename)\n  file_path_from_root = fileinfo.RepositoryName()\n  if _root:\n    file_path_from_root = re.sub(\'^\' + _root + os.sep, \'\', file_path_from_root)\n  return re.sub(r\'[-./\\s]\', \'_\', file_path_from_root).upper() + \'_\'\n\n\ndef CheckForHeaderGuard(filename, lines, error):\n  """"""Checks that the file contains a header guard.\n\n  Logs an error if no #ifndef header guard is present.  For other\n  headers, checks that the full pathname is used.\n\n  Args:\n    filename: The name of the C++ header file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  """"""\n\n  cppvar = GetHeaderGuardCPPVariable(filename)\n\n  ifndef = None\n  ifndef_linenum = 0\n  define = None\n  endif = None\n  endif_linenum = 0\n  for linenum, line in enumerate(lines):\n    linesplit = line.split()\n    if len(linesplit) >= 2:\n      # find the first occurrence of #ifndef and #define, save arg\n      if not ifndef and linesplit[0] == \'#ifndef\':\n        # set ifndef to the header guard presented on the #ifndef line.\n        ifndef = linesplit[1]\n        ifndef_linenum = linenum\n      if not define and linesplit[0] == \'#define\':\n        define = linesplit[1]\n    # find the last occurrence of #endif, save entire line\n    if line.startswith(\'#endif\'):\n      endif = line\n      endif_linenum = linenum\n\n  if not ifndef:\n    error(filename, 0, \'build/header_guard\', 5,\n          \'No #ifndef header guard found, suggested CPP variable is: %s\' %\n          cppvar)\n    return\n\n  if not define:\n    error(filename, 0, \'build/header_guard\', 5,\n          \'No #define header guard found, suggested CPP variable is: %s\' %\n          cppvar)\n    return\n\n  # The guard should be PATH_FILE_H_, but we also allow PATH_FILE_H__\n  # for backward compatibility.\n  if ifndef != cppvar:\n    error_level = 0\n    if ifndef != cppvar + \'_\':\n      error_level = 5\n\n    ParseNolintSuppressions(filename, lines[ifndef_linenum], ifndef_linenum,\n                            error)\n    error(filename, ifndef_linenum, \'build/header_guard\', error_level,\n          \'#ifndef header guard has wrong style, please use: %s\' % cppvar)\n\n  if define != ifndef:\n    error(filename, 0, \'build/header_guard\', 5,\n          \'#ifndef and #define don\\\'t match, suggested CPP variable is: %s\' %\n          cppvar)\n    return\n\n  if endif != (\'#endif  // %s\' % cppvar):\n    error_level = 0\n    if endif != (\'#endif  // %s\' % (cppvar + \'_\')):\n      error_level = 5\n\n    ParseNolintSuppressions(filename, lines[endif_linenum], endif_linenum,\n                            error)\n    error(filename, endif_linenum, \'build/header_guard\', error_level,\n          \'#endif line should be ""#endif  // %s""\' % cppvar)\n\n\ndef CheckForBadCharacters(filename, lines, error):\n  """"""Logs an error for each line containing bad characters.\n\n  Two kinds of bad characters:\n\n  1. Unicode replacement characters: These indicate that either the file\n  contained invalid UTF-8 (likely) or Unicode replacement characters (which\n  it shouldn\'t).  Note that it\'s possible for this to throw off line\n  numbering if the invalid UTF-8 occurred adjacent to a newline.\n\n  2. NUL bytes.  These are problematic for some tools.\n\n  Args:\n    filename: The name of the current file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  """"""\n  for linenum, line in enumerate(lines):\n    if u\'\\ufffd\' in line:\n      error(filename, linenum, \'readability/utf8\', 5,\n            \'Line contains invalid UTF-8 (or Unicode replacement character).\')\n    if \'\\0\' in line:\n      error(filename, linenum, \'readability/nul\', 5, \'Line contains NUL byte.\')\n\n\ndef CheckForNewlineAtEOF(filename, lines, error):\n  """"""Logs an error if there is no newline char at the end of the file.\n\n  Args:\n    filename: The name of the current file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  """"""\n\n  # The array lines() was created by adding two newlines to the\n  # original file (go figure), then splitting on \\n.\n  # To verify that the file ends in \\n, we just have to make sure the\n  # last-but-two element of lines() exists and is empty.\n  if len(lines) < 3 or lines[-2]:\n    error(filename, len(lines) - 2, \'whitespace/ending_newline\', 5,\n          \'Could not find a newline character at the end of the file.\')\n\n\ndef CheckForMultilineCommentsAndStrings(filename, clean_lines, linenum, error):\n  """"""Logs an error if we see /* ... */ or ""..."" that extend past one line.\n\n  /* ... */ comments are legit inside macros, for one line.\n  Otherwise, we prefer // comments, so it\'s ok to warn about the\n  other.  Likewise, it\'s ok for strings to extend across multiple\n  lines, as long as a line continuation character (backslash)\n  terminates each line. Although not currently prohibited by the C++\n  style guide, it\'s ugly and unnecessary. We don\'t do well with either\n  in this lint program, so we warn about both.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n\n  # Remove all \\\\ (escaped backslashes) from the line. They are OK, and the\n  # second (escaped) slash may trigger later \\"" detection erroneously.\n  line = line.replace(\'\\\\\\\\\', \'\')\n\n  if line.count(\'/*\') > line.count(\'*/\'):\n    error(filename, linenum, \'readability/multiline_comment\', 5,\n          \'Complex multi-line /*...*/-style comment found. \'\n          \'Lint may give bogus warnings.  \'\n          \'Consider replacing these with //-style comments, \'\n          \'with #if 0...#endif, \'\n          \'or with more clearly structured multi-line comments.\')\n\n  if (line.count(\'""\') - line.count(\'\\\\""\')) % 2:\n    error(filename, linenum, \'readability/multiline_string\', 5,\n          \'Multi-line string (""..."") found.  This lint script doesn\\\'t \'\n          \'do well with such strings, and may give bogus warnings.  \'\n          \'Use C++11 raw strings or concatenation instead.\')\n\n\ncaffe_alt_function_list = (\n    (\'memset\', [\'caffe_set\', \'caffe_memset\']),\n    (\'cudaMemset\', [\'caffe_gpu_set\', \'caffe_gpu_memset\']),\n    (\'memcpy\', [\'caffe_copy\']),\n    (\'cudaMemcpy\', [\'caffe_copy\', \'caffe_gpu_memcpy\']),\n    )\n\n\ndef CheckCaffeAlternatives(filename, clean_lines, linenum, error):\n  """"""Checks for C(++) functions for which a Caffe substitute should be used.\n\n  For certain native C functions (memset, memcpy), there is a Caffe alternative\n  which should be used instead.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  for function, alts in caffe_alt_function_list:\n    ix = line.find(function + \'(\')\n    if ix >= 0 and (ix == 0 or (not line[ix - 1].isalnum() and\n                                line[ix - 1] not in (\'_\', \'.\', \'>\'))):\n      disp_alts = [\'%s(...)\' % alt for alt in alts]\n      error(filename, linenum, \'caffe/alt_fn\', 2,\n            \'Use Caffe function %s instead of %s(...).\' %\n                (\' or \'.join(disp_alts), function))\n\n\ndef CheckCaffeDataLayerSetUp(filename, clean_lines, linenum, error):\n  """"""Except the base classes, Caffe DataLayer should define DataLayerSetUp\n     instead of LayerSetUp.\n     \n  The base DataLayers define common SetUp steps, the subclasses should\n  not override them.\n  \n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  ix = line.find(\'DataLayer<Dtype>::LayerSetUp\')\n  if ix >= 0 and (\n       line.find(\'void DataLayer<Dtype>::LayerSetUp\') != -1 or\n       line.find(\'void ImageDataLayer<Dtype>::LayerSetUp\') != -1 or\n       line.find(\'void MemoryDataLayer<Dtype>::LayerSetUp\') != -1 or\n       line.find(\'void WindowDataLayer<Dtype>::LayerSetUp\') != -1):\n      error(filename, linenum, \'caffe/data_layer_setup\', 2,\n            \'Except the base classes, Caffe DataLayer should define\'\n            + \' DataLayerSetUp instead of LayerSetUp. The base DataLayers\'\n            + \' define common SetUp steps, the subclasses should\'\n            + \' not override them.\')\n  ix = line.find(\'DataLayer<Dtype>::DataLayerSetUp\')\n  if ix >= 0 and (\n       line.find(\'void Base\') == -1 and\n       line.find(\'void DataLayer<Dtype>::DataLayerSetUp\') == -1 and\n       line.find(\'void ImageDataLayer<Dtype>::DataLayerSetUp\') == -1 and\n       line.find(\'void MemoryDataLayer<Dtype>::DataLayerSetUp\') == -1 and\n       line.find(\'void WindowDataLayer<Dtype>::DataLayerSetUp\') == -1):\n      error(filename, linenum, \'caffe/data_layer_setup\', 2,\n            \'Except the base classes, Caffe DataLayer should define\'\n            + \' DataLayerSetUp instead of LayerSetUp. The base DataLayers\'\n            + \' define common SetUp steps, the subclasses should\'\n            + \' not override them.\')\n\n\nc_random_function_list = (\n    \'rand(\',\n    \'rand_r(\',\n    \'random(\',\n    )\n\ndef CheckCaffeRandom(filename, clean_lines, linenum, error):\n  """"""Checks for calls to C random functions (rand, rand_r, random, ...).\n\n  Caffe code should (almost) always use the caffe_rng_* functions rather\n  than these, as the internal state of these C functions is independent of the\n  native Caffe RNG system which should produce deterministic results for a\n  fixed Caffe seed set using Caffe::set_random_seed(...).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  for function in c_random_function_list:\n    ix = line.find(function)\n    # Comparisons made explicit for clarity -- pylint: disable=g-explicit-bool-comparison\n    if ix >= 0 and (ix == 0 or (not line[ix - 1].isalnum() and\n                                line[ix - 1] not in (\'_\', \'.\', \'>\'))):\n      error(filename, linenum, \'caffe/random_fn\', 2,\n            \'Use caffe_rng_rand() (or other caffe_rng_* function) instead of \'\n            + function +\n            \') to ensure results are deterministic for a fixed Caffe seed.\')\n\n\nthreading_list = (\n    (\'asctime(\', \'asctime_r(\'),\n    (\'ctime(\', \'ctime_r(\'),\n    (\'getgrgid(\', \'getgrgid_r(\'),\n    (\'getgrnam(\', \'getgrnam_r(\'),\n    (\'getlogin(\', \'getlogin_r(\'),\n    (\'getpwnam(\', \'getpwnam_r(\'),\n    (\'getpwuid(\', \'getpwuid_r(\'),\n    (\'gmtime(\', \'gmtime_r(\'),\n    (\'localtime(\', \'localtime_r(\'),\n    (\'strtok(\', \'strtok_r(\'),\n    (\'ttyname(\', \'ttyname_r(\'),\n    )\n\n\ndef CheckPosixThreading(filename, clean_lines, linenum, error):\n  """"""Checks for calls to thread-unsafe functions.\n\n  Much code has been originally written without consideration of\n  multi-threading. Also, engineers are relying on their old experience;\n  they have learned posix before threading extensions were added. These\n  tests guide the engineers to use thread-safe functions (when using\n  posix directly).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  for single_thread_function, multithread_safe_function in threading_list:\n    ix = line.find(single_thread_function)\n    # Comparisons made explicit for clarity -- pylint: disable=g-explicit-bool-comparison\n    if ix >= 0 and (ix == 0 or (not line[ix - 1].isalnum() and\n                                line[ix - 1] not in (\'_\', \'.\', \'>\'))):\n      error(filename, linenum, \'runtime/threadsafe_fn\', 2,\n            \'Consider using \' + multithread_safe_function +\n            \'...) instead of \' + single_thread_function +\n            \'...) for improved thread safety.\')\n\n\ndef CheckVlogArguments(filename, clean_lines, linenum, error):\n  """"""Checks that VLOG() is only used for defining a logging level.\n\n  For example, VLOG(2) is correct. VLOG(INFO), VLOG(WARNING), VLOG(ERROR), and\n  VLOG(FATAL) are not.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  if Search(r\'\\bVLOG\\((INFO|ERROR|WARNING|DFATAL|FATAL)\\)\', line):\n    error(filename, linenum, \'runtime/vlog\', 5,\n          \'VLOG() should be used with numeric verbosity level.  \'\n          \'Use LOG() if you want symbolic severity levels.\')\n\n\n# Matches invalid increment: *count++, which moves pointer instead of\n# incrementing a value.\n_RE_PATTERN_INVALID_INCREMENT = re.compile(\n    r\'^\\s*\\*\\w+(\\+\\+|--);\')\n\n\ndef CheckInvalidIncrement(filename, clean_lines, linenum, error):\n  """"""Checks for invalid increment *count++.\n\n  For example following function:\n  void increment_counter(int* count) {\n    *count++;\n  }\n  is invalid, because it effectively does count++, moving pointer, and should\n  be replaced with ++*count, (*count)++ or *count += 1.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  if _RE_PATTERN_INVALID_INCREMENT.match(line):\n    error(filename, linenum, \'runtime/invalid_increment\', 5,\n          \'Changing pointer instead of value (or unused value of operator*).\')\n\n\nclass _BlockInfo(object):\n  """"""Stores information about a generic block of code.""""""\n\n  def __init__(self, seen_open_brace):\n    self.seen_open_brace = seen_open_brace\n    self.open_parentheses = 0\n    self.inline_asm = _NO_ASM\n\n  def CheckBegin(self, filename, clean_lines, linenum, error):\n    """"""Run checks that applies to text up to the opening brace.\n\n    This is mostly for checking the text after the class identifier\n    and the ""{"", usually where the base class is specified.  For other\n    blocks, there isn\'t much to check, so we always pass.\n\n    Args:\n      filename: The name of the current file.\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      error: The function to call with any errors found.\n    """"""\n    pass\n\n  def CheckEnd(self, filename, clean_lines, linenum, error):\n    """"""Run checks that applies to text after the closing brace.\n\n    This is mostly used for checking end of namespace comments.\n\n    Args:\n      filename: The name of the current file.\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      error: The function to call with any errors found.\n    """"""\n    pass\n\n\nclass _ClassInfo(_BlockInfo):\n  """"""Stores information about a class.""""""\n\n  def __init__(self, name, class_or_struct, clean_lines, linenum):\n    _BlockInfo.__init__(self, False)\n    self.name = name\n    self.starting_linenum = linenum\n    self.is_derived = False\n    if class_or_struct == \'struct\':\n      self.access = \'public\'\n      self.is_struct = True\n    else:\n      self.access = \'private\'\n      self.is_struct = False\n\n    # Remember initial indentation level for this class.  Using raw_lines here\n    # instead of elided to account for leading comments.\n    initial_indent = Match(r\'^( *)\\S\', clean_lines.raw_lines[linenum])\n    if initial_indent:\n      self.class_indent = len(initial_indent.group(1))\n    else:\n      self.class_indent = 0\n\n    # Try to find the end of the class.  This will be confused by things like:\n    #   class A {\n    #   } *x = { ...\n    #\n    # But it\'s still good enough for CheckSectionSpacing.\n    self.last_line = 0\n    depth = 0\n    for i in range(linenum, clean_lines.NumLines()):\n      line = clean_lines.elided[i]\n      depth += line.count(\'{\') - line.count(\'}\')\n      if not depth:\n        self.last_line = i\n        break\n\n  def CheckBegin(self, filename, clean_lines, linenum, error):\n    # Look for a bare \':\'\n    if Search(\'(^|[^:]):($|[^:])\', clean_lines.elided[linenum]):\n      self.is_derived = True\n\n  def CheckEnd(self, filename, clean_lines, linenum, error):\n    # Check that closing brace is aligned with beginning of the class.\n    # Only do this if the closing brace is indented by only whitespaces.\n    # This means we will not check single-line class definitions.\n    indent = Match(r\'^( *)\\}\', clean_lines.elided[linenum])\n    if indent and len(indent.group(1)) != self.class_indent:\n      if self.is_struct:\n        parent = \'struct \' + self.name\n      else:\n        parent = \'class \' + self.name\n      error(filename, linenum, \'whitespace/indent\', 3,\n            \'Closing brace should be aligned with beginning of %s\' % parent)\n\n\nclass _NamespaceInfo(_BlockInfo):\n  """"""Stores information about a namespace.""""""\n\n  def __init__(self, name, linenum):\n    _BlockInfo.__init__(self, False)\n    self.name = name or \'\'\n    self.starting_linenum = linenum\n\n  def CheckEnd(self, filename, clean_lines, linenum, error):\n    """"""Check end of namespace comments.""""""\n    line = clean_lines.raw_lines[linenum]\n\n    # Check how many lines is enclosed in this namespace.  Don\'t issue\n    # warning for missing namespace comments if there aren\'t enough\n    # lines.  However, do apply checks if there is already an end of\n    # namespace comment and it\'s incorrect.\n    #\n    # TODO(unknown): We always want to check end of namespace comments\n    # if a namespace is large, but sometimes we also want to apply the\n    # check if a short namespace contained nontrivial things (something\n    # other than forward declarations).  There is currently no logic on\n    # deciding what these nontrivial things are, so this check is\n    # triggered by namespace size only, which works most of the time.\n    if (linenum - self.starting_linenum < 10\n        and not Match(r\'};*\\s*(//|/\\*).*\\bnamespace\\b\', line)):\n      return\n\n    # Look for matching comment at end of namespace.\n    #\n    # Note that we accept C style ""/* */"" comments for terminating\n    # namespaces, so that code that terminate namespaces inside\n    # preprocessor macros can be cpplint clean.\n    #\n    # We also accept stuff like ""// end of namespace <name>."" with the\n    # period at the end.\n    #\n    # Besides these, we don\'t accept anything else, otherwise we might\n    # get false negatives when existing comment is a substring of the\n    # expected namespace.\n    if self.name:\n      # Named namespace\n      if not Match((r\'};*\\s*(//|/\\*).*\\bnamespace\\s+\' + re.escape(self.name) +\n                    r\'[\\*/\\.\\\\\\s]*$\'),\n                   line):\n        error(filename, linenum, \'readability/namespace\', 5,\n              \'Namespace should be terminated with ""// namespace %s""\' %\n              self.name)\n    else:\n      # Anonymous namespace\n      if not Match(r\'};*\\s*(//|/\\*).*\\bnamespace[\\*/\\.\\\\\\s]*$\', line):\n        error(filename, linenum, \'readability/namespace\', 5,\n              \'Namespace should be terminated with ""// namespace""\')\n\n\nclass _PreprocessorInfo(object):\n  """"""Stores checkpoints of nesting stacks when #if/#else is seen.""""""\n\n  def __init__(self, stack_before_if):\n    # The entire nesting stack before #if\n    self.stack_before_if = stack_before_if\n\n    # The entire nesting stack up to #else\n    self.stack_before_else = []\n\n    # Whether we have already seen #else or #elif\n    self.seen_else = False\n\n\nclass _NestingState(object):\n  """"""Holds states related to parsing braces.""""""\n\n  def __init__(self):\n    # Stack for tracking all braces.  An object is pushed whenever we\n    # see a ""{"", and popped when we see a ""}"".  Only 3 types of\n    # objects are possible:\n    # - _ClassInfo: a class or struct.\n    # - _NamespaceInfo: a namespace.\n    # - _BlockInfo: some other type of block.\n    self.stack = []\n\n    # Stack of _PreprocessorInfo objects.\n    self.pp_stack = []\n\n  def SeenOpenBrace(self):\n    """"""Check if we have seen the opening brace for the innermost block.\n\n    Returns:\n      True if we have seen the opening brace, False if the innermost\n      block is still expecting an opening brace.\n    """"""\n    return (not self.stack) or self.stack[-1].seen_open_brace\n\n  def InNamespaceBody(self):\n    """"""Check if we are currently one level inside a namespace body.\n\n    Returns:\n      True if top of the stack is a namespace block, False otherwise.\n    """"""\n    return self.stack and isinstance(self.stack[-1], _NamespaceInfo)\n\n  def UpdatePreprocessor(self, line):\n    """"""Update preprocessor stack.\n\n    We need to handle preprocessors due to classes like this:\n      #ifdef SWIG\n      struct ResultDetailsPageElementExtensionPoint {\n      #else\n      struct ResultDetailsPageElementExtensionPoint : public Extension {\n      #endif\n\n    We make the following assumptions (good enough for most files):\n    - Preprocessor condition evaluates to true from #if up to first\n      #else/#elif/#endif.\n\n    - Preprocessor condition evaluates to false from #else/#elif up\n      to #endif.  We still perform lint checks on these lines, but\n      these do not affect nesting stack.\n\n    Args:\n      line: current line to check.\n    """"""\n    if Match(r\'^\\s*#\\s*(if|ifdef|ifndef)\\b\', line):\n      # Beginning of #if block, save the nesting stack here.  The saved\n      # stack will allow us to restore the parsing state in the #else case.\n      self.pp_stack.append(_PreprocessorInfo(copy.deepcopy(self.stack)))\n    elif Match(r\'^\\s*#\\s*(else|elif)\\b\', line):\n      # Beginning of #else block\n      if self.pp_stack:\n        if not self.pp_stack[-1].seen_else:\n          # This is the first #else or #elif block.  Remember the\n          # whole nesting stack up to this point.  This is what we\n          # keep after the #endif.\n          self.pp_stack[-1].seen_else = True\n          self.pp_stack[-1].stack_before_else = copy.deepcopy(self.stack)\n\n        # Restore the stack to how it was before the #if\n        self.stack = copy.deepcopy(self.pp_stack[-1].stack_before_if)\n      else:\n        # TODO(unknown): unexpected #else, issue warning?\n        pass\n    elif Match(r\'^\\s*#\\s*endif\\b\', line):\n      # End of #if or #else blocks.\n      if self.pp_stack:\n        # If we saw an #else, we will need to restore the nesting\n        # stack to its former state before the #else, otherwise we\n        # will just continue from where we left off.\n        if self.pp_stack[-1].seen_else:\n          # Here we can just use a shallow copy since we are the last\n          # reference to it.\n          self.stack = self.pp_stack[-1].stack_before_else\n        # Drop the corresponding #if\n        self.pp_stack.pop()\n      else:\n        # TODO(unknown): unexpected #endif, issue warning?\n        pass\n\n  def Update(self, filename, clean_lines, linenum, error):\n    """"""Update nesting state with current line.\n\n    Args:\n      filename: The name of the current file.\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      error: The function to call with any errors found.\n    """"""\n    line = clean_lines.elided[linenum]\n\n    # Update pp_stack first\n    self.UpdatePreprocessor(line)\n\n    # Count parentheses.  This is to avoid adding struct arguments to\n    # the nesting stack.\n    if self.stack:\n      inner_block = self.stack[-1]\n      depth_change = line.count(\'(\') - line.count(\')\')\n      inner_block.open_parentheses += depth_change\n\n      # Also check if we are starting or ending an inline assembly block.\n      if inner_block.inline_asm in (_NO_ASM, _END_ASM):\n        if (depth_change != 0 and\n            inner_block.open_parentheses == 1 and\n            _MATCH_ASM.match(line)):\n          # Enter assembly block\n          inner_block.inline_asm = _INSIDE_ASM\n        else:\n          # Not entering assembly block.  If previous line was _END_ASM,\n          # we will now shift to _NO_ASM state.\n          inner_block.inline_asm = _NO_ASM\n      elif (inner_block.inline_asm == _INSIDE_ASM and\n            inner_block.open_parentheses == 0):\n        # Exit assembly block\n        inner_block.inline_asm = _END_ASM\n\n    # Consume namespace declaration at the beginning of the line.  Do\n    # this in a loop so that we catch same line declarations like this:\n    #   namespace proto2 { namespace bridge { class MessageSet; } }\n    while True:\n      # Match start of namespace.  The ""\\b\\s*"" below catches namespace\n      # declarations even if it weren\'t followed by a whitespace, this\n      # is so that we don\'t confuse our namespace checker.  The\n      # missing spaces will be flagged by CheckSpacing.\n      namespace_decl_match = Match(r\'^\\s*namespace\\b\\s*([:\\w]+)?(.*)$\', line)\n      if not namespace_decl_match:\n        break\n\n      new_namespace = _NamespaceInfo(namespace_decl_match.group(1), linenum)\n      self.stack.append(new_namespace)\n\n      line = namespace_decl_match.group(2)\n      if line.find(\'{\') != -1:\n        new_namespace.seen_open_brace = True\n        line = line[line.find(\'{\') + 1:]\n\n    # Look for a class declaration in whatever is left of the line\n    # after parsing namespaces.  The regexp accounts for decorated classes\n    # such as in:\n    #   class LOCKABLE API Object {\n    #   };\n    #\n    # Templates with class arguments may confuse the parser, for example:\n    #   template <class T\n    #             class Comparator = less<T>,\n    #             class Vector = vector<T> >\n    #   class HeapQueue {\n    #\n    # Because this parser has no nesting state about templates, by the\n    # time it saw ""class Comparator"", it may think that it\'s a new class.\n    # Nested templates have a similar problem:\n    #   template <\n    #       typename ExportedType,\n    #       typename TupleType,\n    #       template <typename, typename> class ImplTemplate>\n    #\n    # To avoid these cases, we ignore classes that are followed by \'=\' or \'>\'\n    class_decl_match = Match(\n        r\'\\s*(template\\s*<[\\w\\s<>,:]*>\\s*)?\'\n        r\'(class|struct)\\s+([A-Z_]+\\s+)*(\\w+(?:::\\w+)*)\'\n        r\'(([^=>]|<[^<>]*>|<[^<>]*<[^<>]*>\\s*>)*)$\', line)\n    if (class_decl_match and\n        (not self.stack or self.stack[-1].open_parentheses == 0)):\n      self.stack.append(_ClassInfo(\n          class_decl_match.group(4), class_decl_match.group(2),\n          clean_lines, linenum))\n      line = class_decl_match.group(5)\n\n    # If we have not yet seen the opening brace for the innermost block,\n    # run checks here.\n    if not self.SeenOpenBrace():\n      self.stack[-1].CheckBegin(filename, clean_lines, linenum, error)\n\n    # Update access control if we are inside a class/struct\n    if self.stack and isinstance(self.stack[-1], _ClassInfo):\n      classinfo = self.stack[-1]\n      access_match = Match(\n          r\'^(.*)\\b(public|private|protected|signals)(\\s+(?:slots\\s*)?)?\'\n          r\':(?:[^:]|$)\',\n          line)\n      if access_match:\n        classinfo.access = access_match.group(2)\n\n        # Check that access keywords are indented +1 space.  Skip this\n        # check if the keywords are not preceded by whitespaces.\n        indent = access_match.group(1)\n        if (len(indent) != classinfo.class_indent + 1 and\n            Match(r\'^\\s*$\', indent)):\n          if classinfo.is_struct:\n            parent = \'struct \' + classinfo.name\n          else:\n            parent = \'class \' + classinfo.name\n          slots = \'\'\n          if access_match.group(3):\n            slots = access_match.group(3)\n          error(filename, linenum, \'whitespace/indent\', 3,\n                \'%s%s: should be indented +1 space inside %s\' % (\n                    access_match.group(2), slots, parent))\n\n    # Consume braces or semicolons from what\'s left of the line\n    while True:\n      # Match first brace, semicolon, or closed parenthesis.\n      matched = Match(r\'^[^{;)}]*([{;)}])(.*)$\', line)\n      if not matched:\n        break\n\n      token = matched.group(1)\n      if token == \'{\':\n        # If namespace or class hasn\'t seen a opening brace yet, mark\n        # namespace/class head as complete.  Push a new block onto the\n        # stack otherwise.\n        if not self.SeenOpenBrace():\n          self.stack[-1].seen_open_brace = True\n        else:\n          self.stack.append(_BlockInfo(True))\n          if _MATCH_ASM.match(line):\n            self.stack[-1].inline_asm = _BLOCK_ASM\n      elif token == \';\' or token == \')\':\n        # If we haven\'t seen an opening brace yet, but we already saw\n        # a semicolon, this is probably a forward declaration.  Pop\n        # the stack for these.\n        #\n        # Similarly, if we haven\'t seen an opening brace yet, but we\n        # already saw a closing parenthesis, then these are probably\n        # function arguments with extra ""class"" or ""struct"" keywords.\n        # Also pop these stack for these.\n        if not self.SeenOpenBrace():\n          self.stack.pop()\n      else:  # token == \'}\'\n        # Perform end of block checks and pop the stack.\n        if self.stack:\n          self.stack[-1].CheckEnd(filename, clean_lines, linenum, error)\n          self.stack.pop()\n      line = matched.group(2)\n\n  def InnermostClass(self):\n    """"""Get class info on the top of the stack.\n\n    Returns:\n      A _ClassInfo object if we are inside a class, or None otherwise.\n    """"""\n    for i in range(len(self.stack), 0, -1):\n      classinfo = self.stack[i - 1]\n      if isinstance(classinfo, _ClassInfo):\n        return classinfo\n    return None\n\n  def CheckCompletedBlocks(self, filename, error):\n    """"""Checks that all classes and namespaces have been completely parsed.\n\n    Call this when all lines in a file have been processed.\n    Args:\n      filename: The name of the current file.\n      error: The function to call with any errors found.\n    """"""\n    # Note: This test can result in false positives if #ifdef constructs\n    # get in the way of brace matching. See the testBuildClass test in\n    # cpplint_unittest.py for an example of this.\n    for obj in self.stack:\n      if isinstance(obj, _ClassInfo):\n        error(filename, obj.starting_linenum, \'build/class\', 5,\n              \'Failed to find complete declaration of class %s\' %\n              obj.name)\n      elif isinstance(obj, _NamespaceInfo):\n        error(filename, obj.starting_linenum, \'build/namespaces\', 5,\n              \'Failed to find complete declaration of namespace %s\' %\n              obj.name)\n\n\ndef CheckForNonStandardConstructs(filename, clean_lines, linenum,\n                                  nesting_state, error):\n  r""""""Logs an error if we see certain non-ANSI constructs ignored by gcc-2.\n\n  Complain about several constructs which gcc-2 accepts, but which are\n  not standard C++.  Warning about these in lint is one way to ease the\n  transition to new compilers.\n  - put storage class first (e.g. ""static const"" instead of ""const static"").\n  - ""%lld"" instead of %qd"" in printf-type functions.\n  - ""%1$d"" is non-standard in printf-type functions.\n  - ""\\%"" is an undefined character escape sequence.\n  - text after #endif is not allowed.\n  - invalid inner-style forward declaration.\n  - >? and <? operators, and their >?= and <?= cousins.\n\n  Additionally, check for constructor/destructor style violations and reference\n  members, as it is very convenient to do so while checking for\n  gcc-2 compliance.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n  """"""\n\n  # Remove comments from the line, but leave in strings for now.\n  line = clean_lines.lines[linenum]\n\n  if Search(r\'printf\\s*\\(.*"".*%[-+ ]?\\d*q\', line):\n    error(filename, linenum, \'runtime/printf_format\', 3,\n          \'%q in format strings is deprecated.  Use %ll instead.\')\n\n  if Search(r\'printf\\s*\\(.*"".*%\\d+\\$\', line):\n    error(filename, linenum, \'runtime/printf_format\', 2,\n          \'%N$ formats are unconventional.  Try rewriting to avoid them.\')\n\n  # Remove escaped backslashes before looking for undefined escapes.\n  line = line.replace(\'\\\\\\\\\', \'\')\n\n  if Search(r\'(""|\\\').*\\\\(%|\\[|\\(|{)\', line):\n    error(filename, linenum, \'build/printf_format\', 3,\n          \'%, [, (, and { are undefined character escapes.  Unescape them.\')\n\n  # For the rest, work with both comments and strings removed.\n  line = clean_lines.elided[linenum]\n\n  if Search(r\'\\b(const|volatile|void|char|short|int|long\'\n            r\'|float|double|signed|unsigned\'\n            r\'|schar|u?int8|u?int16|u?int32|u?int64)\'\n            r\'\\s+(register|static|extern|typedef)\\b\',\n            line):\n    error(filename, linenum, \'build/storage_class\', 5,\n          \'Storage class (static, extern, typedef, etc) should be first.\')\n\n  if Match(r\'\\s*#\\s*endif\\s*[^/\\s]+\', line):\n    error(filename, linenum, \'build/endif_comment\', 5,\n          \'Uncommented text after #endif is non-standard.  Use a comment.\')\n\n  if Match(r\'\\s*class\\s+(\\w+\\s*::\\s*)+\\w+\\s*;\', line):\n    error(filename, linenum, \'build/forward_decl\', 5,\n          \'Inner-style forward declarations are invalid.  Remove this line.\')\n\n  if Search(r\'(\\w+|[+-]?\\d+(\\.\\d*)?)\\s*(<|>)\\?=?\\s*(\\w+|[+-]?\\d+)(\\.\\d*)?\',\n            line):\n    error(filename, linenum, \'build/deprecated\', 3,\n          \'>? and <? (max and min) operators are non-standard and deprecated.\')\n\n  if Search(r\'^\\s*const\\s*string\\s*&\\s*\\w+\\s*;\', line):\n    # TODO(unknown): Could it be expanded safely to arbitrary references,\n    # without triggering too many false positives? The first\n    # attempt triggered 5 warnings for mostly benign code in the regtest, hence\n    # the restriction.\n    # Here\'s the original regexp, for the reference:\n    # type_name = r\'\\w+((\\s*::\\s*\\w+)|(\\s*<\\s*\\w+?\\s*>))?\'\n    # r\'\\s*const\\s*\' + type_name + \'\\s*&\\s*\\w+\\s*;\'\n    error(filename, linenum, \'runtime/member_string_references\', 2,\n          \'const string& members are dangerous. It is much better to use \'\n          \'alternatives, such as pointers or simple constants.\')\n\n  # Everything else in this function operates on class declarations.\n  # Return early if the top of the nesting stack is not a class, or if\n  # the class head is not completed yet.\n  classinfo = nesting_state.InnermostClass()\n  if not classinfo or not classinfo.seen_open_brace:\n    return\n\n  # The class may have been declared with namespace or classname qualifiers.\n  # The constructor and destructor will not have those qualifiers.\n  base_classname = classinfo.name.split(\'::\')[-1]\n\n  # Look for single-argument constructors that aren\'t marked explicit.\n  # Technically a valid construct, but against style.\n  args = Match(r\'\\s+(?:inline\\s+)?%s\\s*\\(([^,()]+)\\)\'\n               % re.escape(base_classname),\n               line)\n  if (args and\n      args.group(1) != \'void\' and\n      not Match(r\'(const\\s+)?%s(\\s+const)?\\s*(?:<\\w+>\\s*)?&\'\n                % re.escape(base_classname), args.group(1).strip())):\n    error(filename, linenum, \'runtime/explicit\', 5,\n          \'Single-argument constructors should be marked explicit.\')\n\n\ndef CheckSpacingForFunctionCall(filename, line, linenum, error):\n  """"""Checks for the correctness of various spacing around function calls.\n\n  Args:\n    filename: The name of the current file.\n    line: The text of the line to check.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n\n  # Since function calls often occur inside if/for/while/switch\n  # expressions - which have their own, more liberal conventions - we\n  # first see if we should be looking inside such an expression for a\n  # function call, to which we can apply more strict standards.\n  fncall = line    # if there\'s no control flow construct, look at whole line\n  for pattern in (r\'\\bif\\s*\\((.*)\\)\\s*{\',\n                  r\'\\bfor\\s*\\((.*)\\)\\s*{\',\n                  r\'\\bwhile\\s*\\((.*)\\)\\s*[{;]\',\n                  r\'\\bswitch\\s*\\((.*)\\)\\s*{\'):\n    match = Search(pattern, line)\n    if match:\n      fncall = match.group(1)    # look inside the parens for function calls\n      break\n\n  # Except in if/for/while/switch, there should never be space\n  # immediately inside parens (eg ""f( 3, 4 )"").  We make an exception\n  # for nested parens ( (a+b) + c ).  Likewise, there should never be\n  # a space before a ( when it\'s a function argument.  I assume it\'s a\n  # function argument when the char before the whitespace is legal in\n  # a function name (alnum + _) and we\'re not starting a macro. Also ignore\n  # pointers and references to arrays and functions coz they\'re too tricky:\n  # we use a very simple way to recognize these:\n  # "" (something)(maybe-something)"" or\n  # "" (something)(maybe-something,"" or\n  # "" (something)[something]""\n  # Note that we assume the contents of [] to be short enough that\n  # they\'ll never need to wrap.\n  if (  # Ignore control structures.\n      not Search(r\'\\b(if|for|while|switch|return|new|delete|catch|sizeof)\\b\',\n                 fncall) and\n      # Ignore pointers/references to functions.\n      not Search(r\' \\([^)]+\\)\\([^)]*(\\)|,$)\', fncall) and\n      # Ignore pointers/references to arrays.\n      not Search(r\' \\([^)]+\\)\\[[^\\]]+\\]\', fncall)):\n    if Search(r\'\\w\\s*\\(\\s(?!\\s*\\\\$)\', fncall):      # a ( used for a fn call\n      error(filename, linenum, \'whitespace/parens\', 4,\n            \'Extra space after ( in function call\')\n    elif Search(r\'\\(\\s+(?!(\\s*\\\\)|\\()\', fncall):\n      error(filename, linenum, \'whitespace/parens\', 2,\n            \'Extra space after (\')\n    if (Search(r\'\\w\\s+\\(\', fncall) and\n        not Search(r\'#\\s*define|typedef\', fncall) and\n        not Search(r\'\\w\\s+\\((\\w+::)*\\*\\w+\\)\\(\', fncall)):\n      error(filename, linenum, \'whitespace/parens\', 4,\n            \'Extra space before ( in function call\')\n    # If the ) is followed only by a newline or a { + newline, assume it\'s\n    # part of a control statement (if/while/etc), and don\'t complain\n    if Search(r\'[^)]\\s+\\)\\s*[^{\\s]\', fncall):\n      # If the closing parenthesis is preceded by only whitespaces,\n      # try to give a more descriptive error message.\n      if Search(r\'^\\s+\\)\', fncall):\n        error(filename, linenum, \'whitespace/parens\', 2,\n              \'Closing ) should be moved to the previous line\')\n      else:\n        error(filename, linenum, \'whitespace/parens\', 2,\n              \'Extra space before )\')\n\n\ndef IsBlankLine(line):\n  """"""Returns true if the given line is blank.\n\n  We consider a line to be blank if the line is empty or consists of\n  only white spaces.\n\n  Args:\n    line: A line of a string.\n\n  Returns:\n    True, if the given line is blank.\n  """"""\n  return not line or line.isspace()\n\n\ndef CheckForFunctionLengths(filename, clean_lines, linenum,\n                            function_state, error):\n  """"""Reports for long function bodies.\n\n  For an overview why this is done, see:\n  http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Write_Short_Functions\n\n  Uses a simplistic algorithm assuming other style guidelines\n  (especially spacing) are followed.\n  Only checks unindented functions, so class members are unchecked.\n  Trivial bodies are unchecked, so constructors with huge initializer lists\n  may be missed.\n  Blank/comment lines are not counted so as to avoid encouraging the removal\n  of vertical space and comments just to get through a lint check.\n  NOLINT *on the last line of a function* disables this check.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    function_state: Current function name and lines in body so far.\n    error: The function to call with any errors found.\n  """"""\n  lines = clean_lines.lines\n  line = lines[linenum]\n  raw = clean_lines.raw_lines\n  raw_line = raw[linenum]\n  joined_line = \'\'\n\n  starting_func = False\n  regexp = r\'(\\w(\\w|::|\\*|\\&|\\s)*)\\(\'  # decls * & space::name( ...\n  match_result = Match(regexp, line)\n  if match_result:\n    # If the name is all caps and underscores, figure it\'s a macro and\n    # ignore it, unless it\'s TEST or TEST_F.\n    function_name = match_result.group(1).split()[-1]\n    if function_name == \'TEST\' or function_name == \'TEST_F\' or (\n        not Match(r\'[A-Z_]+$\', function_name)):\n      starting_func = True\n\n  if starting_func:\n    body_found = False\n    for start_linenum in xrange(linenum, clean_lines.NumLines()):\n      start_line = lines[start_linenum]\n      joined_line += \' \' + start_line.lstrip()\n      if Search(r\'(;|})\', start_line):  # Declarations and trivial functions\n        body_found = True\n        break                              # ... ignore\n      elif Search(r\'{\', start_line):\n        body_found = True\n        function = Search(r\'((\\w|:)*)\\(\', line).group(1)\n        if Match(r\'TEST\', function):    # Handle TEST... macros\n          parameter_regexp = Search(r\'(\\(.*\\))\', joined_line)\n          if parameter_regexp:             # Ignore bad syntax\n            function += parameter_regexp.group(1)\n        else:\n          function += \'()\'\n        function_state.Begin(function)\n        break\n    if not body_found:\n      # No body for the function (or evidence of a non-function) was found.\n      error(filename, linenum, \'readability/fn_size\', 5,\n            \'Lint failed to find start of function body.\')\n  elif Match(r\'^\\}\\s*$\', line):  # function end\n    function_state.Check(error, filename, linenum)\n    function_state.End()\n  elif not Match(r\'^\\s*$\', line):\n    function_state.Count()  # Count non-blank/non-comment lines.\n\n\n_RE_PATTERN_TODO = re.compile(r\'^//(\\s*)TODO(\\(.+?\\))?:?(\\s|$)?\')\n\n\ndef CheckComment(comment, filename, linenum, error):\n  """"""Checks for common mistakes in TODO comments.\n\n  Args:\n    comment: The text of the comment from the line in question.\n    filename: The name of the current file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  match = _RE_PATTERN_TODO.match(comment)\n  if match:\n    # One whitespace is correct; zero whitespace is handled elsewhere.\n    leading_whitespace = match.group(1)\n    if len(leading_whitespace) > 1:\n      error(filename, linenum, \'whitespace/todo\', 2,\n            \'Too many spaces before TODO\')\n\n    username = match.group(2)\n    if not username:\n      error(filename, linenum, \'readability/todo\', 2,\n            \'Missing username in TODO; it should look like \'\n            \'""// TODO(my_username): Stuff.""\')\n\n    middle_whitespace = match.group(3)\n    # Comparisons made explicit for correctness -- pylint: disable=g-explicit-bool-comparison\n    if middle_whitespace != \' \' and middle_whitespace != \'\':\n      error(filename, linenum, \'whitespace/todo\', 2,\n            \'TODO(my_username) should be followed by a space\')\n\ndef CheckAccess(filename, clean_lines, linenum, nesting_state, error):\n  """"""Checks for improper use of DISALLOW* macros.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]  # get rid of comments and strings\n\n  matched = Match((r\'\\s*(DISALLOW_COPY_AND_ASSIGN|\'\n                   r\'DISALLOW_EVIL_CONSTRUCTORS|\'\n                   r\'DISALLOW_IMPLICIT_CONSTRUCTORS)\'), line)\n  if not matched:\n    return\n  if nesting_state.stack and isinstance(nesting_state.stack[-1], _ClassInfo):\n    if nesting_state.stack[-1].access != \'private\':\n      error(filename, linenum, \'readability/constructors\', 3,\n            \'%s must be in the private: section\' % matched.group(1))\n\n  else:\n    # Found DISALLOW* macro outside a class declaration, or perhaps it\n    # was used inside a function when it should have been part of the\n    # class declaration.  We could issue a warning here, but it\n    # probably resulted in a compiler error already.\n    pass\n\n\ndef FindNextMatchingAngleBracket(clean_lines, linenum, init_suffix):\n  """"""Find the corresponding > to close a template.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: Current line number.\n    init_suffix: Remainder of the current line after the initial <.\n\n  Returns:\n    True if a matching bracket exists.\n  """"""\n  line = init_suffix\n  nesting_stack = [\'<\']\n  while True:\n    # Find the next operator that can tell us whether < is used as an\n    # opening bracket or as a less-than operator.  We only want to\n    # warn on the latter case.\n    #\n    # We could also check all other operators and terminate the search\n    # early, e.g. if we got something like this ""a<b+c"", the ""<"" is\n    # most likely a less-than operator, but then we will get false\n    # positives for default arguments and other template expressions.\n    match = Search(r\'^[^<>(),;\\[\\]]*([<>(),;\\[\\]])(.*)$\', line)\n    if match:\n      # Found an operator, update nesting stack\n      operator = match.group(1)\n      line = match.group(2)\n\n      if nesting_stack[-1] == \'<\':\n        # Expecting closing angle bracket\n        if operator in (\'<\', \'(\', \'[\'):\n          nesting_stack.append(operator)\n        elif operator == \'>\':\n          nesting_stack.pop()\n          if not nesting_stack:\n            # Found matching angle bracket\n            return True\n        elif operator == \',\':\n          # Got a comma after a bracket, this is most likely a template\n          # argument.  We have not seen a closing angle bracket yet, but\n          # it\'s probably a few lines later if we look for it, so just\n          # return early here.\n          return True\n        else:\n          # Got some other operator.\n          return False\n\n      else:\n        # Expecting closing parenthesis or closing bracket\n        if operator in (\'<\', \'(\', \'[\'):\n          nesting_stack.append(operator)\n        elif operator in (\')\', \']\'):\n          # We don\'t bother checking for matching () or [].  If we got\n          # something like (] or [), it would have been a syntax error.\n          nesting_stack.pop()\n\n    else:\n      # Scan the next line\n      linenum += 1\n      if linenum >= len(clean_lines.elided):\n        break\n      line = clean_lines.elided[linenum]\n\n  # Exhausted all remaining lines and still no matching angle bracket.\n  # Most likely the input was incomplete, otherwise we should have\n  # seen a semicolon and returned early.\n  return True\n\n\ndef FindPreviousMatchingAngleBracket(clean_lines, linenum, init_prefix):\n  """"""Find the corresponding < that started a template.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: Current line number.\n    init_prefix: Part of the current line before the initial >.\n\n  Returns:\n    True if a matching bracket exists.\n  """"""\n  line = init_prefix\n  nesting_stack = [\'>\']\n  while True:\n    # Find the previous operator\n    match = Search(r\'^(.*)([<>(),;\\[\\]])[^<>(),;\\[\\]]*$\', line)\n    if match:\n      # Found an operator, update nesting stack\n      operator = match.group(2)\n      line = match.group(1)\n\n      if nesting_stack[-1] == \'>\':\n        # Expecting opening angle bracket\n        if operator in (\'>\', \')\', \']\'):\n          nesting_stack.append(operator)\n        elif operator == \'<\':\n          nesting_stack.pop()\n          if not nesting_stack:\n            # Found matching angle bracket\n            return True\n        elif operator == \',\':\n          # Got a comma before a bracket, this is most likely a\n          # template argument.  The opening angle bracket is probably\n          # there if we look for it, so just return early here.\n          return True\n        else:\n          # Got some other operator.\n          return False\n\n      else:\n        # Expecting opening parenthesis or opening bracket\n        if operator in (\'>\', \')\', \']\'):\n          nesting_stack.append(operator)\n        elif operator in (\'(\', \'[\'):\n          nesting_stack.pop()\n\n    else:\n      # Scan the previous line\n      linenum -= 1\n      if linenum < 0:\n        break\n      line = clean_lines.elided[linenum]\n\n  # Exhausted all earlier lines and still no matching angle bracket.\n  return False\n\n\ndef CheckSpacing(filename, clean_lines, linenum, nesting_state, error):\n  """"""Checks for the correctness of various spacing issues in the code.\n\n  Things we check for: spaces around operators, spaces after\n  if/for/while/switch, no spaces around parens in function calls, two\n  spaces between code and comment, don\'t start a block with a blank\n  line, don\'t end a function with a blank line, don\'t add a blank line\n  after public/protected/private, don\'t have too many blank lines in a row.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  """"""\n\n  # Don\'t use ""elided"" lines here, otherwise we can\'t check commented lines.\n  # Don\'t want to use ""raw"" either, because we don\'t want to check inside C++11\n  # raw strings,\n  raw = clean_lines.lines_without_raw_strings\n  line = raw[linenum]\n\n  # Before nixing comments, check if the line is blank for no good\n  # reason.  This includes the first line after a block is opened, and\n  # blank lines at the end of a function (ie, right before a line like \'}\'\n  #\n  # Skip all the blank line checks if we are immediately inside a\n  # namespace body.  In other words, don\'t issue blank line warnings\n  # for this block:\n  #   namespace {\n  #\n  #   }\n  #\n  # A warning about missing end of namespace comments will be issued instead.\n  if IsBlankLine(line) and not nesting_state.InNamespaceBody():\n    elided = clean_lines.elided\n    prev_line = elided[linenum - 1]\n    prevbrace = prev_line.rfind(\'{\')\n    # TODO(unknown): Don\'t complain if line before blank line, and line after,\n    #                both start with alnums and are indented the same amount.\n    #                This ignores whitespace at the start of a namespace block\n    #                because those are not usually indented.\n    if prevbrace != -1 and prev_line[prevbrace:].find(\'}\') == -1:\n      # OK, we have a blank line at the start of a code block.  Before we\n      # complain, we check if it is an exception to the rule: The previous\n      # non-empty line has the parameters of a function header that are indented\n      # 4 spaces (because they did not fit in a 80 column line when placed on\n      # the same line as the function name).  We also check for the case where\n      # the previous line is indented 6 spaces, which may happen when the\n      # initializers of a constructor do not fit into a 80 column line.\n      exception = False\n      if Match(r\' {6}\\w\', prev_line):  # Initializer list?\n        # We are looking for the opening column of initializer list, which\n        # should be indented 4 spaces to cause 6 space indentation afterwards.\n        search_position = linenum-2\n        while (search_position >= 0\n               and Match(r\' {6}\\w\', elided[search_position])):\n          search_position -= 1\n        exception = (search_position >= 0\n                     and elided[search_position][:5] == \'    :\')\n      else:\n        # Search for the function arguments or an initializer list.  We use a\n        # simple heuristic here: If the line is indented 4 spaces; and we have a\n        # closing paren, without the opening paren, followed by an opening brace\n        # or colon (for initializer lists) we assume that it is the last line of\n        # a function header.  If we have a colon indented 4 spaces, it is an\n        # initializer list.\n        exception = (Match(r\' {4}\\w[^\\(]*\\)\\s*(const\\s*)?(\\{\\s*$|:)\',\n                           prev_line)\n                     or Match(r\' {4}:\', prev_line))\n\n      if not exception:\n        error(filename, linenum, \'whitespace/blank_line\', 2,\n              \'Redundant blank line at the start of a code block \'\n              \'should be deleted.\')\n    # Ignore blank lines at the end of a block in a long if-else\n    # chain, like this:\n    #   if (condition1) {\n    #     // Something followed by a blank line\n    #\n    #   } else if (condition2) {\n    #     // Something else\n    #   }\n    if linenum + 1 < clean_lines.NumLines():\n      next_line = raw[linenum + 1]\n      if (next_line\n          and Match(r\'\\s*}\', next_line)\n          and next_line.find(\'} else \') == -1):\n        error(filename, linenum, \'whitespace/blank_line\', 3,\n              \'Redundant blank line at the end of a code block \'\n              \'should be deleted.\')\n\n    matched = Match(r\'\\s*(public|protected|private):\', prev_line)\n    if matched:\n      error(filename, linenum, \'whitespace/blank_line\', 3,\n            \'Do not leave a blank line after ""%s:""\' % matched.group(1))\n\n  # Next, we complain if there\'s a comment too near the text\n  commentpos = line.find(\'//\')\n  if commentpos != -1:\n    # Check if the // may be in quotes.  If so, ignore it\n    # Comparisons made explicit for clarity -- pylint: disable=g-explicit-bool-comparison\n    if (line.count(\'""\', 0, commentpos) -\n        line.count(\'\\\\""\', 0, commentpos)) % 2 == 0:   # not in quotes\n      # Allow one space for new scopes, two spaces otherwise:\n      if (not Match(r\'^\\s*{ //\', line) and\n          ((commentpos >= 1 and\n            line[commentpos-1] not in string.whitespace) or\n           (commentpos >= 2 and\n            line[commentpos-2] not in string.whitespace))):\n        error(filename, linenum, \'whitespace/comments\', 2,\n              \'At least two spaces is best between code and comments\')\n      # There should always be a space between the // and the comment\n      commentend = commentpos + 2\n      if commentend < len(line) and not line[commentend] == \' \':\n        # but some lines are exceptions -- e.g. if they\'re big\n        # comment delimiters like:\n        # //----------------------------------------------------------\n        # or are an empty C++ style Doxygen comment, like:\n        # ///\n        # or C++ style Doxygen comments placed after the variable:\n        # ///<  Header comment\n        # //!<  Header comment\n        # or they begin with multiple slashes followed by a space:\n        # //////// Header comment\n        match = (Search(r\'[=/-]{4,}\\s*$\', line[commentend:]) or\n                 Search(r\'^/$\', line[commentend:]) or\n                 Search(r\'^!< \', line[commentend:]) or\n                 Search(r\'^/< \', line[commentend:]) or\n                 Search(r\'^/+ \', line[commentend:]))\n        if not match:\n          error(filename, linenum, \'whitespace/comments\', 4,\n                \'Should have a space between // and comment\')\n      CheckComment(line[commentpos:], filename, linenum, error)\n\n  line = clean_lines.elided[linenum]  # get rid of comments and strings\n\n  # Don\'t try to do spacing checks for operator methods\n  line = re.sub(r\'operator(==|!=|<|<<|<=|>=|>>|>)\\(\', \'operator\\(\', line)\n\n  # We allow no-spaces around = within an if: ""if ( (a=Foo()) == 0 )"".\n  # Otherwise not.  Note we only check for non-spaces on *both* sides;\n  # sometimes people put non-spaces on one side when aligning =\'s among\n  # many lines (not that this is behavior that I approve of...)\n  if Search(r\'[\\w.]=[\\w.]\', line) and not Search(r\'\\b(if|while) \', line):\n    error(filename, linenum, \'whitespace/operators\', 4,\n          \'Missing spaces around =\')\n\n  # It\'s ok not to have spaces around binary operators like + - * /, but if\n  # there\'s too little whitespace, we get concerned.  It\'s hard to tell,\n  # though, so we punt on this one for now.  TODO.\n\n  # You should always have whitespace around binary operators.\n  #\n  # Check <= and >= first to avoid false positives with < and >, then\n  # check non-include lines for spacing around < and >.\n  match = Search(r\'[^<>=!\\s](==|!=|<=|>=)[^<>=!\\s]\', line)\n  if match:\n    error(filename, linenum, \'whitespace/operators\', 3,\n          \'Missing spaces around %s\' % match.group(1))\n  # We allow no-spaces around << when used like this: 10<<20, but\n  # not otherwise (particularly, not when used as streams)\n  # Also ignore using ns::operator<<;\n  match = Search(r\'(operator|\\S)(?:L|UL|ULL|l|ul|ull)?<<(\\S)\', line)\n  if (match and\n      not (match.group(1).isdigit() and match.group(2).isdigit()) and\n      not (match.group(1) == \'operator\' and match.group(2) == \';\')):\n    error(filename, linenum, \'whitespace/operators\', 3,\n          \'Missing spaces around <<\')\n  elif not Match(r\'#.*include\', line):\n    # Avoid false positives on ->\n    reduced_line = line.replace(\'->\', \'\')\n\n    # Look for < that is not surrounded by spaces.  This is only\n    # triggered if both sides are missing spaces, even though\n    # technically should should flag if at least one side is missing a\n    # space.  This is done to avoid some false positives with shifts.\n    match = Search(r\'[^\\s<]<([^\\s=<].*)\', reduced_line)\n    if (match and\n        not FindNextMatchingAngleBracket(clean_lines, linenum, match.group(1))):\n      error(filename, linenum, \'whitespace/operators\', 3,\n            \'Missing spaces around <\')\n\n    # Look for > that is not surrounded by spaces.  Similar to the\n    # above, we only trigger if both sides are missing spaces to avoid\n    # false positives with shifts.\n    match = Search(r\'^(.*[^\\s>])>[^\\s=>]\', reduced_line)\n    if (match and\n        not FindPreviousMatchingAngleBracket(clean_lines, linenum,\n                                             match.group(1))):\n      error(filename, linenum, \'whitespace/operators\', 3,\n            \'Missing spaces around >\')\n\n  # We allow no-spaces around >> for almost anything.  This is because\n  # C++11 allows "">>"" to close nested templates, which accounts for\n  # most cases when "">>"" is not followed by a space.\n  #\n  # We still warn on "">>"" followed by alpha character, because that is\n  # likely due to "">>"" being used for right shifts, e.g.:\n  #   value >> alpha\n  #\n  # When "">>"" is used to close templates, the alphanumeric letter that\n  # follows would be part of an identifier, and there should still be\n  # a space separating the template type and the identifier.\n  #   type<type<type>> alpha\n  match = Search(r\'>>[a-zA-Z_]\', line)\n  if match:\n    error(filename, linenum, \'whitespace/operators\', 3,\n          \'Missing spaces around >>\')\n\n  # There shouldn\'t be space around unary operators\n  match = Search(r\'(!\\s|~\\s|[\\s]--[\\s;]|[\\s]\\+\\+[\\s;])\', line)\n  if match:\n    error(filename, linenum, \'whitespace/operators\', 4,\n          \'Extra space for operator %s\' % match.group(1))\n\n  # A pet peeve of mine: no spaces after an if, while, switch, or for\n  match = Search(r\' (if\\(|for\\(|while\\(|switch\\()\', line)\n  if match:\n    error(filename, linenum, \'whitespace/parens\', 5,\n          \'Missing space before ( in %s\' % match.group(1))\n\n  # For if/for/while/switch, the left and right parens should be\n  # consistent about how many spaces are inside the parens, and\n  # there should either be zero or one spaces inside the parens.\n  # We don\'t want: ""if ( foo)"" or ""if ( foo   )"".\n  # Exception: ""for ( ; foo; bar)"" and ""for (foo; bar; )"" are allowed.\n  match = Search(r\'\\b(if|for|while|switch)\\s*\'\n                 r\'\\(([ ]*)(.).*[^ ]+([ ]*)\\)\\s*{\\s*$\',\n                 line)\n  if match:\n    if len(match.group(2)) != len(match.group(4)):\n      if not (match.group(3) == \';\' and\n              len(match.group(2)) == 1 + len(match.group(4)) or\n              not match.group(2) and Search(r\'\\bfor\\s*\\(.*; \\)\', line)):\n        error(filename, linenum, \'whitespace/parens\', 5,\n              \'Mismatching spaces inside () in %s\' % match.group(1))\n    if len(match.group(2)) not in [0, 1]:\n      error(filename, linenum, \'whitespace/parens\', 5,\n            \'Should have zero or one spaces inside ( and ) in %s\' %\n            match.group(1))\n\n  # You should always have a space after a comma (either as fn arg or operator)\n  #\n  # This does not apply when the non-space character following the\n  # comma is another comma, since the only time when that happens is\n  # for empty macro arguments.\n  #\n  # We run this check in two passes: first pass on elided lines to\n  # verify that lines contain missing whitespaces, second pass on raw\n  # lines to confirm that those missing whitespaces are not due to\n  # elided comments.\n  if Search(r\',[^,\\s]\', line) and Search(r\',[^,\\s]\', raw[linenum]):\n    error(filename, linenum, \'whitespace/comma\', 3,\n          \'Missing space after ,\')\n\n  # You should always have a space after a semicolon\n  # except for few corner cases\n  # TODO(unknown): clarify if \'if (1) { return 1;}\' is requires one more\n  # space after ;\n  if Search(r\';[^\\s};\\\\)/]\', line):\n    error(filename, linenum, \'whitespace/semicolon\', 3,\n          \'Missing space after ;\')\n\n  # Next we will look for issues with function calls.\n  CheckSpacingForFunctionCall(filename, line, linenum, error)\n\n  # Except after an opening paren, or after another opening brace (in case of\n  # an initializer list, for instance), you should have spaces before your\n  # braces. And since you should never have braces at the beginning of a line,\n  # this is an easy test.\n  match = Match(r\'^(.*[^ ({]){\', line)\n  if match:\n    # Try a bit harder to check for brace initialization.  This\n    # happens in one of the following forms:\n    #   Constructor() : initializer_list_{} { ... }\n    #   Constructor{}.MemberFunction()\n    #   Type variable{};\n    #   FunctionCall(type{}, ...);\n    #   LastArgument(..., type{});\n    #   LOG(INFO) << type{} << "" ..."";\n    #   map_of_type[{...}] = ...;\n    #\n    # We check for the character following the closing brace, and\n    # silence the warning if it\'s one of those listed above, i.e.\n    # ""{.;,)<]"".\n    #\n    # To account for nested initializer list, we allow any number of\n    # closing braces up to ""{;,)<"".  We can\'t simply silence the\n    # warning on first sight of closing brace, because that would\n    # cause false negatives for things that are not initializer lists.\n    #   Silence this:         But not this:\n    #     Outer{                if (...) {\n    #       Inner{...}            if (...){  // Missing space before {\n    #     };                    }\n    #\n    # There is a false negative with this approach if people inserted\n    # spurious semicolons, e.g. ""if (cond){};"", but we will catch the\n    # spurious semicolon with a separate check.\n    (endline, endlinenum, endpos) = CloseExpression(\n        clean_lines, linenum, len(match.group(1)))\n    trailing_text = \'\'\n    if endpos > -1:\n      trailing_text = endline[endpos:]\n    for offset in xrange(endlinenum + 1,\n                         min(endlinenum + 3, clean_lines.NumLines() - 1)):\n      trailing_text += clean_lines.elided[offset]\n    if not Match(r\'^[\\s}]*[{.;,)<\\]]\', trailing_text):\n      error(filename, linenum, \'whitespace/braces\', 5,\n            \'Missing space before {\')\n\n  # Make sure \'} else {\' has spaces.\n  if Search(r\'}else\', line):\n    error(filename, linenum, \'whitespace/braces\', 5,\n          \'Missing space before else\')\n\n  # You shouldn\'t have spaces before your brackets, except maybe after\n  # \'delete []\' or \'new char * []\'.\n  if Search(r\'\\w\\s+\\[\', line) and not Search(r\'delete\\s+\\[\', line):\n    error(filename, linenum, \'whitespace/braces\', 5,\n          \'Extra space before [\')\n\n  # You shouldn\'t have a space before a semicolon at the end of the line.\n  # There\'s a special case for ""for"" since the style guide allows space before\n  # the semicolon there.\n  if Search(r\':\\s*;\\s*$\', line):\n    error(filename, linenum, \'whitespace/semicolon\', 5,\n          \'Semicolon defining empty statement. Use {} instead.\')\n  elif Search(r\'^\\s*;\\s*$\', line):\n    error(filename, linenum, \'whitespace/semicolon\', 5,\n          \'Line contains only semicolon. If this should be an empty statement, \'\n          \'use {} instead.\')\n  elif (Search(r\'\\s+;\\s*$\', line) and\n        not Search(r\'\\bfor\\b\', line)):\n    error(filename, linenum, \'whitespace/semicolon\', 5,\n          \'Extra space before last semicolon. If this should be an empty \'\n          \'statement, use {} instead.\')\n\n  # In range-based for, we wanted spaces before and after the colon, but\n  # not around ""::"" tokens that might appear.\n  if (Search(\'for *\\(.*[^:]:[^: ]\', line) or\n      Search(\'for *\\(.*[^: ]:[^:]\', line)):\n    error(filename, linenum, \'whitespace/forcolon\', 2,\n          \'Missing space around colon in range-based for loop\')\n\n\ndef CheckSectionSpacing(filename, clean_lines, class_info, linenum, error):\n  """"""Checks for additional blank line issues related to sections.\n\n  Currently the only thing checked here is blank line before protected/private.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    class_info: A _ClassInfo objects.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  # Skip checks if the class is small, where small means 25 lines or less.\n  # 25 lines seems like a good cutoff since that\'s the usual height of\n  # terminals, and any class that can\'t fit in one screen can\'t really\n  # be considered ""small"".\n  #\n  # Also skip checks if we are on the first line.  This accounts for\n  # classes that look like\n  #   class Foo { public: ... };\n  #\n  # If we didn\'t find the end of the class, last_line would be zero,\n  # and the check will be skipped by the first condition.\n  if (class_info.last_line - class_info.starting_linenum <= 24 or\n      linenum <= class_info.starting_linenum):\n    return\n\n  matched = Match(r\'\\s*(public|protected|private):\', clean_lines.lines[linenum])\n  if matched:\n    # Issue warning if the line before public/protected/private was\n    # not a blank line, but don\'t do this if the previous line contains\n    # ""class"" or ""struct"".  This can happen two ways:\n    #  - We are at the beginning of the class.\n    #  - We are forward-declaring an inner class that is semantically\n    #    private, but needed to be public for implementation reasons.\n    # Also ignores cases where the previous line ends with a backslash as can be\n    # common when defining classes in C macros.\n    prev_line = clean_lines.lines[linenum - 1]\n    if (not IsBlankLine(prev_line) and\n        not Search(r\'\\b(class|struct)\\b\', prev_line) and\n        not Search(r\'\\\\$\', prev_line)):\n      # Try a bit harder to find the beginning of the class.  This is to\n      # account for multi-line base-specifier lists, e.g.:\n      #   class Derived\n      #       : public Base {\n      end_class_head = class_info.starting_linenum\n      for i in range(class_info.starting_linenum, linenum):\n        if Search(r\'\\{\\s*$\', clean_lines.lines[i]):\n          end_class_head = i\n          break\n      if end_class_head < linenum - 1:\n        error(filename, linenum, \'whitespace/blank_line\', 3,\n              \'""%s:"" should be preceded by a blank line\' % matched.group(1))\n\n\ndef GetPreviousNonBlankLine(clean_lines, linenum):\n  """"""Return the most recent non-blank line and its line number.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file contents.\n    linenum: The number of the line to check.\n\n  Returns:\n    A tuple with two elements.  The first element is the contents of the last\n    non-blank line before the current line, or the empty string if this is the\n    first non-blank line.  The second is the line number of that line, or -1\n    if this is the first non-blank line.\n  """"""\n\n  prevlinenum = linenum - 1\n  while prevlinenum >= 0:\n    prevline = clean_lines.elided[prevlinenum]\n    if not IsBlankLine(prevline):     # if not a blank line...\n      return (prevline, prevlinenum)\n    prevlinenum -= 1\n  return (\'\', -1)\n\n\ndef CheckBraces(filename, clean_lines, linenum, error):\n  """"""Looks for misplaced braces (e.g. at the end of line).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n\n  line = clean_lines.elided[linenum]        # get rid of comments and strings\n\n  if Match(r\'\\s*{\\s*$\', line):\n    # We allow an open brace to start a line in the case where someone is using\n    # braces in a block to explicitly create a new scope, which is commonly used\n    # to control the lifetime of stack-allocated variables.  Braces are also\n    # used for brace initializers inside function calls.  We don\'t detect this\n    # perfectly: we just don\'t complain if the last non-whitespace character on\n    # the previous non-blank line is \',\', \';\', \':\', \'(\', \'{\', or \'}\', or if the\n    # previous line starts a preprocessor block.\n    prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]\n    if (not Search(r\'[,;:}{(]\\s*$\', prevline) and\n        not Match(r\'\\s*#\', prevline)):\n      error(filename, linenum, \'whitespace/braces\', 4,\n            \'{ should almost always be at the end of the previous line\')\n\n  # An else clause should be on the same line as the preceding closing brace.\n  if Match(r\'\\s*else\\s*\', line):\n    prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]\n    if Match(r\'\\s*}\\s*$\', prevline):\n      error(filename, linenum, \'whitespace/newline\', 4,\n            \'An else should appear on the same line as the preceding }\')\n\n  # If braces come on one side of an else, they should be on both.\n  # However, we have to worry about ""else if"" that spans multiple lines!\n  if Search(r\'}\\s*else[^{]*$\', line) or Match(r\'[^}]*else\\s*{\', line):\n    if Search(r\'}\\s*else if([^{]*)$\', line):       # could be multi-line if\n      # find the ( after the if\n      pos = line.find(\'else if\')\n      pos = line.find(\'(\', pos)\n      if pos > 0:\n        (endline, _, endpos) = CloseExpression(clean_lines, linenum, pos)\n        if endline[endpos:].find(\'{\') == -1:    # must be brace after if\n          error(filename, linenum, \'readability/braces\', 5,\n                \'If an else has a brace on one side, it should have it on both\')\n    else:            # common case: else not followed by a multi-line if\n      error(filename, linenum, \'readability/braces\', 5,\n            \'If an else has a brace on one side, it should have it on both\')\n\n  # Likewise, an else should never have the else clause on the same line\n  if Search(r\'\\belse [^\\s{]\', line) and not Search(r\'\\belse if\\b\', line):\n    error(filename, linenum, \'whitespace/newline\', 4,\n          \'Else clause should never be on same line as else (use 2 lines)\')\n\n  # In the same way, a do/while should never be on one line\n  if Match(r\'\\s*do [^\\s{]\', line):\n    error(filename, linenum, \'whitespace/newline\', 4,\n          \'do/while clauses should not be on a single line\')\n\n  # Block bodies should not be followed by a semicolon.  Due to C++11\n  # brace initialization, there are more places where semicolons are\n  # required than not, so we use a whitelist approach to check these\n  # rather than a blacklist.  These are the places where ""};"" should\n  # be replaced by just ""}"":\n  # 1. Some flavor of block following closing parenthesis:\n  #    for (;;) {};\n  #    while (...) {};\n  #    switch (...) {};\n  #    Function(...) {};\n  #    if (...) {};\n  #    if (...) else if (...) {};\n  #\n  # 2. else block:\n  #    if (...) else {};\n  #\n  # 3. const member function:\n  #    Function(...) const {};\n  #\n  # 4. Block following some statement:\n  #    x = 42;\n  #    {};\n  #\n  # 5. Block at the beginning of a function:\n  #    Function(...) {\n  #      {};\n  #    }\n  #\n  #    Note that naively checking for the preceding ""{"" will also match\n  #    braces inside multi-dimensional arrays, but this is fine since\n  #    that expression will not contain semicolons.\n  #\n  # 6. Block following another block:\n  #    while (true) {}\n  #    {};\n  #\n  # 7. End of namespaces:\n  #    namespace {};\n  #\n  #    These semicolons seems far more common than other kinds of\n  #    redundant semicolons, possibly due to people converting classes\n  #    to namespaces.  For now we do not warn for this case.\n  #\n  # Try matching case 1 first.\n  match = Match(r\'^(.*\\)\\s*)\\{\', line)\n  if match:\n    # Matched closing parenthesis (case 1).  Check the token before the\n    # matching opening parenthesis, and don\'t warn if it looks like a\n    # macro.  This avoids these false positives:\n    #  - macro that defines a base class\n    #  - multi-line macro that defines a base class\n    #  - macro that defines the whole class-head\n    #\n    # But we still issue warnings for macros that we know are safe to\n    # warn, specifically:\n    #  - TEST, TEST_F, TEST_P, MATCHER, MATCHER_P\n    #  - TYPED_TEST\n    #  - INTERFACE_DEF\n    #  - EXCLUSIVE_LOCKS_REQUIRED, SHARED_LOCKS_REQUIRED, LOCKS_EXCLUDED:\n    #\n    # We implement a whitelist of safe macros instead of a blacklist of\n    # unsafe macros, even though the latter appears less frequently in\n    # google code and would have been easier to implement.  This is because\n    # the downside for getting the whitelist wrong means some extra\n    # semicolons, while the downside for getting the blacklist wrong\n    # would result in compile errors.\n    #\n    # In addition to macros, we also don\'t want to warn on compound\n    # literals.\n    closing_brace_pos = match.group(1).rfind(\')\')\n    opening_parenthesis = ReverseCloseExpression(\n        clean_lines, linenum, closing_brace_pos)\n    if opening_parenthesis[2] > -1:\n      line_prefix = opening_parenthesis[0][0:opening_parenthesis[2]]\n      macro = Search(r\'\\b([A-Z_]+)\\s*$\', line_prefix)\n      if ((macro and\n           macro.group(1) not in (\n               \'TEST\', \'TEST_F\', \'MATCHER\', \'MATCHER_P\', \'TYPED_TEST\',\n               \'EXCLUSIVE_LOCKS_REQUIRED\', \'SHARED_LOCKS_REQUIRED\',\n               \'LOCKS_EXCLUDED\', \'INTERFACE_DEF\')) or\n          Search(r\'\\s+=\\s*$\', line_prefix)):\n        match = None\n\n  else:\n    # Try matching cases 2-3.\n    match = Match(r\'^(.*(?:else|\\)\\s*const)\\s*)\\{\', line)\n    if not match:\n      # Try matching cases 4-6.  These are always matched on separate lines.\n      #\n      # Note that we can\'t simply concatenate the previous line to the\n      # current line and do a single match, otherwise we may output\n      # duplicate warnings for the blank line case:\n      #   if (cond) {\n      #     // blank line\n      #   }\n      prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]\n      if prevline and Search(r\'[;{}]\\s*$\', prevline):\n        match = Match(r\'^(\\s*)\\{\', line)\n\n  # Check matching closing brace\n  if match:\n    (endline, endlinenum, endpos) = CloseExpression(\n        clean_lines, linenum, len(match.group(1)))\n    if endpos > -1 and Match(r\'^\\s*;\', endline[endpos:]):\n      # Current {} pair is eligible for semicolon check, and we have found\n      # the redundant semicolon, output warning here.\n      #\n      # Note: because we are scanning forward for opening braces, and\n      # outputting warnings for the matching closing brace, if there are\n      # nested blocks with trailing semicolons, we will get the error\n      # messages in reversed order.\n      error(filename, endlinenum, \'readability/braces\', 4,\n            ""You don\'t need a ; after a }"")\n\n\ndef CheckEmptyBlockBody(filename, clean_lines, linenum, error):\n  """"""Look for empty loop/conditional body with only a single semicolon.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n\n  # Search for loop keywords at the beginning of the line.  Because only\n  # whitespaces are allowed before the keywords, this will also ignore most\n  # do-while-loops, since those lines should start with closing brace.\n  #\n  # We also check ""if"" blocks here, since an empty conditional block\n  # is likely an error.\n  line = clean_lines.elided[linenum]\n  matched = Match(r\'\\s*(for|while|if)\\s*\\(\', line)\n  if matched:\n    # Find the end of the conditional expression\n    (end_line, end_linenum, end_pos) = CloseExpression(\n        clean_lines, linenum, line.find(\'(\'))\n\n    # Output warning if what follows the condition expression is a semicolon.\n    # No warning for all other cases, including whitespace or newline, since we\n    # have a separate check for semicolons preceded by whitespace.\n    if end_pos >= 0 and Match(r\';\', end_line[end_pos:]):\n      if matched.group(1) == \'if\':\n        error(filename, end_linenum, \'whitespace/empty_conditional_body\', 5,\n              \'Empty conditional bodies should use {}\')\n      else:\n        error(filename, end_linenum, \'whitespace/empty_loop_body\', 5,\n              \'Empty loop bodies should use {} or continue\')\n\n\ndef CheckCheck(filename, clean_lines, linenum, error):\n  """"""Checks the use of CHECK and EXPECT macros.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n\n  # Decide the set of replacement macros that should be suggested\n  lines = clean_lines.elided\n  check_macro = None\n  start_pos = -1\n  for macro in _CHECK_MACROS:\n    i = lines[linenum].find(macro)\n    if i >= 0:\n      check_macro = macro\n\n      # Find opening parenthesis.  Do a regular expression match here\n      # to make sure that we are matching the expected CHECK macro, as\n      # opposed to some other macro that happens to contain the CHECK\n      # substring.\n      matched = Match(r\'^(.*\\b\' + check_macro + r\'\\s*)\\(\', lines[linenum])\n      if not matched:\n        continue\n      start_pos = len(matched.group(1))\n      break\n  if not check_macro or start_pos < 0:\n    # Don\'t waste time here if line doesn\'t contain \'CHECK\' or \'EXPECT\'\n    return\n\n  # Find end of the boolean expression by matching parentheses\n  (last_line, end_line, end_pos) = CloseExpression(\n      clean_lines, linenum, start_pos)\n  if end_pos < 0:\n    return\n  if linenum == end_line:\n    expression = lines[linenum][start_pos + 1:end_pos - 1]\n  else:\n    expression = lines[linenum][start_pos + 1:]\n    for i in xrange(linenum + 1, end_line):\n      expression += lines[i]\n    expression += last_line[0:end_pos - 1]\n\n  # Parse expression so that we can take parentheses into account.\n  # This avoids false positives for inputs like ""CHECK((a < 4) == b)"",\n  # which is not replaceable by CHECK_LE.\n  lhs = \'\'\n  rhs = \'\'\n  operator = None\n  while expression:\n    matched = Match(r\'^\\s*(<<|<<=|>>|>>=|->\\*|->|&&|\\|\\||\'\n                    r\'==|!=|>=|>|<=|<|\\()(.*)$\', expression)\n    if matched:\n      token = matched.group(1)\n      if token == \'(\':\n        # Parenthesized operand\n        expression = matched.group(2)\n        (end, _) = FindEndOfExpressionInLine(expression, 0, 1, \'(\', \')\')\n        if end < 0:\n          return  # Unmatched parenthesis\n        lhs += \'(\' + expression[0:end]\n        expression = expression[end:]\n      elif token in (\'&&\', \'||\'):\n        # Logical and/or operators.  This means the expression\n        # contains more than one term, for example:\n        #   CHECK(42 < a && a < b);\n        #\n        # These are not replaceable with CHECK_LE, so bail out early.\n        return\n      elif token in (\'<<\', \'<<=\', \'>>\', \'>>=\', \'->*\', \'->\'):\n        # Non-relational operator\n        lhs += token\n        expression = matched.group(2)\n      else:\n        # Relational operator\n        operator = token\n        rhs = matched.group(2)\n        break\n    else:\n      # Unparenthesized operand.  Instead of appending to lhs one character\n      # at a time, we do another regular expression match to consume several\n      # characters at once if possible.  Trivial benchmark shows that this\n      # is more efficient when the operands are longer than a single\n      # character, which is generally the case.\n      matched = Match(r\'^([^-=!<>()&|]+)(.*)$\', expression)\n      if not matched:\n        matched = Match(r\'^(\\s*\\S)(.*)$\', expression)\n        if not matched:\n          break\n      lhs += matched.group(1)\n      expression = matched.group(2)\n\n  # Only apply checks if we got all parts of the boolean expression\n  if not (lhs and operator and rhs):\n    return\n\n  # Check that rhs do not contain logical operators.  We already know\n  # that lhs is fine since the loop above parses out && and ||.\n  if rhs.find(\'&&\') > -1 or rhs.find(\'||\') > -1:\n    return\n\n  # At least one of the operands must be a constant literal.  This is\n  # to avoid suggesting replacements for unprintable things like\n  # CHECK(variable != iterator)\n  #\n  # The following pattern matches decimal, hex integers, strings, and\n  # characters (in that order).\n  lhs = lhs.strip()\n  rhs = rhs.strip()\n  match_constant = r\'^([-+]?(\\d+|0[xX][0-9a-fA-F]+)[lLuU]{0,3}|"".*""|\\\'.*\\\')$\'\n  if Match(match_constant, lhs) or Match(match_constant, rhs):\n    # Note: since we know both lhs and rhs, we can provide a more\n    # descriptive error message like:\n    #   Consider using CHECK_EQ(x, 42) instead of CHECK(x == 42)\n    # Instead of:\n    #   Consider using CHECK_EQ instead of CHECK(a == b)\n    #\n    # We are still keeping the less descriptive message because if lhs\n    # or rhs gets long, the error message might become unreadable.\n    error(filename, linenum, \'readability/check\', 2,\n          \'Consider using %s instead of %s(a %s b)\' % (\n              _CHECK_REPLACEMENT[check_macro][operator],\n              check_macro, operator))\n\n\ndef CheckAltTokens(filename, clean_lines, linenum, error):\n  """"""Check alternative keywords being used in boolean expressions.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n\n  # Avoid preprocessor lines\n  if Match(r\'^\\s*#\', line):\n    return\n\n  # Last ditch effort to avoid multi-line comments.  This will not help\n  # if the comment started before the current line or ended after the\n  # current line, but it catches most of the false positives.  At least,\n  # it provides a way to workaround this warning for people who use\n  # multi-line comments in preprocessor macros.\n  #\n  # TODO(unknown): remove this once cpplint has better support for\n  # multi-line comments.\n  if line.find(\'/*\') >= 0 or line.find(\'*/\') >= 0:\n    return\n\n  for match in _ALT_TOKEN_REPLACEMENT_PATTERN.finditer(line):\n    error(filename, linenum, \'readability/alt_tokens\', 2,\n          \'Use operator %s instead of %s\' % (\n              _ALT_TOKEN_REPLACEMENT[match.group(1)], match.group(1)))\n\n\ndef GetLineWidth(line):\n  """"""Determines the width of the line in column positions.\n\n  Args:\n    line: A string, which may be a Unicode string.\n\n  Returns:\n    The width of the line in column positions, accounting for Unicode\n    combining characters and wide characters.\n  """"""\n  if isinstance(line, unicode):\n    width = 0\n    for uc in unicodedata.normalize(\'NFC\', line):\n      if unicodedata.east_asian_width(uc) in (\'W\', \'F\'):\n        width += 2\n      elif not unicodedata.combining(uc):\n        width += 1\n    return width\n  else:\n    return len(line)\n\n\ndef CheckStyle(filename, clean_lines, linenum, file_extension, nesting_state,\n               error):\n  """"""Checks rules from the \'C++ style rules\' section of cppguide.html.\n\n  Most of these rules are hard to test (naming, comment style), but we\n  do what we can.  In particular we check for 2-space indents, line lengths,\n  tab usage, spaces inside code, etc.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    file_extension: The extension (without the dot) of the filename.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  """"""\n\n  # Don\'t use ""elided"" lines here, otherwise we can\'t check commented lines.\n  # Don\'t want to use ""raw"" either, because we don\'t want to check inside C++11\n  # raw strings,\n  raw_lines = clean_lines.lines_without_raw_strings\n  line = raw_lines[linenum]\n\n  if line.find(\'\\t\') != -1:\n    error(filename, linenum, \'whitespace/tab\', 1,\n          \'Tab found; better to use spaces\')\n\n  # One or three blank spaces at the beginning of the line is weird; it\'s\n  # hard to reconcile that with 2-space indents.\n  # NOTE: here are the conditions rob pike used for his tests.  Mine aren\'t\n  # as sophisticated, but it may be worth becoming so:  RLENGTH==initial_spaces\n  # if(RLENGTH > 20) complain = 0;\n  # if(match($0, "" +(error|private|public|protected):"")) complain = 0;\n  # if(match(prev, ""&& *$"")) complain = 0;\n  # if(match(prev, ""\\\\|\\\\| *$"")) complain = 0;\n  # if(match(prev, ""[\\"",=><] *$"")) complain = 0;\n  # if(match($0, "" <<"")) complain = 0;\n  # if(match(prev, "" +for \\\\("")) complain = 0;\n  # if(prevodd && match(prevprev, "" +for \\\\("")) complain = 0;\n  initial_spaces = 0\n  cleansed_line = clean_lines.elided[linenum]\n  while initial_spaces < len(line) and line[initial_spaces] == \' \':\n    initial_spaces += 1\n  if line and line[-1].isspace():\n    error(filename, linenum, \'whitespace/end_of_line\', 4,\n          \'Line ends in whitespace.  Consider deleting these extra spaces.\')\n  # There are certain situations we allow one space, notably for section labels\n  elif ((initial_spaces == 1 or initial_spaces == 3) and\n        not Match(r\'\\s*\\w+\\s*:\\s*$\', cleansed_line)):\n    error(filename, linenum, \'whitespace/indent\', 3,\n          \'Weird number of spaces at line-start.  \'\n          \'Are you using a 2-space indent?\')\n\n  # Check if the line is a header guard.\n  is_header_guard = False\n  if file_extension == \'h\':\n    cppvar = GetHeaderGuardCPPVariable(filename)\n    if (line.startswith(\'#ifndef %s\' % cppvar) or\n        line.startswith(\'#define %s\' % cppvar) or\n        line.startswith(\'#endif  // %s\' % cppvar)):\n      is_header_guard = True\n  # #include lines and header guards can be long, since there\'s no clean way to\n  # split them.\n  #\n  # URLs can be long too.  It\'s possible to split these, but it makes them\n  # harder to cut&paste.\n  #\n  # The ""$Id:...$"" comment may also get very long without it being the\n  # developers fault.\n  if (not line.startswith(\'#include\') and not is_header_guard and\n      not Match(r\'^\\s*//.*http(s?)://\\S*$\', line) and\n      not Match(r\'^// \\$Id:.*#[0-9]+ \\$$\', line)):\n    line_width = GetLineWidth(line)\n    extended_length = int((_line_length * 1.25))\n    if line_width > extended_length:\n      error(filename, linenum, \'whitespace/line_length\', 4,\n            \'Lines should very rarely be longer than %i characters\' %\n            extended_length)\n    elif line_width > _line_length:\n      error(filename, linenum, \'whitespace/line_length\', 2,\n            \'Lines should be <= %i characters long\' % _line_length)\n\n  if (cleansed_line.count(\';\') > 1 and\n      # for loops are allowed two ;\'s (and may run over two lines).\n      cleansed_line.find(\'for\') == -1 and\n      (GetPreviousNonBlankLine(clean_lines, linenum)[0].find(\'for\') == -1 or\n       GetPreviousNonBlankLine(clean_lines, linenum)[0].find(\';\') != -1) and\n      # It\'s ok to have many commands in a switch case that fits in 1 line\n      not ((cleansed_line.find(\'case \') != -1 or\n            cleansed_line.find(\'default:\') != -1) and\n           cleansed_line.find(\'break;\') != -1)):\n    error(filename, linenum, \'whitespace/newline\', 0,\n          \'More than one command on the same line\')\n\n  # Some more style checks\n  CheckBraces(filename, clean_lines, linenum, error)\n  CheckEmptyBlockBody(filename, clean_lines, linenum, error)\n  CheckAccess(filename, clean_lines, linenum, nesting_state, error)\n  CheckSpacing(filename, clean_lines, linenum, nesting_state, error)\n  CheckCheck(filename, clean_lines, linenum, error)\n  CheckAltTokens(filename, clean_lines, linenum, error)\n  classinfo = nesting_state.InnermostClass()\n  if classinfo:\n    CheckSectionSpacing(filename, clean_lines, classinfo, linenum, error)\n\n\n_RE_PATTERN_INCLUDE_NEW_STYLE = re.compile(r\'#include +""[^/]+\\.h""\')\n_RE_PATTERN_INCLUDE = re.compile(r\'^\\s*#\\s*include\\s*([<""])([^>""]*)[>""].*$\')\n# Matches the first component of a filename delimited by -s and _s. That is:\n#  _RE_FIRST_COMPONENT.match(\'foo\').group(0) == \'foo\'\n#  _RE_FIRST_COMPONENT.match(\'foo.cc\').group(0) == \'foo\'\n#  _RE_FIRST_COMPONENT.match(\'foo-bar_baz.cc\').group(0) == \'foo\'\n#  _RE_FIRST_COMPONENT.match(\'foo_bar-baz.cc\').group(0) == \'foo\'\n_RE_FIRST_COMPONENT = re.compile(r\'^[^-_.]+\')\n\n\ndef _DropCommonSuffixes(filename):\n  """"""Drops common suffixes like _test.cc or -inl.h from filename.\n\n  For example:\n    >>> _DropCommonSuffixes(\'foo/foo-inl.h\')\n    \'foo/foo\'\n    >>> _DropCommonSuffixes(\'foo/bar/foo.cc\')\n    \'foo/bar/foo\'\n    >>> _DropCommonSuffixes(\'foo/foo_internal.h\')\n    \'foo/foo\'\n    >>> _DropCommonSuffixes(\'foo/foo_unusualinternal.h\')\n    \'foo/foo_unusualinternal\'\n\n  Args:\n    filename: The input filename.\n\n  Returns:\n    The filename with the common suffix removed.\n  """"""\n  for suffix in (\'test.cc\', \'regtest.cc\', \'unittest.cc\',\n                 \'inl.h\', \'impl.h\', \'internal.h\'):\n    if (filename.endswith(suffix) and len(filename) > len(suffix) and\n        filename[-len(suffix) - 1] in (\'-\', \'_\')):\n      return filename[:-len(suffix) - 1]\n  return os.path.splitext(filename)[0]\n\n\ndef _IsTestFilename(filename):\n  """"""Determines if the given filename has a suffix that identifies it as a test.\n\n  Args:\n    filename: The input filename.\n\n  Returns:\n    True if \'filename\' looks like a test, False otherwise.\n  """"""\n  if (filename.endswith(\'_test.cc\') or\n      filename.endswith(\'_unittest.cc\') or\n      filename.endswith(\'_regtest.cc\')):\n    return True\n  else:\n    return False\n\n\ndef _ClassifyInclude(fileinfo, include, is_system):\n  """"""Figures out what kind of header \'include\' is.\n\n  Args:\n    fileinfo: The current file cpplint is running over. A FileInfo instance.\n    include: The path to a #included file.\n    is_system: True if the #include used <> rather than """".\n\n  Returns:\n    One of the _XXX_HEADER constants.\n\n  For example:\n    >>> _ClassifyInclude(FileInfo(\'foo/foo.cc\'), \'stdio.h\', True)\n    _C_SYS_HEADER\n    >>> _ClassifyInclude(FileInfo(\'foo/foo.cc\'), \'string\', True)\n    _CPP_SYS_HEADER\n    >>> _ClassifyInclude(FileInfo(\'foo/foo.cc\'), \'foo/foo.h\', False)\n    _LIKELY_MY_HEADER\n    >>> _ClassifyInclude(FileInfo(\'foo/foo_unknown_extension.cc\'),\n    ...                  \'bar/foo_other_ext.h\', False)\n    _POSSIBLE_MY_HEADER\n    >>> _ClassifyInclude(FileInfo(\'foo/foo.cc\'), \'foo/bar.h\', False)\n    _OTHER_HEADER\n  """"""\n  # This is a list of all standard c++ header files, except\n  # those already checked for above.\n  is_cpp_h = include in _CPP_HEADERS\n\n  if is_system:\n    if is_cpp_h:\n      return _CPP_SYS_HEADER\n    else:\n      return _C_SYS_HEADER\n\n  # If the target file and the include we\'re checking share a\n  # basename when we drop common extensions, and the include\n  # lives in . , then it\'s likely to be owned by the target file.\n  target_dir, target_base = (\n      os.path.split(_DropCommonSuffixes(fileinfo.RepositoryName())))\n  include_dir, include_base = os.path.split(_DropCommonSuffixes(include))\n  if target_base == include_base and (\n      include_dir == target_dir or\n      include_dir == os.path.normpath(target_dir + \'/../public\')):\n    return _LIKELY_MY_HEADER\n\n  # If the target and include share some initial basename\n  # component, it\'s possible the target is implementing the\n  # include, so it\'s allowed to be first, but we\'ll never\n  # complain if it\'s not there.\n  target_first_component = _RE_FIRST_COMPONENT.match(target_base)\n  include_first_component = _RE_FIRST_COMPONENT.match(include_base)\n  if (target_first_component and include_first_component and\n      target_first_component.group(0) ==\n      include_first_component.group(0)):\n    return _POSSIBLE_MY_HEADER\n\n  return _OTHER_HEADER\n\n\n\ndef CheckIncludeLine(filename, clean_lines, linenum, include_state, error):\n  """"""Check rules that are applicable to #include lines.\n\n  Strings on #include lines are NOT removed from elided line, to make\n  certain tasks easier. However, to prevent false positives, checks\n  applicable to #include lines in CheckLanguage must be put here.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    error: The function to call with any errors found.\n  """"""\n  fileinfo = FileInfo(filename)\n\n  line = clean_lines.lines[linenum]\n\n  # ""include"" should use the new style ""foo/bar.h"" instead of just ""bar.h""\n  if _RE_PATTERN_INCLUDE_NEW_STYLE.search(line):\n    error(filename, linenum, \'build/include_dir\', 4,\n          \'Include the directory when naming .h files\')\n\n  # we shouldn\'t include a file more than once. actually, there are a\n  # handful of instances where doing so is okay, but in general it\'s\n  # not.\n  match = _RE_PATTERN_INCLUDE.search(line)\n  if match:\n    include = match.group(2)\n    is_system = (match.group(1) == \'<\')\n    if include in include_state:\n      error(filename, linenum, \'build/include\', 4,\n            \'""%s"" already included at %s:%s\' %\n            (include, filename, include_state[include]))\n    else:\n      include_state[include] = linenum\n\n      # We want to ensure that headers appear in the right order:\n      # 1) for foo.cc, foo.h  (preferred location)\n      # 2) c system files\n      # 3) cpp system files\n      # 4) for foo.cc, foo.h  (deprecated location)\n      # 5) other google headers\n      #\n      # We classify each include statement as one of those 5 types\n      # using a number of techniques. The include_state object keeps\n      # track of the highest type seen, and complains if we see a\n      # lower type after that.\n      error_message = include_state.CheckNextIncludeOrder(\n          _ClassifyInclude(fileinfo, include, is_system))\n      if error_message:\n        error(filename, linenum, \'build/include_order\', 4,\n              \'%s. Should be: %s.h, c system, c++ system, other.\' %\n              (error_message, fileinfo.BaseName()))\n      canonical_include = include_state.CanonicalizeAlphabeticalOrder(include)\n      if not include_state.IsInAlphabeticalOrder(\n          clean_lines, linenum, canonical_include):\n        error(filename, linenum, \'build/include_alpha\', 4,\n              \'Include ""%s"" not in alphabetical order\' % include)\n      include_state.SetLastHeader(canonical_include)\n\n  # Look for any of the stream classes that are part of standard C++.\n  match = _RE_PATTERN_INCLUDE.match(line)\n  if match:\n    include = match.group(2)\n    if Match(r\'(f|ind|io|i|o|parse|pf|stdio|str|)?stream$\', include):\n      # Many unit tests use cout, so we exempt them.\n      if not _IsTestFilename(filename):\n        error(filename, linenum, \'readability/streams\', 3,\n              \'Streams are highly discouraged.\')\n\n\ndef _GetTextInside(text, start_pattern):\n  r""""""Retrieves all the text between matching open and close parentheses.\n\n  Given a string of lines and a regular expression string, retrieve all the text\n  following the expression and between opening punctuation symbols like\n  (, [, or {, and the matching close-punctuation symbol. This properly nested\n  occurrences of the punctuations, so for the text like\n    printf(a(), b(c()));\n  a call to _GetTextInside(text, r\'printf\\(\') will return \'a(), b(c())\'.\n  start_pattern must match string having an open punctuation symbol at the end.\n\n  Args:\n    text: The lines to extract text. Its comments and strings must be elided.\n           It can be single line and can span multiple lines.\n    start_pattern: The regexp string indicating where to start extracting\n                   the text.\n  Returns:\n    The extracted text.\n    None if either the opening string or ending punctuation could not be found.\n  """"""\n  # TODO(sugawarayu): Audit cpplint.py to see what places could be profitably\n  # rewritten to use _GetTextInside (and use inferior regexp matching today).\n\n  # Give opening punctuations to get the matching close-punctuations.\n  matching_punctuation = {\'(\': \')\', \'{\': \'}\', \'[\': \']\'}\n  closing_punctuation = set(matching_punctuation.itervalues())\n\n  # Find the position to start extracting text.\n  match = re.search(start_pattern, text, re.M)\n  if not match:  # start_pattern not found in text.\n    return None\n  start_position = match.end(0)\n\n  assert start_position > 0, (\n      \'start_pattern must ends with an opening punctuation.\')\n  assert text[start_position - 1] in matching_punctuation, (\n      \'start_pattern must ends with an opening punctuation.\')\n  # Stack of closing punctuations we expect to have in text after position.\n  punctuation_stack = [matching_punctuation[text[start_position - 1]]]\n  position = start_position\n  while punctuation_stack and position < len(text):\n    if text[position] == punctuation_stack[-1]:\n      punctuation_stack.pop()\n    elif text[position] in closing_punctuation:\n      # A closing punctuation without matching opening punctuations.\n      return None\n    elif text[position] in matching_punctuation:\n      punctuation_stack.append(matching_punctuation[text[position]])\n    position += 1\n  if punctuation_stack:\n    # Opening punctuations left without matching close-punctuations.\n    return None\n  # punctuations match.\n  return text[start_position:position - 1]\n\n\n# Patterns for matching call-by-reference parameters.\n#\n# Supports nested templates up to 2 levels deep using this messy pattern:\n#   < (?: < (?: < [^<>]*\n#               >\n#           |   [^<>] )*\n#         >\n#     |   [^<>] )*\n#   >\n_RE_PATTERN_IDENT = r\'[_a-zA-Z]\\w*\'  # =~ [[:alpha:]][[:alnum:]]*\n_RE_PATTERN_TYPE = (\n    r\'(?:const\\s+)?(?:typename\\s+|class\\s+|struct\\s+|union\\s+|enum\\s+)?\'\n    r\'(?:\\w|\'\n    r\'\\s*<(?:<(?:<[^<>]*>|[^<>])*>|[^<>])*>|\'\n    r\'::)+\')\n# A call-by-reference parameter ends with \'& identifier\'.\n_RE_PATTERN_REF_PARAM = re.compile(\n    r\'(\' + _RE_PATTERN_TYPE + r\'(?:\\s*(?:\\bconst\\b|[*]))*\\s*\'\n    r\'&\\s*\' + _RE_PATTERN_IDENT + r\')\\s*(?:=[^,()]+)?[,)]\')\n# A call-by-const-reference parameter either ends with \'const& identifier\'\n# or looks like \'const type& identifier\' when \'type\' is atomic.\n_RE_PATTERN_CONST_REF_PARAM = (\n    r\'(?:.*\\s*\\bconst\\s*&\\s*\' + _RE_PATTERN_IDENT +\n    r\'|const\\s+\' + _RE_PATTERN_TYPE + r\'\\s*&\\s*\' + _RE_PATTERN_IDENT + r\')\')\n\n\ndef CheckLanguage(filename, clean_lines, linenum, file_extension,\n                  include_state, nesting_state, error):\n  """"""Checks rules from the \'C++ language rules\' section of cppguide.html.\n\n  Some of these rules are hard to test (function overloading, using\n  uint32 inappropriately), but we do the best we can.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    file_extension: The extension (without the dot) of the filename.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  """"""\n  # If the line is empty or consists of entirely a comment, no need to\n  # check it.\n  line = clean_lines.elided[linenum]\n  if not line:\n    return\n\n  match = _RE_PATTERN_INCLUDE.search(line)\n  if match:\n    CheckIncludeLine(filename, clean_lines, linenum, include_state, error)\n    return\n\n  # Reset include state across preprocessor directives.  This is meant\n  # to silence warnings for conditional includes.\n  if Match(r\'^\\s*#\\s*(?:ifdef|elif|else|endif)\\b\', line):\n    include_state.ResetSection()\n\n  # Make Windows paths like Unix.\n  fullname = os.path.abspath(filename).replace(\'\\\\\', \'/\')\n\n  # TODO(unknown): figure out if they\'re using default arguments in fn proto.\n\n  # Check to see if they\'re using an conversion function cast.\n  # I just try to capture the most common basic types, though there are more.\n  # Parameterless conversion functions, such as bool(), are allowed as they are\n  # probably a member operator declaration or default constructor.\n  match = Search(\n      r\'(\\bnew\\s+)?\\b\'  # Grab \'new\' operator, if it\'s there\n      r\'(int|float|double|bool|char|int32|uint32|int64|uint64)\'\n      r\'(\\([^)].*)\', line)\n  if match:\n    matched_new = match.group(1)\n    matched_type = match.group(2)\n    matched_funcptr = match.group(3)\n\n    # gMock methods are defined using some variant of MOCK_METHODx(name, type)\n    # where type may be float(), int(string), etc.  Without context they are\n    # virtually indistinguishable from int(x) casts. Likewise, gMock\'s\n    # MockCallback takes a template parameter of the form return_type(arg_type),\n    # which looks much like the cast we\'re trying to detect.\n    #\n    # std::function<> wrapper has a similar problem.\n    #\n    # Return types for function pointers also look like casts if they\n    # don\'t have an extra space.\n    if (matched_new is None and  # If new operator, then this isn\'t a cast\n        not (Match(r\'^\\s*MOCK_(CONST_)?METHOD\\d+(_T)?\\(\', line) or\n             Search(r\'\\bMockCallback<.*>\', line) or\n             Search(r\'\\bstd::function<.*>\', line)) and\n        not (matched_funcptr and\n             Match(r\'\\((?:[^() ]+::\\s*\\*\\s*)?[^() ]+\\)\\s*\\(\',\n                   matched_funcptr))):\n      # Try a bit harder to catch gmock lines: the only place where\n      # something looks like an old-style cast is where we declare the\n      # return type of the mocked method, and the only time when we\n      # are missing context is if MOCK_METHOD was split across\n      # multiple lines.  The missing MOCK_METHOD is usually one or two\n      # lines back, so scan back one or two lines.\n      #\n      # It\'s not possible for gmock macros to appear in the first 2\n      # lines, since the class head + section name takes up 2 lines.\n      if (linenum < 2 or\n          not (Match(r\'^\\s*MOCK_(?:CONST_)?METHOD\\d+(?:_T)?\\((?:\\S+,)?\\s*$\',\n                     clean_lines.elided[linenum - 1]) or\n               Match(r\'^\\s*MOCK_(?:CONST_)?METHOD\\d+(?:_T)?\\(\\s*$\',\n                     clean_lines.elided[linenum - 2]))):\n        error(filename, linenum, \'readability/casting\', 4,\n              \'Using deprecated casting style.  \'\n              \'Use static_cast<%s>(...) instead\' %\n              matched_type)\n\n  CheckCStyleCast(filename, linenum, line, clean_lines.raw_lines[linenum],\n                  \'static_cast\',\n                  r\'\\((int|float|double|bool|char|u?int(16|32|64))\\)\', error)\n\n  # This doesn\'t catch all cases. Consider (const char * const)""hello"".\n  #\n  # (char *) ""foo"" should always be a const_cast (reinterpret_cast won\'t\n  # compile).\n  if CheckCStyleCast(filename, linenum, line, clean_lines.raw_lines[linenum],\n                     \'const_cast\', r\'\\((char\\s?\\*+\\s?)\\)\\s*""\', error):\n    pass\n  else:\n    # Check pointer casts for other than string constants\n    CheckCStyleCast(filename, linenum, line, clean_lines.raw_lines[linenum],\n                    \'reinterpret_cast\', r\'\\((\\w+\\s?\\*+\\s?)\\)\', error)\n\n  # In addition, we look for people taking the address of a cast.  This\n  # is dangerous -- casts can assign to temporaries, so the pointer doesn\'t\n  # point where you think.\n  match = Search(\n      r\'(?:&\\(([^)]+)\\)[\\w(])|\'\n      r\'(?:&(static|dynamic|down|reinterpret)_cast\\b)\', line)\n  if match and match.group(1) != \'*\':\n    error(filename, linenum, \'runtime/casting\', 4,\n          (\'Are you taking an address of a cast?  \'\n           \'This is dangerous: could be a temp var.  \'\n           \'Take the address before doing the cast, rather than after\'))\n\n  # Create an extended_line, which is the concatenation of the current and\n  # next lines, for more effective checking of code that may span more than one\n  # line.\n  if linenum + 1 < clean_lines.NumLines():\n    extended_line = line + clean_lines.elided[linenum + 1]\n  else:\n    extended_line = line\n\n  # Check for people declaring static/global STL strings at the top level.\n  # This is dangerous because the C++ language does not guarantee that\n  # globals with constructors are initialized before the first access.\n  match = Match(\n      r\'((?:|static +)(?:|const +))string +([a-zA-Z0-9_:]+)\\b(.*)\',\n      line)\n  # Make sure it\'s not a function.\n  # Function template specialization looks like: ""string foo<Type>(..."".\n  # Class template definitions look like: ""string Foo<Type>::Method(..."".\n  #\n  # Also ignore things that look like operators.  These are matched separately\n  # because operator names cross non-word boundaries.  If we change the pattern\n  # above, we would decrease the accuracy of matching identifiers.\n  if (match and\n      not Search(r\'\\boperator\\W\', line) and\n      not Match(r\'\\s*(<.*>)?(::[a-zA-Z0-9_]+)?\\s*\\(([^""]|$)\', match.group(3))):\n    error(filename, linenum, \'runtime/string\', 4,\n          \'For a static/global string constant, use a C style string instead: \'\n          \'""%schar %s[]"".\' %\n          (match.group(1), match.group(2)))\n\n  if Search(r\'\\b([A-Za-z0-9_]*_)\\(\\1\\)\', line):\n    error(filename, linenum, \'runtime/init\', 4,\n          \'You seem to be initializing a member variable with itself.\')\n\n  if file_extension == \'h\':\n    # TODO(unknown): check that 1-arg constructors are explicit.\n    #                How to tell it\'s a constructor?\n    #                (handled in CheckForNonStandardConstructs for now)\n    # TODO(unknown): check that classes have DISALLOW_EVIL_CONSTRUCTORS\n    #                (level 1 error)\n    pass\n\n  # Check if people are using the verboten C basic types.  The only exception\n  # we regularly allow is ""unsigned short port"" for port.\n  if Search(r\'\\bshort port\\b\', line):\n    if not Search(r\'\\bunsigned short port\\b\', line):\n      error(filename, linenum, \'runtime/int\', 4,\n            \'Use ""unsigned short"" for ports, not ""short""\')\n  else:\n    match = Search(r\'\\b(short|long(?! +double)|long long)\\b\', line)\n    if match:\n      error(filename, linenum, \'runtime/int\', 4,\n            \'Use int16/int64/etc, rather than the C type %s\' % match.group(1))\n\n  # When snprintf is used, the second argument shouldn\'t be a literal.\n  match = Search(r\'snprintf\\s*\\(([^,]*),\\s*([0-9]*)\\s*,\', line)\n  if match and match.group(2) != \'0\':\n    # If 2nd arg is zero, snprintf is used to calculate size.\n    error(filename, linenum, \'runtime/printf\', 3,\n          \'If you can, use sizeof(%s) instead of %s as the 2nd arg \'\n          \'to snprintf.\' % (match.group(1), match.group(2)))\n\n  # Check if some verboten C functions are being used.\n  if Search(r\'\\bsprintf\\b\', line):\n    error(filename, linenum, \'runtime/printf\', 5,\n          \'Never use sprintf.  Use snprintf instead.\')\n  match = Search(r\'\\b(strcpy|strcat)\\b\', line)\n  if match:\n    error(filename, linenum, \'runtime/printf\', 4,\n          \'Almost always, snprintf is better than %s\' % match.group(1))\n\n  # Check if some verboten operator overloading is going on\n  # TODO(unknown): catch out-of-line unary operator&:\n  #   class X {};\n  #   int operator&(const X& x) { return 42; }  // unary operator&\n  # The trick is it\'s hard to tell apart from binary operator&:\n  #   class Y { int operator&(const Y& x) { return 23; } }; // binary operator&\n  if Search(r\'\\boperator\\s*&\\s*\\(\\s*\\)\', line):\n    error(filename, linenum, \'runtime/operator\', 4,\n          \'Unary operator& is dangerous.  Do not use it.\')\n\n  # Check for suspicious usage of ""if"" like\n  # } if (a == b) {\n  if Search(r\'\\}\\s*if\\s*\\(\', line):\n    error(filename, linenum, \'readability/braces\', 4,\n          \'Did you mean ""else if""? If not, start a new line for ""if"".\')\n\n  # Check for potential format string bugs like printf(foo).\n  # We constrain the pattern not to pick things like DocidForPrintf(foo).\n  # Not perfect but it can catch printf(foo.c_str()) and printf(foo->c_str())\n  # TODO(sugawarayu): Catch the following case. Need to change the calling\n  # convention of the whole function to process multiple line to handle it.\n  #   printf(\n  #       boy_this_is_a_really_long_variable_that_cannot_fit_on_the_prev_line);\n  printf_args = _GetTextInside(line, r\'(?i)\\b(string)?printf\\s*\\(\')\n  if printf_args:\n    match = Match(r\'([\\w.\\->()]+)$\', printf_args)\n    if match and match.group(1) != \'__VA_ARGS__\':\n      function_name = re.search(r\'\\b((?:string)?printf)\\s*\\(\',\n                                line, re.I).group(1)\n      error(filename, linenum, \'runtime/printf\', 4,\n            \'Potential format string bug. Do %s(""%%s"", %s) instead.\'\n            % (function_name, match.group(1)))\n\n  # Check for potential memset bugs like memset(buf, sizeof(buf), 0).\n  match = Search(r\'memset\\s*\\(([^,]*),\\s*([^,]*),\\s*0\\s*\\)\', line)\n  if match and not Match(r""^\'\'|-?[0-9]+|0x[0-9A-Fa-f]$"", match.group(2)):\n    error(filename, linenum, \'runtime/memset\', 4,\n          \'Did you mean ""memset(%s, 0, %s)""?\'\n          % (match.group(1), match.group(2)))\n\n  if Search(r\'\\busing namespace\\b\', line):\n    error(filename, linenum, \'build/namespaces\', 5,\n          \'Do not use namespace using-directives.  \'\n          \'Use using-declarations instead.\')\n\n  # Detect variable-length arrays.\n  match = Match(r\'\\s*(.+::)?(\\w+) [a-z]\\w*\\[(.+)];\', line)\n  if (match and match.group(2) != \'return\' and match.group(2) != \'delete\' and\n      match.group(3).find(\']\') == -1):\n    # Split the size using space and arithmetic operators as delimiters.\n    # If any of the resulting tokens are not compile time constants then\n    # report the error.\n    tokens = re.split(r\'\\s|\\+|\\-|\\*|\\/|<<|>>]\', match.group(3))\n    is_const = True\n    skip_next = False\n    for tok in tokens:\n      if skip_next:\n        skip_next = False\n        continue\n\n      if Search(r\'sizeof\\(.+\\)\', tok): continue\n      if Search(r\'arraysize\\(\\w+\\)\', tok): continue\n\n      tok = tok.lstrip(\'(\')\n      tok = tok.rstrip(\')\')\n      if not tok: continue\n      if Match(r\'\\d+\', tok): continue\n      if Match(r\'0[xX][0-9a-fA-F]+\', tok): continue\n      if Match(r\'k[A-Z0-9]\\w*\', tok): continue\n      if Match(r\'(.+::)?k[A-Z0-9]\\w*\', tok): continue\n      if Match(r\'(.+::)?[A-Z][A-Z0-9_]*\', tok): continue\n      # A catch all for tricky sizeof cases, including \'sizeof expression\',\n      # \'sizeof(*type)\', \'sizeof(const type)\', \'sizeof(struct StructName)\'\n      # requires skipping the next token because we split on \' \' and \'*\'.\n      if tok.startswith(\'sizeof\'):\n        skip_next = True\n        continue\n      is_const = False\n      break\n    if not is_const:\n      error(filename, linenum, \'runtime/arrays\', 1,\n            \'Do not use variable-length arrays.  Use an appropriately named \'\n            ""(\'k\' followed by CamelCase) compile-time constant for the size."")\n\n  # If DISALLOW_EVIL_CONSTRUCTORS, DISALLOW_COPY_AND_ASSIGN, or\n  # DISALLOW_IMPLICIT_CONSTRUCTORS is present, then it should be the last thing\n  # in the class declaration.\n  match = Match(\n      (r\'\\s*\'\n       r\'(DISALLOW_(EVIL_CONSTRUCTORS|COPY_AND_ASSIGN|IMPLICIT_CONSTRUCTORS))\'\n       r\'\\(.*\\);$\'),\n      line)\n  if match and linenum + 1 < clean_lines.NumLines():\n    next_line = clean_lines.elided[linenum + 1]\n    # We allow some, but not all, declarations of variables to be present\n    # in the statement that defines the class.  The [\\w\\*,\\s]* fragment of\n    # the regular expression below allows users to declare instances of\n    # the class or pointers to instances, but not less common types such\n    # as function pointers or arrays.  It\'s a tradeoff between allowing\n    # reasonable code and avoiding trying to parse more C++ using regexps.\n    if not Search(r\'^\\s*}[\\w\\*,\\s]*;\', next_line):\n      error(filename, linenum, \'readability/constructors\', 3,\n            match.group(1) + \' should be the last thing in the class\')\n\n  # Check for use of unnamed namespaces in header files.  Registration\n  # macros are typically OK, so we allow use of ""namespace {"" on lines\n  # that end with backslashes.\n  if (file_extension == \'h\'\n      and Search(r\'\\bnamespace\\s*{\', line)\n      and line[-1] != \'\\\\\'):\n    error(filename, linenum, \'build/namespaces\', 4,\n          \'Do not use unnamed namespaces in header files.  See \'\n          \'http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Namespaces\'\n          \' for more information.\')\n\ndef CheckForNonConstReference(filename, clean_lines, linenum,\n                              nesting_state, error):\n  """"""Check for non-const references.\n\n  Separate from CheckLanguage since it scans backwards from current\n  line, instead of scanning forward.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  """"""\n  # Do nothing if there is no \'&\' on current line.\n  line = clean_lines.elided[linenum]\n  if \'&\' not in line:\n    return\n\n  # Long type names may be broken across multiple lines, usually in one\n  # of these forms:\n  #   LongType\n  #       ::LongTypeContinued &identifier\n  #   LongType::\n  #       LongTypeContinued &identifier\n  #   LongType<\n  #       ...>::LongTypeContinued &identifier\n  #\n  # If we detected a type split across two lines, join the previous\n  # line to current line so that we can match const references\n  # accordingly.\n  #\n  # Note that this only scans back one line, since scanning back\n  # arbitrary number of lines would be expensive.  If you have a type\n  # that spans more than 2 lines, please use a typedef.\n  if linenum > 1:\n    previous = None\n    if Match(r\'\\s*::(?:[\\w<>]|::)+\\s*&\\s*\\S\', line):\n      # previous_line\\n + ::current_line\n      previous = Search(r\'\\b((?:const\\s*)?(?:[\\w<>]|::)+[\\w<>])\\s*$\',\n                        clean_lines.elided[linenum - 1])\n    elif Match(r\'\\s*[a-zA-Z_]([\\w<>]|::)+\\s*&\\s*\\S\', line):\n      # previous_line::\\n + current_line\n      previous = Search(r\'\\b((?:const\\s*)?(?:[\\w<>]|::)+::)\\s*$\',\n                        clean_lines.elided[linenum - 1])\n    if previous:\n      line = previous.group(1) + line.lstrip()\n    else:\n      # Check for templated parameter that is split across multiple lines\n      endpos = line.rfind(\'>\')\n      if endpos > -1:\n        (_, startline, startpos) = ReverseCloseExpression(\n            clean_lines, linenum, endpos)\n        if startpos > -1 and startline < linenum:\n          # Found the matching < on an earlier line, collect all\n          # pieces up to current line.\n          line = \'\'\n          for i in xrange(startline, linenum + 1):\n            line += clean_lines.elided[i].strip()\n\n  # Check for non-const references in function parameters.  A single \'&\' may\n  # found in the following places:\n  #   inside expression: binary & for bitwise AND\n  #   inside expression: unary & for taking the address of something\n  #   inside declarators: reference parameter\n  # We will exclude the first two cases by checking that we are not inside a\n  # function body, including one that was just introduced by a trailing \'{\'.\n  # TODO(unknwon): Doesn\'t account for preprocessor directives.\n  # TODO(unknown): Doesn\'t account for \'catch(Exception& e)\' [rare].\n  check_params = False\n  if not nesting_state.stack:\n    check_params = True  # top level\n  elif (isinstance(nesting_state.stack[-1], _ClassInfo) or\n        isinstance(nesting_state.stack[-1], _NamespaceInfo)):\n    check_params = True  # within class or namespace\n  elif Match(r\'.*{\\s*$\', line):\n    if (len(nesting_state.stack) == 1 or\n        isinstance(nesting_state.stack[-2], _ClassInfo) or\n        isinstance(nesting_state.stack[-2], _NamespaceInfo)):\n      check_params = True  # just opened global/class/namespace block\n  # We allow non-const references in a few standard places, like functions\n  # called ""swap()"" or iostream operators like ""<<"" or "">>"".  Do not check\n  # those function parameters.\n  #\n  # We also accept & in static_assert, which looks like a function but\n  # it\'s actually a declaration expression.\n  whitelisted_functions = (r\'(?:[sS]wap(?:<\\w:+>)?|\'\n                           r\'operator\\s*[<>][<>]|\'\n                           r\'static_assert|COMPILE_ASSERT\'\n                           r\')\\s*\\(\')\n  if Search(whitelisted_functions, line):\n    check_params = False\n  elif not Search(r\'\\S+\\([^)]*$\', line):\n    # Don\'t see a whitelisted function on this line.  Actually we\n    # didn\'t see any function name on this line, so this is likely a\n    # multi-line parameter list.  Try a bit harder to catch this case.\n    for i in xrange(2):\n      if (linenum > i and\n          Search(whitelisted_functions, clean_lines.elided[linenum - i - 1])):\n        check_params = False\n        break\n\n  if check_params:\n    decls = ReplaceAll(r\'{[^}]*}\', \' \', line)  # exclude function body\n    for parameter in re.findall(_RE_PATTERN_REF_PARAM, decls):\n      if not Match(_RE_PATTERN_CONST_REF_PARAM, parameter):\n        error(filename, linenum, \'runtime/references\', 2,\n              \'Is this a non-const reference? \'\n              \'If so, make const or use a pointer: \' +\n              ReplaceAll(\' *<\', \'<\', parameter))\n\n\ndef CheckCStyleCast(filename, linenum, line, raw_line, cast_type, pattern,\n                    error):\n  """"""Checks for a C-style cast by looking for the pattern.\n\n  Args:\n    filename: The name of the current file.\n    linenum: The number of the line to check.\n    line: The line of code to check.\n    raw_line: The raw line of code to check, with comments.\n    cast_type: The string for the C++ cast to recommend.  This is either\n      reinterpret_cast, static_cast, or const_cast, depending.\n    pattern: The regular expression used to find C-style casts.\n    error: The function to call with any errors found.\n\n  Returns:\n    True if an error was emitted.\n    False otherwise.\n  """"""\n  match = Search(pattern, line)\n  if not match:\n    return False\n\n  # Exclude lines with sizeof, since sizeof looks like a cast.\n  sizeof_match = Match(r\'.*sizeof\\s*$\', line[0:match.start(1) - 1])\n  if sizeof_match:\n    return False\n\n  # operator++(int) and operator--(int)\n  if (line[0:match.start(1) - 1].endswith(\' operator++\') or\n      line[0:match.start(1) - 1].endswith(\' operator--\')):\n    return False\n\n  # A single unnamed argument for a function tends to look like old\n  # style cast.  If we see those, don\'t issue warnings for deprecated\n  # casts, instead issue warnings for unnamed arguments where\n  # appropriate.\n  #\n  # These are things that we want warnings for, since the style guide\n  # explicitly require all parameters to be named:\n  #   Function(int);\n  #   Function(int) {\n  #   ConstMember(int) const;\n  #   ConstMember(int) const {\n  #   ExceptionMember(int) throw (...);\n  #   ExceptionMember(int) throw (...) {\n  #   PureVirtual(int) = 0;\n  #\n  # These are functions of some sort, where the compiler would be fine\n  # if they had named parameters, but people often omit those\n  # identifiers to reduce clutter:\n  #   (FunctionPointer)(int);\n  #   (FunctionPointer)(int) = value;\n  #   Function((function_pointer_arg)(int))\n  #   <TemplateArgument(int)>;\n  #   <(FunctionPointerTemplateArgument)(int)>;\n  remainder = line[match.end(0):]\n  if Match(r\'^\\s*(?:;|const\\b|throw\\b|=|>|\\{|\\))\', remainder):\n    # Looks like an unnamed parameter.\n\n    # Don\'t warn on any kind of template arguments.\n    if Match(r\'^\\s*>\', remainder):\n      return False\n\n    # Don\'t warn on assignments to function pointers, but keep warnings for\n    # unnamed parameters to pure virtual functions.  Note that this pattern\n    # will also pass on assignments of ""0"" to function pointers, but the\n    # preferred values for those would be ""nullptr"" or ""NULL"".\n    matched_zero = Match(r\'^\\s=\\s*(\\S+)\\s*;\', remainder)\n    if matched_zero and matched_zero.group(1) != \'0\':\n      return False\n\n    # Don\'t warn on function pointer declarations.  For this we need\n    # to check what came before the ""(type)"" string.\n    if Match(r\'.*\\)\\s*$\', line[0:match.start(0)]):\n      return False\n\n    # Don\'t warn if the parameter is named with block comments, e.g.:\n    #  Function(int /*unused_param*/);\n    if \'/*\' in raw_line:\n      return False\n\n    # Passed all filters, issue warning here.\n    error(filename, linenum, \'readability/function\', 3,\n          \'All parameters should be named in a function\')\n    return True\n\n  # At this point, all that should be left is actual casts.\n  error(filename, linenum, \'readability/casting\', 4,\n        \'Using C-style cast.  Use %s<%s>(...) instead\' %\n        (cast_type, match.group(1)))\n\n  return True\n\n\n_HEADERS_CONTAINING_TEMPLATES = (\n    (\'<deque>\', (\'deque\',)),\n    (\'<functional>\', (\'unary_function\', \'binary_function\',\n                      \'plus\', \'minus\', \'multiplies\', \'divides\', \'modulus\',\n                      \'negate\',\n                      \'equal_to\', \'not_equal_to\', \'greater\', \'less\',\n                      \'greater_equal\', \'less_equal\',\n                      \'logical_and\', \'logical_or\', \'logical_not\',\n                      \'unary_negate\', \'not1\', \'binary_negate\', \'not2\',\n                      \'bind1st\', \'bind2nd\',\n                      \'pointer_to_unary_function\',\n                      \'pointer_to_binary_function\',\n                      \'ptr_fun\',\n                      \'mem_fun_t\', \'mem_fun\', \'mem_fun1_t\', \'mem_fun1_ref_t\',\n                      \'mem_fun_ref_t\',\n                      \'const_mem_fun_t\', \'const_mem_fun1_t\',\n                      \'const_mem_fun_ref_t\', \'const_mem_fun1_ref_t\',\n                      \'mem_fun_ref\',\n                     )),\n    (\'<limits>\', (\'numeric_limits\',)),\n    (\'<list>\', (\'list\',)),\n    (\'<map>\', (\'map\', \'multimap\',)),\n    (\'<memory>\', (\'allocator\',)),\n    (\'<queue>\', (\'queue\', \'priority_queue\',)),\n    (\'<set>\', (\'set\', \'multiset\',)),\n    (\'<stack>\', (\'stack\',)),\n    (\'<string>\', (\'char_traits\', \'basic_string\',)),\n    (\'<utility>\', (\'pair\',)),\n    (\'<vector>\', (\'vector\',)),\n\n    # gcc extensions.\n    # Note: std::hash is their hash, ::hash is our hash\n    (\'<hash_map>\', (\'hash_map\', \'hash_multimap\',)),\n    (\'<hash_set>\', (\'hash_set\', \'hash_multiset\',)),\n    (\'<slist>\', (\'slist\',)),\n    )\n\n_RE_PATTERN_STRING = re.compile(r\'\\bstring\\b\')\n\n_re_pattern_algorithm_header = []\nfor _template in (\'copy\', \'max\', \'min\', \'min_element\', \'sort\', \'swap\',\n                  \'transform\'):\n  # Match max<type>(..., ...), max(..., ...), but not foo->max, foo.max or\n  # type::max().\n  _re_pattern_algorithm_header.append(\n      (re.compile(r\'[^>.]\\b\' + _template + r\'(<.*?>)?\\([^\\)]\'),\n       _template,\n       \'<algorithm>\'))\n\n_re_pattern_templates = []\nfor _header, _templates in _HEADERS_CONTAINING_TEMPLATES:\n  for _template in _templates:\n    _re_pattern_templates.append(\n        (re.compile(r\'(\\<|\\b)\' + _template + r\'\\s*\\<\'),\n         _template + \'<>\',\n         _header))\n\n\ndef FilesBelongToSameModule(filename_cc, filename_h):\n  """"""Check if these two filenames belong to the same module.\n\n  The concept of a \'module\' here is a as follows:\n  foo.h, foo-inl.h, foo.cc, foo_test.cc and foo_unittest.cc belong to the\n  same \'module\' if they are in the same directory.\n  some/path/public/xyzzy and some/path/internal/xyzzy are also considered\n  to belong to the same module here.\n\n  If the filename_cc contains a longer path than the filename_h, for example,\n  \'/absolute/path/to/base/sysinfo.cc\', and this file would include\n  \'base/sysinfo.h\', this function also produces the prefix needed to open the\n  header. This is used by the caller of this function to more robustly open the\n  header file. We don\'t have access to the real include paths in this context,\n  so we need this guesswork here.\n\n  Known bugs: tools/base/bar.cc and base/bar.h belong to the same module\n  according to this implementation. Because of this, this function gives\n  some false positives. This should be sufficiently rare in practice.\n\n  Args:\n    filename_cc: is the path for the .cc file\n    filename_h: is the path for the header path\n\n  Returns:\n    Tuple with a bool and a string:\n    bool: True if filename_cc and filename_h belong to the same module.\n    string: the additional prefix needed to open the header file.\n  """"""\n\n  if not filename_cc.endswith(\'.cc\'):\n    return (False, \'\')\n  filename_cc = filename_cc[:-len(\'.cc\')]\n  if filename_cc.endswith(\'_unittest\'):\n    filename_cc = filename_cc[:-len(\'_unittest\')]\n  elif filename_cc.endswith(\'_test\'):\n    filename_cc = filename_cc[:-len(\'_test\')]\n  filename_cc = filename_cc.replace(\'/public/\', \'/\')\n  filename_cc = filename_cc.replace(\'/internal/\', \'/\')\n\n  if not filename_h.endswith(\'.h\'):\n    return (False, \'\')\n  filename_h = filename_h[:-len(\'.h\')]\n  if filename_h.endswith(\'-inl\'):\n    filename_h = filename_h[:-len(\'-inl\')]\n  filename_h = filename_h.replace(\'/public/\', \'/\')\n  filename_h = filename_h.replace(\'/internal/\', \'/\')\n\n  files_belong_to_same_module = filename_cc.endswith(filename_h)\n  common_path = \'\'\n  if files_belong_to_same_module:\n    common_path = filename_cc[:-len(filename_h)]\n  return files_belong_to_same_module, common_path\n\n\ndef UpdateIncludeState(filename, include_state, io=codecs):\n  """"""Fill up the include_state with new includes found from the file.\n\n  Args:\n    filename: the name of the header to read.\n    include_state: an _IncludeState instance in which the headers are inserted.\n    io: The io factory to use to read the file. Provided for testability.\n\n  Returns:\n    True if a header was succesfully added. False otherwise.\n  """"""\n  headerfile = None\n  try:\n    headerfile = io.open(filename, \'r\', \'utf8\', \'replace\')\n  except IOError:\n    return False\n  linenum = 0\n  for line in headerfile:\n    linenum += 1\n    clean_line = CleanseComments(line)\n    match = _RE_PATTERN_INCLUDE.search(clean_line)\n    if match:\n      include = match.group(2)\n      # The value formatting is cute, but not really used right now.\n      # What matters here is that the key is in include_state.\n      include_state.setdefault(include, \'%s:%d\' % (filename, linenum))\n  return True\n\n\ndef CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error,\n                              io=codecs):\n  """"""Reports for missing stl includes.\n\n  This function will output warnings to make sure you are including the headers\n  necessary for the stl containers and functions that you use. We only give one\n  reason to include a header. For example, if you use both equal_to<> and\n  less<> in a .h file, only one (the latter in the file) of these will be\n  reported as a reason to include the <functional>.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    include_state: An _IncludeState instance.\n    error: The function to call with any errors found.\n    io: The IO factory to use to read the header file. Provided for unittest\n        injection.\n  """"""\n  required = {}  # A map of header name to linenumber and the template entity.\n                 # Example of required: { \'<functional>\': (1219, \'less<>\') }\n\n  for linenum in xrange(clean_lines.NumLines()):\n    line = clean_lines.elided[linenum]\n    if not line or line[0] == \'#\':\n      continue\n\n    # String is special -- it is a non-templatized type in STL.\n    matched = _RE_PATTERN_STRING.search(line)\n    if matched:\n      # Don\'t warn about strings in non-STL namespaces:\n      # (We check only the first match per line; good enough.)\n      prefix = line[:matched.start()]\n      if prefix.endswith(\'std::\') or not prefix.endswith(\'::\'):\n        required[\'<string>\'] = (linenum, \'string\')\n\n    for pattern, template, header in _re_pattern_algorithm_header:\n      if pattern.search(line):\n        required[header] = (linenum, template)\n\n    # The following function is just a speed up, no semantics are changed.\n    if not \'<\' in line:  # Reduces the cpu time usage by skipping lines.\n      continue\n\n    for pattern, template, header in _re_pattern_templates:\n      if pattern.search(line):\n        required[header] = (linenum, template)\n\n  # The policy is that if you #include something in foo.h you don\'t need to\n  # include it again in foo.cc. Here, we will look at possible includes.\n  # Let\'s copy the include_state so it is only messed up within this function.\n  include_state = include_state.copy()\n\n  # Did we find the header for this file (if any) and succesfully load it?\n  header_found = False\n\n  # Use the absolute path so that matching works properly.\n  abs_filename = FileInfo(filename).FullName()\n\n  # For Emacs\'s flymake.\n  # If cpplint is invoked from Emacs\'s flymake, a temporary file is generated\n  # by flymake and that file name might end with \'_flymake.cc\'. In that case,\n  # restore original file name here so that the corresponding header file can be\n  # found.\n  # e.g. If the file name is \'foo_flymake.cc\', we should search for \'foo.h\'\n  # instead of \'foo_flymake.h\'\n  abs_filename = re.sub(r\'_flymake\\.cc$\', \'.cc\', abs_filename)\n\n  # include_state is modified during iteration, so we iterate over a copy of\n  # the keys.\n  header_keys = include_state.keys()\n  for header in header_keys:\n    (same_module, common_path) = FilesBelongToSameModule(abs_filename, header)\n    fullpath = common_path + header\n    if same_module and UpdateIncludeState(fullpath, include_state, io):\n      header_found = True\n\n  # If we can\'t find the header file for a .cc, assume it\'s because we don\'t\n  # know where to look. In that case we\'ll give up as we\'re not sure they\n  # didn\'t include it in the .h file.\n  # TODO(unknown): Do a better job of finding .h files so we are confident that\n  # not having the .h file means there isn\'t one.\n  if filename.endswith(\'.cc\') and not header_found:\n    return\n\n  # All the lines have been processed, report the errors found.\n  for required_header_unstripped in required:\n    template = required[required_header_unstripped][1]\n    if required_header_unstripped.strip(\'<>""\') not in include_state:\n      error(filename, required[required_header_unstripped][0],\n            \'build/include_what_you_use\', 4,\n            \'Add #include \' + required_header_unstripped + \' for \' + template)\n\n\n_RE_PATTERN_EXPLICIT_MAKEPAIR = re.compile(r\'\\bmake_pair\\s*<\')\n\n\ndef CheckMakePairUsesDeduction(filename, clean_lines, linenum, error):\n  """"""Check that make_pair\'s template arguments are deduced.\n\n  G++ 4.6 in C++0x mode fails badly if make_pair\'s template arguments are\n  specified explicitly, and such use isn\'t intended in any case.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  """"""\n  line = clean_lines.elided[linenum]\n  match = _RE_PATTERN_EXPLICIT_MAKEPAIR.search(line)\n  if match:\n    error(filename, linenum, \'build/explicit_make_pair\',\n          4,  # 4 = high confidence\n          \'For C++11-compatibility, omit template arguments from make_pair\'\n          \' OR use pair directly OR if appropriate, construct a pair directly\')\n\n\ndef ProcessLine(filename, file_extension, clean_lines, line,\n                include_state, function_state, nesting_state, error,\n                extra_check_functions=[]):\n  """"""Processes a single line in the file.\n\n  Args:\n    filename: Filename of the file that is being processed.\n    file_extension: The extension (dot not included) of the file.\n    clean_lines: An array of strings, each representing a line of the file,\n                 with comments stripped.\n    line: Number of line being processed.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    function_state: A _FunctionState instance which counts function lines, etc.\n    nesting_state: A _NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  """"""\n  raw_lines = clean_lines.raw_lines\n  ParseNolintSuppressions(filename, raw_lines[line], line, error)\n  nesting_state.Update(filename, clean_lines, line, error)\n  if nesting_state.stack and nesting_state.stack[-1].inline_asm != _NO_ASM:\n    return\n  CheckForFunctionLengths(filename, clean_lines, line, function_state, error)\n  CheckForMultilineCommentsAndStrings(filename, clean_lines, line, error)\n  CheckStyle(filename, clean_lines, line, file_extension, nesting_state, error)\n  CheckLanguage(filename, clean_lines, line, file_extension, include_state,\n                nesting_state, error)\n  CheckForNonConstReference(filename, clean_lines, line, nesting_state, error)\n  CheckForNonStandardConstructs(filename, clean_lines, line,\n                                nesting_state, error)\n  CheckVlogArguments(filename, clean_lines, line, error)\n  CheckCaffeAlternatives(filename, clean_lines, line, error)\n  CheckCaffeDataLayerSetUp(filename, clean_lines, line, error)\n  CheckCaffeRandom(filename, clean_lines, line, error)\n  CheckPosixThreading(filename, clean_lines, line, error)\n  CheckInvalidIncrement(filename, clean_lines, line, error)\n  CheckMakePairUsesDeduction(filename, clean_lines, line, error)\n  for check_fn in extra_check_functions:\n    check_fn(filename, clean_lines, line, error)\n\ndef ProcessFileData(filename, file_extension, lines, error,\n                    extra_check_functions=[]):\n  """"""Performs lint checks and reports any errors to the given error function.\n\n  Args:\n    filename: Filename of the file that is being processed.\n    file_extension: The extension (dot not included) of the file.\n    lines: An array of strings, each representing a line of the file, with the\n           last element being empty if the file is terminated with a newline.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  """"""\n  lines = ([\'// marker so line numbers and indices both start at 1\'] + lines +\n           [\'// marker so line numbers end in a known way\'])\n\n  include_state = _IncludeState()\n  function_state = _FunctionState()\n  nesting_state = _NestingState()\n\n  ResetNolintSuppressions()\n\n  CheckForCopyright(filename, lines, error)\n\n  if file_extension == \'h\':\n    CheckForHeaderGuard(filename, lines, error)\n\n  RemoveMultiLineComments(filename, lines, error)\n  clean_lines = CleansedLines(lines)\n  for line in xrange(clean_lines.NumLines()):\n    ProcessLine(filename, file_extension, clean_lines, line,\n                include_state, function_state, nesting_state, error,\n                extra_check_functions)\n  nesting_state.CheckCompletedBlocks(filename, error)\n\n  CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error)\n\n  # We check here rather than inside ProcessLine so that we see raw\n  # lines rather than ""cleaned"" lines.\n  CheckForBadCharacters(filename, lines, error)\n\n  CheckForNewlineAtEOF(filename, lines, error)\n\ndef ProcessFile(filename, vlevel, extra_check_functions=[]):\n  """"""Does google-lint on a single file.\n\n  Args:\n    filename: The name of the file to parse.\n\n    vlevel: The level of errors to report.  Every error of confidence\n    >= verbose_level will be reported.  0 is a good default.\n\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  """"""\n\n  _SetVerboseLevel(vlevel)\n\n  try:\n    # Support the UNIX convention of using ""-"" for stdin.  Note that\n    # we are not opening the file with universal newline support\n    # (which codecs doesn\'t support anyway), so the resulting lines do\n    # contain trailing \'\\r\' characters if we are reading a file that\n    # has CRLF endings.\n    # If after the split a trailing \'\\r\' is present, it is removed\n    # below. If it is not expected to be present (i.e. os.linesep !=\n    # \'\\r\\n\' as in Windows), a warning is issued below if this file\n    # is processed.\n\n    if filename == \'-\':\n      lines = codecs.StreamReaderWriter(sys.stdin,\n                                        codecs.getreader(\'utf8\'),\n                                        codecs.getwriter(\'utf8\'),\n                                        \'replace\').read().split(\'\\n\')\n    else:\n      lines = codecs.open(filename, \'r\', \'utf8\', \'replace\').read().split(\'\\n\')\n\n    carriage_return_found = False\n    # Remove trailing \'\\r\'.\n    for linenum in range(len(lines)):\n      if lines[linenum].endswith(\'\\r\'):\n        lines[linenum] = lines[linenum].rstrip(\'\\r\')\n        carriage_return_found = True\n\n  except IOError:\n    sys.stderr.write(\n        ""Skipping input \'%s\': Can\'t open for reading\\n"" % filename)\n    return\n\n  # Note, if no dot is found, this will give the entire filename as the ext.\n  file_extension = filename[filename.rfind(\'.\') + 1:]\n\n  # When reading from stdin, the extension is unknown, so no cpplint tests\n  # should rely on the extension.\n  if filename != \'-\' and file_extension not in _valid_extensions:\n    sys.stderr.write(\'Ignoring %s; not a valid file name \'\n                     \'(%s)\\n\' % (filename, \', \'.join(_valid_extensions)))\n  else:\n    ProcessFileData(filename, file_extension, lines, Error,\n                    extra_check_functions)\n    if carriage_return_found and os.linesep != \'\\r\\n\':\n      # Use 0 for linenum since outputting only one error for potentially\n      # several lines.\n      Error(filename, 0, \'whitespace/newline\', 1,\n            \'One or more unexpected \\\\r (^M) found;\'\n            \'better to use only a \\\\n\')\n\n  sys.stderr.write(\'Done processing %s\\n\' % filename)\n\n\ndef PrintUsage(message):\n  """"""Prints a brief usage string and exits, optionally with an error message.\n\n  Args:\n    message: The optional error message.\n  """"""\n  sys.stderr.write(_USAGE)\n  if message:\n    sys.exit(\'\\nFATAL ERROR: \' + message)\n  else:\n    sys.exit(1)\n\n\ndef PrintCategories():\n  """"""Prints a list of all the error-categories used by error messages.\n\n  These are the categories used to filter messages via --filter.\n  """"""\n  sys.stderr.write(\'\'.join(\'  %s\\n\' % cat for cat in _ERROR_CATEGORIES))\n  sys.exit(0)\n\n\ndef ParseArguments(args):\n  """"""Parses the command line arguments.\n\n  This may set the output format and verbosity level as side-effects.\n\n  Args:\n    args: The command line arguments:\n\n  Returns:\n    The list of filenames to lint.\n  """"""\n  try:\n    (opts, filenames) = getopt.getopt(args, \'\', [\'help\', \'output=\', \'verbose=\',\n                                                 \'counting=\',\n                                                 \'filter=\',\n                                                 \'root=\',\n                                                 \'linelength=\',\n                                                 \'extensions=\'])\n  except getopt.GetoptError:\n    PrintUsage(\'Invalid arguments.\')\n\n  verbosity = _VerboseLevel()\n  output_format = _OutputFormat()\n  filters = \'\'\n  counting_style = \'\'\n\n  for (opt, val) in opts:\n    if opt == \'--help\':\n      PrintUsage(None)\n    elif opt == \'--output\':\n      if val not in (\'emacs\', \'vs7\', \'eclipse\'):\n        PrintUsage(\'The only allowed output formats are emacs, vs7 and eclipse.\')\n      output_format = val\n    elif opt == \'--verbose\':\n      verbosity = int(val)\n    elif opt == \'--filter\':\n      filters = val\n      if not filters:\n        PrintCategories()\n    elif opt == \'--counting\':\n      if val not in (\'total\', \'toplevel\', \'detailed\'):\n        PrintUsage(\'Valid counting options are total, toplevel, and detailed\')\n      counting_style = val\n    elif opt == \'--root\':\n      global _root\n      _root = val\n    elif opt == \'--linelength\':\n      global _line_length\n      try:\n          _line_length = int(val)\n      except ValueError:\n          PrintUsage(\'Line length must be digits.\')\n    elif opt == \'--extensions\':\n      global _valid_extensions\n      try:\n          _valid_extensions = set(val.split(\',\'))\n      except ValueError:\n          PrintUsage(\'Extensions must be comma seperated list.\')\n\n  if not filenames:\n    PrintUsage(\'No files were specified.\')\n\n  _SetOutputFormat(output_format)\n  _SetVerboseLevel(verbosity)\n  _SetFilters(filters)\n  _SetCountingStyle(counting_style)\n\n  return filenames\n\n\ndef main():\n  filenames = ParseArguments(sys.argv[1:])\n\n  # Change stderr to write with replacement characters so we don\'t die\n  # if we try to print something containing non-ASCII characters.\n  sys.stderr = codecs.StreamReaderWriter(sys.stderr,\n                                         codecs.getreader(\'utf8\'),\n                                         codecs.getwriter(\'utf8\'),\n                                         \'replace\')\n\n  _cpplint_state.ResetErrorCounts()\n  for filename in filenames:\n    ProcessFile(filename, _cpplint_state.verbose_level)\n  _cpplint_state.PrintErrorCounts()\n\n  sys.exit(_cpplint_state.error_count > 0)\n\n\nif __name__ == \'__main__\':\n  main()\n'"
scripts/download_model_binary.py,0,"b'#!/usr/bin/env python\nimport os\nimport sys\nimport time\nimport yaml\nimport urllib\nimport hashlib\nimport argparse\n\nrequired_keys = [\'caffemodel\', \'caffemodel_url\', \'sha1\']\n\n\ndef reporthook(count, block_size, total_size):\n    """"""\n    From http://blog.moleculea.com/2012/10/04/urlretrieve-progres-indicator/\n    """"""\n    global start_time\n    if count == 0:\n        start_time = time.time()\n        return\n    duration = (time.time() - start_time) or 0.01\n    progress_size = int(count * block_size)\n    speed = int(progress_size / (1024 * duration))\n    percent = int(count * block_size * 100 / total_size)\n    sys.stdout.write(""\\r...%d%%, %d MB, %d KB/s, %d seconds passed"" %\n                    (percent, progress_size / (1024 * 1024), speed, duration))\n    sys.stdout.flush()\n\n\ndef parse_readme_frontmatter(dirname):\n    readme_filename = os.path.join(dirname, \'readme.md\')\n    with open(readme_filename) as f:\n        lines = [line.strip() for line in f.readlines()]\n    top = lines.index(\'---\')\n    bottom = lines.index(\'---\', top + 1)\n    frontmatter = yaml.load(\'\\n\'.join(lines[top + 1:bottom]))\n    assert all(key in frontmatter for key in required_keys)\n    return dirname, frontmatter\n\n\ndef valid_dirname(dirname):\n    try:\n        return parse_readme_frontmatter(dirname)\n    except Exception as e:\n        print(\'ERROR: {}\'.format(e))\n        raise argparse.ArgumentTypeError(\n            \'Must be valid Caffe model directory with a correct readme.md\')\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser(\n        description=\'Download trained model binary.\')\n    parser.add_argument(\'dirname\', type=valid_dirname)\n    args = parser.parse_args()\n\n    # A tiny hack: the dirname validator also returns readme YAML frontmatter.\n    dirname = args.dirname[0]\n    frontmatter = args.dirname[1]\n    model_filename = os.path.join(dirname, frontmatter[\'caffemodel\'])\n\n    # Closure-d function for checking SHA1.\n    def model_checks_out(filename=model_filename, sha1=frontmatter[\'sha1\']):\n        with open(filename, \'rb\') as f:\n            return hashlib.sha1(f.read()).hexdigest() == sha1\n\n    # Check if model exists.\n    if os.path.exists(model_filename) and model_checks_out():\n        print(""Model already exists."")\n        sys.exit(0)\n\n    # Download and verify model.\n    urllib.urlretrieve(\n        frontmatter[\'caffemodel_url\'], model_filename, reporthook)\n    if not model_checks_out():\n        print(\'ERROR: model did not download correctly! Run this again.\')\n        sys.exit(1)\n'"
models/testing/test_batch.py,0,"b'#!/usr/bin/env python\nimport os, sys\nimport subprocess\nfrom math import ceil\n\ncaffe_bin = \'bin/caffe.bin\'\nimg_size_bin = \'bin/get_image_size\'\n\ntemplate = \'./deploy.prototxt\'\ncnn_model = \'MODEL\'   # MODEL = liteflownet, liteflownet-ft-sintel or liteflownet-ft-kitti\n\n# =========================================================\ndef get_image_size(filename):\n    global img_size_bin\n    dim_list = [int(dimstr) for dimstr in str(subprocess.check_output([img_size_bin, filename])).split(\',\')]\n    if not len(dim_list) == 2:\n        print(\'Could not determine size of image %s\' % filename)\n        sys.exit(1)\n    return dim_list\n\n\ndef sizes_equal(size1, size2):\n    return size1[0] == size2[0] and size1[1] == size2[1]\n\n\ndef check_image_lists(lists):\n    images = [[], []]\n\n    with open(lists[0], \'r\') as f:\n        images[0] = [line.strip() for line in f.readlines() if len(line.strip()) > 0]\n    with open(lists[1], \'r\') as f:\n        images[1] = [line.strip() for line in f.readlines() if len(line.strip()) > 0]\n\n    if len(images[0]) != len(images[1]):\n        print(""Unequal amount of images in the given lists (%d vs. %d)"" % (len(images[0]), len(images[1])))\n        sys.exit(1)\n\n    if not os.path.isfile(images[0][0]):\n        print(\'Image %s not found\' % images[0][0])\n        sys.exit(1)\n\n    base_size = get_image_size(images[0][0])\n\n    for idx in range(len(images[0])):\n        print(""Checking image pair %d of %d"" % (idx+1, len(images[0])))\n        img1 = images[0][idx]\n        img2 = images[1][idx]\n\n        if not os.path.isfile(img1):\n            print(\'Image %s not found\' % img1)\n            sys.exit(1)\n\n        if not os.path.isfile(img2):\n            print(\'Image %s not found\' % img2)\n            sys.exit(1)\n\n        img1_size = get_image_size(img1)\n        img2_size = get_image_size(img2)\n\n        if not (sizes_equal(base_size, img1_size) and sizes_equal(base_size, img2_size)):\n            print(\'The images do not all have the same size. (Images: %s or %s vs. %s)\\n Please use the pair-mode.\' % (img1, img2, images[0][idx]))\n            sys.exit(1)\n\n    return base_size[0], base_size[1], len(images[0])\n\n\nmy_dir = os.path.dirname(os.path.realpath(__file__))\nos.chdir(my_dir)\n\nif not (os.path.isfile(caffe_bin) and os.path.isfile(img_size_bin)):\n    print(\'Caffe tool binaries not found. Did you compile caffe with tools (make all tools)?\')\n    sys.exit(1)\n\nif len(sys.argv)-1 != 3:\n    print(""Use this tool to test FlowNet on images\\n""\n          ""Usage for single image pair:\\n""\n          ""    ./demo_flownets.py IMAGE1 IMAGE2 OUTPUT_FOLDER\\n""\n          ""\\n""\n          ""Usage for a pair of image lists (must end with .txt):\\n""\n          ""    ./demo_flownets.py LIST1.TXT LIST2.TXT OUTPUT_FOLDER\\n"")\n    sys.exit(1)\n\nimg_files = sys.argv[1:]\nusing_lists = False\nlist_length = 1\n\nif img_files[0][-4:].lower() == \'.txt\':\n    print(""Checking the images in your lists..."")\n    (width, height, list_length) = check_image_lists(img_files)\n    using_lists = True\n    print(""Done."")\nelse:\n    print(""Image files: "" + str(img_files))\n\n    # Check images\n\n    for img_file in img_files:\n        if not os.path.isfile(img_file):\n            print(\'Image %s not found\' % img_file)\n            sys.exit(1)\n\n\n    # Get image sizes and check\n    img_sizes = [get_image_size(img_file) for img_file in img_files]\n\n    print(""Image sizes: "" + str(img_sizes))\n\n    if not sizes_equal(img_sizes[0], img_sizes[1]):\n        print(\'Images do not have the same size.\')\n        sys.exit(1)\n\n    width = img_sizes[0][0]\n    height = img_sizes[0][1]\n\n# Prepare prototxt\nsubprocess.call(\'mkdir -p tmp\', shell=True)\n\nif not using_lists:\n    with open(\'tmp/img1.txt\', ""w"") as tfile:\n        tfile.write(""%s\\n"" % img_files[0])\n\n    with open(\'tmp/img2.txt\', ""w"") as tfile:\n        tfile.write(""%s\\n"" % img_files[1])\nelse:\n    subprocess.call([\'cp\', img_files[0], \'tmp/img1.txt\'])\n    subprocess.call([\'cp\', img_files[1], \'tmp/img2.txt\'])\n\ndivisor = 32.\nadapted_width = ceil(width/divisor) * divisor\nadapted_height = ceil(height/divisor) * divisor\nrescale_coeff_x = width / adapted_width\nrescale_coeff_y = height / adapted_height\n\nreplacement_list = {\n    \'$ADAPTED_WIDTH\': (\'%d\' % adapted_width),\n    \'$ADAPTED_HEIGHT\': (\'%d\' % adapted_height),\n    \'$TARGET_WIDTH\': (\'%d\' % width),\n    \'$TARGET_HEIGHT\': (\'%d\' % height),\n    \'$SCALE_WIDTH\': (\'%.8f\' % rescale_coeff_x),\n    \'$SCALE_HEIGHT\': (\'%.8f\' % rescale_coeff_y),\n    \'$OUTFOLDER\': (\'%s\' % \'""\' + img_files[2] + \'""\'),\n    \'$CNN\': (\'%s\' % \'""\' + cnn_model + \'-""\')\n}\n\nproto = \'\'\nwith open(template, ""r"") as tfile:\n    proto = tfile.read()\n\nfor r in replacement_list:\n    proto = proto.replace(r, replacement_list[r])\n\nwith open(\'tmp/deploy.prototxt\', ""w"") as tfile:\n    tfile.write(proto)\n\n# Run caffe\n\nargs = [caffe_bin, \'test\', \'-model\', \'tmp/deploy.prototxt\',\n        \'-weights\', \'../trained/\' + cnn_model + \'.caffemodel\',\n        \'-iterations\', str(list_length),\n        \'-gpu\', \'0\']\n\ncmd = str.join(\' \', args)\nprint(\'Executing %s\' % cmd)\n\nsubprocess.call(args)\n\nprint(\'\\nThe resulting FLOW is stored in CNN-NNNNNNN.flo\')\n'"
models/testing/test_iter.py,0,"b'#!/usr/bin/env python\nimport os, sys\nimport subprocess\nfrom math import ceil\n\ncaffe_bin = \'bin/caffe.bin\'\nimg_size_bin = \'bin/get_image_size\'\n\ntemplate = \'./deploy.prototxt\'\ncnn_model = \'MODEL\'   # MODEL = liteflownet, liteflownet-ft-sintel or liteflownet-ft-kitti\n\n# =========================================================\ndef get_image_size(filename):\n    global img_size_bin\n    dim_list = [int(dimstr) for dimstr in str(subprocess.check_output([img_size_bin, filename])).split(\',\')]\n    if not len(dim_list) == 2:\n        print(\'Could not determine size of image %s\' % filename)\n        sys.exit(1)\n    return dim_list\n\n\ndef sizes_equal(size1, size2):\n    return size1[0] == size2[0] and size1[1] == size2[1]\n\n\ndef check_image_lists(lists):\n    images = [[], []]\n\n    with open(lists[0], \'r\') as f:\n        images[0] = [line.strip() for line in f.readlines() if len(line.strip()) > 0]\n    with open(lists[1], \'r\') as f:\n        images[1] = [line.strip() for line in f.readlines() if len(line.strip()) > 0]\n\n    if len(images[0]) != len(images[1]):\n        print(""Unequal amount of images in the given lists (%d vs. %d)"" % (len(images[0]), len(images[1])))\n        sys.exit(1)\n\n    if not os.path.isfile(images[0][0]):\n        print(\'Image %s not found\' % images[0][0])\n        sys.exit(1)\n\n    base_size = get_image_size(images[0][0])\n\n    for idx in range(len(images[0])):\n        print(""Checking image pair %d of %d"" % (idx+1, len(images[0])))\n        img1 = images[0][idx]\n        img2 = images[1][idx]\n\n        if not os.path.isfile(img1):\n            print(\'Image %s not found\' % img1)\n            sys.exit(1)\n\n        if not os.path.isfile(img2):\n            print(\'Image %s not found\' % img2)\n            sys.exit(1)\n\n        img1_size = get_image_size(img1)\n        img2_size = get_image_size(img2)\n\n        if not (sizes_equal(base_size, img1_size) and sizes_equal(base_size, img2_size)):\n            print(\'The images do not all have the same size. (Images: %s or %s vs. %s)\\n Please use the pair-mode.\' % (img1, img2, images[0][idx]))\n            sys.exit(1)\n\n    return base_size[0], base_size[1], len(images[0])\n\nmy_dir = os.path.dirname(os.path.realpath(__file__))\nos.chdir(my_dir)\n\nif not (os.path.isfile(caffe_bin) and os.path.isfile(img_size_bin)):\n    print(\'Caffe tool binaries not found. Did you compile caffe with tools (make all tools)?\')\n    sys.exit(1)\n\nif len(sys.argv)-1 != 3:\n    print(""Use this tool to test FlowNet on images\\n""\n          ""Usage for single image pair:\\n""\n          ""    ./demo_flownets.py IMAGE1 IMAGE2 OUTPUT_FOLDER\\n""\n          ""\\n""\n          ""Usage for a pair of image lists (must end with .txt):\\n""\n          ""    ./demo_flownets.py LIST1.TXT LIST2.TXT OUTPUT_FOLDER\\n"")\n    sys.exit(1)\n\nimg_files = sys.argv[1:]\nprint(""Image files: "" + str(img_files))\n\n\n# Frame-by-frame processing\nimages = [[], []]\n\nwith open(img_files[0], \'r\') as f:\n    images[0] = [line.strip() for line in f.readlines() if len(line.strip()) > 0]\nwith open(img_files[1], \'r\') as f:\n    images[1] = [line.strip() for line in f.readlines() if len(line.strip()) > 0]\n\nfor idx in reversed(range(len(images[0]))):\n\n    img1_size = get_image_size(images[0][idx])\n    img2_size = get_image_size(images[1][idx])\n\n    if not (sizes_equal(img1_size, img2_size)):\n        print(\'The images do not have the same size. (Images: %s or %s vs. %s)\\n Please use the pair-mode.\' % (img1, img2, images[0][idx]))\n        sys.exit(1)\n\n    width = img1_size[0]\n    height = img1_size[1]\n\n    # Prepare prototxt\n    subprocess.call(\'mkdir -p tmp\', shell=True)\n\n    with open(\'tmp/img1.txt\', ""w"") as tfile:\n       tfile.write(""%s\\n"" % images[0][idx])\n\n    with open(\'tmp/img2.txt\', ""w"") as tfile:\n       tfile.write(""%s\\n"" % images[1][idx])\n\n\n    divisor = 32.\n    adapted_width = ceil(width/divisor) * divisor\n    adapted_height = ceil(height/divisor) * divisor\n    rescale_coeff_x = width / adapted_width\n    rescale_coeff_y = height / adapted_height\n\n    replacement_list = {\n        \'$ADAPTED_WIDTH\': (\'%d\' % adapted_width),\n        \'$ADAPTED_HEIGHT\': (\'%d\' % adapted_height),\n        \'$TARGET_WIDTH\': (\'%d\' % width),\n        \'$TARGET_HEIGHT\': (\'%d\' % height),\n        \'$SCALE_WIDTH\': (\'%.8f\' % rescale_coeff_x),\n        \'$SCALE_HEIGHT\': (\'%.8f\' % rescale_coeff_y),\n        \'$OUTFOLDER\': (\'%s\' % \'""\' + img_files[2] + \'""\'),\n        \'$CNN\': (\'%s\' % \'""\' + cnn_model + \'-""\'),\n    }\n\n    proto = \'\'\n    with open(template, ""r"") as tfile:\n        proto = tfile.read()\n\n    for r in replacement_list:\n        proto = proto.replace(r, replacement_list[r])\n\n    with open(\'tmp/deploy.prototxt\', ""w"") as tfile:\n        tfile.write(proto)\n\n    # Run caffe\n    args = [caffe_bin, \'test\', \'-model\', \'tmp/deploy.prototxt\',\n            \'-weights\', \'../trained/\' + cnn_model + \'.caffemodel\',\n            \'-iterations\', str(1),\n            \'-gpu\', \'0\']\n\n    cmd = str.join(\' \', args)\n    print(\'Executing %s\' % cmd)\n    subprocess.call(args)\n\n    if idx > 0:\n        os.rename(img_files[2] + \'/\' + cnn_model + \'-0000000.flo\', img_files[2] + \'/\' + cnn_model +\'-\' + \'{0:07d}\'.format(idx) + \'.flo\')\n\n\nprint(\'\\nThe resulting FLOW is stored in CNN-NNNNNNN.flo\')\n'"
python/caffe/__init__.py,0,"b'from .pycaffe import Net, SGDSolver, NesterovSolver, AdaGradSolver, RMSPropSolver, AdaDeltaSolver, AdamSolver\nfrom ._caffe import set_mode_cpu, set_mode_gpu, set_device, Layer, get_solver, layer_type_list\nfrom ._caffe import __version__\nfrom .proto.caffe_pb2 import TRAIN, TEST\nfrom .classifier import Classifier\nfrom .detector import Detector\nfrom . import io\nfrom .net_spec import layers, params, NetSpec, to_proto\n'"
python/caffe/classifier.py,0,"b'#!/usr/bin/env python\n""""""\nClassifier is an image classifier specialization of Net.\n""""""\n\nimport numpy as np\n\nimport caffe\n\n\nclass Classifier(caffe.Net):\n    """"""\n    Classifier extends Net for image class prediction\n    by scaling, center cropping, or oversampling.\n\n    Parameters\n    ----------\n    image_dims : dimensions to scale input for cropping/sampling.\n        Default is to scale to net input size for whole-image crop.\n    mean, input_scale, raw_scale, channel_swap: params for\n        preprocessing options.\n    """"""\n    def __init__(self, model_file, pretrained_file, image_dims=None,\n                 mean=None, input_scale=None, raw_scale=None,\n                 channel_swap=None):\n        caffe.Net.__init__(self, model_file, pretrained_file, caffe.TEST)\n\n        # configure pre-processing\n        in_ = self.inputs[0]\n        self.transformer = caffe.io.Transformer(\n            {in_: self.blobs[in_].data.shape})\n        self.transformer.set_transpose(in_, (2, 0, 1))\n        if mean is not None:\n            self.transformer.set_mean(in_, mean)\n        if input_scale is not None:\n            self.transformer.set_input_scale(in_, input_scale)\n        if raw_scale is not None:\n            self.transformer.set_raw_scale(in_, raw_scale)\n        if channel_swap is not None:\n            self.transformer.set_channel_swap(in_, channel_swap)\n\n        self.crop_dims = np.array(self.blobs[in_].data.shape[2:])\n        if not image_dims:\n            image_dims = self.crop_dims\n        self.image_dims = image_dims\n\n    def predict(self, inputs, oversample=True):\n        """"""\n        Predict classification probabilities of inputs.\n\n        Parameters\n        ----------\n        inputs : iterable of (H x W x K) input ndarrays.\n        oversample : boolean\n            average predictions across center, corners, and mirrors\n            when True (default). Center-only prediction when False.\n\n        Returns\n        -------\n        predictions: (N x C) ndarray of class probabilities for N images and C\n            classes.\n        """"""\n        # Scale to standardize input dimensions.\n        input_ = np.zeros((len(inputs),\n                           self.image_dims[0],\n                           self.image_dims[1],\n                           inputs[0].shape[2]),\n                          dtype=np.float32)\n        for ix, in_ in enumerate(inputs):\n            input_[ix] = caffe.io.resize_image(in_, self.image_dims)\n\n        if oversample:\n            # Generate center, corner, and mirrored crops.\n            input_ = caffe.io.oversample(input_, self.crop_dims)\n        else:\n            # Take center crop.\n            center = np.array(self.image_dims) / 2.0\n            crop = np.tile(center, (1, 2))[0] + np.concatenate([\n                -self.crop_dims / 2.0,\n                self.crop_dims / 2.0\n            ])\n            crop = crop.astype(int)\n            input_ = input_[:, crop[0]:crop[2], crop[1]:crop[3], :]\n\n        # Classify\n        caffe_in = np.zeros(np.array(input_.shape)[[0, 3, 1, 2]],\n                            dtype=np.float32)\n        for ix, in_ in enumerate(input_):\n            caffe_in[ix] = self.transformer.preprocess(self.inputs[0], in_)\n        out = self.forward_all(**{self.inputs[0]: caffe_in})\n        predictions = out[self.outputs[0]]\n\n        # For oversampling, average predictions across crops.\n        if oversample:\n            predictions = predictions.reshape((len(predictions) / 10, 10, -1))\n            predictions = predictions.mean(1)\n\n        return predictions\n'"
python/caffe/coord_map.py,0,"b'""""""\nDetermine spatial relationships between layers to relate their coordinates.\nCoordinates are mapped from input-to-output (forward), but can\nbe mapped output-to-input (backward) by the inverse mapping too.\nThis helps crop and align feature maps among other uses.\n""""""\n\nfrom __future__ import division\nimport numpy as np\nfrom caffe import layers as L\n\nPASS_THROUGH_LAYERS = [\'AbsVal\', \'BatchNorm\', \'Bias\', \'BNLL\', \'Dropout\',\n                       \'Eltwise\', \'ELU\', \'Log\', \'LRN\', \'Exp\', \'MVN\', \'Power\',\n                       \'ReLU\', \'PReLU\', \'Scale\', \'Sigmoid\', \'Split\', \'TanH\',\n                       \'Threshold\']\n\n\ndef conv_params(fn):\n    """"""\n    Extract the spatial parameters that determine the coordinate mapping:\n    kernel size, stride, padding, and dilation.\n\n    Implementation detail: Convolution, Deconvolution, and Im2col layers\n    define these in the convolution_param message, while Pooling has its\n    own fields in pooling_param. This method deals with these details to\n    extract canonical parameters.\n    """"""\n    params = fn.params.get(\'convolution_param\', fn.params)\n    axis = params.get(\'axis\', 1)\n    ks = np.array(params[\'kernel_size\'], ndmin=1)\n    dilation = np.array(params.get(\'dilation\', 1), ndmin=1)\n    assert len({\'pad_h\', \'pad_w\', \'kernel_h\', \'kernel_w\', \'stride_h\',\n                \'stride_w\'} & set(fn.params)) == 0, \\\n        \'cropping does not support legacy _h/_w params\'\n    return (axis, np.array(params.get(\'stride\', 1), ndmin=1),\n            (ks - 1) * dilation + 1,\n            np.array(params.get(\'pad\', 0), ndmin=1))\n\n\ndef crop_params(fn):\n    """"""\n    Extract the crop layer parameters with defaults.\n    """"""\n    params = fn.params.get(\'crop_param\', fn.params)\n    axis = params.get(\'axis\', 2)  # default to spatial crop for N, C, H, W\n    offset = np.array(params.get(\'offset\', 0), ndmin=1)\n    return (axis, offset)\n\n\nclass UndefinedMapException(Exception):\n    """"""\n    Exception raised for layers that do not have a defined coordinate mapping.\n    """"""\n    pass\n\n\ndef coord_map(fn):\n    """"""\n    Define the coordinate mapping by its\n    - axis\n    - scale: output coord[i * scale] <- input_coord[i]\n    - shift: output coord[i] <- output_coord[i + shift]\n    s.t. the identity mapping, as for pointwise layers like ReLu, is defined by\n    (None, 1, 0) since it is independent of axis and does not transform coords.\n    """"""\n    if fn.type_name in [\'Convolution\', \'Pooling\', \'Im2col\']:\n        axis, stride, ks, pad = conv_params(fn)\n        return axis, 1 / stride, (pad - (ks - 1) / 2) / stride\n    elif fn.type_name == \'Deconvolution\':\n        axis, stride, ks, pad = conv_params(fn)\n        return axis, stride, (ks - 1) / 2 - pad\n    elif fn.type_name in PASS_THROUGH_LAYERS:\n        return None, 1, 0\n    elif fn.type_name == \'Crop\':\n        axis, offset = crop_params(fn)\n        axis -= 1  # -1 for last non-coordinate dim.\n        return axis, 1, - offset\n    else:\n        raise UndefinedMapException\n\n\nclass AxisMismatchException(Exception):\n    """"""\n    Exception raised for mappings with incompatible axes.\n    """"""\n    pass\n\n\ndef compose(base_map, next_map):\n    """"""\n    Compose a base coord map with scale a1, shift b1 with a further coord map\n    with scale a2, shift b2. The scales multiply and the further shift, b2,\n    is scaled by base coord scale a1.\n    """"""\n    ax1, a1, b1 = base_map\n    ax2, a2, b2 = next_map\n    if ax1 is None:\n        ax = ax2\n    elif ax2 is None or ax1 == ax2:\n        ax = ax1\n    else:\n        raise AxisMismatchException\n    return ax, a1 * a2, a1 * b2 + b1\n\n\ndef inverse(coord_map):\n    """"""\n    Invert a coord map by de-scaling and un-shifting;\n    this gives the backward mapping for the gradient.\n    """"""\n    ax, a, b = coord_map\n    return ax, 1 / a, -b / a\n\n\ndef coord_map_from_to(top_from, top_to):\n    """"""\n    Determine the coordinate mapping betweeen a top (from) and a top (to).\n    Walk the graph to find a common ancestor while composing the coord maps for\n    from and to until they meet. As a last step the from map is inverted.\n    """"""\n    # We need to find a common ancestor of top_from and top_to.\n    # We\'ll assume that all ancestors are equivalent here (otherwise the graph\n    # is an inconsistent state (which we could improve this to check for)).\n    # For now use a brute-force algorithm.\n\n    def collect_bottoms(top):\n        """"""\n        Collect the bottoms to walk for the coordinate mapping.\n        The general rule is that all the bottoms of a layer can be mapped, as\n        most layers have the same coordinate mapping for each bottom.\n        Crop layer is a notable exception. Only the first/cropped bottom is\n        mappable; the second/dimensions bottom is excluded from the walk.\n        """"""\n        bottoms = top.fn.inputs\n        if top.fn.type_name == \'Crop\':\n            bottoms = bottoms[:1]\n        return bottoms\n\n    # walk back from top_from, keeping the coord map as we go\n    from_maps = {top_from: (None, 1, 0)}\n    frontier = {top_from}\n    while frontier:\n        top = frontier.pop()\n        try:\n            bottoms = collect_bottoms(top)\n            for bottom in bottoms:\n                from_maps[bottom] = compose(from_maps[top], coord_map(top.fn))\n                frontier.add(bottom)\n        except UndefinedMapException:\n            pass\n\n    # now walk back from top_to until we hit a common blob\n    to_maps = {top_to: (None, 1, 0)}\n    frontier = {top_to}\n    while frontier:\n        top = frontier.pop()\n        if top in from_maps:\n            return compose(to_maps[top], inverse(from_maps[top]))\n        try:\n            bottoms = collect_bottoms(top)\n            for bottom in bottoms:\n                to_maps[bottom] = compose(to_maps[top], coord_map(top.fn))\n                frontier.add(bottom)\n        except UndefinedMapException:\n            continue\n\n    # if we got here, we did not find a blob in common\n    raise RuntimeError(\'Could not compute map between tops; are they \'\n                       \'connected by spatial layers?\')\n\n\ndef crop(top_from, top_to):\n    """"""\n    Define a Crop layer to crop a top (from) to another top (to) by\n    determining the coordinate mapping between the two and net spec\'ing\n    the axis and shift parameters of the crop.\n    """"""\n    ax, a, b = coord_map_from_to(top_from, top_to)\n    assert (a == 1).all(), \'scale mismatch on crop (a = {})\'.format(a)\n    assert (b <= 0).all(), \'cannot crop negative offset (b = {})\'.format(b)\n    assert (np.round(b) == b).all(), \'cannot crop noninteger offset \' \\\n        \'(b = {})\'.format(b)\n    return L.Crop(top_from, top_to,\n                  crop_param=dict(axis=ax + 1,  # +1 for first cropping dim.\n                                  offset=list(-np.round(b).astype(int))))\n'"
python/caffe/detector.py,0,"b'#!/usr/bin/env python\n""""""\nDo windowed detection by classifying a number of images/crops at once,\noptionally using the selective search window proposal method.\n\nThis implementation follows ideas in\n    Ross Girshick, Jeff Donahue, Trevor Darrell, Jitendra Malik.\n    Rich feature hierarchies for accurate object detection and semantic\n    segmentation.\n    http://arxiv.org/abs/1311.2524\n\nThe selective_search_ijcv_with_python code required for the selective search\nproposal mode is available at\n    https://github.com/sergeyk/selective_search_ijcv_with_python\n""""""\nimport numpy as np\nimport os\n\nimport caffe\n\n\nclass Detector(caffe.Net):\n    """"""\n    Detector extends Net for windowed detection by a list of crops or\n    selective search proposals.\n\n    Parameters\n    ----------\n    mean, input_scale, raw_scale, channel_swap : params for preprocessing\n        options.\n    context_pad : amount of surrounding context to take s.t. a `context_pad`\n        sized border of pixels in the network input image is context, as in\n        R-CNN feature extraction.\n    """"""\n    def __init__(self, model_file, pretrained_file, mean=None,\n                 input_scale=None, raw_scale=None, channel_swap=None,\n                 context_pad=None):\n        caffe.Net.__init__(self, model_file, pretrained_file, caffe.TEST)\n\n        # configure pre-processing\n        in_ = self.inputs[0]\n        self.transformer = caffe.io.Transformer(\n            {in_: self.blobs[in_].data.shape})\n        self.transformer.set_transpose(in_, (2, 0, 1))\n        if mean is not None:\n            self.transformer.set_mean(in_, mean)\n        if input_scale is not None:\n            self.transformer.set_input_scale(in_, input_scale)\n        if raw_scale is not None:\n            self.transformer.set_raw_scale(in_, raw_scale)\n        if channel_swap is not None:\n            self.transformer.set_channel_swap(in_, channel_swap)\n\n        self.configure_crop(context_pad)\n\n    def detect_windows(self, images_windows):\n        """"""\n        Do windowed detection over given images and windows. Windows are\n        extracted then warped to the input dimensions of the net.\n\n        Parameters\n        ----------\n        images_windows: (image filename, window list) iterable.\n        context_crop: size of context border to crop in pixels.\n\n        Returns\n        -------\n        detections: list of {filename: image filename, window: crop coordinates,\n            predictions: prediction vector} dicts.\n        """"""\n        # Extract windows.\n        window_inputs = []\n        for image_fname, windows in images_windows:\n            image = caffe.io.load_image(image_fname).astype(np.float32)\n            for window in windows:\n                window_inputs.append(self.crop(image, window))\n\n        # Run through the net (warping windows to input dimensions).\n        in_ = self.inputs[0]\n        caffe_in = np.zeros((len(window_inputs), window_inputs[0].shape[2])\n                            + self.blobs[in_].data.shape[2:],\n                            dtype=np.float32)\n        for ix, window_in in enumerate(window_inputs):\n            caffe_in[ix] = self.transformer.preprocess(in_, window_in)\n        out = self.forward_all(**{in_: caffe_in})\n        predictions = out[self.outputs[0]].squeeze(axis=(2, 3))\n\n        # Package predictions with images and windows.\n        detections = []\n        ix = 0\n        for image_fname, windows in images_windows:\n            for window in windows:\n                detections.append({\n                    \'window\': window,\n                    \'prediction\': predictions[ix],\n                    \'filename\': image_fname\n                })\n                ix += 1\n        return detections\n\n    def detect_selective_search(self, image_fnames):\n        """"""\n        Do windowed detection over Selective Search proposals by extracting\n        the crop and warping to the input dimensions of the net.\n\n        Parameters\n        ----------\n        image_fnames: list\n\n        Returns\n        -------\n        detections: list of {filename: image filename, window: crop coordinates,\n            predictions: prediction vector} dicts.\n        """"""\n        import selective_search_ijcv_with_python as selective_search\n        # Make absolute paths so MATLAB can find the files.\n        image_fnames = [os.path.abspath(f) for f in image_fnames]\n        windows_list = selective_search.get_windows(\n            image_fnames,\n            cmd=\'selective_search_rcnn\'\n        )\n        # Run windowed detection on the selective search list.\n        return self.detect_windows(zip(image_fnames, windows_list))\n\n    def crop(self, im, window):\n        """"""\n        Crop a window from the image for detection. Include surrounding context\n        according to the `context_pad` configuration.\n\n        Parameters\n        ----------\n        im: H x W x K image ndarray to crop.\n        window: bounding box coordinates as ymin, xmin, ymax, xmax.\n\n        Returns\n        -------\n        crop: cropped window.\n        """"""\n        # Crop window from the image.\n        crop = im[window[0]:window[2], window[1]:window[3]]\n\n        if self.context_pad:\n            box = window.copy()\n            crop_size = self.blobs[self.inputs[0]].width  # assumes square\n            scale = crop_size / (1. * crop_size - self.context_pad * 2)\n            # Crop a box + surrounding context.\n            half_h = (box[2] - box[0] + 1) / 2.\n            half_w = (box[3] - box[1] + 1) / 2.\n            center = (box[0] + half_h, box[1] + half_w)\n            scaled_dims = scale * np.array((-half_h, -half_w, half_h, half_w))\n            box = np.round(np.tile(center, 2) + scaled_dims)\n            full_h = box[2] - box[0] + 1\n            full_w = box[3] - box[1] + 1\n            scale_h = crop_size / full_h\n            scale_w = crop_size / full_w\n            pad_y = round(max(0, -box[0]) * scale_h)  # amount out-of-bounds\n            pad_x = round(max(0, -box[1]) * scale_w)\n\n            # Clip box to image dimensions.\n            im_h, im_w = im.shape[:2]\n            box = np.clip(box, 0., [im_h, im_w, im_h, im_w])\n            clip_h = box[2] - box[0] + 1\n            clip_w = box[3] - box[1] + 1\n            assert(clip_h > 0 and clip_w > 0)\n            crop_h = round(clip_h * scale_h)\n            crop_w = round(clip_w * scale_w)\n            if pad_y + crop_h > crop_size:\n                crop_h = crop_size - pad_y\n            if pad_x + crop_w > crop_size:\n                crop_w = crop_size - pad_x\n\n            # collect with context padding and place in input\n            # with mean padding\n            context_crop = im[box[0]:box[2], box[1]:box[3]]\n            context_crop = caffe.io.resize_image(context_crop, (crop_h, crop_w))\n            crop = np.ones(self.crop_dims, dtype=np.float32) * self.crop_mean\n            crop[pad_y:(pad_y + crop_h), pad_x:(pad_x + crop_w)] = context_crop\n\n        return crop\n\n    def configure_crop(self, context_pad):\n        """"""\n        Configure crop dimensions and amount of context for cropping.\n        If context is included, make the special input mean for context padding.\n\n        Parameters\n        ----------\n        context_pad : amount of context for cropping.\n        """"""\n        # crop dimensions\n        in_ = self.inputs[0]\n        tpose = self.transformer.transpose[in_]\n        inv_tpose = [tpose[t] for t in tpose]\n        self.crop_dims = np.array(self.blobs[in_].data.shape[1:])[inv_tpose]\n        #.transpose(inv_tpose)\n        # context padding\n        self.context_pad = context_pad\n        if self.context_pad:\n            in_ = self.inputs[0]\n            transpose = self.transformer.transpose.get(in_)\n            channel_order = self.transformer.channel_swap.get(in_)\n            raw_scale = self.transformer.raw_scale.get(in_)\n            # Padding context crops needs the mean in unprocessed input space.\n            mean = self.transformer.mean.get(in_)\n            if mean is not None:\n                inv_transpose = [transpose[t] for t in transpose]\n                crop_mean = mean.copy().transpose(inv_transpose)\n                if channel_order is not None:\n                    channel_order_inverse = [channel_order.index(i)\n                                             for i in range(crop_mean.shape[2])]\n                    crop_mean = crop_mean[:, :, channel_order_inverse]\n                if raw_scale is not None:\n                    crop_mean /= raw_scale\n                self.crop_mean = crop_mean\n            else:\n                self.crop_mean = np.zeros(self.crop_dims, dtype=np.float32)\n'"
python/caffe/draw.py,0,"b'""""""\nCaffe network visualization: draw the NetParameter protobuffer.\n\n\n.. note::\n\n    This requires pydot>=1.0.2, which is not included in requirements.txt since\n    it requires graphviz and other prerequisites outside the scope of the\n    Caffe.\n""""""\n\nfrom caffe.proto import caffe_pb2\n\n""""""\npydot is not supported under python 3 and pydot2 doesn\'t work properly.\npydotplus works nicely (pip install pydotplus)\n""""""\ntry:\n    # Try to load pydotplus\n    import pydotplus as pydot\nexcept ImportError:\n    import pydot\n\n# Internal layer and blob styles.\nLAYER_STYLE_DEFAULT = {\'shape\': \'record\',\n                       \'fillcolor\': \'#6495ED\',\n                       \'style\': \'filled\'}\nNEURON_LAYER_STYLE = {\'shape\': \'record\',\n                      \'fillcolor\': \'#90EE90\',\n                      \'style\': \'filled\'}\nBLOB_STYLE = {\'shape\': \'octagon\',\n              \'fillcolor\': \'#E0E0E0\',\n              \'style\': \'filled\'}\n\n\ndef get_pooling_types_dict():\n    """"""Get dictionary mapping pooling type number to type name\n    """"""\n    desc = caffe_pb2.PoolingParameter.PoolMethod.DESCRIPTOR\n    d = {}\n    for k, v in desc.values_by_name.items():\n        d[v.number] = k\n    return d\n\n\ndef get_edge_label(layer):\n    """"""Define edge label based on layer type.\n    """"""\n\n    if layer.type == \'Data\':\n        edge_label = \'Batch \' + str(layer.data_param.batch_size)\n    elif layer.type == \'Convolution\' or layer.type == \'Deconvolution\':\n        edge_label = str(layer.convolution_param.num_output)\n    elif layer.type == \'InnerProduct\':\n        edge_label = str(layer.inner_product_param.num_output)\n    else:\n        edge_label = \'""""\'\n\n    return edge_label\n\n\ndef get_layer_label(layer, rankdir):\n    """"""Define node label based on layer type.\n\n    Parameters\n    ----------\n    layer : ?\n    rankdir : {\'LR\', \'TB\', \'BT\'}\n        Direction of graph layout.\n\n    Returns\n    -------\n    string :\n        A label for the current layer\n    """"""\n\n    if rankdir in (\'TB\', \'BT\'):\n        # If graph orientation is vertical, horizontal space is free and\n        # vertical space is not; separate words with spaces\n        separator = \' \'\n    else:\n        # If graph orientation is horizontal, vertical space is free and\n        # horizontal space is not; separate words with newlines\n        separator = \'\\\\n\'\n\n    if layer.type == \'Convolution\' or layer.type == \'Deconvolution\':\n        # Outer double quotes needed or else colon characters don\'t parse\n        # properly\n        node_label = \'""%s%s(%s)%skernel size: %d%sstride: %d%spad: %d""\' %\\\n                     (layer.name,\n                      separator,\n                      layer.type,\n                      separator,\n                      layer.convolution_param.kernel_size[0] if len(layer.convolution_param.kernel_size._values) else 1,\n                      separator,\n                      layer.convolution_param.stride[0] if len(layer.convolution_param.stride._values) else 1,\n                      separator,\n                      layer.convolution_param.pad[0] if len(layer.convolution_param.pad._values) else 0)\n    elif layer.type == \'Pooling\':\n        pooling_types_dict = get_pooling_types_dict()\n        node_label = \'""%s%s(%s %s)%skernel size: %d%sstride: %d%spad: %d""\' %\\\n                     (layer.name,\n                      separator,\n                      pooling_types_dict[layer.pooling_param.pool],\n                      layer.type,\n                      separator,\n                      layer.pooling_param.kernel_size,\n                      separator,\n                      layer.pooling_param.stride,\n                      separator,\n                      layer.pooling_param.pad)\n    else:\n        node_label = \'""%s%s(%s)""\' % (layer.name, separator, layer.type)\n    return node_label\n\n\ndef choose_color_by_layertype(layertype):\n    """"""Define colors for nodes based on the layer type.\n    """"""\n    color = \'#6495ED\'  # Default\n    if layertype == \'Convolution\' or layertype == \'Deconvolution\':\n        color = \'#FF5050\'\n    elif layertype == \'Pooling\':\n        color = \'#FF9900\'\n    elif layertype == \'InnerProduct\':\n        color = \'#CC33FF\'\n    return color\n\n\ndef get_pydot_graph(caffe_net, rankdir, label_edges=True):\n    """"""Create a data structure which represents the `caffe_net`.\n\n    Parameters\n    ----------\n    caffe_net : object\n    rankdir : {\'LR\', \'TB\', \'BT\'}\n        Direction of graph layout.\n    label_edges : boolean, optional\n        Label the edges (default is True).\n\n    Returns\n    -------\n    pydot graph object\n    """"""\n    pydot_graph = pydot.Dot(caffe_net.name if caffe_net.name else \'Net\',\n                            graph_type=\'digraph\',\n                            rankdir=rankdir)\n    pydot_nodes = {}\n    pydot_edges = []\n    for layer in caffe_net.layer:\n        node_label = get_layer_label(layer, rankdir)\n        node_name = ""%s_%s"" % (layer.name, layer.type)\n        if (len(layer.bottom) == 1 and len(layer.top) == 1 and\n           layer.bottom[0] == layer.top[0]):\n            # We have an in-place neuron layer.\n            pydot_nodes[node_name] = pydot.Node(node_label,\n                                                **NEURON_LAYER_STYLE)\n        else:\n            layer_style = LAYER_STYLE_DEFAULT\n            layer_style[\'fillcolor\'] = choose_color_by_layertype(layer.type)\n            pydot_nodes[node_name] = pydot.Node(node_label, **layer_style)\n        for bottom_blob in layer.bottom:\n            pydot_nodes[bottom_blob + \'_blob\'] = pydot.Node(\'%s\' % bottom_blob,\n                                                            **BLOB_STYLE)\n            edge_label = \'""""\'\n            pydot_edges.append({\'src\': bottom_blob + \'_blob\',\n                                \'dst\': node_name,\n                                \'label\': edge_label})\n        for top_blob in layer.top:\n            pydot_nodes[top_blob + \'_blob\'] = pydot.Node(\'%s\' % (top_blob))\n            if label_edges:\n                edge_label = get_edge_label(layer)\n            else:\n                edge_label = \'""""\'\n            pydot_edges.append({\'src\': node_name,\n                                \'dst\': top_blob + \'_blob\',\n                                \'label\': edge_label})\n    # Now, add the nodes and edges to the graph.\n    for node in pydot_nodes.values():\n        pydot_graph.add_node(node)\n    for edge in pydot_edges:\n        pydot_graph.add_edge(\n            pydot.Edge(pydot_nodes[edge[\'src\']],\n                       pydot_nodes[edge[\'dst\']],\n                       label=edge[\'label\']))\n    return pydot_graph\n\n\ndef draw_net(caffe_net, rankdir, ext=\'png\'):\n    """"""Draws a caffe net and returns the image string encoded using the given\n    extension.\n\n    Parameters\n    ----------\n    caffe_net : a caffe.proto.caffe_pb2.NetParameter protocol buffer.\n    ext : string, optional\n        The image extension (the default is \'png\').\n\n    Returns\n    -------\n    string :\n        Postscript representation of the graph.\n    """"""\n    return get_pydot_graph(caffe_net, rankdir).create(format=ext)\n\n\ndef draw_net_to_file(caffe_net, filename, rankdir=\'LR\'):\n    """"""Draws a caffe net, and saves it to file using the format given as the\n    file extension. Use \'.raw\' to output raw text that you can manually feed\n    to graphviz to draw graphs.\n\n    Parameters\n    ----------\n    caffe_net : a caffe.proto.caffe_pb2.NetParameter protocol buffer.\n    filename : string\n        The path to a file where the networks visualization will be stored.\n    rankdir : {\'LR\', \'TB\', \'BT\'}\n        Direction of graph layout.\n    """"""\n    ext = filename[filename.rfind(\'.\')+1:]\n    with open(filename, \'wb\') as fid:\n        fid.write(draw_net(caffe_net, rankdir, ext))\n'"
python/caffe/io.py,0,"b'import numpy as np\nimport skimage.io\nfrom scipy.ndimage import zoom\nfrom skimage.transform import resize\n\ntry:\n    # Python3 will most likely not be able to load protobuf\n    from caffe.proto import caffe_pb2\nexcept:\n    import sys\n    if sys.version_info >= (3, 0):\n        print(""Failed to include caffe_pb2, things might go wrong!"")\n    else:\n        raise\n\n\n## proto / datum / ndarray conversion\ndef blobproto_to_array(blob, return_diff=False):\n    """"""\n    Convert a blob proto to an array. In default, we will just return the data,\n    unless return_diff is True, in which case we will return the diff.\n    """"""\n    # Read the data into an array\n    if return_diff:\n        data = np.array(blob.diff)\n    else:\n        data = np.array(blob.data)\n\n    # Reshape the array\n    if blob.HasField(\'num\') or blob.HasField(\'channels\') or blob.HasField(\'height\') or blob.HasField(\'width\'):\n        # Use legacy 4D shape\n        return data.reshape(blob.num, blob.channels, blob.height, blob.width)\n    else:\n        return data.reshape(blob.shape.dim)\n\ndef array_to_blobproto(arr, diff=None):\n    """"""Converts a N-dimensional array to blob proto. If diff is given, also\n    convert the diff. You need to make sure that arr and diff have the same\n    shape, and this function does not do sanity check.\n    """"""\n    blob = caffe_pb2.BlobProto()\n    blob.shape.dim.extend(arr.shape)\n    blob.data.extend(arr.astype(float).flat)\n    if diff is not None:\n        blob.diff.extend(diff.astype(float).flat)\n    return blob\n\n\ndef arraylist_to_blobprotovector_str(arraylist):\n    """"""Converts a list of arrays to a serialized blobprotovec, which could be\n    then passed to a network for processing.\n    """"""\n    vec = caffe_pb2.BlobProtoVector()\n    vec.blobs.extend([array_to_blobproto(arr) for arr in arraylist])\n    return vec.SerializeToString()\n\n\ndef blobprotovector_str_to_arraylist(str):\n    """"""Converts a serialized blobprotovec to a list of arrays.\n    """"""\n    vec = caffe_pb2.BlobProtoVector()\n    vec.ParseFromString(str)\n    return [blobproto_to_array(blob) for blob in vec.blobs]\n\n\ndef array_to_datum(arr, label=None):\n    """"""Converts a 3-dimensional array to datum. If the array has dtype uint8,\n    the output data will be encoded as a string. Otherwise, the output data\n    will be stored in float format.\n    """"""\n    if arr.ndim != 3:\n        raise ValueError(\'Incorrect array shape.\')\n    datum = caffe_pb2.Datum()\n    datum.channels, datum.height, datum.width = arr.shape\n    if arr.dtype == np.uint8:\n        datum.data = arr.tostring()\n    else:\n        datum.float_data.extend(arr.flat)\n    if label is not None:\n        datum.label = label\n    return datum\n\n\ndef datum_to_array(datum):\n    """"""Converts a datum to an array. Note that the label is not returned,\n    as one can easily get it by calling datum.label.\n    """"""\n    if len(datum.data):\n        return np.fromstring(datum.data, dtype=np.uint8).reshape(\n            datum.channels, datum.height, datum.width)\n    else:\n        return np.array(datum.float_data).astype(float).reshape(\n            datum.channels, datum.height, datum.width)\n\n\n## Pre-processing\n\nclass Transformer:\n    """"""\n    Transform input for feeding into a Net.\n\n    Note: this is mostly for illustrative purposes and it is likely better\n    to define your own input preprocessing routine for your needs.\n\n    Parameters\n    ----------\n    net : a Net for which the input should be prepared\n    """"""\n    def __init__(self, inputs):\n        self.inputs = inputs\n        self.transpose = {}\n        self.channel_swap = {}\n        self.raw_scale = {}\n        self.mean = {}\n        self.input_scale = {}\n\n    def __check_input(self, in_):\n        if in_ not in self.inputs:\n            raise Exception(\'{} is not one of the net inputs: {}\'.format(\n                in_, self.inputs))\n\n    def preprocess(self, in_, data):\n        """"""\n        Format input for Caffe:\n        - convert to single\n        - resize to input dimensions (preserving number of channels)\n        - transpose dimensions to K x H x W\n        - reorder channels (for instance color to BGR)\n        - scale raw input (e.g. from [0, 1] to [0, 255] for ImageNet models)\n        - subtract mean\n        - scale feature\n\n        Parameters\n        ----------\n        in_ : name of input blob to preprocess for\n        data : (H\' x W\' x K) ndarray\n\n        Returns\n        -------\n        caffe_in : (K x H x W) ndarray for input to a Net\n        """"""\n        self.__check_input(in_)\n        caffe_in = data.astype(np.float32, copy=False)\n        transpose = self.transpose.get(in_)\n        channel_swap = self.channel_swap.get(in_)\n        raw_scale = self.raw_scale.get(in_)\n        mean = self.mean.get(in_)\n        input_scale = self.input_scale.get(in_)\n        in_dims = self.inputs[in_][2:]\n        if caffe_in.shape[:2] != in_dims:\n            caffe_in = resize_image(caffe_in, in_dims)\n        if transpose is not None:\n            caffe_in = caffe_in.transpose(transpose)\n        if channel_swap is not None:\n            caffe_in = caffe_in[channel_swap, :, :]\n        if raw_scale is not None:\n            caffe_in *= raw_scale\n        if mean is not None:\n            caffe_in -= mean\n        if input_scale is not None:\n            caffe_in *= input_scale\n        return caffe_in\n\n    def deprocess(self, in_, data):\n        """"""\n        Invert Caffe formatting; see preprocess().\n        """"""\n        self.__check_input(in_)\n        decaf_in = data.copy().squeeze()\n        transpose = self.transpose.get(in_)\n        channel_swap = self.channel_swap.get(in_)\n        raw_scale = self.raw_scale.get(in_)\n        mean = self.mean.get(in_)\n        input_scale = self.input_scale.get(in_)\n        if input_scale is not None:\n            decaf_in /= input_scale\n        if mean is not None:\n            decaf_in += mean\n        if raw_scale is not None:\n            decaf_in /= raw_scale\n        if channel_swap is not None:\n            decaf_in = decaf_in[np.argsort(channel_swap), :, :]\n        if transpose is not None:\n            decaf_in = decaf_in.transpose(np.argsort(transpose))\n        return decaf_in\n\n    def set_transpose(self, in_, order):\n        """"""\n        Set the input channel order for e.g. RGB to BGR conversion\n        as needed for the reference ImageNet model.\n\n        Parameters\n        ----------\n        in_ : which input to assign this channel order\n        order : the order to transpose the dimensions\n        """"""\n        self.__check_input(in_)\n        if len(order) != len(self.inputs[in_]) - 1:\n            raise Exception(\'Transpose order needs to have the same number of \'\n                            \'dimensions as the input.\')\n        self.transpose[in_] = order\n\n    def set_channel_swap(self, in_, order):\n        """"""\n        Set the input channel order for e.g. RGB to BGR conversion\n        as needed for the reference ImageNet model.\n        N.B. this assumes the channels are the first dimension AFTER transpose.\n\n        Parameters\n        ----------\n        in_ : which input to assign this channel order\n        order : the order to take the channels.\n            (2,1,0) maps RGB to BGR for example.\n        """"""\n        self.__check_input(in_)\n        if len(order) != self.inputs[in_][1]:\n            raise Exception(\'Channel swap needs to have the same number of \'\n                            \'dimensions as the input channels.\')\n        self.channel_swap[in_] = order\n\n    def set_raw_scale(self, in_, scale):\n        """"""\n        Set the scale of raw features s.t. the input blob = input * scale.\n        While Python represents images in [0, 1], certain Caffe models\n        like CaffeNet and AlexNet represent images in [0, 255] so the raw_scale\n        of these models must be 255.\n\n        Parameters\n        ----------\n        in_ : which input to assign this scale factor\n        scale : scale coefficient\n        """"""\n        self.__check_input(in_)\n        self.raw_scale[in_] = scale\n\n    def set_mean(self, in_, mean):\n        """"""\n        Set the mean to subtract for centering the data.\n\n        Parameters\n        ----------\n        in_ : which input to assign this mean.\n        mean : mean ndarray (input dimensional or broadcastable)\n        """"""\n        self.__check_input(in_)\n        ms = mean.shape\n        if mean.ndim == 1:\n            # broadcast channels\n            if ms[0] != self.inputs[in_][1]:\n                raise ValueError(\'Mean channels incompatible with input.\')\n            mean = mean[:, np.newaxis, np.newaxis]\n        else:\n            # elementwise mean\n            if len(ms) == 2:\n                ms = (1,) + ms\n            if len(ms) != 3:\n                raise ValueError(\'Mean shape invalid\')\n            if ms != self.inputs[in_][1:]:\n                raise ValueError(\'Mean shape incompatible with input shape.\')\n        self.mean[in_] = mean\n\n    def set_input_scale(self, in_, scale):\n        """"""\n        Set the scale of preprocessed inputs s.t. the blob = blob * scale.\n        N.B. input_scale is done AFTER mean subtraction and other preprocessing\n        while raw_scale is done BEFORE.\n\n        Parameters\n        ----------\n        in_ : which input to assign this scale factor\n        scale : scale coefficient\n        """"""\n        self.__check_input(in_)\n        self.input_scale[in_] = scale\n\n\n## Image IO\n\ndef load_image(filename, color=True):\n    """"""\n    Load an image converting from grayscale or alpha as needed.\n\n    Parameters\n    ----------\n    filename : string\n    color : boolean\n        flag for color format. True (default) loads as RGB while False\n        loads as intensity (if image is already grayscale).\n\n    Returns\n    -------\n    image : an image with type np.float32 in range [0, 1]\n        of size (H x W x 3) in RGB or\n        of size (H x W x 1) in grayscale.\n    """"""\n    img = skimage.img_as_float(skimage.io.imread(filename, as_grey=not color)).astype(np.float32)\n    if img.ndim == 2:\n        img = img[:, :, np.newaxis]\n        if color:\n            img = np.tile(img, (1, 1, 3))\n    elif img.shape[2] == 4:\n        img = img[:, :, :3]\n    return img\n\n\ndef resize_image(im, new_dims, interp_order=1):\n    """"""\n    Resize an image array with interpolation.\n\n    Parameters\n    ----------\n    im : (H x W x K) ndarray\n    new_dims : (height, width) tuple of new dimensions.\n    interp_order : interpolation order, default is linear.\n\n    Returns\n    -------\n    im : resized ndarray with shape (new_dims[0], new_dims[1], K)\n    """"""\n    if im.shape[-1] == 1 or im.shape[-1] == 3:\n        im_min, im_max = im.min(), im.max()\n        if im_max > im_min:\n            # skimage is fast but only understands {1,3} channel images\n            # in [0, 1].\n            im_std = (im - im_min) / (im_max - im_min)\n            resized_std = resize(im_std, new_dims, order=interp_order)\n            resized_im = resized_std * (im_max - im_min) + im_min\n        else:\n            # the image is a constant -- avoid divide by 0\n            ret = np.empty((new_dims[0], new_dims[1], im.shape[-1]),\n                           dtype=np.float32)\n            ret.fill(im_min)\n            return ret\n    else:\n        # ndimage interpolates anything but more slowly.\n        scale = tuple(np.array(new_dims, dtype=float) / np.array(im.shape[:2]))\n        resized_im = zoom(im, scale + (1,), order=interp_order)\n    return resized_im.astype(np.float32)\n\n\ndef oversample(images, crop_dims):\n    """"""\n    Crop images into the four corners, center, and their mirrored versions.\n\n    Parameters\n    ----------\n    image : iterable of (H x W x K) ndarrays\n    crop_dims : (height, width) tuple for the crops.\n\n    Returns\n    -------\n    crops : (10*N x H x W x K) ndarray of crops for number of inputs N.\n    """"""\n    # Dimensions and center.\n    im_shape = np.array(images[0].shape)\n    crop_dims = np.array(crop_dims)\n    im_center = im_shape[:2] / 2.0\n\n    # Make crop coordinates\n    h_indices = (0, im_shape[0] - crop_dims[0])\n    w_indices = (0, im_shape[1] - crop_dims[1])\n    crops_ix = np.empty((5, 4), dtype=int)\n    curr = 0\n    for i in h_indices:\n        for j in w_indices:\n            crops_ix[curr] = (i, j, i + crop_dims[0], j + crop_dims[1])\n            curr += 1\n    crops_ix[4] = np.tile(im_center, (1, 2)) + np.concatenate([\n        -crop_dims / 2.0,\n         crop_dims / 2.0\n    ])\n    crops_ix = np.tile(crops_ix, (2, 1))\n\n    # Extract crops\n    crops = np.empty((10 * len(images), crop_dims[0], crop_dims[1],\n                      im_shape[-1]), dtype=np.float32)\n    ix = 0\n    for im in images:\n        for crop in crops_ix:\n            crops[ix] = im[crop[0]:crop[2], crop[1]:crop[3], :]\n            ix += 1\n        crops[ix-5:ix] = crops[ix-5:ix, :, ::-1, :]  # flip for mirrors\n    return crops\n'"
python/caffe/net_spec.py,0,"b'""""""Python net specification.\n\nThis module provides a way to write nets directly in Python, using a natural,\nfunctional style. See examples/pycaffe/caffenet.py for an example.\n\nCurrently this works as a thin wrapper around the Python protobuf interface,\nwith layers and parameters automatically generated for the ""layers"" and\n""params"" pseudo-modules, which are actually objects using __getattr__ magic\nto generate protobuf messages.\n\nNote that when using to_proto or Top.to_proto, names of intermediate blobs will\nbe automatically generated. To explicitly specify blob names, use the NetSpec\nclass -- assign to its attributes directly to name layers, and call\nNetSpec.to_proto to serialize all assigned layers.\n\nThis interface is expected to continue to evolve as Caffe gains new capabilities\nfor specifying nets. In particular, the automatically generated layer names\nare not guaranteed to be forward-compatible.\n""""""\n\nfrom collections import OrderedDict, Counter\n\nfrom .proto import caffe_pb2\nfrom google import protobuf\nimport six\n\n\ndef param_name_dict():\n    """"""Find out the correspondence between layer names and parameter names.""""""\n\n    layer = caffe_pb2.LayerParameter()\n    # get all parameter names (typically underscore case) and corresponding\n    # type names (typically camel case), which contain the layer names\n    # (note that not all parameters correspond to layers, but we\'ll ignore that)\n    param_names = [f.name for f in layer.DESCRIPTOR.fields if f.name.endswith(\'_param\')]\n    param_type_names = [type(getattr(layer, s)).__name__ for s in param_names]\n    # strip the final \'_param\' or \'Parameter\'\n    param_names = [s[:-len(\'_param\')] for s in param_names]\n    param_type_names = [s[:-len(\'Parameter\')] for s in param_type_names]\n    return dict(zip(param_type_names, param_names))\n\n\ndef to_proto(*tops):\n    """"""Generate a NetParameter that contains all layers needed to compute\n    all arguments.""""""\n\n    layers = OrderedDict()\n    autonames = Counter()\n    for top in tops:\n        top.fn._to_proto(layers, {}, autonames)\n    net = caffe_pb2.NetParameter()\n    net.layer.extend(layers.values())\n    return net\n\n\ndef assign_proto(proto, name, val):\n    """"""Assign a Python object to a protobuf message, based on the Python\n    type (in recursive fashion). Lists become repeated fields/messages, dicts\n    become messages, and other types are assigned directly. For convenience,\n    repeated fields whose values are not lists are converted to single-element\n    lists; e.g., `my_repeated_int_field=3` is converted to\n    `my_repeated_int_field=[3]`.""""""\n\n    is_repeated_field = hasattr(getattr(proto, name), \'extend\')\n    if is_repeated_field and not isinstance(val, list):\n        val = [val]\n    if isinstance(val, list):\n        if isinstance(val[0], dict):\n            for item in val:\n                proto_item = getattr(proto, name).add()\n                for k, v in six.iteritems(item):\n                    assign_proto(proto_item, k, v)\n        else:\n            getattr(proto, name).extend(val)\n    elif isinstance(val, dict):\n        for k, v in six.iteritems(val):\n            assign_proto(getattr(proto, name), k, v)\n    else:\n        setattr(proto, name, val)\n\n\nclass Top(object):\n    """"""A Top specifies a single output blob (which could be one of several\n    produced by a layer.)""""""\n\n    def __init__(self, fn, n):\n        self.fn = fn\n        self.n = n\n\n    def to_proto(self):\n        """"""Generate a NetParameter that contains all layers needed to compute\n        this top.""""""\n\n        return to_proto(self)\n\n    def _to_proto(self, layers, names, autonames):\n        return self.fn._to_proto(layers, names, autonames)\n\n\nclass Function(object):\n    """"""A Function specifies a layer, its parameters, and its inputs (which\n    are Tops from other layers).""""""\n\n    def __init__(self, type_name, inputs, params):\n        self.type_name = type_name\n        self.inputs = inputs\n        self.params = params\n        self.ntop = self.params.get(\'ntop\', 1)\n        # use del to make sure kwargs are not double-processed as layer params\n        if \'ntop\' in self.params:\n            del self.params[\'ntop\']\n        self.in_place = self.params.get(\'in_place\', False)\n        if \'in_place\' in self.params:\n            del self.params[\'in_place\']\n        self.tops = tuple(Top(self, n) for n in range(self.ntop))\n\n    def _get_name(self, names, autonames):\n        if self not in names and self.ntop > 0:\n            names[self] = self._get_top_name(self.tops[0], names, autonames)\n        elif self not in names:\n            autonames[self.type_name] += 1\n            names[self] = self.type_name + str(autonames[self.type_name])\n        return names[self]\n\n    def _get_top_name(self, top, names, autonames):\n        if top not in names:\n            autonames[top.fn.type_name] += 1\n            names[top] = top.fn.type_name + str(autonames[top.fn.type_name])\n        return names[top]\n\n    def _to_proto(self, layers, names, autonames):\n        if self in layers:\n            return\n        bottom_names = []\n        for inp in self.inputs:\n            inp._to_proto(layers, names, autonames)\n            bottom_names.append(layers[inp.fn].top[inp.n])\n        layer = caffe_pb2.LayerParameter()\n        layer.type = self.type_name\n        layer.bottom.extend(bottom_names)\n\n        if self.in_place:\n            layer.top.extend(layer.bottom)\n        else:\n            for top in self.tops:\n                layer.top.append(self._get_top_name(top, names, autonames))\n        layer.name = self._get_name(names, autonames)\n\n        for k, v in six.iteritems(self.params):\n            # special case to handle generic *params\n            if k.endswith(\'param\'):\n                assign_proto(layer, k, v)\n            else:\n                try:\n                    assign_proto(getattr(layer,\n                        _param_names[self.type_name] + \'_param\'), k, v)\n                except (AttributeError, KeyError):\n                    assign_proto(layer, k, v)\n\n        layers[self] = layer\n\n\nclass NetSpec(object):\n    """"""A NetSpec contains a set of Tops (assigned directly as attributes).\n    Calling NetSpec.to_proto generates a NetParameter containing all of the\n    layers needed to produce all of the assigned Tops, using the assigned\n    names.""""""\n\n    def __init__(self):\n        super(NetSpec, self).__setattr__(\'tops\', OrderedDict())\n\n    def __setattr__(self, name, value):\n        self.tops[name] = value\n\n    def __getattr__(self, name):\n        return self.tops[name]\n\n    def __setitem__(self, key, value):\n        self.__setattr__(key, value)\n\n    def __getitem__(self, item):\n        return self.__getattr__(item)\n\n    def to_proto(self):\n        names = {v: k for k, v in six.iteritems(self.tops)}\n        autonames = Counter()\n        layers = OrderedDict()\n        for name, top in six.iteritems(self.tops):\n            top._to_proto(layers, names, autonames)\n        net = caffe_pb2.NetParameter()\n        net.layer.extend(layers.values())\n        return net\n\n\nclass Layers(object):\n    """"""A Layers object is a pseudo-module which generates functions that specify\n    layers; e.g., Layers().Convolution(bottom, kernel_size=3) will produce a Top\n    specifying a 3x3 convolution applied to bottom.""""""\n\n    def __getattr__(self, name):\n        def layer_fn(*args, **kwargs):\n            fn = Function(name, args, kwargs)\n            if fn.ntop == 0:\n                return fn\n            elif fn.ntop == 1:\n                return fn.tops[0]\n            else:\n                return fn.tops\n        return layer_fn\n\n\nclass Parameters(object):\n    """"""A Parameters object is a pseudo-module which generates constants used\n    in layer parameters; e.g., Parameters().Pooling.MAX is the value used\n    to specify max pooling.""""""\n\n    def __getattr__(self, name):\n       class Param:\n            def __getattr__(self, param_name):\n                return getattr(getattr(caffe_pb2, name + \'Parameter\'), param_name)\n       return Param()\n\n\n_param_names = param_name_dict()\nlayers = Layers()\nparams = Parameters()\n'"
python/caffe/pycaffe.py,0,"b'""""""\nWrap the internal caffe C++ module (_caffe.so) with a clean, Pythonic\ninterface.\n""""""\n\nfrom collections import OrderedDict\ntry:\n    from itertools import izip_longest\nexcept:\n    from itertools import zip_longest as izip_longest\nimport numpy as np\n\nfrom ._caffe import Net, SGDSolver, NesterovSolver, AdaGradSolver, \\\n        RMSPropSolver, AdaDeltaSolver, AdamSolver\nimport caffe.io\n\nimport six\n\n# We directly update methods from Net here (rather than using composition or\n# inheritance) so that nets created by caffe (e.g., by SGDSolver) will\n# automatically have the improved interface.\n\n\n@property\ndef _Net_blobs(self):\n    """"""\n    An OrderedDict (bottom to top, i.e., input to output) of network\n    blobs indexed by name\n    """"""\n    if not hasattr(self, \'_blobs_dict\'):\n        self._blobs_dict = OrderedDict(zip(self._blob_names, self._blobs))\n    return self._blobs_dict\n\n\n@property\ndef _Net_blob_loss_weights(self):\n    """"""\n    An OrderedDict (bottom to top, i.e., input to output) of network\n    blob loss weights indexed by name\n    """"""\n    if not hasattr(self, \'_blobs_loss_weights_dict\'):\n        self._blob_loss_weights_dict = OrderedDict(zip(self._blob_names,\n                                                       self._blob_loss_weights))\n    return self._blob_loss_weights_dict\n\n\n@property\ndef _Net_params(self):\n    """"""\n    An OrderedDict (bottom to top, i.e., input to output) of network\n    parameters indexed by name; each is a list of multiple blobs (e.g.,\n    weights and biases)\n    """"""\n    if not hasattr(self, \'_params_dict\'):\n        self._params_dict = OrderedDict([(name, lr.blobs)\n                                        for name, lr in zip(\n                                            self._layer_names, self.layers)\n                                        if len(lr.blobs) > 0])\n    return self._params_dict\n\n\n@property\ndef _Net_inputs(self):\n    if not hasattr(self, \'_input_list\'):\n        keys = list(self.blobs.keys())\n        self._input_list = [keys[i] for i in self._inputs]\n    return self._input_list\n\n\n@property\ndef _Net_outputs(self):\n    if not hasattr(self, \'_output_list\'):\n        keys = list(self.blobs.keys())\n        self._output_list = [keys[i] for i in self._outputs]\n    return self._output_list\n\n\ndef _Net_forward(self, blobs=None, start=None, end=None, **kwargs):\n    """"""\n    Forward pass: prepare inputs and run the net forward.\n\n    Parameters\n    ----------\n    blobs : list of blobs to return in addition to output blobs.\n    kwargs : Keys are input blob names and values are blob ndarrays.\n             For formatting inputs for Caffe, see Net.preprocess().\n             If None, input is taken from data layers.\n    start : optional name of layer at which to begin the forward pass\n    end : optional name of layer at which to finish the forward pass\n          (inclusive)\n\n    Returns\n    -------\n    outs : {blob name: blob ndarray} dict.\n    """"""\n    if blobs is None:\n        blobs = []\n\n    if start is not None:\n        start_ind = list(self._layer_names).index(start)\n    else:\n        start_ind = 0\n\n    if end is not None:\n        end_ind = list(self._layer_names).index(end)\n        outputs = set([end] + blobs)\n    else:\n        end_ind = len(self.layers) - 1\n        outputs = set(self.outputs + blobs)\n\n    if kwargs:\n        if set(kwargs.keys()) != set(self.inputs):\n            raise Exception(\'Input blob arguments do not match net inputs.\')\n        # Set input according to defined shapes and make arrays single and\n        # C-contiguous as Caffe expects.\n        for in_, blob in six.iteritems(kwargs):\n            if blob.shape[0] != self.blobs[in_].shape[0]:\n                raise Exception(\'Input is not batch sized\')\n            self.blobs[in_].data[...] = blob\n\n    self._forward(start_ind, end_ind)\n\n    # Unpack blobs to extract\n    return {out: self.blobs[out].data for out in outputs}\n\n\ndef _Net_backward(self, diffs=None, start=None, end=None, **kwargs):\n    """"""\n    Backward pass: prepare diffs and run the net backward.\n\n    Parameters\n    ----------\n    diffs : list of diffs to return in addition to bottom diffs.\n    kwargs : Keys are output blob names and values are diff ndarrays.\n            If None, top diffs are taken from forward loss.\n    start : optional name of layer at which to begin the backward pass\n    end : optional name of layer at which to finish the backward pass\n        (inclusive)\n\n    Returns\n    -------\n    outs: {blob name: diff ndarray} dict.\n    """"""\n    if diffs is None:\n        diffs = []\n\n    if start is not None:\n        start_ind = list(self._layer_names).index(start)\n    else:\n        start_ind = len(self.layers) - 1\n\n    if end is not None:\n        end_ind = list(self._layer_names).index(end)\n        outputs = set([end] + diffs)\n    else:\n        end_ind = 0\n        outputs = set(self.inputs + diffs)\n\n    if kwargs:\n        if set(kwargs.keys()) != set(self.outputs):\n            raise Exception(\'Top diff arguments do not match net outputs.\')\n        # Set top diffs according to defined shapes and make arrays single and\n        # C-contiguous as Caffe expects.\n        for top, diff in six.iteritems(kwargs):\n            if diff.shape[0] != self.blobs[top].shape[0]:\n                raise Exception(\'Diff is not batch sized\')\n            self.blobs[top].diff[...] = diff\n\n    self._backward(start_ind, end_ind)\n\n    # Unpack diffs to extract\n    return {out: self.blobs[out].diff for out in outputs}\n\n\ndef _Net_forward_all(self, blobs=None, **kwargs):\n    """"""\n    Run net forward in batches.\n\n    Parameters\n    ----------\n    blobs : list of blobs to extract as in forward()\n    kwargs : Keys are input blob names and values are blob ndarrays.\n             Refer to forward().\n\n    Returns\n    -------\n    all_outs : {blob name: list of blobs} dict.\n    """"""\n    # Collect outputs from batches\n    all_outs = {out: [] for out in set(self.outputs + (blobs or []))}\n    for batch in self._batch(kwargs):\n        outs = self.forward(blobs=blobs, **batch)\n        for out, out_blob in six.iteritems(outs):\n            all_outs[out].extend(out_blob.copy())\n    # Package in ndarray.\n    for out in all_outs:\n        all_outs[out] = np.asarray(all_outs[out])\n    # Discard padding.\n    pad = len(six.next(six.itervalues(all_outs))) - len(six.next(six.itervalues(kwargs)))\n    if pad:\n        for out in all_outs:\n            all_outs[out] = all_outs[out][:-pad]\n    return all_outs\n\n\ndef _Net_forward_backward_all(self, blobs=None, diffs=None, **kwargs):\n    """"""\n    Run net forward + backward in batches.\n\n    Parameters\n    ----------\n    blobs: list of blobs to extract as in forward()\n    diffs: list of diffs to extract as in backward()\n    kwargs: Keys are input (for forward) and output (for backward) blob names\n            and values are ndarrays. Refer to forward() and backward().\n            Prefilled variants are called for lack of input or output blobs.\n\n    Returns\n    -------\n    all_blobs: {blob name: blob ndarray} dict.\n    all_diffs: {blob name: diff ndarray} dict.\n    """"""\n    # Batch blobs and diffs.\n    all_outs = {out: [] for out in set(self.outputs + (blobs or []))}\n    all_diffs = {diff: [] for diff in set(self.inputs + (diffs or []))}\n    forward_batches = self._batch({in_: kwargs[in_]\n                                   for in_ in self.inputs if in_ in kwargs})\n    backward_batches = self._batch({out: kwargs[out]\n                                    for out in self.outputs if out in kwargs})\n    # Collect outputs from batches (and heed lack of forward/backward batches).\n    for fb, bb in izip_longest(forward_batches, backward_batches, fillvalue={}):\n        batch_blobs = self.forward(blobs=blobs, **fb)\n        batch_diffs = self.backward(diffs=diffs, **bb)\n        for out, out_blobs in six.iteritems(batch_blobs):\n            all_outs[out].extend(out_blobs.copy())\n        for diff, out_diffs in six.iteritems(batch_diffs):\n            all_diffs[diff].extend(out_diffs.copy())\n    # Package in ndarray.\n    for out, diff in zip(all_outs, all_diffs):\n        all_outs[out] = np.asarray(all_outs[out])\n        all_diffs[diff] = np.asarray(all_diffs[diff])\n    # Discard padding at the end and package in ndarray.\n    pad = len(six.next(six.itervalues(all_outs))) - len(six.next(six.itervalues(kwargs)))\n    if pad:\n        for out, diff in zip(all_outs, all_diffs):\n            all_outs[out] = all_outs[out][:-pad]\n            all_diffs[diff] = all_diffs[diff][:-pad]\n    return all_outs, all_diffs\n\n\ndef _Net_set_input_arrays(self, data, labels):\n    """"""\n    Set input arrays of the in-memory MemoryDataLayer.\n    (Note: this is only for networks declared with the memory data layer.)\n    """"""\n    if labels.ndim == 1:\n        labels = np.ascontiguousarray(labels[:, np.newaxis, np.newaxis,\n                                             np.newaxis])\n    return self._set_input_arrays(data, labels)\n\n\ndef _Net_batch(self, blobs):\n    """"""\n    Batch blob lists according to net\'s batch size.\n\n    Parameters\n    ----------\n    blobs: Keys blob names and values are lists of blobs (of any length).\n           Naturally, all the lists should have the same length.\n\n    Yields\n    ------\n    batch: {blob name: list of blobs} dict for a single batch.\n    """"""\n    num = len(six.next(six.itervalues(blobs)))\n    batch_size = six.next(six.itervalues(self.blobs)).shape[0]\n    remainder = num % batch_size\n    num_batches = num // batch_size\n\n    # Yield full batches.\n    for b in range(num_batches):\n        i = b * batch_size\n        yield {name: blobs[name][i:i + batch_size] for name in blobs}\n\n    # Yield last padded batch, if any.\n    if remainder > 0:\n        padded_batch = {}\n        for name in blobs:\n            padding = np.zeros((batch_size - remainder,)\n                               + blobs[name].shape[1:])\n            padded_batch[name] = np.concatenate([blobs[name][-remainder:],\n                                                 padding])\n        yield padded_batch\n\n\nclass _Net_IdNameWrapper:\n    """"""\n    A simple wrapper that allows the ids propery to be accessed as a dict\n    indexed by names. Used for top and bottom names\n    """"""\n    def __init__(self, net, func):\n        self.net, self.func = net, func\n\n    def __getitem__(self, name):\n        # Map the layer name to id\n        ids = self.func(self.net, list(self.net._layer_names).index(name))\n        # Map the blob id to name\n        id_to_name = list(self.net.blobs)\n        return [id_to_name[i] for i in ids]\n\n# Attach methods to Net.\nNet.blobs = _Net_blobs\nNet.blob_loss_weights = _Net_blob_loss_weights\nNet.params = _Net_params\nNet.forward = _Net_forward\nNet.backward = _Net_backward\nNet.forward_all = _Net_forward_all\nNet.forward_backward_all = _Net_forward_backward_all\nNet.set_input_arrays = _Net_set_input_arrays\nNet._batch = _Net_batch\nNet.inputs = _Net_inputs\nNet.outputs = _Net_outputs\nNet.top_names = property(lambda n: _Net_IdNameWrapper(n, Net._top_ids))\nNet.bottom_names = property(lambda n: _Net_IdNameWrapper(n, Net._bottom_ids))\n'"
python/layers/python_layers.py,0,"b'import caffe\nimport numpy as np\n\nclass Meshgrid(caffe.Layer):\n   \n    def setup(self, bottom, top):\n        params = eval(self.param_str)\n        self.width = params[\'width\']\n        self.height = params[\'height\']\n        self.batch = params[\'batch\']\n\n    def reshape(self, bottom, top):\n        assert len(bottom) == 0, ""No bottom accepted""\n        assert len(top) == 1, ""Only one top accepted""\n        top[0].reshape(self.batch, 2, self.height, self.width)\n        # top[1].reshape(self.batch, 1, self.height, self.width)\n\n    def forward(self, bottom, top):\n        gx, gy = np.meshgrid(range(self.width), range(self.height))\n        gxy = np.concatenate((gx[None,:,:], gy[None,:,:]), axis=0)\n        top[0].data[...] = gxy[None, :, :, :]\n        # top[1].data[...] = gy[None,None,:,:]\n\n    def backward(self, top, propagate_down, bottom):\n       pass\n\nclass MeanVals(caffe.Layer):\n\n    def setup(self, bottom, top):\n        params = eval(self.param_str)\n        self.width = params[\'width\']\n        self.height = params[\'height\']\n        self.batch = params[\'batch\']\n    \n    def reshape(self, bottom, top):\n       assert len(bottom) == 0, ""No bottom accepted""\n       assert len(top) == 1, ""Only one top accepted""\n       top[0].reshape(self.batch, 3, self.height, self.width)\n\n    def forward(self, bottom, top):\n        m1 = 104 * np.ones((self.height, self.width))\n        m2 = 117 * np.ones((self.height, self.width))\n        m3 = 123 * np.ones((self.height, self.width))\n        mall = np.concatenate((m1[None,:,:], m2[None,:,:], m3[None,:,:]), axis=0)\n        top[0].data[...] = mall[None, :, :, :]\n        # top[1].data[...] = gy[None,None,:,:]\n\n    def backward(self, top, propagate_down, bottom):\n       pass\n'"
tools/extra/extract_seconds.py,0,"b'#!/usr/bin/env python\nimport datetime\nimport os\nimport sys\n\ndef extract_datetime_from_line(line, year):\n    # Expected format: I0210 13:39:22.381027 25210 solver.cpp:204] Iteration 100, lr = 0.00992565\n    line = line.strip().split()\n    month = int(line[0][1:3])\n    day = int(line[0][3:])\n    timestamp = line[1]\n    pos = timestamp.rfind(\'.\')\n    ts = [int(x) for x in timestamp[:pos].split(\':\')]\n    hour = ts[0]\n    minute = ts[1]\n    second = ts[2]\n    microsecond = int(timestamp[pos + 1:])\n    dt = datetime.datetime(year, month, day, hour, minute, second, microsecond)\n    return dt\n\n\ndef get_log_created_year(input_file):\n    """"""Get year from log file system timestamp\n    """"""\n\n    log_created_time = os.path.getctime(input_file)\n    log_created_year = datetime.datetime.fromtimestamp(log_created_time).year\n    return log_created_year\n\n\ndef get_start_time(line_iterable, year):\n    """"""Find start time from group of lines\n    """"""\n\n    start_datetime = None\n    for line in line_iterable:\n        line = line.strip()\n        if line.find(\'Solving\') != -1:\n            start_datetime = extract_datetime_from_line(line, year)\n            break\n    return start_datetime\n\n\ndef extract_seconds(input_file, output_file):\n    with open(input_file, \'r\') as f:\n        lines = f.readlines()\n    log_created_year = get_log_created_year(input_file)\n    start_datetime = get_start_time(lines, log_created_year)\n    assert start_datetime, \'Start time not found\'\n\n    out = open(output_file, \'w\')\n    for line in lines:\n        line = line.strip()\n        if line.find(\'Iteration\') != -1:\n            dt = extract_datetime_from_line(line, log_created_year)\n            elapsed_seconds = (dt - start_datetime).total_seconds()\n            out.write(\'%f\\n\' % elapsed_seconds)\n    out.close()\n\nif __name__ == \'__main__\':\n    if len(sys.argv) < 3:\n        print(\'Usage: ./extract_seconds input_file output_file\')\n        exit(1)\n    extract_seconds(sys.argv[1], sys.argv[2])\n'"
tools/extra/parse_log.py,0,"b'#!/usr/bin/env python\n\n""""""\nParse training log\n\nEvolved from parse_log.sh\n""""""\n\nimport os\nimport re\nimport extract_seconds\nimport argparse\nimport csv\nfrom collections import OrderedDict\n\n\ndef parse_log(path_to_log):\n    """"""Parse log file\n    Returns (train_dict_list, train_dict_names, test_dict_list, test_dict_names)\n\n    train_dict_list and test_dict_list are lists of dicts that define the table\n    rows\n\n    train_dict_names and test_dict_names are ordered tuples of the column names\n    for the two dict_lists\n    """"""\n\n    regex_iteration = re.compile(\'Iteration (\\d+)\')\n    regex_train_output = re.compile(\'Train net output #(\\d+): (\\S+) = ([\\.\\deE+-]+)\')\n    regex_test_output = re.compile(\'Test net output #(\\d+): (\\S+) = ([\\.\\deE+-]+)\')\n    regex_learning_rate = re.compile(\'lr = ([-+]?[0-9]*\\.?[0-9]+([eE]?[-+]?[0-9]+)?)\')\n\n    # Pick out lines of interest\n    iteration = -1\n    learning_rate = float(\'NaN\')\n    train_dict_list = []\n    test_dict_list = []\n    train_row = None\n    test_row = None\n\n    logfile_year = extract_seconds.get_log_created_year(path_to_log)\n    with open(path_to_log) as f:\n        start_time = extract_seconds.get_start_time(f, logfile_year)\n\n        for line in f:\n            iteration_match = regex_iteration.search(line)\n            if iteration_match:\n                iteration = float(iteration_match.group(1))\n            if iteration == -1:\n                # Only start parsing for other stuff if we\'ve found the first\n                # iteration\n                continue\n\n            time = extract_seconds.extract_datetime_from_line(line,\n                                                              logfile_year)\n            seconds = (time - start_time).total_seconds()\n\n            learning_rate_match = regex_learning_rate.search(line)\n            if learning_rate_match:\n                learning_rate = float(learning_rate_match.group(1))\n\n            train_dict_list, train_row = parse_line_for_net_output(\n                regex_train_output, train_row, train_dict_list,\n                line, iteration, seconds, learning_rate\n            )\n            test_dict_list, test_row = parse_line_for_net_output(\n                regex_test_output, test_row, test_dict_list,\n                line, iteration, seconds, learning_rate\n            )\n\n    fix_initial_nan_learning_rate(train_dict_list)\n    fix_initial_nan_learning_rate(test_dict_list)\n\n    return train_dict_list, test_dict_list\n\n\ndef parse_line_for_net_output(regex_obj, row, row_dict_list,\n                              line, iteration, seconds, learning_rate):\n    """"""Parse a single line for training or test output\n\n    Returns a a tuple with (row_dict_list, row)\n    row: may be either a new row or an augmented version of the current row\n    row_dict_list: may be either the current row_dict_list or an augmented\n    version of the current row_dict_list\n    """"""\n\n    output_match = regex_obj.search(line)\n    if output_match:\n        if not row or row[\'NumIters\'] != iteration:\n            # Push the last row and start a new one\n            if row:\n                # If we\'re on a new iteration, push the last row\n                # This will probably only happen for the first row; otherwise\n                # the full row checking logic below will push and clear full\n                # rows\n                row_dict_list.append(row)\n\n            row = OrderedDict([\n                (\'NumIters\', iteration),\n                (\'Seconds\', seconds),\n                (\'LearningRate\', learning_rate)\n            ])\n\n        # output_num is not used; may be used in the future\n        # output_num = output_match.group(1)\n        output_name = output_match.group(2)\n        output_val = output_match.group(3)\n        row[output_name] = float(output_val)\n\n    if row and len(row_dict_list) >= 1 and len(row) == len(row_dict_list[0]):\n        # The row is full, based on the fact that it has the same number of\n        # columns as the first row; append it to the list\n        row_dict_list.append(row)\n        row = None\n\n    return row_dict_list, row\n\n\ndef fix_initial_nan_learning_rate(dict_list):\n    """"""Correct initial value of learning rate\n\n    Learning rate is normally not printed until after the initial test and\n    training step, which means the initial testing and training rows have\n    LearningRate = NaN. Fix this by copying over the LearningRate from the\n    second row, if it exists.\n    """"""\n\n    if len(dict_list) > 1:\n        dict_list[0][\'LearningRate\'] = dict_list[1][\'LearningRate\']\n\n\ndef save_csv_files(logfile_path, output_dir, train_dict_list, test_dict_list,\n                   delimiter=\',\', verbose=False):\n    """"""Save CSV files to output_dir\n\n    If the input log file is, e.g., caffe.INFO, the names will be\n    caffe.INFO.train and caffe.INFO.test\n    """"""\n\n    log_basename = os.path.basename(logfile_path)\n    train_filename = os.path.join(output_dir, log_basename + \'.train\')\n    write_csv(train_filename, train_dict_list, delimiter, verbose)\n\n    test_filename = os.path.join(output_dir, log_basename + \'.test\')\n    write_csv(test_filename, test_dict_list, delimiter, verbose)\n\n\ndef write_csv(output_filename, dict_list, delimiter, verbose=False):\n    """"""Write a CSV file\n    """"""\n\n    if not dict_list:\n        if verbose:\n            print(\'Not writing %s; no lines to write\' % output_filename)\n        return\n\n    dialect = csv.excel\n    dialect.delimiter = delimiter\n\n    with open(output_filename, \'w\') as f:\n        dict_writer = csv.DictWriter(f, fieldnames=dict_list[0].keys(),\n                                     dialect=dialect)\n        dict_writer.writeheader()\n        dict_writer.writerows(dict_list)\n    if verbose:\n        print \'Wrote %s\' % output_filename\n\n\ndef parse_args():\n    description = (\'Parse a Caffe training log into two CSV files \'\n                   \'containing training and testing information\')\n    parser = argparse.ArgumentParser(description=description)\n\n    parser.add_argument(\'logfile_path\',\n                        help=\'Path to log file\')\n\n    parser.add_argument(\'output_dir\',\n                        help=\'Directory in which to place output CSV files\')\n\n    parser.add_argument(\'--verbose\',\n                        action=\'store_true\',\n                        help=\'Print some extra info (e.g., output filenames)\')\n\n    parser.add_argument(\'--delimiter\',\n                        default=\',\',\n                        help=(\'Column delimiter in output files \'\n                              \'(default: \\\'%(default)s\\\')\'))\n\n    args = parser.parse_args()\n    return args\n\n\ndef main():\n    args = parse_args()\n    train_dict_list, test_dict_list = parse_log(args.logfile_path)\n    save_csv_files(args.logfile_path, args.output_dir, train_dict_list,\n                   test_dict_list, delimiter=args.delimiter)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tools/extra/resize_and_crop_images.py,0,"b""#!/usr/bin/env python\nfrom mincepie import mapreducer, launcher\nimport gflags\nimport os\nimport cv2\nfrom PIL import Image\n\n# gflags\ngflags.DEFINE_string('image_lib', 'opencv',\n                     'OpenCV or PIL, case insensitive. The default value is the faster OpenCV.')\ngflags.DEFINE_string('input_folder', '',\n                     'The folder that contains all input images, organized in synsets.')\ngflags.DEFINE_integer('output_side_length', 256,\n                     'Expected side length of the output image.')\ngflags.DEFINE_string('output_folder', '',\n                     'The folder that we write output resized and cropped images to')\nFLAGS = gflags.FLAGS\n\nclass OpenCVResizeCrop:\n    def resize_and_crop_image(self, input_file, output_file, output_side_length = 256):\n        '''Takes an image name, resize it and crop the center square\n        '''\n        img = cv2.imread(input_file)\n        height, width, depth = img.shape\n        new_height = output_side_length\n        new_width = output_side_length\n        if height > width:\n            new_height = output_side_length * height / width\n        else:\n            new_width = output_side_length * width / height\n        resized_img = cv2.resize(img, (new_width, new_height))\n        height_offset = (new_height - output_side_length) / 2\n        width_offset = (new_width - output_side_length) / 2\n        cropped_img = resized_img[height_offset:height_offset + output_side_length,\n                                  width_offset:width_offset + output_side_length]\n        cv2.imwrite(output_file, cropped_img)\n\nclass PILResizeCrop:\n## http://united-coders.com/christian-harms/image-resizing-tips-every-coder-should-know/\n    def resize_and_crop_image(self, input_file, output_file, output_side_length = 256, fit = True):\n        '''Downsample the image.\n        '''\n        img = Image.open(input_file)\n        box = (output_side_length, output_side_length)\n        #preresize image with factor 2, 4, 8 and fast algorithm\n        factor = 1\n        while img.size[0]/factor > 2*box[0] and img.size[1]*2/factor > 2*box[1]:\n            factor *=2\n        if factor > 1:\n            img.thumbnail((img.size[0]/factor, img.size[1]/factor), Image.NEAREST)\n\n        #calculate the cropping box and get the cropped part\n        if fit:\n            x1 = y1 = 0\n            x2, y2 = img.size\n            wRatio = 1.0 * x2/box[0]\n            hRatio = 1.0 * y2/box[1]\n            if hRatio > wRatio:\n                y1 = int(y2/2-box[1]*wRatio/2)\n                y2 = int(y2/2+box[1]*wRatio/2)\n            else:\n                x1 = int(x2/2-box[0]*hRatio/2)\n                x2 = int(x2/2+box[0]*hRatio/2)\n            img = img.crop((x1,y1,x2,y2))\n\n        #Resize the image with best quality algorithm ANTI-ALIAS\n        img.thumbnail(box, Image.ANTIALIAS)\n\n        #save it into a file-like object\n        with open(output_file, 'wb') as out:\n            img.save(out, 'JPEG', quality=75)\n\nclass ResizeCropImagesMapper(mapreducer.BasicMapper):\n    '''The ImageNet Compute mapper. \n    The input value would be the file listing images' paths relative to input_folder.\n    '''\n    def map(self, key, value):\n        if type(value) is not str:\n            value = str(value)\n        files = [value]\n        image_lib = FLAGS.image_lib.lower()\n        if image_lib == 'pil':\n            resize_crop = PILResizeCrop()\n        else:\n            resize_crop = OpenCVResizeCrop()\n        for i, line in enumerate(files):\n            try:\n                line = line.replace(FLAGS.input_folder, '').strip()\n                line = line.split()\n                image_file_name = line[0]\n                input_file = os.path.join(FLAGS.input_folder, image_file_name)\n                output_file = os.path.join(FLAGS.output_folder, image_file_name)\n                output_dir = output_file[:output_file.rfind('/')]\n                if not os.path.exists(output_dir):\n                    os.makedirs(output_dir)\n                feat = resize_crop.resize_and_crop_image(input_file, output_file,\n                                                              FLAGS.output_side_length)\n            except Exception, e:\n                # we ignore the exception (maybe the image is corrupted?)\n                print line, Exception, e\n        yield value, FLAGS.output_folder\n\nmapreducer.REGISTER_DEFAULT_MAPPER(ResizeCropImagesMapper)\n\nmapreducer.REGISTER_DEFAULT_READER(mapreducer.FileReader)\nmapreducer.REGISTER_DEFAULT_WRITER(mapreducer.FileWriter)\n \nif __name__ == '__main__':\n    launcher.launch()\n"""
tools/extra/summarize.py,0,"b'#!/usr/bin/env python\n\n""""""Net summarization tool.\n\nThis tool summarizes the structure of a net in a concise but comprehensive\ntabular listing, taking a prototxt file as input.\n\nUse this tool to check at a glance that the computation you\'ve specified is the\ncomputation you expect.\n""""""\n\nfrom caffe.proto import caffe_pb2\nfrom google import protobuf\nimport re\nimport argparse\n\n# ANSI codes for coloring blobs (used cyclically)\nCOLORS = [\'92\', \'93\', \'94\', \'95\', \'97\', \'96\', \'42\', \'43;30\', \'100\',\n          \'444\', \'103;30\', \'107;30\']\nDISCONNECTED_COLOR = \'41\'\n\ndef read_net(filename):\n    net = caffe_pb2.NetParameter()\n    with open(filename) as f:\n        protobuf.text_format.Parse(f.read(), net)\n    return net\n\ndef format_param(param):\n    out = []\n    if len(param.name) > 0:\n        out.append(param.name)\n    if param.lr_mult != 1:\n        out.append(\'x{}\'.format(param.lr_mult))\n    if param.decay_mult != 1:\n        out.append(\'Dx{}\'.format(param.decay_mult))\n    return \' \'.join(out)\n\ndef printed_len(s):\n    return len(re.sub(r\'\\033\\[[\\d;]+m\', \'\', s))\n\ndef print_table(table, max_width):\n    """"""Print a simple nicely-aligned table.\n\n    table must be a list of (equal-length) lists. Columns are space-separated,\n    and as narrow as possible, but no wider than max_width. Text may overflow\n    columns; note that unlike string.format, this will not affect subsequent\n    columns, if possible.""""""\n\n    max_widths = [max_width] * len(table[0])\n    column_widths = [max(printed_len(row[j]) + 1 for row in table)\n                     for j in range(len(table[0]))]\n    column_widths = [min(w, max_w) for w, max_w in zip(column_widths, max_widths)]\n\n    for row in table:\n        row_str = \'\'\n        right_col = 0\n        for cell, width in zip(row, column_widths):\n            right_col += width\n            row_str += cell + \' \'\n            row_str += \' \' * max(right_col - printed_len(row_str), 0)\n        print row_str\n\ndef summarize_net(net):\n    disconnected_tops = set()\n    for lr in net.layer:\n        disconnected_tops |= set(lr.top)\n        disconnected_tops -= set(lr.bottom)\n\n    table = []\n    colors = {}\n    for lr in net.layer:\n        tops = []\n        for ind, top in enumerate(lr.top):\n            color = colors.setdefault(top, COLORS[len(colors) % len(COLORS)])\n            if top in disconnected_tops:\n                top = \'\\033[1;4m\' + top\n            if len(lr.loss_weight) > 0:\n                top = \'{} * {}\'.format(lr.loss_weight[ind], top)\n            tops.append(\'\\033[{}m{}\\033[0m\'.format(color, top))\n        top_str = \', \'.join(tops)\n\n        bottoms = []\n        for bottom in lr.bottom:\n            color = colors.get(bottom, DISCONNECTED_COLOR)\n            bottoms.append(\'\\033[{}m{}\\033[0m\'.format(color, bottom))\n        bottom_str = \', \'.join(bottoms)\n\n        if lr.type == \'Python\':\n            type_str = lr.python_param.module + \'.\' + lr.python_param.layer\n        else:\n            type_str = lr.type\n\n        # Summarize conv/pool parameters.\n        # TODO support rectangular/ND parameters\n        conv_param = lr.convolution_param\n        if (lr.type in [\'Convolution\', \'Deconvolution\']\n                and len(conv_param.kernel_size) == 1):\n            arg_str = str(conv_param.kernel_size[0])\n            if len(conv_param.stride) > 0 and conv_param.stride[0] != 1:\n                arg_str += \'/\' + str(conv_param.stride[0])\n            if len(conv_param.pad) > 0 and conv_param.pad[0] != 0:\n                arg_str += \'+\' + str(conv_param.pad[0])\n            arg_str += \' \' + str(conv_param.num_output)\n            if conv_param.group != 1:\n                arg_str += \'/\' + str(conv_param.group)\n        elif lr.type == \'Pooling\':\n            arg_str = str(lr.pooling_param.kernel_size)\n            if lr.pooling_param.stride != 1:\n                arg_str += \'/\' + str(lr.pooling_param.stride)\n            if lr.pooling_param.pad != 0:\n                arg_str += \'+\' + str(lr.pooling_param.pad)\n        else:\n            arg_str = \'\'\n\n        if len(lr.param) > 0:\n            param_strs = map(format_param, lr.param)\n            if max(map(len, param_strs)) > 0:\n                param_str = \'({})\'.format(\', \'.join(param_strs))\n            else:\n                param_str = \'\'\n        else:\n            param_str = \'\'\n\n        table.append([lr.name, type_str, param_str, bottom_str, \'->\', top_str,\n                      arg_str])\n    return table\n\ndef main():\n    parser = argparse.ArgumentParser(description=""Print a concise summary of net computation."")\n    parser.add_argument(\'filename\', help=\'net prototxt file to summarize\')\n    parser.add_argument(\'-w\', \'--max-width\', help=\'maximum field width\',\n            type=int, default=30)\n    args = parser.parse_args()\n\n    net = read_net(args.filename)\n    table = summarize_net(net)\n    print_table(table, max_width=args.max_width)\n\nif __name__ == \'__main__\':\n    main()\n'"
python/caffe/proto/caffe_pb2.py,0,"b'# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: caffe.proto\n\nfrom google.protobuf.internal import enum_type_wrapper\nfrom google.protobuf import descriptor as _descriptor\nfrom google.protobuf import message as _message\nfrom google.protobuf import reflection as _reflection\nfrom google.protobuf import descriptor_pb2\n# @@protoc_insertion_point(imports)\n\n\n\n\nDESCRIPTOR = _descriptor.FileDescriptor(\n  name=\'caffe.proto\',\n  package=\'caffe\',\n  serialized_pb=\'\\n\\x0b\\x63\\x61\\x66\\x66\\x65.proto\\x12\\x05\\x63\\x61\\x66\\x66\\x65\\""\\x1c\\n\\tBlobShape\\x12\\x0f\\n\\x03\\x64im\\x18\\x01 \\x03(\\x03\\x42\\x02\\x10\\x01\\""\\xcc\\x01\\n\\tBlobProto\\x12\\x1f\\n\\x05shape\\x18\\x07 \\x01(\\x0b\\x32\\x10.caffe.BlobShape\\x12\\x10\\n\\x04\\x64\\x61ta\\x18\\x05 \\x03(\\x02\\x42\\x02\\x10\\x01\\x12\\x10\\n\\x04\\x64iff\\x18\\x06 \\x03(\\x02\\x42\\x02\\x10\\x01\\x12\\x17\\n\\x0b\\x64ouble_data\\x18\\x08 \\x03(\\x01\\x42\\x02\\x10\\x01\\x12\\x17\\n\\x0b\\x64ouble_diff\\x18\\t \\x03(\\x01\\x42\\x02\\x10\\x01\\x12\\x0e\\n\\x03num\\x18\\x01 \\x01(\\x05:\\x01\\x30\\x12\\x13\\n\\x08\\x63hannels\\x18\\x02 \\x01(\\x05:\\x01\\x30\\x12\\x11\\n\\x06height\\x18\\x03 \\x01(\\x05:\\x01\\x30\\x12\\x10\\n\\x05width\\x18\\x04 \\x01(\\x05:\\x01\\x30\\""2\\n\\x0f\\x42lobProtoVector\\x12\\x1f\\n\\x05\\x62lobs\\x18\\x01 \\x03(\\x0b\\x32\\x10.caffe.BlobProto\\""\\x81\\x01\\n\\x05\\x44\\x61tum\\x12\\x10\\n\\x08\\x63hannels\\x18\\x01 \\x01(\\x05\\x12\\x0e\\n\\x06height\\x18\\x02 \\x01(\\x05\\x12\\r\\n\\x05width\\x18\\x03 \\x01(\\x05\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x04 \\x01(\\x0c\\x12\\r\\n\\x05label\\x18\\x05 \\x01(\\x05\\x12\\x12\\n\\nfloat_data\\x18\\x06 \\x03(\\x02\\x12\\x16\\n\\x07\\x65ncoded\\x18\\x07 \\x01(\\x08:\\x05\\x66\\x61lse\\""\\xaa\\x02\\n\\x0f\\x46illerParameter\\x12\\x16\\n\\x04type\\x18\\x01 \\x01(\\t:\\x08\\x63onstant\\x12\\x10\\n\\x05value\\x18\\x02 \\x01(\\x02:\\x01\\x30\\x12\\x0e\\n\\x03min\\x18\\x03 \\x01(\\x02:\\x01\\x30\\x12\\x0e\\n\\x03max\\x18\\x04 \\x01(\\x02:\\x01\\x31\\x12\\x0f\\n\\x04mean\\x18\\x05 \\x01(\\x02:\\x01\\x30\\x12\\x0e\\n\\x03std\\x18\\x06 \\x01(\\x02:\\x01\\x31\\x12\\x12\\n\\x06sparse\\x18\\x07 \\x01(\\x05:\\x02-1\\x12\\x42\\n\\rvariance_norm\\x18\\x08 \\x01(\\x0e\\x32#.caffe.FillerParameter.VarianceNorm:\\x06\\x46\\x41N_IN\\x12\\x10\\n\\x08\\x64iag_val\\x18\\t \\x03(\\x02\\x12\\x0c\\n\\x04\\x66ile\\x18\\n \\x01(\\t\\""4\\n\\x0cVarianceNorm\\x12\\n\\n\\x06\\x46\\x41N_IN\\x10\\x00\\x12\\x0b\\n\\x07\\x46\\x41N_OUT\\x10\\x01\\x12\\x0b\\n\\x07\\x41VERAGE\\x10\\x02\\""\\x8e\\x02\\n\\x0cNetParameter\\x12\\x0c\\n\\x04name\\x18\\x01 \\x01(\\t\\x12\\r\\n\\x05input\\x18\\x03 \\x03(\\t\\x12%\\n\\x0binput_shape\\x18\\x08 \\x03(\\x0b\\x32\\x10.caffe.BlobShape\\x12\\x11\\n\\tinput_dim\\x18\\x04 \\x03(\\x05\\x12\\x1d\\n\\x0e\\x66orce_backward\\x18\\x05 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x1e\\n\\x05state\\x18\\x06 \\x01(\\x0b\\x32\\x0f.caffe.NetState\\x12\\x19\\n\\ndebug_info\\x18\\x07 \\x01(\\x08:\\x05\\x66\\x61lse\\x12$\\n\\x05layer\\x18\\x64 \\x03(\\x0b\\x32\\x15.caffe.LayerParameter\\x12\\\'\\n\\x06layers\\x18\\x02 \\x03(\\x0b\\x32\\x17.caffe.V1LayerParameter\\""\\x9c\\n\\n\\x0fSolverParameter\\x12\\x0b\\n\\x03net\\x18\\x18 \\x01(\\t\\x12&\\n\\tnet_param\\x18\\x19 \\x01(\\x0b\\x32\\x13.caffe.NetParameter\\x12\\x11\\n\\ttrain_net\\x18\\x01 \\x01(\\t\\x12\\x10\\n\\x08test_net\\x18\\x02 \\x03(\\t\\x12,\\n\\x0ftrain_net_param\\x18\\x15 \\x01(\\x0b\\x32\\x13.caffe.NetParameter\\x12+\\n\\x0etest_net_param\\x18\\x16 \\x03(\\x0b\\x32\\x13.caffe.NetParameter\\x12$\\n\\x0btrain_state\\x18\\x1a \\x01(\\x0b\\x32\\x0f.caffe.NetState\\x12#\\n\\ntest_state\\x18\\x1b \\x03(\\x0b\\x32\\x0f.caffe.NetState\\x12\\x11\\n\\ttest_iter\\x18\\x03 \\x03(\\x05\\x12\\x18\\n\\rtest_interval\\x18\\x04 \\x01(\\x05:\\x01\\x30\\x12 \\n\\x11test_compute_loss\\x18\\x13 \\x01(\\x08:\\x05\\x66\\x61lse\\x12!\\n\\x13test_initialization\\x18  \\x01(\\x08:\\x04true\\x12\\x0f\\n\\x07\\x62\\x61se_lr\\x18\\x05 \\x01(\\x02\\x12\\x0f\\n\\x07\\x64isplay\\x18\\x06 \\x01(\\x05\\x12\\x17\\n\\x0c\\x61verage_loss\\x18! \\x01(\\x05:\\x01\\x31\\x12\\x10\\n\\x08max_iter\\x18\\x07 \\x01(\\x05\\x12\\x14\\n\\titer_size\\x18$ \\x01(\\x05:\\x01\\x31\\x12\\x11\\n\\tlr_policy\\x18\\x08 \\x01(\\t\\x12\\r\\n\\x05gamma\\x18\\t \\x01(\\x02\\x12\\r\\n\\x05power\\x18\\n \\x01(\\x02\\x12\\x10\\n\\x08momentum\\x18\\x0b \\x01(\\x02\\x12\\x14\\n\\x0cweight_decay\\x18\\x0c \\x01(\\x02\\x12\\x1f\\n\\x13regularization_type\\x18\\x1d \\x01(\\t:\\x02L2\\x12\\x10\\n\\x08stepsize\\x18\\r \\x01(\\x05\\x12\\x11\\n\\tstepvalue\\x18\\"" \\x03(\\x05\\x12\\x1a\\n\\x0e\\x63lip_gradients\\x18# \\x01(\\x02:\\x02-1\\x12\\x13\\n\\x08snapshot\\x18\\x0e \\x01(\\x05:\\x01\\x30\\x12\\x17\\n\\x0fsnapshot_prefix\\x18\\x0f \\x01(\\t\\x12\\x1c\\n\\rsnapshot_diff\\x18\\x10 \\x01(\\x08:\\x05\\x66\\x61lse\\x12K\\n\\x0fsnapshot_format\\x18% \\x01(\\x0e\\x32%.caffe.SolverParameter.SnapshotFormat:\\x0b\\x42INARYPROTO\\x12;\\n\\x0bsolver_mode\\x18\\x11 \\x01(\\x0e\\x32!.caffe.SolverParameter.SolverMode:\\x03GPU\\x12\\x14\\n\\tdevice_id\\x18\\x12 \\x01(\\x05:\\x01\\x30\\x12\\x17\\n\\x0brandom_seed\\x18\\x14 \\x01(\\x03:\\x02-1\\x12\\x11\\n\\x04type\\x18( \\x01(\\t:\\x03SGD\\x12\\x14\\n\\x05\\x64\\x65lta\\x18\\x1f \\x01(\\x02:\\x05\\x31\\x65-08\\x12\\x18\\n\\tmomentum2\\x18\\\' \\x01(\\x02:\\x05\\x30.999\\x12\\x11\\n\\trms_decay\\x18& \\x01(\\x02\\x12\\x19\\n\\ndebug_info\\x18\\x17 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\""\\n\\x14snapshot_after_train\\x18\\x1c \\x01(\\x08:\\x04true\\x12;\\n\\x0bsolver_type\\x18\\x1e \\x01(\\x0e\\x32!.caffe.SolverParameter.SolverType:\\x03SGD\\""+\\n\\x0eSnapshotFormat\\x12\\x08\\n\\x04HDF5\\x10\\x00\\x12\\x0f\\n\\x0b\\x42INARYPROTO\\x10\\x01\\""\\x1e\\n\\nSolverMode\\x12\\x07\\n\\x03\\x43PU\\x10\\x00\\x12\\x07\\n\\x03GPU\\x10\\x01\\""U\\n\\nSolverType\\x12\\x07\\n\\x03SGD\\x10\\x00\\x12\\x0c\\n\\x08NESTEROV\\x10\\x01\\x12\\x0b\\n\\x07\\x41\\x44\\x41GRAD\\x10\\x02\\x12\\x0b\\n\\x07RMSPROP\\x10\\x03\\x12\\x0c\\n\\x08\\x41\\x44\\x41\\x44\\x45LTA\\x10\\x04\\x12\\x08\\n\\x04\\x41\\x44\\x41M\\x10\\x05\\""l\\n\\x0bSolverState\\x12\\x0c\\n\\x04iter\\x18\\x01 \\x01(\\x05\\x12\\x13\\n\\x0blearned_net\\x18\\x02 \\x01(\\t\\x12!\\n\\x07history\\x18\\x03 \\x03(\\x0b\\x32\\x10.caffe.BlobProto\\x12\\x17\\n\\x0c\\x63urrent_step\\x18\\x04 \\x01(\\x05:\\x01\\x30\\""N\\n\\x08NetState\\x12!\\n\\x05phase\\x18\\x01 \\x01(\\x0e\\x32\\x0c.caffe.Phase:\\x04TEST\\x12\\x10\\n\\x05level\\x18\\x02 \\x01(\\x05:\\x01\\x30\\x12\\r\\n\\x05stage\\x18\\x03 \\x03(\\t\\""s\\n\\x0cNetStateRule\\x12\\x1b\\n\\x05phase\\x18\\x01 \\x01(\\x0e\\x32\\x0c.caffe.Phase\\x12\\x11\\n\\tmin_level\\x18\\x02 \\x01(\\x05\\x12\\x11\\n\\tmax_level\\x18\\x03 \\x01(\\x05\\x12\\r\\n\\x05stage\\x18\\x04 \\x03(\\t\\x12\\x11\\n\\tnot_stage\\x18\\x05 \\x03(\\t\\""\\xa3\\x01\\n\\tParamSpec\\x12\\x0c\\n\\x04name\\x18\\x01 \\x01(\\t\\x12\\x31\\n\\nshare_mode\\x18\\x02 \\x01(\\x0e\\x32\\x1d.caffe.ParamSpec.DimCheckMode\\x12\\x12\\n\\x07lr_mult\\x18\\x03 \\x01(\\x02:\\x01\\x31\\x12\\x15\\n\\ndecay_mult\\x18\\x04 \\x01(\\x02:\\x01\\x31\\""*\\n\\x0c\\x44imCheckMode\\x12\\n\\n\\x06STRICT\\x10\\x00\\x12\\x0e\\n\\nPERMISSIVE\\x10\\x01\\""\\xde\\x18\\n\\x0eLayerParameter\\x12\\x0c\\n\\x04name\\x18\\x01 \\x01(\\t\\x12\\x0c\\n\\x04type\\x18\\x02 \\x01(\\t\\x12\\x0e\\n\\x06\\x62ottom\\x18\\x03 \\x03(\\t\\x12\\x0b\\n\\x03top\\x18\\x04 \\x03(\\t\\x12\\x1b\\n\\x05phase\\x18\\n \\x01(\\x0e\\x32\\x0c.caffe.Phase\\x12\\x13\\n\\x0bloss_weight\\x18\\x05 \\x03(\\x02\\x12\\x1f\\n\\x05param\\x18\\x06 \\x03(\\x0b\\x32\\x10.caffe.ParamSpec\\x12\\x1f\\n\\x05\\x62lobs\\x18\\x07 \\x03(\\x0b\\x32\\x10.caffe.BlobProto\\x12\\x16\\n\\x0epropagate_down\\x18\\x0b \\x03(\\x08\\x12$\\n\\x07include\\x18\\x08 \\x03(\\x0b\\x32\\x13.caffe.NetStateRule\\x12$\\n\\x07\\x65xclude\\x18\\t \\x03(\\x0b\\x32\\x13.caffe.NetStateRule\\x12\\x37\\n\\x0ftransform_param\\x18\\x64 \\x01(\\x0b\\x32\\x1e.caffe.TransformationParameter\\x12(\\n\\nloss_param\\x18\\x65 \\x01(\\x0b\\x32\\x14.caffe.LossParameter\\x12\\x30\\n\\x0e\\x61\\x63\\x63uracy_param\\x18\\x66 \\x01(\\x0b\\x32\\x18.caffe.AccuracyParameter\\x12,\\n\\x0c\\x61rgmax_param\\x18g \\x01(\\x0b\\x32\\x16.caffe.ArgMaxParameter\\x12\\x34\\n\\x10\\x62\\x61tch_norm_param\\x18\\x8b\\x01 \\x01(\\x0b\\x32\\x19.caffe.BatchNormParameter\\x12)\\n\\nbias_param\\x18\\x8d\\x01 \\x01(\\x0b\\x32\\x14.caffe.BiasParameter\\x12,\\n\\x0c\\x63oncat_param\\x18h \\x01(\\x0b\\x32\\x16.caffe.ConcatParameter\\x12?\\n\\x16\\x63ontrastive_loss_param\\x18i \\x01(\\x0b\\x32\\x1f.caffe.ContrastiveLossParameter\\x12\\x36\\n\\x11\\x63onvolution_param\\x18j \\x01(\\x0b\\x32\\x1b.caffe.ConvolutionParameter\\x12)\\n\\ncrop_param\\x18\\x90\\x01 \\x01(\\x0b\\x32\\x14.caffe.CropParameter\\x12(\\n\\ndata_param\\x18k \\x01(\\x0b\\x32\\x14.caffe.DataParameter\\x12.\\n\\rdropout_param\\x18l \\x01(\\x0b\\x32\\x17.caffe.DropoutParameter\\x12\\x33\\n\\x10\\x64ummy_data_param\\x18m \\x01(\\x0b\\x32\\x19.caffe.DummyDataParameter\\x12.\\n\\reltwise_param\\x18n \\x01(\\x0b\\x32\\x17.caffe.EltwiseParameter\\x12\\\'\\n\\telu_param\\x18\\x8c\\x01 \\x01(\\x0b\\x32\\x13.caffe.ELUParameter\\x12+\\n\\x0b\\x65mbed_param\\x18\\x89\\x01 \\x01(\\x0b\\x32\\x15.caffe.EmbedParameter\\x12&\\n\\texp_param\\x18o \\x01(\\x0b\\x32\\x13.caffe.ExpParameter\\x12-\\n\\x0c\\x65xpmax_param\\x18\\x9e\\x01 \\x01(\\x0b\\x32\\x16.caffe.ExpMaxParameter\\x12/\\n\\rflatten_param\\x18\\x87\\x01 \\x01(\\x0b\\x32\\x17.caffe.FlattenParameter\\x12\\x31\\n\\x0fhdf5_data_param\\x18p \\x01(\\x0b\\x32\\x18.caffe.HDF5DataParameter\\x12\\x35\\n\\x11hdf5_output_param\\x18q \\x01(\\x0b\\x32\\x1a.caffe.HDF5OutputParameter\\x12\\x33\\n\\x10hinge_loss_param\\x18r \\x01(\\x0b\\x32\\x19.caffe.HingeLossParameter\\x12\\x33\\n\\x10image_data_param\\x18s \\x01(\\x0b\\x32\\x19.caffe.ImageDataParameter\\x12\\x39\\n\\x13infogain_loss_param\\x18t \\x01(\\x0b\\x32\\x1c.caffe.InfogainLossParameter\\x12\\x39\\n\\x13inner_product_param\\x18u \\x01(\\x0b\\x32\\x1c.caffe.InnerProductParameter\\x12+\\n\\x0binput_param\\x18\\x8f\\x01 \\x01(\\x0b\\x32\\x15.caffe.InputParameter\\x12\\\'\\n\\tlog_param\\x18\\x86\\x01 \\x01(\\x0b\\x32\\x13.caffe.LogParameter\\x12&\\n\\tlrn_param\\x18v \\x01(\\x0b\\x32\\x13.caffe.LRNParameter\\x12\\x35\\n\\x11memory_data_param\\x18w \\x01(\\x0b\\x32\\x1a.caffe.MemoryDataParameter\\x12&\\n\\tmvn_param\\x18x \\x01(\\x0b\\x32\\x13.caffe.MVNParameter\\x12\\x33\\n\\x0fparameter_param\\x18\\x91\\x01 \\x01(\\x0b\\x32\\x19.caffe.ParameterParameter\\x12.\\n\\rpooling_param\\x18y \\x01(\\x0b\\x32\\x17.caffe.PoolingParameter\\x12*\\n\\x0bpower_param\\x18z \\x01(\\x0b\\x32\\x15.caffe.PowerParameter\\x12+\\n\\x0bprelu_param\\x18\\x83\\x01 \\x01(\\x0b\\x32\\x15.caffe.PReLUParameter\\x12-\\n\\x0cpython_param\\x18\\x82\\x01 \\x01(\\x0b\\x32\\x16.caffe.PythonParameter\\x12\\x33\\n\\x0frecurrent_param\\x18\\x92\\x01 \\x01(\\x0b\\x32\\x19.caffe.RecurrentParameter\\x12\\x33\\n\\x0freduction_param\\x18\\x88\\x01 \\x01(\\x0b\\x32\\x19.caffe.ReductionParameter\\x12(\\n\\nrelu_param\\x18{ \\x01(\\x0b\\x32\\x14.caffe.ReLUParameter\\x12/\\n\\rreshape_param\\x18\\x85\\x01 \\x01(\\x0b\\x32\\x17.caffe.ReshapeParameter\\x12+\\n\\x0bscale_param\\x18\\x8e\\x01 \\x01(\\x0b\\x32\\x15.caffe.ScaleParameter\\x12.\\n\\rsigmoid_param\\x18| \\x01(\\x0b\\x32\\x17.caffe.SigmoidParameter\\x12.\\n\\rsoftmax_param\\x18} \\x01(\\x0b\\x32\\x17.caffe.SoftmaxParameter\\x12\\\'\\n\\tspp_param\\x18\\x84\\x01 \\x01(\\x0b\\x32\\x13.caffe.SPPParameter\\x12*\\n\\x0bslice_param\\x18~ \\x01(\\x0b\\x32\\x15.caffe.SliceParameter\\x12(\\n\\ntanh_param\\x18\\x7f \\x01(\\x0b\\x32\\x14.caffe.TanHParameter\\x12\\x33\\n\\x0fthreshold_param\\x18\\x80\\x01 \\x01(\\x0b\\x32\\x19.caffe.ThresholdParameter\\x12)\\n\\ntile_param\\x18\\x8a\\x01 \\x01(\\x0b\\x32\\x14.caffe.TileParameter\\x12\\x36\\n\\x11window_data_param\\x18\\x81\\x01 \\x01(\\x0b\\x32\\x1a.caffe.WindowDataParameter\\x12<\\n\\x14\\x63oeff_schedule_param\\x18\\x94\\x01 \\x01(\\x0b\\x32\\x1d.caffe.CoeffScheduleParameter\\x12\\x39\\n\\x12\\x61ugmentation_param\\x18\\x95\\x01 \\x01(\\x0b\\x32\\x1c.caffe.AugmentationParameter\\x12\\x37\\n\\x11\\x63orrelation_param\\x18\\x96\\x01 \\x01(\\x0b\\x32\\x1b.caffe.CorrelationParameter\\x12.\\n\\rl1_loss_param\\x18\\x97\\x01 \\x01(\\x0b\\x32\\x16.caffe.L1LossParameter\\x12-\\n\\x0cwriter_param\\x18\\x98\\x01 \\x01(\\x0b\\x32\\x16.caffe.WriterParameter\\x12-\\n\\x0creader_param\\x18\\x99\\x01 \\x01(\\x0b\\x32\\x16.caffe.ReaderParameter\\x12)\\n\\nmean_param\\x18\\x9a\\x01 \\x01(\\x0b\\x32\\x14.caffe.MeanParameter\\x12\\x31\\n\\x0eresample_param\\x18\\x9b\\x01 \\x01(\\x0b\\x32\\x18.caffe.ResampleParameter\\x12\\x35\\n\\x10\\x64ownsample_param\\x18\\x9c\\x01 \\x01(\\x0b\\x32\\x1a.caffe.DownsampleParameter\\x12\\x33\\n\\x0fnegsquare_param\\x18\\x9f\\x01 \\x01(\\x0b\\x32\\x19.caffe.NegSquareParameter\\x12!\\n\\x12reshape_every_iter\\x18\\x9d\\x01 \\x01(\\x08:\\x04true\\""=\\n\\rGridParameter\\x12\\x0e\\n\\x06height\\x18\\x01 \\x01(\\r\\x12\\r\\n\\x05width\\x18\\x02 \\x01(\\r\\x12\\r\\n\\x05\\x62\\x61tch\\x18\\x03 \\x01(\\r\\""\\xde\\x07\\n\\x11\\x41ugmentationCoeff\\x12\\x11\\n\\x06mirror\\x18\\x01 \\x01(\\x02:\\x01\\x30\\x12\\r\\n\\x02\\x64x\\x18\\x02 \\x01(\\x02:\\x01\\x30\\x12\\r\\n\\x02\\x64y\\x18\\x03 \\x01(\\x02:\\x01\\x30\\x12\\x10\\n\\x05\\x61ngle\\x18\\x04 \\x01(\\x02:\\x01\\x30\\x12\\x11\\n\\x06zoom_x\\x18\\x05 \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\x06zoom_y\\x18\\x06 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x05gamma\\x18\\x64 \\x01(\\x02:\\x01\\x31\\x12\\x15\\n\\nbrightness\\x18\\x65 \\x01(\\x02:\\x01\\x30\\x12\\x13\\n\\x08\\x63ontrast\\x18\\x66 \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\x06\\x63olor1\\x18g \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\x06\\x63olor2\\x18h \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\x06\\x63olor3\\x18i \\x01(\\x02:\\x01\\x31\\x12\\x16\\n\\x0bpow_nomean0\\x18\\n \\x01(\\x02:\\x01\\x31\\x12\\x16\\n\\x0bpow_nomean1\\x18\\x0b \\x01(\\x02:\\x01\\x31\\x12\\x16\\n\\x0bpow_nomean2\\x18\\x0c \\x01(\\x02:\\x01\\x31\\x12\\x16\\n\\x0b\\x61\\x64\\x64_nomean0\\x18\\r \\x01(\\x02:\\x01\\x30\\x12\\x16\\n\\x0b\\x61\\x64\\x64_nomean1\\x18\\x0e \\x01(\\x02:\\x01\\x30\\x12\\x16\\n\\x0b\\x61\\x64\\x64_nomean2\\x18\\x0f \\x01(\\x02:\\x01\\x30\\x12\\x17\\n\\x0cmult_nomean0\\x18\\x10 \\x01(\\x02:\\x01\\x31\\x12\\x17\\n\\x0cmult_nomean1\\x18\\x11 \\x01(\\x02:\\x01\\x31\\x12\\x17\\n\\x0cmult_nomean2\\x18\\x12 \\x01(\\x02:\\x01\\x31\\x12\\x18\\n\\rpow_withmean0\\x18\\x13 \\x01(\\x02:\\x01\\x31\\x12\\x18\\n\\rpow_withmean1\\x18\\x14 \\x01(\\x02:\\x01\\x31\\x12\\x18\\n\\rpow_withmean2\\x18\\x15 \\x01(\\x02:\\x01\\x31\\x12\\x18\\n\\radd_withmean0\\x18\\x16 \\x01(\\x02:\\x01\\x30\\x12\\x18\\n\\radd_withmean1\\x18\\x17 \\x01(\\x02:\\x01\\x30\\x12\\x18\\n\\radd_withmean2\\x18\\x18 \\x01(\\x02:\\x01\\x30\\x12\\x19\\n\\x0emult_withmean0\\x18\\x19 \\x01(\\x02:\\x01\\x31\\x12\\x19\\n\\x0emult_withmean1\\x18\\x1a \\x01(\\x02:\\x01\\x31\\x12\\x19\\n\\x0emult_withmean2\\x18\\x1b \\x01(\\x02:\\x01\\x31\\x12\\x14\\n\\tlmult_pow\\x18\\x1c \\x01(\\x02:\\x01\\x31\\x12\\x14\\n\\tlmult_add\\x18\\x1d \\x01(\\x02:\\x01\\x30\\x12\\x15\\n\\nlmult_mult\\x18\\x1e \\x01(\\x02:\\x01\\x31\\x12\\x14\\n\\tcol_angle\\x18\\x1f \\x01(\\x02:\\x01\\x30\\x12\\x15\\n\\nfog_amount\\x18& \\x01(\\x02:\\x01\\x30\\x12\\x13\\n\\x08\\x66og_size\\x18\\\' \\x01(\\x02:\\x01\\x30\\x12\\x1c\\n\\x11motion_blur_angle\\x18( \\x01(\\x02:\\x01\\x30\\x12\\x1b\\n\\x10motion_blur_size\\x18) \\x01(\\x02:\\x01\\x30\\x12\\x17\\n\\x0cshadow_angle\\x18* \\x01(\\x02:\\x01\\x30\\x12\\x1a\\n\\x0fshadow_distance\\x18+ \\x01(\\x02:\\x01\\x30\\x12\\x1a\\n\\x0fshadow_strength\\x18, \\x01(\\x02:\\x01\\x30\\x12\\x10\\n\\x05noise\\x18- \\x01(\\x02:\\x01\\x30\\""\\xec\\x0f\\n\\x15\\x41ugmentationParameter\\x12\\x15\\n\\ncrop_width\\x18! \\x01(\\r:\\x01\\x30\\x12\\x16\\n\\x0b\\x63rop_height\\x18\\"" \\x01(\\r:\\x01\\x30\\x12\\x19\\n\\x0fwrite_augmented\\x18\\x02 \\x01(\\t:\\x00\\x12\\x1b\\n\\x0emax_multiplier\\x18\\x03 \\x01(\\x02:\\x03\\x32\\x35\\x35\\x12\\""\\n\\x13\\x61ugment_during_test\\x18\\x04 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x19\\n\\x0erecompute_mean\\x18\\x05 \\x01(\\r:\\x01\\x30\\x12\\x14\\n\\nwrite_mean\\x18\\x06 \\x01(\\t:\\x00\\x12\\x1c\\n\\x0emean_per_pixel\\x18\\x07 \\x01(\\x08:\\x04true\\x12\\x0c\\n\\x04mean\\x18\\x12 \\x03(\\x02\\x12\\x11\\n\\x04mode\\x18\\x08 \\x01(\\t:\\x03\\x61\\x64\\x64\\x12\\x16\\n\\x0b\\x62ottomwidth\\x18P \\x01(\\r:\\x01\\x30\\x12\\x17\\n\\x0c\\x62ottomheight\\x18Q \\x01(\\r:\\x01\\x30\\x12\\x0e\\n\\x03num\\x18R \\x01(\\r:\\x01\\x30\\x12\\x18\\n\\x10\\x63hromatic_eigvec\\x18S \\x03(\\x02\\x12/\\n\\x06mirror\\x18\\n \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x32\\n\\ttranslate\\x18\\x0b \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12/\\n\\x06rotate\\x18\\x0c \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12-\\n\\x04zoom\\x18\\r \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x30\\n\\x07squeeze\\x18\\x0e \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x34\\n\\x0btranslate_x\\x18\\x0f \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x34\\n\\x0btranslate_y\\x18\\x10 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12.\\n\\x05gamma\\x18# \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x33\\n\\nbrightness\\x18$ \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x31\\n\\x08\\x63ontrast\\x18% \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12.\\n\\x05\\x63olor\\x18& \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x32\\n\\tlmult_pow\\x18\\x14 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x33\\n\\nlmult_mult\\x18\\x15 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x32\\n\\tlmult_add\\x18\\x16 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x30\\n\\x07sat_pow\\x18\\x17 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x31\\n\\x08sat_mult\\x18\\x18 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x30\\n\\x07sat_add\\x18\\x19 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x30\\n\\x07\\x63ol_pow\\x18\\x1a \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x31\\n\\x08\\x63ol_mult\\x18\\x1b \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x30\\n\\x07\\x63ol_add\\x18\\x1c \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x31\\n\\x08ladd_pow\\x18\\x1d \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x32\\n\\tladd_mult\\x18\\x1e \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x31\\n\\x08ladd_add\\x18\\x1f \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x33\\n\\ncol_rotate\\x18  \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x33\\n\\nfog_amount\\x18\\x64 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x31\\n\\x08\\x66og_size\\x18\\x65 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12:\\n\\x11motion_blur_angle\\x18\\x66 \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x39\\n\\x10motion_blur_size\\x18g \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x35\\n\\x0cshadow_angle\\x18h \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x38\\n\\x0fshadow_distance\\x18i \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12\\x38\\n\\x0fshadow_strength\\x18j \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\x12.\\n\\x05noise\\x18k \\x01(\\x0b\\x32\\x1f.caffe.RandomGeneratorParameter\\""\\xcf\\x01\\n\\x18RandomGeneratorParameter\\x12\\x1a\\n\\trand_type\\x18\\x01 \\x01(\\t:\\x07uniform\\x12\\x12\\n\\x03\\x65xp\\x18\\x02 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x0f\\n\\x04mean\\x18\\x04 \\x01(\\x02:\\x01\\x30\\x12\\x11\\n\\x06spread\\x18\\x05 \\x01(\\x02:\\x01\\x30\\x12\\x0f\\n\\x04prob\\x18\\x06 \\x01(\\x02:\\x01\\x31\\x12\\x1c\\n\\x0e\\x61pply_schedule\\x18\\x07 \\x01(\\x08:\\x04true\\x12\\x19\\n\\ndiscretize\\x18\\x08 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x15\\n\\nmultiplier\\x18\\t \\x01(\\x02:\\x01\\x31\\""\\xc2\\x01\\n\\x0fL1LossParameter\\x12\\x1e\\n\\x0fl2_per_location\\x18\\x01 \\x01(\\x08:\\x05\\x66\\x61lse\\x12&\\n\\x17l2_prescale_by_channels\\x18\\x02 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\\'\\n\\x18normalize_by_num_entries\\x18\\x03 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x15\\n\\x07\\x65psilon\\x18\\x04 \\x01(\\x02:\\x04\\x30.01\\x12\\x13\\n\\x07plateau\\x18\\xb9\\x17 \\x01(\\x02:\\x01\\x30\\x12\\x12\\n\\x05power\\x18\\x05 \\x01(\\x02:\\x03\\x30.5\\""\\xb3\\x02\\n\\x14\\x43orrelationParameter\\x12\\x0e\\n\\x03pad\\x18\\x02 \\x01(\\r:\\x01\\x30\\x12\\x13\\n\\x0bkernel_size\\x18\\x03 \\x01(\\r\\x12\\x18\\n\\x10max_displacement\\x18\\x04 \\x01(\\r\\x12\\x13\\n\\x08stride_1\\x18\\x05 \\x01(\\r:\\x01\\x31\\x12\\x13\\n\\x08stride_2\\x18\\x06 \\x01(\\r:\\x01\\x31\\x12\\x1b\\n\\x10single_direction\\x18\\x08 \\x01(\\x05:\\x01\\x30\\x12\\x15\\n\\x06\\x64o_abs\\x18\\x07 \\x01(\\x08:\\x05\\x66\\x61lse\\x12O\\n\\x10\\x63orrelation_type\\x18\\x0f \\x01(\\x0e\\x32+.caffe.CorrelationParameter.CorrelationType:\\x08MULTIPLY\\""-\\n\\x0f\\x43orrelationType\\x12\\x0c\\n\\x08MULTIPLY\\x10\\x00\\x12\\x0c\\n\\x08SUBTRACT\\x10\\x01\\""B\\n\\x13\\x44ownsampleParameter\\x12\\x15\\n\\ntop_height\\x18\\x01 \\x01(\\r:\\x01\\x30\\x12\\x14\\n\\ttop_width\\x18\\x02 \\x01(\\r:\\x01\\x30\\""/\\n\\x0fReaderParameter\\x12\\x0c\\n\\x04\\x66ile\\x18\\x01 \\x02(\\t\\x12\\x0e\\n\\x03num\\x18\\x02 \\x01(\\r:\\x01\\x31\\""\\x83\\x01\\n\\x0fWriterParameter\\x12\\x0e\\n\\x04\\x66ile\\x18\\x01 \\x01(\\t:\\x00\\x12\\x10\\n\\x06\\x66older\\x18\\x02 \\x01(\\t:\\x00\\x12\\x10\\n\\x06prefix\\x18\\x03 \\x01(\\t:\\x00\\x12\\x10\\n\\x06suffix\\x18\\x04 \\x01(\\t:\\x00\\x12\\x18\\n\\tnormalize\\x18\\x05 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x10\\n\\x05scale\\x18\\x06 \\x01(\\x02:\\x01\\x31\\""\\xc6\\x01\\n\\x11ResampleParameter\\x12\\x17\\n\\tantialias\\x18\\x04 \\x01(\\x08:\\x04true\\x12\\r\\n\\x05width\\x18\\x01 \\x01(\\r\\x12\\x0e\\n\\x06height\\x18\\x02 \\x01(\\r\\x12;\\n\\x04type\\x18\\x03 \\x01(\\x0e\\x32%.caffe.ResampleParameter.ResampleType:\\x06LINEAR\\""<\\n\\x0cResampleType\\x12\\x0b\\n\\x07NEAREST\\x10\\x01\\x12\\n\\n\\x06LINEAR\\x10\\x02\\x12\\t\\n\\x05\\x43UBIC\\x10\\x03\\x12\\x08\\n\\x04\\x41REA\\x10\\x04\\""\\xd3\\x01\\n\\rMeanParameter\\x12\\x35\\n\\toperation\\x18\\x01 \\x02(\\x0e\\x32\\"".caffe.MeanParameter.MeanOperation\\x12\\x0c\\n\\x04\\x66ile\\x18\\x02 \\x01(\\t\\x12\\r\\n\\x05value\\x18\\x03 \\x03(\\x02\\x12\\x15\\n\\nmean_scale\\x18\\x04 \\x01(\\x02:\\x01\\x31\\x12\\x16\\n\\x0binput_scale\\x18\\x05 \\x01(\\x02:\\x01\\x31\\x12\\x17\\n\\x0coutput_scale\\x18\\x06 \\x01(\\x02:\\x01\\x31\\""&\\n\\rMeanOperation\\x12\\x07\\n\\x03\\x41\\x44\\x44\\x10\\x01\\x12\\x0c\\n\\x08SUBTRACT\\x10\\x04\\""`\\n\\x16\\x43oeffScheduleParameter\\x12\\x14\\n\\thalf_life\\x18\\x01 \\x01(\\x02:\\x01\\x31\\x12\\x18\\n\\rinitial_coeff\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x16\\n\\x0b\\x66inal_coeff\\x18\\x03 \\x01(\\x02:\\x01\\x31\\""\\xb6\\x01\\n\\x17TransformationParameter\\x12\\x10\\n\\x05scale\\x18\\x01 \\x01(\\x02:\\x01\\x31\\x12\\x15\\n\\x06mirror\\x18\\x02 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x14\\n\\tcrop_size\\x18\\x03 \\x01(\\r:\\x01\\x30\\x12\\x11\\n\\tmean_file\\x18\\x04 \\x01(\\t\\x12\\x12\\n\\nmean_value\\x18\\x05 \\x03(\\x02\\x12\\x1a\\n\\x0b\\x66orce_color\\x18\\x06 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x19\\n\\nforce_gray\\x18\\x07 \\x01(\\x08:\\x05\\x66\\x61lse\\""\\xc2\\x01\\n\\rLossParameter\\x12\\x14\\n\\x0cignore_label\\x18\\x01 \\x01(\\x05\\x12\\x44\\n\\rnormalization\\x18\\x03 \\x01(\\x0e\\x32&.caffe.LossParameter.NormalizationMode:\\x05VALID\\x12\\x11\\n\\tnormalize\\x18\\x02 \\x01(\\x08\\""B\\n\\x11NormalizationMode\\x12\\x08\\n\\x04\\x46ULL\\x10\\x00\\x12\\t\\n\\x05VALID\\x10\\x01\\x12\\x0e\\n\\nBATCH_SIZE\\x10\\x02\\x12\\x08\\n\\x04NONE\\x10\\x03\\""L\\n\\x11\\x41\\x63\\x63uracyParameter\\x12\\x10\\n\\x05top_k\\x18\\x01 \\x01(\\r:\\x01\\x31\\x12\\x0f\\n\\x04\\x61xis\\x18\\x02 \\x01(\\x05:\\x01\\x31\\x12\\x14\\n\\x0cignore_label\\x18\\x03 \\x01(\\x05\\""M\\n\\x0f\\x41rgMaxParameter\\x12\\x1a\\n\\x0bout_max_val\\x18\\x01 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x10\\n\\x05top_k\\x18\\x02 \\x01(\\r:\\x01\\x31\\x12\\x0c\\n\\x04\\x61xis\\x18\\x03 \\x01(\\x05\\""9\\n\\x0f\\x43oncatParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x02 \\x01(\\x05:\\x01\\x31\\x12\\x15\\n\\nconcat_dim\\x18\\x01 \\x01(\\r:\\x01\\x31\\""j\\n\\x12\\x42\\x61tchNormParameter\\x12\\x18\\n\\x10use_global_stats\\x18\\x01 \\x01(\\x08\\x12&\\n\\x17moving_average_fraction\\x18\\x02 \\x01(\\x02:\\x05\\x30.999\\x12\\x12\\n\\x03\\x65ps\\x18\\x03 \\x01(\\x02:\\x05\\x31\\x65-05\\""]\\n\\rBiasParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x01 \\x01(\\x05:\\x01\\x31\\x12\\x13\\n\\x08num_axes\\x18\\x02 \\x01(\\x05:\\x01\\x31\\x12&\\n\\x06\\x66iller\\x18\\x03 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\""L\\n\\x18\\x43ontrastiveLossParameter\\x12\\x11\\n\\x06margin\\x18\\x01 \\x01(\\x02:\\x01\\x31\\x12\\x1d\\n\\x0elegacy_version\\x18\\x02 \\x01(\\x08:\\x05\\x66\\x61lse\\""\\xfc\\x03\\n\\x14\\x43onvolutionParameter\\x12\\x12\\n\\nnum_output\\x18\\x01 \\x01(\\r\\x12\\x17\\n\\tbias_term\\x18\\x02 \\x01(\\x08:\\x04true\\x12\\x0b\\n\\x03pad\\x18\\x03 \\x03(\\r\\x12\\x13\\n\\x0bkernel_size\\x18\\x04 \\x03(\\r\\x12\\x0e\\n\\x06stride\\x18\\x06 \\x03(\\r\\x12\\x10\\n\\x08\\x64ilation\\x18\\x12 \\x03(\\r\\x12\\x10\\n\\x05pad_h\\x18\\t \\x01(\\r:\\x01\\x30\\x12\\x10\\n\\x05pad_w\\x18\\n \\x01(\\r:\\x01\\x30\\x12\\x10\\n\\x08kernel_h\\x18\\x0b \\x01(\\r\\x12\\x10\\n\\x08kernel_w\\x18\\x0c \\x01(\\r\\x12\\x10\\n\\x08stride_h\\x18\\r \\x01(\\r\\x12\\x10\\n\\x08stride_w\\x18\\x0e \\x01(\\r\\x12\\x10\\n\\x05group\\x18\\x05 \\x01(\\r:\\x01\\x31\\x12-\\n\\rweight_filler\\x18\\x07 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12+\\n\\x0b\\x62ias_filler\\x18\\x08 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12;\\n\\x06\\x65ngine\\x18\\x0f \\x01(\\x0e\\x32\\"".caffe.ConvolutionParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\x12\\x0f\\n\\x04\\x61xis\\x18\\x10 \\x01(\\x05:\\x01\\x31\\x12\\x1e\\n\\x0f\\x66orce_nd_im2col\\x18\\x11 \\x01(\\x08:\\x05\\x66\\x61lse\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""0\\n\\rCropParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x01 \\x01(\\x05:\\x01\\x32\\x12\\x0e\\n\\x06offset\\x18\\x02 \\x03(\\r\\""\\xc3\\x07\\n\\rDataParameter\\x12\\x0e\\n\\x06source\\x18\\x01 \\x01(\\t\\x12\\x15\\n\\nbatch_size\\x18\\x04 \\x01(\\r:\\x01\\x31\\x12\\x14\\n\\trand_skip\\x18\\x07 \\x01(\\r:\\x01\\x30\\x12\\x31\\n\\x07\\x62\\x61\\x63kend\\x18\\x08 \\x01(\\x0e\\x32\\x17.caffe.DataParameter.DB:\\x07LEVELDB\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\tmean_file\\x18\\x03 \\x01(\\t\\x12\\x14\\n\\tcrop_size\\x18\\x05 \\x01(\\r:\\x01\\x30\\x12\\x15\\n\\x06mirror\\x18\\x06 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\""\\n\\x13\\x66orce_encoded_color\\x18\\t \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x13\\n\\x08prefetch\\x18\\n \\x01(\\r:\\x01\\x34\\x12\\x1f\\n\\x13\\x64isk_reader_threads\\x18\\xa1\\x1f \\x01(\\r:\\x01\\x31\\x12\\""\\n\\x12huge_video_dataset\\x18\\xd8\\x36 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x1a\\n\\rlimit_samples\\x18\\xd9\\x36 \\x01(\\x05:\\x02-1\\x12\\x1a\\n\\x11preselection_file\\x18\\xb9\\x17 \\x01(\\t\\x12\\x1b\\n\\x12preselection_label\\x18\\xba\\x17 \\x01(\\x05\\x12\\x17\\n\\x0brange_start\\x18\\xbb\\x17 \\x01(\\x05:\\x01\\x30\\x12\\x16\\n\\trange_end\\x18\\xbc\\x17 \\x01(\\x05:\\x02-1\\x12\\x1c\\n\\x0crand_permute\\x18\\xbd\\x17 \\x01(\\x08:\\x05\\x66\\x61lse\\x12Y\\n\\x12rand_permute_order\\x18\\xbe\\x17 \\x01(\\x0e\\x32\\"".caffe.DataParameter.RANDPERMORDER:\\x18\\x46IRST_PERMUTE_THEN_RANGE\\x12\\x1d\\n\\x11rand_permute_seed\\x18\\xbf\\x17 \\x01(\\r:\\x01\\x30\\x12\\x14\\n\\x0bslice_point\\x18\\xc0\\x17 \\x03(\\r\\x12\\x37\\n\\x08\\x65ncoding\\x18\\xc1\\x17 \\x03(\\x0e\\x32$.caffe.DataParameter.CHANNELENCODING\\x12\\x17\\n\\x07verbose\\x18\\xc2\\x17 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x11\\n\\x08subtract\\x18\\xc3\\x17 \\x03(\\x02\\x12\\x1e\\n\\x12permute_every_iter\\x18\\xc4\\x17 \\x01(\\r:\\x01\\x30\\x12\\x16\\n\\nblock_size\\x18\\xc5\\x17 \\x01(\\r:\\x01\\x30\\""\\x1b\\n\\x02\\x44\\x42\\x12\\x0b\\n\\x07LEVELDB\\x10\\x00\\x12\\x08\\n\\x04LMDB\\x10\\x01\\""7\\n\\x0f\\x43HANNELENCODING\\x12\\t\\n\\x05UINT8\\x10\\x01\\x12\\x0e\\n\\nUINT16FLOW\\x10\\x02\\x12\\t\\n\\x05\\x42OOL1\\x10\\x03\\""K\\n\\rRANDPERMORDER\\x12\\x1c\\n\\x18\\x46IRST_PERMUTE_THEN_RANGE\\x10\\x00\\x12\\x1c\\n\\x18\\x46IRST_RANGE_THEN_PERMUTE\\x10\\x01\\"".\\n\\x10\\x44ropoutParameter\\x12\\x1a\\n\\rdropout_ratio\\x18\\x01 \\x01(\\x02:\\x03\\x30.5\\""\\xa0\\x01\\n\\x12\\x44ummyDataParameter\\x12+\\n\\x0b\\x64\\x61ta_filler\\x18\\x01 \\x03(\\x0b\\x32\\x16.caffe.FillerParameter\\x12\\x1f\\n\\x05shape\\x18\\x06 \\x03(\\x0b\\x32\\x10.caffe.BlobShape\\x12\\x0b\\n\\x03num\\x18\\x02 \\x03(\\r\\x12\\x10\\n\\x08\\x63hannels\\x18\\x03 \\x03(\\r\\x12\\x0e\\n\\x06height\\x18\\x04 \\x03(\\r\\x12\\r\\n\\x05width\\x18\\x05 \\x03(\\r\\""\\xa5\\x01\\n\\x10\\x45ltwiseParameter\\x12\\x39\\n\\toperation\\x18\\x01 \\x01(\\x0e\\x32!.caffe.EltwiseParameter.EltwiseOp:\\x03SUM\\x12\\r\\n\\x05\\x63oeff\\x18\\x02 \\x03(\\x02\\x12\\x1e\\n\\x10stable_prod_grad\\x18\\x03 \\x01(\\x08:\\x04true\\""\\\'\\n\\tEltwiseOp\\x12\\x08\\n\\x04PROD\\x10\\x00\\x12\\x07\\n\\x03SUM\\x10\\x01\\x12\\x07\\n\\x03MAX\\x10\\x02\\"" \\n\\x0c\\x45LUParameter\\x12\\x10\\n\\x05\\x61lpha\\x18\\x01 \\x01(\\x02:\\x01\\x31\\""\\xac\\x01\\n\\x0e\\x45mbedParameter\\x12\\x12\\n\\nnum_output\\x18\\x01 \\x01(\\r\\x12\\x11\\n\\tinput_dim\\x18\\x02 \\x01(\\r\\x12\\x17\\n\\tbias_term\\x18\\x03 \\x01(\\x08:\\x04true\\x12-\\n\\rweight_filler\\x18\\x04 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12+\\n\\x0b\\x62ias_filler\\x18\\x05 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\""D\\n\\x0c\\x45xpParameter\\x12\\x10\\n\\x04\\x62\\x61se\\x18\\x01 \\x01(\\x02:\\x02-1\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x05shift\\x18\\x03 \\x01(\\x02:\\x01\\x30\\""G\\n\\x0f\\x45xpMaxParameter\\x12\\x10\\n\\x04\\x62\\x61se\\x18\\x01 \\x01(\\x02:\\x02-1\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x05shift\\x18\\x03 \\x01(\\x02:\\x01\\x30\\""9\\n\\x10\\x46lattenParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x01 \\x01(\\x05:\\x01\\x31\\x12\\x14\\n\\x08\\x65nd_axis\\x18\\x02 \\x01(\\x05:\\x02-1\\""O\\n\\x11HDF5DataParameter\\x12\\x0e\\n\\x06source\\x18\\x01 \\x01(\\t\\x12\\x12\\n\\nbatch_size\\x18\\x02 \\x01(\\r\\x12\\x16\\n\\x07shuffle\\x18\\x03 \\x01(\\x08:\\x05\\x66\\x61lse\\""(\\n\\x13HDF5OutputParameter\\x12\\x11\\n\\tfile_name\\x18\\x01 \\x01(\\t\\""^\\n\\x12HingeLossParameter\\x12\\x30\\n\\x04norm\\x18\\x01 \\x01(\\x0e\\x32\\x1e.caffe.HingeLossParameter.Norm:\\x02L1\\""\\x16\\n\\x04Norm\\x12\\x06\\n\\x02L1\\x10\\x01\\x12\\x06\\n\\x02L2\\x10\\x02\\""\\x97\\x02\\n\\x12ImageDataParameter\\x12\\x0e\\n\\x06source\\x18\\x01 \\x01(\\t\\x12\\x15\\n\\nbatch_size\\x18\\x04 \\x01(\\r:\\x01\\x31\\x12\\x14\\n\\trand_skip\\x18\\x07 \\x01(\\r:\\x01\\x30\\x12\\x16\\n\\x07shuffle\\x18\\x08 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x15\\n\\nnew_height\\x18\\t \\x01(\\r:\\x01\\x30\\x12\\x14\\n\\tnew_width\\x18\\n \\x01(\\r:\\x01\\x30\\x12\\x16\\n\\x08is_color\\x18\\x0b \\x01(\\x08:\\x04true\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\tmean_file\\x18\\x03 \\x01(\\t\\x12\\x14\\n\\tcrop_size\\x18\\x05 \\x01(\\r:\\x01\\x30\\x12\\x15\\n\\x06mirror\\x18\\x06 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x15\\n\\x0broot_folder\\x18\\x0c \\x01(\\t:\\x00\\""\\\'\\n\\x15InfogainLossParameter\\x12\\x0e\\n\\x06source\\x18\\x01 \\x01(\\t\\""\\xcb\\x01\\n\\x15InnerProductParameter\\x12\\x12\\n\\nnum_output\\x18\\x01 \\x01(\\r\\x12\\x17\\n\\tbias_term\\x18\\x02 \\x01(\\x08:\\x04true\\x12-\\n\\rweight_filler\\x18\\x03 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12+\\n\\x0b\\x62ias_filler\\x18\\x04 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x05 \\x01(\\x05:\\x01\\x31\\x12\\x18\\n\\ttranspose\\x18\\x06 \\x01(\\x08:\\x05\\x66\\x61lse\\""1\\n\\x0eInputParameter\\x12\\x1f\\n\\x05shape\\x18\\x01 \\x03(\\x0b\\x32\\x10.caffe.BlobShape\\""D\\n\\x0cLogParameter\\x12\\x10\\n\\x04\\x62\\x61se\\x18\\x01 \\x01(\\x02:\\x02-1\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x05shift\\x18\\x03 \\x01(\\x02:\\x01\\x30\\""\\xca\\x02\\n\\x0cLRNParameter\\x12\\x15\\n\\nlocal_size\\x18\\x01 \\x01(\\r:\\x01\\x35\\x12\\x10\\n\\x05\\x61lpha\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x12\\n\\x04\\x62\\x65ta\\x18\\x03 \\x01(\\x02:\\x04\\x30.75\\x12\\x44\\n\\x0bnorm_region\\x18\\x04 \\x01(\\x0e\\x32\\x1e.caffe.LRNParameter.NormRegion:\\x0f\\x41\\x43ROSS_CHANNELS\\x12\\x0c\\n\\x01k\\x18\\x05 \\x01(\\x02:\\x01\\x31\\x12\\x33\\n\\x06\\x65ngine\\x18\\x06 \\x01(\\x0e\\x32\\x1a.caffe.LRNParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\x12\\x10\\n\\x05shift\\x18\\x07 \\x01(\\x02:\\x01\\x31\\""5\\n\\nNormRegion\\x12\\x13\\n\\x0f\\x41\\x43ROSS_CHANNELS\\x10\\x00\\x12\\x12\\n\\x0eWITHIN_CHANNEL\\x10\\x01\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""Z\\n\\x13MemoryDataParameter\\x12\\x12\\n\\nbatch_size\\x18\\x01 \\x01(\\r\\x12\\x10\\n\\x08\\x63hannels\\x18\\x02 \\x01(\\r\\x12\\x0e\\n\\x06height\\x18\\x03 \\x01(\\r\\x12\\r\\n\\x05width\\x18\\x04 \\x01(\\r\\""d\\n\\x0cMVNParameter\\x12 \\n\\x12normalize_variance\\x18\\x01 \\x01(\\x08:\\x04true\\x12\\x1e\\n\\x0f\\x61\\x63ross_channels\\x18\\x02 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x12\\n\\x03\\x65ps\\x18\\x03 \\x01(\\x02:\\x05\\x31\\x65-09\\""5\\n\\x12ParameterParameter\\x12\\x1f\\n\\x05shape\\x18\\x01 \\x01(\\x0b\\x32\\x10.caffe.BlobShape\\""\\xa2\\x03\\n\\x10PoolingParameter\\x12\\x35\\n\\x04pool\\x18\\x01 \\x01(\\x0e\\x32\\"".caffe.PoolingParameter.PoolMethod:\\x03MAX\\x12\\x0e\\n\\x03pad\\x18\\x04 \\x01(\\r:\\x01\\x30\\x12\\x10\\n\\x05pad_h\\x18\\t \\x01(\\r:\\x01\\x30\\x12\\x10\\n\\x05pad_w\\x18\\n \\x01(\\r:\\x01\\x30\\x12\\x13\\n\\x0bkernel_size\\x18\\x02 \\x01(\\r\\x12\\x10\\n\\x08kernel_h\\x18\\x05 \\x01(\\r\\x12\\x10\\n\\x08kernel_w\\x18\\x06 \\x01(\\r\\x12\\x11\\n\\x06stride\\x18\\x03 \\x01(\\r:\\x01\\x31\\x12\\x10\\n\\x08stride_h\\x18\\x07 \\x01(\\r\\x12\\x10\\n\\x08stride_w\\x18\\x08 \\x01(\\r\\x12\\x37\\n\\x06\\x65ngine\\x18\\x0b \\x01(\\x0e\\x32\\x1e.caffe.PoolingParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\x12\\x1d\\n\\x0eglobal_pooling\\x18\\x0c \\x01(\\x08:\\x05\\x66\\x61lse\\"".\\n\\nPoolMethod\\x12\\x07\\n\\x03MAX\\x10\\x00\\x12\\x07\\n\\x03\\x41VE\\x10\\x01\\x12\\x0e\\n\\nSTOCHASTIC\\x10\\x02\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""F\\n\\x0ePowerParameter\\x12\\x10\\n\\x05power\\x18\\x01 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x05shift\\x18\\x03 \\x01(\\x02:\\x01\\x30\\""\\x14\\n\\x12NegSquareParameter\\""g\\n\\x0fPythonParameter\\x12\\x0e\\n\\x06module\\x18\\x01 \\x01(\\t\\x12\\r\\n\\x05layer\\x18\\x02 \\x01(\\t\\x12\\x13\\n\\tparam_str\\x18\\x03 \\x01(\\t:\\x00\\x12 \\n\\x11share_in_parallel\\x18\\x04 \\x01(\\x08:\\x05\\x66\\x61lse\\""\\xc0\\x01\\n\\x12RecurrentParameter\\x12\\x15\\n\\nnum_output\\x18\\x01 \\x01(\\r:\\x01\\x30\\x12-\\n\\rweight_filler\\x18\\x02 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12+\\n\\x0b\\x62ias_filler\\x18\\x03 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12\\x19\\n\\ndebug_info\\x18\\x04 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x1c\\n\\rexpose_hidden\\x18\\x05 \\x01(\\x08:\\x05\\x66\\x61lse\\""\\xad\\x01\\n\\x12ReductionParameter\\x12=\\n\\toperation\\x18\\x01 \\x01(\\x0e\\x32%.caffe.ReductionParameter.ReductionOp:\\x03SUM\\x12\\x0f\\n\\x04\\x61xis\\x18\\x02 \\x01(\\x05:\\x01\\x30\\x12\\x10\\n\\x05\\x63oeff\\x18\\x03 \\x01(\\x02:\\x01\\x31\\""5\\n\\x0bReductionOp\\x12\\x07\\n\\x03SUM\\x10\\x01\\x12\\x08\\n\\x04\\x41SUM\\x10\\x02\\x12\\t\\n\\x05SUMSQ\\x10\\x03\\x12\\x08\\n\\x04MEAN\\x10\\x04\\""\\x8d\\x01\\n\\rReLUParameter\\x12\\x19\\n\\x0enegative_slope\\x18\\x01 \\x01(\\x02:\\x01\\x30\\x12\\x34\\n\\x06\\x65ngine\\x18\\x02 \\x01(\\x0e\\x32\\x1b.caffe.ReLUParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""Z\\n\\x10ReshapeParameter\\x12\\x1f\\n\\x05shape\\x18\\x01 \\x01(\\x0b\\x32\\x10.caffe.BlobShape\\x12\\x0f\\n\\x04\\x61xis\\x18\\x02 \\x01(\\x05:\\x01\\x30\\x12\\x14\\n\\x08num_axes\\x18\\x03 \\x01(\\x05:\\x02-1\\""\\xa5\\x01\\n\\x0eScaleParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x01 \\x01(\\x05:\\x01\\x31\\x12\\x13\\n\\x08num_axes\\x18\\x02 \\x01(\\x05:\\x01\\x31\\x12&\\n\\x06\\x66iller\\x18\\x03 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12\\x18\\n\\tbias_term\\x18\\x04 \\x01(\\x08:\\x05\\x66\\x61lse\\x12+\\n\\x0b\\x62ias_filler\\x18\\x05 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\""x\\n\\x10SigmoidParameter\\x12\\x37\\n\\x06\\x65ngine\\x18\\x01 \\x01(\\x0e\\x32\\x1e.caffe.SigmoidParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""L\\n\\x0eSliceParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x03 \\x01(\\x05:\\x01\\x31\\x12\\x13\\n\\x0bslice_point\\x18\\x02 \\x03(\\r\\x12\\x14\\n\\tslice_dim\\x18\\x01 \\x01(\\r:\\x01\\x31\\""\\x89\\x01\\n\\x10SoftmaxParameter\\x12\\x37\\n\\x06\\x65ngine\\x18\\x01 \\x01(\\x0e\\x32\\x1e.caffe.SoftmaxParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\x12\\x0f\\n\\x04\\x61xis\\x18\\x02 \\x01(\\x05:\\x01\\x31\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""r\\n\\rTanHParameter\\x12\\x34\\n\\x06\\x65ngine\\x18\\x01 \\x01(\\x0e\\x32\\x1b.caffe.TanHParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""/\\n\\rTileParameter\\x12\\x0f\\n\\x04\\x61xis\\x18\\x01 \\x01(\\x05:\\x01\\x31\\x12\\r\\n\\x05tiles\\x18\\x02 \\x01(\\x05\\""*\\n\\x12ThresholdParameter\\x12\\x14\\n\\tthreshold\\x18\\x01 \\x01(\\x02:\\x01\\x30\\""\\xc1\\x02\\n\\x13WindowDataParameter\\x12\\x0e\\n\\x06source\\x18\\x01 \\x01(\\t\\x12\\x10\\n\\x05scale\\x18\\x02 \\x01(\\x02:\\x01\\x31\\x12\\x11\\n\\tmean_file\\x18\\x03 \\x01(\\t\\x12\\x12\\n\\nbatch_size\\x18\\x04 \\x01(\\r\\x12\\x14\\n\\tcrop_size\\x18\\x05 \\x01(\\r:\\x01\\x30\\x12\\x15\\n\\x06mirror\\x18\\x06 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x19\\n\\x0c\\x66g_threshold\\x18\\x07 \\x01(\\x02:\\x03\\x30.5\\x12\\x19\\n\\x0c\\x62g_threshold\\x18\\x08 \\x01(\\x02:\\x03\\x30.5\\x12\\x19\\n\\x0b\\x66g_fraction\\x18\\t \\x01(\\x02:\\x04\\x30.25\\x12\\x16\\n\\x0b\\x63ontext_pad\\x18\\n \\x01(\\r:\\x01\\x30\\x12\\x17\\n\\tcrop_mode\\x18\\x0b \\x01(\\t:\\x04warp\\x12\\x1b\\n\\x0c\\x63\\x61\\x63he_images\\x18\\x0c \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x15\\n\\x0broot_folder\\x18\\r \\x01(\\t:\\x00\\""\\xeb\\x01\\n\\x0cSPPParameter\\x12\\x16\\n\\x0epyramid_height\\x18\\x01 \\x01(\\r\\x12\\x31\\n\\x04pool\\x18\\x02 \\x01(\\x0e\\x32\\x1e.caffe.SPPParameter.PoolMethod:\\x03MAX\\x12\\x33\\n\\x06\\x65ngine\\x18\\x06 \\x01(\\x0e\\x32\\x1a.caffe.SPPParameter.Engine:\\x07\\x44\\x45\\x46\\x41ULT\\"".\\n\\nPoolMethod\\x12\\x07\\n\\x03MAX\\x10\\x00\\x12\\x07\\n\\x03\\x41VE\\x10\\x01\\x12\\x0e\\n\\nSTOCHASTIC\\x10\\x02\\""+\\n\\x06\\x45ngine\\x12\\x0b\\n\\x07\\x44\\x45\\x46\\x41ULT\\x10\\x00\\x12\\t\\n\\x05\\x43\\x41\\x46\\x46\\x45\\x10\\x01\\x12\\t\\n\\x05\\x43UDNN\\x10\\x02\\""\\xe0\\x13\\n\\x10V1LayerParameter\\x12\\x0e\\n\\x06\\x62ottom\\x18\\x02 \\x03(\\t\\x12\\x0b\\n\\x03top\\x18\\x03 \\x03(\\t\\x12\\x0c\\n\\x04name\\x18\\x04 \\x01(\\t\\x12$\\n\\x07include\\x18  \\x03(\\x0b\\x32\\x13.caffe.NetStateRule\\x12$\\n\\x07\\x65xclude\\x18! \\x03(\\x0b\\x32\\x13.caffe.NetStateRule\\x12/\\n\\x04type\\x18\\x05 \\x01(\\x0e\\x32!.caffe.V1LayerParameter.LayerType\\x12\\x1f\\n\\x05\\x62lobs\\x18\\x06 \\x03(\\x0b\\x32\\x10.caffe.BlobProto\\x12\\x0e\\n\\x05param\\x18\\xe9\\x07 \\x03(\\t\\x12>\\n\\x0f\\x62lob_share_mode\\x18\\xea\\x07 \\x03(\\x0e\\x32$.caffe.V1LayerParameter.DimCheckMode\\x12\\x10\\n\\x08\\x62lobs_lr\\x18\\x07 \\x03(\\x02\\x12\\x14\\n\\x0cweight_decay\\x18\\x08 \\x03(\\x02\\x12\\x13\\n\\x0bloss_weight\\x18# \\x03(\\x02\\x12\\x30\\n\\x0e\\x61\\x63\\x63uracy_param\\x18\\x1b \\x01(\\x0b\\x32\\x18.caffe.AccuracyParameter\\x12,\\n\\x0c\\x61rgmax_param\\x18\\x17 \\x01(\\x0b\\x32\\x16.caffe.ArgMaxParameter\\x12,\\n\\x0c\\x63oncat_param\\x18\\t \\x01(\\x0b\\x32\\x16.caffe.ConcatParameter\\x12?\\n\\x16\\x63ontrastive_loss_param\\x18( \\x01(\\x0b\\x32\\x1f.caffe.ContrastiveLossParameter\\x12\\x36\\n\\x11\\x63onvolution_param\\x18\\n \\x01(\\x0b\\x32\\x1b.caffe.ConvolutionParameter\\x12(\\n\\ndata_param\\x18\\x0b \\x01(\\x0b\\x32\\x14.caffe.DataParameter\\x12.\\n\\rdropout_param\\x18\\x0c \\x01(\\x0b\\x32\\x17.caffe.DropoutParameter\\x12\\x33\\n\\x10\\x64ummy_data_param\\x18\\x1a \\x01(\\x0b\\x32\\x19.caffe.DummyDataParameter\\x12.\\n\\reltwise_param\\x18\\x18 \\x01(\\x0b\\x32\\x17.caffe.EltwiseParameter\\x12&\\n\\texp_param\\x18) \\x01(\\x0b\\x32\\x13.caffe.ExpParameter\\x12\\x31\\n\\x0fhdf5_data_param\\x18\\r \\x01(\\x0b\\x32\\x18.caffe.HDF5DataParameter\\x12\\x35\\n\\x11hdf5_output_param\\x18\\x0e \\x01(\\x0b\\x32\\x1a.caffe.HDF5OutputParameter\\x12\\x33\\n\\x10hinge_loss_param\\x18\\x1d \\x01(\\x0b\\x32\\x19.caffe.HingeLossParameter\\x12\\x33\\n\\x10image_data_param\\x18\\x0f \\x01(\\x0b\\x32\\x19.caffe.ImageDataParameter\\x12\\x39\\n\\x13infogain_loss_param\\x18\\x10 \\x01(\\x0b\\x32\\x1c.caffe.InfogainLossParameter\\x12\\x39\\n\\x13inner_product_param\\x18\\x11 \\x01(\\x0b\\x32\\x1c.caffe.InnerProductParameter\\x12&\\n\\tlrn_param\\x18\\x12 \\x01(\\x0b\\x32\\x13.caffe.LRNParameter\\x12\\x35\\n\\x11memory_data_param\\x18\\x16 \\x01(\\x0b\\x32\\x1a.caffe.MemoryDataParameter\\x12&\\n\\tmvn_param\\x18\\"" \\x01(\\x0b\\x32\\x13.caffe.MVNParameter\\x12.\\n\\rpooling_param\\x18\\x13 \\x01(\\x0b\\x32\\x17.caffe.PoolingParameter\\x12*\\n\\x0bpower_param\\x18\\x15 \\x01(\\x0b\\x32\\x15.caffe.PowerParameter\\x12(\\n\\nrelu_param\\x18\\x1e \\x01(\\x0b\\x32\\x14.caffe.ReLUParameter\\x12.\\n\\rsigmoid_param\\x18& \\x01(\\x0b\\x32\\x17.caffe.SigmoidParameter\\x12.\\n\\rsoftmax_param\\x18\\\' \\x01(\\x0b\\x32\\x17.caffe.SoftmaxParameter\\x12*\\n\\x0bslice_param\\x18\\x1f \\x01(\\x0b\\x32\\x15.caffe.SliceParameter\\x12(\\n\\ntanh_param\\x18% \\x01(\\x0b\\x32\\x14.caffe.TanHParameter\\x12\\x32\\n\\x0fthreshold_param\\x18\\x19 \\x01(\\x0b\\x32\\x19.caffe.ThresholdParameter\\x12\\x35\\n\\x11window_data_param\\x18\\x14 \\x01(\\x0b\\x32\\x1a.caffe.WindowDataParameter\\x12\\x37\\n\\x0ftransform_param\\x18$ \\x01(\\x0b\\x32\\x1e.caffe.TransformationParameter\\x12(\\n\\nloss_param\\x18* \\x01(\\x0b\\x32\\x14.caffe.LossParameter\\x12&\\n\\x05layer\\x18\\x01 \\x01(\\x0b\\x32\\x17.caffe.V0LayerParameter\\""\\xd8\\x04\\n\\tLayerType\\x12\\x08\\n\\x04NONE\\x10\\x00\\x12\\n\\n\\x06\\x41\\x42SVAL\\x10#\\x12\\x0c\\n\\x08\\x41\\x43\\x43URACY\\x10\\x01\\x12\\n\\n\\x06\\x41RGMAX\\x10\\x1e\\x12\\x08\\n\\x04\\x42NLL\\x10\\x02\\x12\\n\\n\\x06\\x43ONCAT\\x10\\x03\\x12\\x14\\n\\x10\\x43ONTRASTIVE_LOSS\\x10%\\x12\\x0f\\n\\x0b\\x43ONVOLUTION\\x10\\x04\\x12\\x08\\n\\x04\\x44\\x41TA\\x10\\x05\\x12\\x11\\n\\rDECONVOLUTION\\x10\\\'\\x12\\x0b\\n\\x07\\x44ROPOUT\\x10\\x06\\x12\\x0e\\n\\nDUMMY_DATA\\x10 \\x12\\x12\\n\\x0e\\x45UCLIDEAN_LOSS\\x10\\x07\\x12\\x0b\\n\\x07\\x45LTWISE\\x10\\x19\\x12\\x07\\n\\x03\\x45XP\\x10&\\x12\\x0b\\n\\x07\\x46LATTEN\\x10\\x08\\x12\\r\\n\\tHDF5_DATA\\x10\\t\\x12\\x0f\\n\\x0bHDF5_OUTPUT\\x10\\n\\x12\\x0e\\n\\nHINGE_LOSS\\x10\\x1c\\x12\\n\\n\\x06IM2COL\\x10\\x0b\\x12\\x0e\\n\\nIMAGE_DATA\\x10\\x0c\\x12\\x11\\n\\rINFOGAIN_LOSS\\x10\\r\\x12\\x11\\n\\rINNER_PRODUCT\\x10\\x0e\\x12\\x07\\n\\x03LRN\\x10\\x0f\\x12\\x0f\\n\\x0bMEMORY_DATA\\x10\\x1d\\x12\\x1d\\n\\x19MULTINOMIAL_LOGISTIC_LOSS\\x10\\x10\\x12\\x07\\n\\x03MVN\\x10\\""\\x12\\x0b\\n\\x07POOLING\\x10\\x11\\x12\\t\\n\\x05POWER\\x10\\x1a\\x12\\x08\\n\\x04RELU\\x10\\x12\\x12\\x0b\\n\\x07SIGMOID\\x10\\x13\\x12\\x1e\\n\\x1aSIGMOID_CROSS_ENTROPY_LOSS\\x10\\x1b\\x12\\x0b\\n\\x07SILENCE\\x10$\\x12\\x0b\\n\\x07SOFTMAX\\x10\\x14\\x12\\x10\\n\\x0cSOFTMAX_LOSS\\x10\\x15\\x12\\t\\n\\x05SPLIT\\x10\\x16\\x12\\t\\n\\x05SLICE\\x10!\\x12\\x08\\n\\x04TANH\\x10\\x17\\x12\\x0f\\n\\x0bWINDOW_DATA\\x10\\x18\\x12\\r\\n\\tTHRESHOLD\\x10\\x1f\\""*\\n\\x0c\\x44imCheckMode\\x12\\n\\n\\x06STRICT\\x10\\x00\\x12\\x0e\\n\\nPERMISSIVE\\x10\\x01\\""\\xfd\\x07\\n\\x10V0LayerParameter\\x12\\x0c\\n\\x04name\\x18\\x01 \\x01(\\t\\x12\\x0c\\n\\x04type\\x18\\x02 \\x01(\\t\\x12\\x12\\n\\nnum_output\\x18\\x03 \\x01(\\r\\x12\\x16\\n\\x08\\x62iasterm\\x18\\x04 \\x01(\\x08:\\x04true\\x12-\\n\\rweight_filler\\x18\\x05 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12+\\n\\x0b\\x62ias_filler\\x18\\x06 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12\\x0e\\n\\x03pad\\x18\\x07 \\x01(\\r:\\x01\\x30\\x12\\x12\\n\\nkernelsize\\x18\\x08 \\x01(\\r\\x12\\x10\\n\\x05group\\x18\\t \\x01(\\r:\\x01\\x31\\x12\\x11\\n\\x06stride\\x18\\n \\x01(\\r:\\x01\\x31\\x12\\x35\\n\\x04pool\\x18\\x0b \\x01(\\x0e\\x32\\"".caffe.V0LayerParameter.PoolMethod:\\x03MAX\\x12\\x1a\\n\\rdropout_ratio\\x18\\x0c \\x01(\\x02:\\x03\\x30.5\\x12\\x15\\n\\nlocal_size\\x18\\r \\x01(\\r:\\x01\\x35\\x12\\x10\\n\\x05\\x61lpha\\x18\\x0e \\x01(\\x02:\\x01\\x31\\x12\\x12\\n\\x04\\x62\\x65ta\\x18\\x0f \\x01(\\x02:\\x04\\x30.75\\x12\\x0c\\n\\x01k\\x18\\x16 \\x01(\\x02:\\x01\\x31\\x12\\x0e\\n\\x06source\\x18\\x10 \\x01(\\t\\x12\\x10\\n\\x05scale\\x18\\x11 \\x01(\\x02:\\x01\\x31\\x12\\x10\\n\\x08meanfile\\x18\\x12 \\x01(\\t\\x12\\x11\\n\\tbatchsize\\x18\\x13 \\x01(\\r\\x12\\x13\\n\\x08\\x63ropsize\\x18\\x14 \\x01(\\r:\\x01\\x30\\x12\\x15\\n\\x06mirror\\x18\\x15 \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x1f\\n\\x05\\x62lobs\\x18\\x32 \\x03(\\x0b\\x32\\x10.caffe.BlobProto\\x12\\x10\\n\\x08\\x62lobs_lr\\x18\\x33 \\x03(\\x02\\x12\\x14\\n\\x0cweight_decay\\x18\\x34 \\x03(\\x02\\x12\\x14\\n\\trand_skip\\x18\\x35 \\x01(\\r:\\x01\\x30\\x12\\x1d\\n\\x10\\x64\\x65t_fg_threshold\\x18\\x36 \\x01(\\x02:\\x03\\x30.5\\x12\\x1d\\n\\x10\\x64\\x65t_bg_threshold\\x18\\x37 \\x01(\\x02:\\x03\\x30.5\\x12\\x1d\\n\\x0f\\x64\\x65t_fg_fraction\\x18\\x38 \\x01(\\x02:\\x04\\x30.25\\x12\\x1a\\n\\x0f\\x64\\x65t_context_pad\\x18: \\x01(\\r:\\x01\\x30\\x12\\x1b\\n\\rdet_crop_mode\\x18; \\x01(\\t:\\x04warp\\x12\\x12\\n\\x07new_num\\x18< \\x01(\\x05:\\x01\\x30\\x12\\x17\\n\\x0cnew_channels\\x18= \\x01(\\x05:\\x01\\x30\\x12\\x15\\n\\nnew_height\\x18> \\x01(\\x05:\\x01\\x30\\x12\\x14\\n\\tnew_width\\x18? \\x01(\\x05:\\x01\\x30\\x12\\x1d\\n\\x0eshuffle_images\\x18@ \\x01(\\x08:\\x05\\x66\\x61lse\\x12\\x15\\n\\nconcat_dim\\x18\\x41 \\x01(\\r:\\x01\\x31\\x12\\x36\\n\\x11hdf5_output_param\\x18\\xe9\\x07 \\x01(\\x0b\\x32\\x1a.caffe.HDF5OutputParameter\\"".\\n\\nPoolMethod\\x12\\x07\\n\\x03MAX\\x10\\x00\\x12\\x07\\n\\x03\\x41VE\\x10\\x01\\x12\\x0e\\n\\nSTOCHASTIC\\x10\\x02\\""W\\n\\x0ePReLUParameter\\x12&\\n\\x06\\x66iller\\x18\\x01 \\x01(\\x0b\\x32\\x16.caffe.FillerParameter\\x12\\x1d\\n\\x0e\\x63hannel_shared\\x18\\x02 \\x01(\\x08:\\x05\\x66\\x61lse*\\x1c\\n\\x05Phase\\x12\\t\\n\\x05TRAIN\\x10\\x00\\x12\\x08\\n\\x04TEST\\x10\\x01\')\n\n_PHASE = _descriptor.EnumDescriptor(\n  name=\'Phase\',\n  full_name=\'caffe.Phase\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'TRAIN\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'TEST\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=21335,\n  serialized_end=21363,\n)\n\nPhase = enum_type_wrapper.EnumTypeWrapper(_PHASE)\nTRAIN = 0\nTEST = 1\n\n\n_FILLERPARAMETER_VARIANCENORM = _descriptor.EnumDescriptor(\n  name=\'VarianceNorm\',\n  full_name=\'caffe.FillerParameter.VarianceNorm\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'FAN_IN\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'FAN_OUT\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'AVERAGE\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=690,\n  serialized_end=742,\n)\n\n_SOLVERPARAMETER_SNAPSHOTFORMAT = _descriptor.EnumDescriptor(\n  name=\'SnapshotFormat\',\n  full_name=\'caffe.SolverParameter.SnapshotFormat\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'HDF5\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'BINARYPROTO\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=2164,\n  serialized_end=2207,\n)\n\n_SOLVERPARAMETER_SOLVERMODE = _descriptor.EnumDescriptor(\n  name=\'SolverMode\',\n  full_name=\'caffe.SolverParameter.SolverMode\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'CPU\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'GPU\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=2209,\n  serialized_end=2239,\n)\n\n_SOLVERPARAMETER_SOLVERTYPE = _descriptor.EnumDescriptor(\n  name=\'SolverType\',\n  full_name=\'caffe.SolverParameter.SolverType\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'SGD\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'NESTEROV\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ADAGRAD\', index=2, number=2,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'RMSPROP\', index=3, number=3,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ADADELTA\', index=4, number=4,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ADAM\', index=5, number=5,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=2241,\n  serialized_end=2326,\n)\n\n_PARAMSPEC_DIMCHECKMODE = _descriptor.EnumDescriptor(\n  name=\'DimCheckMode\',\n  full_name=\'caffe.ParamSpec.DimCheckMode\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'STRICT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'PERMISSIVE\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=2757,\n  serialized_end=2799,\n)\n\n_CORRELATIONPARAMETER_CORRELATIONTYPE = _descriptor.EnumDescriptor(\n  name=\'CorrelationType\',\n  full_name=\'caffe.CorrelationParameter.CorrelationType\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'MULTIPLY\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SUBTRACT\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=9727,\n  serialized_end=9772,\n)\n\n_RESAMPLEPARAMETER_RESAMPLETYPE = _descriptor.EnumDescriptor(\n  name=\'ResampleType\',\n  full_name=\'caffe.ResampleParameter.ResampleType\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'NEAREST\', index=0, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'LINEAR\', index=1, number=2,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUBIC\', index=2, number=3,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'AREA\', index=3, number=4,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=10164,\n  serialized_end=10224,\n)\n\n_MEANPARAMETER_MEANOPERATION = _descriptor.EnumDescriptor(\n  name=\'MeanOperation\',\n  full_name=\'caffe.MeanParameter.MeanOperation\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'ADD\', index=0, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SUBTRACT\', index=1, number=4,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=10400,\n  serialized_end=10438,\n)\n\n_LOSSPARAMETER_NORMALIZATIONMODE = _descriptor.EnumDescriptor(\n  name=\'NormalizationMode\',\n  full_name=\'caffe.LossParameter.NormalizationMode\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'FULL\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'VALID\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'BATCH_SIZE\', index=2, number=2,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'NONE\', index=3, number=3,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=10852,\n  serialized_end=10918,\n)\n\n_CONVOLUTIONPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.ConvolutionParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_DATAPARAMETER_DB = _descriptor.EnumDescriptor(\n  name=\'DB\',\n  full_name=\'caffe.DataParameter.DB\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'LEVELDB\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'LMDB\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=12781,\n  serialized_end=12808,\n)\n\n_DATAPARAMETER_CHANNELENCODING = _descriptor.EnumDescriptor(\n  name=\'CHANNELENCODING\',\n  full_name=\'caffe.DataParameter.CHANNELENCODING\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'UINT8\', index=0, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'UINT16FLOW\', index=1, number=2,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'BOOL1\', index=2, number=3,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=12810,\n  serialized_end=12865,\n)\n\n_DATAPARAMETER_RANDPERMORDER = _descriptor.EnumDescriptor(\n  name=\'RANDPERMORDER\',\n  full_name=\'caffe.DataParameter.RANDPERMORDER\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'FIRST_PERMUTE_THEN_RANGE\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'FIRST_RANGE_THEN_PERMUTE\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=12867,\n  serialized_end=12942,\n)\n\n_ELTWISEPARAMETER_ELTWISEOP = _descriptor.EnumDescriptor(\n  name=\'EltwiseOp\',\n  full_name=\'caffe.EltwiseParameter.EltwiseOp\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'PROD\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SUM\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'MAX\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=13282,\n  serialized_end=13321,\n)\n\n_HINGELOSSPARAMETER_NORM = _descriptor.EnumDescriptor(\n  name=\'Norm\',\n  full_name=\'caffe.HingeLossParameter.Norm\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'L1\', index=0, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'L2\', index=1, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=13929,\n  serialized_end=13951,\n)\n\n_LRNPARAMETER_NORMREGION = _descriptor.EnumDescriptor(\n  name=\'NormRegion\',\n  full_name=\'caffe.LRNParameter.NormRegion\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'ACROSS_CHANNELS\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'WITHIN_CHANNEL\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=14836,\n  serialized_end=14889,\n)\n\n_LRNPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.LRNParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_POOLINGPARAMETER_POOLMETHOD = _descriptor.EnumDescriptor(\n  name=\'PoolMethod\',\n  full_name=\'caffe.PoolingParameter.PoolMethod\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'MAX\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'AVE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'STOCHASTIC\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=15513,\n  serialized_end=15559,\n)\n\n_POOLINGPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.PoolingParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_REDUCTIONPARAMETER_REDUCTIONOP = _descriptor.EnumDescriptor(\n  name=\'ReductionOp\',\n  full_name=\'caffe.ReductionParameter.ReductionOp\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'SUM\', index=0, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ASUM\', index=1, number=2,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SUMSQ\', index=2, number=3,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'MEAN\', index=3, number=4,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=16121,\n  serialized_end=16174,\n)\n\n_RELUPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.ReLUParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_SIGMOIDPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.SigmoidParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_SOFTMAXPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.SoftmaxParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_TANHPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.TanHParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_SPPPARAMETER_POOLMETHOD = _descriptor.EnumDescriptor(\n  name=\'PoolMethod\',\n  full_name=\'caffe.SPPParameter.PoolMethod\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'MAX\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'AVE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'STOCHASTIC\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=15513,\n  serialized_end=15559,\n)\n\n_SPPPARAMETER_ENGINE = _descriptor.EnumDescriptor(\n  name=\'Engine\',\n  full_name=\'caffe.SPPParameter.Engine\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'DEFAULT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CAFFE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CUDNN\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=11883,\n  serialized_end=11926,\n)\n\n_V1LAYERPARAMETER_LAYERTYPE = _descriptor.EnumDescriptor(\n  name=\'LayerType\',\n  full_name=\'caffe.V1LayerParameter.LayerType\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'NONE\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ABSVAL\', index=1, number=35,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ACCURACY\', index=2, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ARGMAX\', index=3, number=30,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'BNLL\', index=4, number=2,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CONCAT\', index=5, number=3,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CONTRASTIVE_LOSS\', index=6, number=37,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'CONVOLUTION\', index=7, number=4,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'DATA\', index=8, number=5,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'DECONVOLUTION\', index=9, number=39,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'DROPOUT\', index=10, number=6,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'DUMMY_DATA\', index=11, number=32,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'EUCLIDEAN_LOSS\', index=12, number=7,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'ELTWISE\', index=13, number=25,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'EXP\', index=14, number=38,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'FLATTEN\', index=15, number=8,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'HDF5_DATA\', index=16, number=9,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'HDF5_OUTPUT\', index=17, number=10,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'HINGE_LOSS\', index=18, number=28,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'IM2COL\', index=19, number=11,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'IMAGE_DATA\', index=20, number=12,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'INFOGAIN_LOSS\', index=21, number=13,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'INNER_PRODUCT\', index=22, number=14,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'LRN\', index=23, number=15,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'MEMORY_DATA\', index=24, number=29,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'MULTINOMIAL_LOGISTIC_LOSS\', index=25, number=16,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'MVN\', index=26, number=34,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'POOLING\', index=27, number=17,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'POWER\', index=28, number=26,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'RELU\', index=29, number=18,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SIGMOID\', index=30, number=19,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SIGMOID_CROSS_ENTROPY_LOSS\', index=31, number=27,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SILENCE\', index=32, number=36,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SOFTMAX\', index=33, number=20,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SOFTMAX_LOSS\', index=34, number=21,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SPLIT\', index=35, number=22,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'SLICE\', index=36, number=33,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'TANH\', index=37, number=23,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'WINDOW_DATA\', index=38, number=24,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'THRESHOLD\', index=39, number=31,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=19576,\n  serialized_end=20176,\n)\n\n_V1LAYERPARAMETER_DIMCHECKMODE = _descriptor.EnumDescriptor(\n  name=\'DimCheckMode\',\n  full_name=\'caffe.V1LayerParameter.DimCheckMode\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'STRICT\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'PERMISSIVE\', index=1, number=1,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=2757,\n  serialized_end=2799,\n)\n\n_V0LAYERPARAMETER_POOLMETHOD = _descriptor.EnumDescriptor(\n  name=\'PoolMethod\',\n  full_name=\'caffe.V0LayerParameter.PoolMethod\',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name=\'MAX\', index=0, number=0,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'AVE\', index=1, number=1,\n      options=None,\n      type=None),\n    _descriptor.EnumValueDescriptor(\n      name=\'STOCHASTIC\', index=2, number=2,\n      options=None,\n      type=None),\n  ],\n  containing_type=None,\n  options=None,\n  serialized_start=15513,\n  serialized_end=15559,\n)\n\n\n_BLOBSHAPE = _descriptor.Descriptor(\n  name=\'BlobShape\',\n  full_name=\'caffe.BlobShape\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'dim\', full_name=\'caffe.BlobShape.dim\', index=0,\n      number=1, type=3, cpp_type=2, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=_descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=22,\n  serialized_end=50,\n)\n\n\n_BLOBPROTO = _descriptor.Descriptor(\n  name=\'BlobProto\',\n  full_name=\'caffe.BlobProto\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'shape\', full_name=\'caffe.BlobProto.shape\', index=0,\n      number=7, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'data\', full_name=\'caffe.BlobProto.data\', index=1,\n      number=5, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=_descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')),\n    _descriptor.FieldDescriptor(\n      name=\'diff\', full_name=\'caffe.BlobProto.diff\', index=2,\n      number=6, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=_descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')),\n    _descriptor.FieldDescriptor(\n      name=\'double_data\', full_name=\'caffe.BlobProto.double_data\', index=3,\n      number=8, type=1, cpp_type=5, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=_descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')),\n    _descriptor.FieldDescriptor(\n      name=\'double_diff\', full_name=\'caffe.BlobProto.double_diff\', index=4,\n      number=9, type=1, cpp_type=5, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=_descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')),\n    _descriptor.FieldDescriptor(\n      name=\'num\', full_name=\'caffe.BlobProto.num\', index=5,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'channels\', full_name=\'caffe.BlobProto.channels\', index=6,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'height\', full_name=\'caffe.BlobProto.height\', index=7,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'width\', full_name=\'caffe.BlobProto.width\', index=8,\n      number=4, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=53,\n  serialized_end=257,\n)\n\n\n_BLOBPROTOVECTOR = _descriptor.Descriptor(\n  name=\'BlobProtoVector\',\n  full_name=\'caffe.BlobProtoVector\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'blobs\', full_name=\'caffe.BlobProtoVector.blobs\', index=0,\n      number=1, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=259,\n  serialized_end=309,\n)\n\n\n_DATUM = _descriptor.Descriptor(\n  name=\'Datum\',\n  full_name=\'caffe.Datum\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'channels\', full_name=\'caffe.Datum.channels\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'height\', full_name=\'caffe.Datum.height\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'width\', full_name=\'caffe.Datum.width\', index=2,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'data\', full_name=\'caffe.Datum.data\', index=3,\n      number=4, type=12, cpp_type=9, label=1,\n      has_default_value=False, default_value="""",\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'label\', full_name=\'caffe.Datum.label\', index=4,\n      number=5, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'float_data\', full_name=\'caffe.Datum.float_data\', index=5,\n      number=6, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'encoded\', full_name=\'caffe.Datum.encoded\', index=6,\n      number=7, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=312,\n  serialized_end=441,\n)\n\n\n_FILLERPARAMETER = _descriptor.Descriptor(\n  name=\'FillerParameter\',\n  full_name=\'caffe.FillerParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'type\', full_name=\'caffe.FillerParameter.type\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""constant"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'value\', full_name=\'caffe.FillerParameter.value\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'min\', full_name=\'caffe.FillerParameter.min\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'max\', full_name=\'caffe.FillerParameter.max\', index=3,\n      number=4, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean\', full_name=\'caffe.FillerParameter.mean\', index=4,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'std\', full_name=\'caffe.FillerParameter.std\', index=5,\n      number=6, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'sparse\', full_name=\'caffe.FillerParameter.sparse\', index=6,\n      number=7, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'variance_norm\', full_name=\'caffe.FillerParameter.variance_norm\', index=7,\n      number=8, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'diag_val\', full_name=\'caffe.FillerParameter.diag_val\', index=8,\n      number=9, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'file\', full_name=\'caffe.FillerParameter.file\', index=9,\n      number=10, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _FILLERPARAMETER_VARIANCENORM,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=444,\n  serialized_end=742,\n)\n\n\n_NETPARAMETER = _descriptor.Descriptor(\n  name=\'NetParameter\',\n  full_name=\'caffe.NetParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'name\', full_name=\'caffe.NetParameter.name\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'input\', full_name=\'caffe.NetParameter.input\', index=1,\n      number=3, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'input_shape\', full_name=\'caffe.NetParameter.input_shape\', index=2,\n      number=8, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'input_dim\', full_name=\'caffe.NetParameter.input_dim\', index=3,\n      number=4, type=5, cpp_type=1, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'force_backward\', full_name=\'caffe.NetParameter.force_backward\', index=4,\n      number=5, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'state\', full_name=\'caffe.NetParameter.state\', index=5,\n      number=6, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'debug_info\', full_name=\'caffe.NetParameter.debug_info\', index=6,\n      number=7, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'layer\', full_name=\'caffe.NetParameter.layer\', index=7,\n      number=100, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'layers\', full_name=\'caffe.NetParameter.layers\', index=8,\n      number=2, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=745,\n  serialized_end=1015,\n)\n\n\n_SOLVERPARAMETER = _descriptor.Descriptor(\n  name=\'SolverParameter\',\n  full_name=\'caffe.SolverParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'net\', full_name=\'caffe.SolverParameter.net\', index=0,\n      number=24, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'net_param\', full_name=\'caffe.SolverParameter.net_param\', index=1,\n      number=25, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'train_net\', full_name=\'caffe.SolverParameter.train_net\', index=2,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_net\', full_name=\'caffe.SolverParameter.test_net\', index=3,\n      number=2, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'train_net_param\', full_name=\'caffe.SolverParameter.train_net_param\', index=4,\n      number=21, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_net_param\', full_name=\'caffe.SolverParameter.test_net_param\', index=5,\n      number=22, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'train_state\', full_name=\'caffe.SolverParameter.train_state\', index=6,\n      number=26, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_state\', full_name=\'caffe.SolverParameter.test_state\', index=7,\n      number=27, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_iter\', full_name=\'caffe.SolverParameter.test_iter\', index=8,\n      number=3, type=5, cpp_type=1, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_interval\', full_name=\'caffe.SolverParameter.test_interval\', index=9,\n      number=4, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_compute_loss\', full_name=\'caffe.SolverParameter.test_compute_loss\', index=10,\n      number=19, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'test_initialization\', full_name=\'caffe.SolverParameter.test_initialization\', index=11,\n      number=32, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'base_lr\', full_name=\'caffe.SolverParameter.base_lr\', index=12,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'display\', full_name=\'caffe.SolverParameter.display\', index=13,\n      number=6, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'average_loss\', full_name=\'caffe.SolverParameter.average_loss\', index=14,\n      number=33, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'max_iter\', full_name=\'caffe.SolverParameter.max_iter\', index=15,\n      number=7, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'iter_size\', full_name=\'caffe.SolverParameter.iter_size\', index=16,\n      number=36, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lr_policy\', full_name=\'caffe.SolverParameter.lr_policy\', index=17,\n      number=8, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'gamma\', full_name=\'caffe.SolverParameter.gamma\', index=18,\n      number=9, type=2, cpp_type=6, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'power\', full_name=\'caffe.SolverParameter.power\', index=19,\n      number=10, type=2, cpp_type=6, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'momentum\', full_name=\'caffe.SolverParameter.momentum\', index=20,\n      number=11, type=2, cpp_type=6, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_decay\', full_name=\'caffe.SolverParameter.weight_decay\', index=21,\n      number=12, type=2, cpp_type=6, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'regularization_type\', full_name=\'caffe.SolverParameter.regularization_type\', index=22,\n      number=29, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""L2"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stepsize\', full_name=\'caffe.SolverParameter.stepsize\', index=23,\n      number=13, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stepvalue\', full_name=\'caffe.SolverParameter.stepvalue\', index=24,\n      number=34, type=5, cpp_type=1, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'clip_gradients\', full_name=\'caffe.SolverParameter.clip_gradients\', index=25,\n      number=35, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'snapshot\', full_name=\'caffe.SolverParameter.snapshot\', index=26,\n      number=14, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'snapshot_prefix\', full_name=\'caffe.SolverParameter.snapshot_prefix\', index=27,\n      number=15, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'snapshot_diff\', full_name=\'caffe.SolverParameter.snapshot_diff\', index=28,\n      number=16, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'snapshot_format\', full_name=\'caffe.SolverParameter.snapshot_format\', index=29,\n      number=37, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'solver_mode\', full_name=\'caffe.SolverParameter.solver_mode\', index=30,\n      number=17, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'device_id\', full_name=\'caffe.SolverParameter.device_id\', index=31,\n      number=18, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'random_seed\', full_name=\'caffe.SolverParameter.random_seed\', index=32,\n      number=20, type=3, cpp_type=2, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'type\', full_name=\'caffe.SolverParameter.type\', index=33,\n      number=40, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""SGD"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'delta\', full_name=\'caffe.SolverParameter.delta\', index=34,\n      number=31, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1e-08,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'momentum2\', full_name=\'caffe.SolverParameter.momentum2\', index=35,\n      number=39, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.999,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rms_decay\', full_name=\'caffe.SolverParameter.rms_decay\', index=36,\n      number=38, type=2, cpp_type=6, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'debug_info\', full_name=\'caffe.SolverParameter.debug_info\', index=37,\n      number=23, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'snapshot_after_train\', full_name=\'caffe.SolverParameter.snapshot_after_train\', index=38,\n      number=28, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'solver_type\', full_name=\'caffe.SolverParameter.solver_type\', index=39,\n      number=30, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _SOLVERPARAMETER_SNAPSHOTFORMAT,\n    _SOLVERPARAMETER_SOLVERMODE,\n    _SOLVERPARAMETER_SOLVERTYPE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=1018,\n  serialized_end=2326,\n)\n\n\n_SOLVERSTATE = _descriptor.Descriptor(\n  name=\'SolverState\',\n  full_name=\'caffe.SolverState\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'iter\', full_name=\'caffe.SolverState.iter\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'learned_net\', full_name=\'caffe.SolverState.learned_net\', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'history\', full_name=\'caffe.SolverState.history\', index=2,\n      number=3, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'current_step\', full_name=\'caffe.SolverState.current_step\', index=3,\n      number=4, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=2328,\n  serialized_end=2436,\n)\n\n\n_NETSTATE = _descriptor.Descriptor(\n  name=\'NetState\',\n  full_name=\'caffe.NetState\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'phase\', full_name=\'caffe.NetState.phase\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'level\', full_name=\'caffe.NetState.level\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stage\', full_name=\'caffe.NetState.stage\', index=2,\n      number=3, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=2438,\n  serialized_end=2516,\n)\n\n\n_NETSTATERULE = _descriptor.Descriptor(\n  name=\'NetStateRule\',\n  full_name=\'caffe.NetStateRule\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'phase\', full_name=\'caffe.NetStateRule.phase\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'min_level\', full_name=\'caffe.NetStateRule.min_level\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'max_level\', full_name=\'caffe.NetStateRule.max_level\', index=2,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stage\', full_name=\'caffe.NetStateRule.stage\', index=3,\n      number=4, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'not_stage\', full_name=\'caffe.NetStateRule.not_stage\', index=4,\n      number=5, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=2518,\n  serialized_end=2633,\n)\n\n\n_PARAMSPEC = _descriptor.Descriptor(\n  name=\'ParamSpec\',\n  full_name=\'caffe.ParamSpec\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'name\', full_name=\'caffe.ParamSpec.name\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'share_mode\', full_name=\'caffe.ParamSpec.share_mode\', index=1,\n      number=2, type=14, cpp_type=8, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lr_mult\', full_name=\'caffe.ParamSpec.lr_mult\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'decay_mult\', full_name=\'caffe.ParamSpec.decay_mult\', index=3,\n      number=4, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _PARAMSPEC_DIMCHECKMODE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=2636,\n  serialized_end=2799,\n)\n\n\n_LAYERPARAMETER = _descriptor.Descriptor(\n  name=\'LayerParameter\',\n  full_name=\'caffe.LayerParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'name\', full_name=\'caffe.LayerParameter.name\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'type\', full_name=\'caffe.LayerParameter.type\', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bottom\', full_name=\'caffe.LayerParameter.bottom\', index=2,\n      number=3, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'top\', full_name=\'caffe.LayerParameter.top\', index=3,\n      number=4, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'phase\', full_name=\'caffe.LayerParameter.phase\', index=4,\n      number=10, type=14, cpp_type=8, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'loss_weight\', full_name=\'caffe.LayerParameter.loss_weight\', index=5,\n      number=5, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'param\', full_name=\'caffe.LayerParameter.param\', index=6,\n      number=6, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'blobs\', full_name=\'caffe.LayerParameter.blobs\', index=7,\n      number=7, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'propagate_down\', full_name=\'caffe.LayerParameter.propagate_down\', index=8,\n      number=11, type=8, cpp_type=7, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'include\', full_name=\'caffe.LayerParameter.include\', index=9,\n      number=8, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'exclude\', full_name=\'caffe.LayerParameter.exclude\', index=10,\n      number=9, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'transform_param\', full_name=\'caffe.LayerParameter.transform_param\', index=11,\n      number=100, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'loss_param\', full_name=\'caffe.LayerParameter.loss_param\', index=12,\n      number=101, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'accuracy_param\', full_name=\'caffe.LayerParameter.accuracy_param\', index=13,\n      number=102, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'argmax_param\', full_name=\'caffe.LayerParameter.argmax_param\', index=14,\n      number=103, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batch_norm_param\', full_name=\'caffe.LayerParameter.batch_norm_param\', index=15,\n      number=139, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_param\', full_name=\'caffe.LayerParameter.bias_param\', index=16,\n      number=141, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'concat_param\', full_name=\'caffe.LayerParameter.concat_param\', index=17,\n      number=104, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'contrastive_loss_param\', full_name=\'caffe.LayerParameter.contrastive_loss_param\', index=18,\n      number=105, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'convolution_param\', full_name=\'caffe.LayerParameter.convolution_param\', index=19,\n      number=106, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_param\', full_name=\'caffe.LayerParameter.crop_param\', index=20,\n      number=144, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'data_param\', full_name=\'caffe.LayerParameter.data_param\', index=21,\n      number=107, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dropout_param\', full_name=\'caffe.LayerParameter.dropout_param\', index=22,\n      number=108, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dummy_data_param\', full_name=\'caffe.LayerParameter.dummy_data_param\', index=23,\n      number=109, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'eltwise_param\', full_name=\'caffe.LayerParameter.eltwise_param\', index=24,\n      number=110, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'elu_param\', full_name=\'caffe.LayerParameter.elu_param\', index=25,\n      number=140, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'embed_param\', full_name=\'caffe.LayerParameter.embed_param\', index=26,\n      number=137, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'exp_param\', full_name=\'caffe.LayerParameter.exp_param\', index=27,\n      number=111, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'expmax_param\', full_name=\'caffe.LayerParameter.expmax_param\', index=28,\n      number=158, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'flatten_param\', full_name=\'caffe.LayerParameter.flatten_param\', index=29,\n      number=135, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hdf5_data_param\', full_name=\'caffe.LayerParameter.hdf5_data_param\', index=30,\n      number=112, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hdf5_output_param\', full_name=\'caffe.LayerParameter.hdf5_output_param\', index=31,\n      number=113, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hinge_loss_param\', full_name=\'caffe.LayerParameter.hinge_loss_param\', index=32,\n      number=114, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'image_data_param\', full_name=\'caffe.LayerParameter.image_data_param\', index=33,\n      number=115, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'infogain_loss_param\', full_name=\'caffe.LayerParameter.infogain_loss_param\', index=34,\n      number=116, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'inner_product_param\', full_name=\'caffe.LayerParameter.inner_product_param\', index=35,\n      number=117, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'input_param\', full_name=\'caffe.LayerParameter.input_param\', index=36,\n      number=143, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'log_param\', full_name=\'caffe.LayerParameter.log_param\', index=37,\n      number=134, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lrn_param\', full_name=\'caffe.LayerParameter.lrn_param\', index=38,\n      number=118, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'memory_data_param\', full_name=\'caffe.LayerParameter.memory_data_param\', index=39,\n      number=119, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mvn_param\', full_name=\'caffe.LayerParameter.mvn_param\', index=40,\n      number=120, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'parameter_param\', full_name=\'caffe.LayerParameter.parameter_param\', index=41,\n      number=145, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pooling_param\', full_name=\'caffe.LayerParameter.pooling_param\', index=42,\n      number=121, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'power_param\', full_name=\'caffe.LayerParameter.power_param\', index=43,\n      number=122, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'prelu_param\', full_name=\'caffe.LayerParameter.prelu_param\', index=44,\n      number=131, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'python_param\', full_name=\'caffe.LayerParameter.python_param\', index=45,\n      number=130, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'recurrent_param\', full_name=\'caffe.LayerParameter.recurrent_param\', index=46,\n      number=146, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'reduction_param\', full_name=\'caffe.LayerParameter.reduction_param\', index=47,\n      number=136, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'relu_param\', full_name=\'caffe.LayerParameter.relu_param\', index=48,\n      number=123, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'reshape_param\', full_name=\'caffe.LayerParameter.reshape_param\', index=49,\n      number=133, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale_param\', full_name=\'caffe.LayerParameter.scale_param\', index=50,\n      number=142, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'sigmoid_param\', full_name=\'caffe.LayerParameter.sigmoid_param\', index=51,\n      number=124, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'softmax_param\', full_name=\'caffe.LayerParameter.softmax_param\', index=52,\n      number=125, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'spp_param\', full_name=\'caffe.LayerParameter.spp_param\', index=53,\n      number=132, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'slice_param\', full_name=\'caffe.LayerParameter.slice_param\', index=54,\n      number=126, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'tanh_param\', full_name=\'caffe.LayerParameter.tanh_param\', index=55,\n      number=127, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'threshold_param\', full_name=\'caffe.LayerParameter.threshold_param\', index=56,\n      number=128, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'tile_param\', full_name=\'caffe.LayerParameter.tile_param\', index=57,\n      number=138, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'window_data_param\', full_name=\'caffe.LayerParameter.window_data_param\', index=58,\n      number=129, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'coeff_schedule_param\', full_name=\'caffe.LayerParameter.coeff_schedule_param\', index=59,\n      number=148, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'augmentation_param\', full_name=\'caffe.LayerParameter.augmentation_param\', index=60,\n      number=149, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'correlation_param\', full_name=\'caffe.LayerParameter.correlation_param\', index=61,\n      number=150, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'l1_loss_param\', full_name=\'caffe.LayerParameter.l1_loss_param\', index=62,\n      number=151, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'writer_param\', full_name=\'caffe.LayerParameter.writer_param\', index=63,\n      number=152, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'reader_param\', full_name=\'caffe.LayerParameter.reader_param\', index=64,\n      number=153, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_param\', full_name=\'caffe.LayerParameter.mean_param\', index=65,\n      number=154, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'resample_param\', full_name=\'caffe.LayerParameter.resample_param\', index=66,\n      number=155, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'downsample_param\', full_name=\'caffe.LayerParameter.downsample_param\', index=67,\n      number=156, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'negsquare_param\', full_name=\'caffe.LayerParameter.negsquare_param\', index=68,\n      number=159, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'reshape_every_iter\', full_name=\'caffe.LayerParameter.reshape_every_iter\', index=69,\n      number=157, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=2802,\n  serialized_end=5968,\n)\n\n\n_GRIDPARAMETER = _descriptor.Descriptor(\n  name=\'GridParameter\',\n  full_name=\'caffe.GridParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'height\', full_name=\'caffe.GridParameter.height\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'width\', full_name=\'caffe.GridParameter.width\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batch\', full_name=\'caffe.GridParameter.batch\', index=2,\n      number=3, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=5970,\n  serialized_end=6031,\n)\n\n\n_AUGMENTATIONCOEFF = _descriptor.Descriptor(\n  name=\'AugmentationCoeff\',\n  full_name=\'caffe.AugmentationCoeff\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.AugmentationCoeff.mirror\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dx\', full_name=\'caffe.AugmentationCoeff.dx\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dy\', full_name=\'caffe.AugmentationCoeff.dy\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'angle\', full_name=\'caffe.AugmentationCoeff.angle\', index=3,\n      number=4, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'zoom_x\', full_name=\'caffe.AugmentationCoeff.zoom_x\', index=4,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'zoom_y\', full_name=\'caffe.AugmentationCoeff.zoom_y\', index=5,\n      number=6, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'gamma\', full_name=\'caffe.AugmentationCoeff.gamma\', index=6,\n      number=100, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'brightness\', full_name=\'caffe.AugmentationCoeff.brightness\', index=7,\n      number=101, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'contrast\', full_name=\'caffe.AugmentationCoeff.contrast\', index=8,\n      number=102, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'color1\', full_name=\'caffe.AugmentationCoeff.color1\', index=9,\n      number=103, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'color2\', full_name=\'caffe.AugmentationCoeff.color2\', index=10,\n      number=104, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'color3\', full_name=\'caffe.AugmentationCoeff.color3\', index=11,\n      number=105, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pow_nomean0\', full_name=\'caffe.AugmentationCoeff.pow_nomean0\', index=12,\n      number=10, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pow_nomean1\', full_name=\'caffe.AugmentationCoeff.pow_nomean1\', index=13,\n      number=11, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pow_nomean2\', full_name=\'caffe.AugmentationCoeff.pow_nomean2\', index=14,\n      number=12, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'add_nomean0\', full_name=\'caffe.AugmentationCoeff.add_nomean0\', index=15,\n      number=13, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'add_nomean1\', full_name=\'caffe.AugmentationCoeff.add_nomean1\', index=16,\n      number=14, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'add_nomean2\', full_name=\'caffe.AugmentationCoeff.add_nomean2\', index=17,\n      number=15, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mult_nomean0\', full_name=\'caffe.AugmentationCoeff.mult_nomean0\', index=18,\n      number=16, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mult_nomean1\', full_name=\'caffe.AugmentationCoeff.mult_nomean1\', index=19,\n      number=17, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mult_nomean2\', full_name=\'caffe.AugmentationCoeff.mult_nomean2\', index=20,\n      number=18, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pow_withmean0\', full_name=\'caffe.AugmentationCoeff.pow_withmean0\', index=21,\n      number=19, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pow_withmean1\', full_name=\'caffe.AugmentationCoeff.pow_withmean1\', index=22,\n      number=20, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pow_withmean2\', full_name=\'caffe.AugmentationCoeff.pow_withmean2\', index=23,\n      number=21, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'add_withmean0\', full_name=\'caffe.AugmentationCoeff.add_withmean0\', index=24,\n      number=22, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'add_withmean1\', full_name=\'caffe.AugmentationCoeff.add_withmean1\', index=25,\n      number=23, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'add_withmean2\', full_name=\'caffe.AugmentationCoeff.add_withmean2\', index=26,\n      number=24, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mult_withmean0\', full_name=\'caffe.AugmentationCoeff.mult_withmean0\', index=27,\n      number=25, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mult_withmean1\', full_name=\'caffe.AugmentationCoeff.mult_withmean1\', index=28,\n      number=26, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mult_withmean2\', full_name=\'caffe.AugmentationCoeff.mult_withmean2\', index=29,\n      number=27, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lmult_pow\', full_name=\'caffe.AugmentationCoeff.lmult_pow\', index=30,\n      number=28, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lmult_add\', full_name=\'caffe.AugmentationCoeff.lmult_add\', index=31,\n      number=29, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lmult_mult\', full_name=\'caffe.AugmentationCoeff.lmult_mult\', index=32,\n      number=30, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'col_angle\', full_name=\'caffe.AugmentationCoeff.col_angle\', index=33,\n      number=31, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'fog_amount\', full_name=\'caffe.AugmentationCoeff.fog_amount\', index=34,\n      number=38, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'fog_size\', full_name=\'caffe.AugmentationCoeff.fog_size\', index=35,\n      number=39, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'motion_blur_angle\', full_name=\'caffe.AugmentationCoeff.motion_blur_angle\', index=36,\n      number=40, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'motion_blur_size\', full_name=\'caffe.AugmentationCoeff.motion_blur_size\', index=37,\n      number=41, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shadow_angle\', full_name=\'caffe.AugmentationCoeff.shadow_angle\', index=38,\n      number=42, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shadow_distance\', full_name=\'caffe.AugmentationCoeff.shadow_distance\', index=39,\n      number=43, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shadow_strength\', full_name=\'caffe.AugmentationCoeff.shadow_strength\', index=40,\n      number=44, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'noise\', full_name=\'caffe.AugmentationCoeff.noise\', index=41,\n      number=45, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=6034,\n  serialized_end=7024,\n)\n\n\n_AUGMENTATIONPARAMETER = _descriptor.Descriptor(\n  name=\'AugmentationParameter\',\n  full_name=\'caffe.AugmentationParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'crop_width\', full_name=\'caffe.AugmentationParameter.crop_width\', index=0,\n      number=33, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_height\', full_name=\'caffe.AugmentationParameter.crop_height\', index=1,\n      number=34, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'write_augmented\', full_name=\'caffe.AugmentationParameter.write_augmented\', index=2,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'max_multiplier\', full_name=\'caffe.AugmentationParameter.max_multiplier\', index=3,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=255,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'augment_during_test\', full_name=\'caffe.AugmentationParameter.augment_during_test\', index=4,\n      number=4, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'recompute_mean\', full_name=\'caffe.AugmentationParameter.recompute_mean\', index=5,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'write_mean\', full_name=\'caffe.AugmentationParameter.write_mean\', index=6,\n      number=6, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_per_pixel\', full_name=\'caffe.AugmentationParameter.mean_per_pixel\', index=7,\n      number=7, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean\', full_name=\'caffe.AugmentationParameter.mean\', index=8,\n      number=18, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mode\', full_name=\'caffe.AugmentationParameter.mode\', index=9,\n      number=8, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""add"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bottomwidth\', full_name=\'caffe.AugmentationParameter.bottomwidth\', index=10,\n      number=80, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bottomheight\', full_name=\'caffe.AugmentationParameter.bottomheight\', index=11,\n      number=81, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num\', full_name=\'caffe.AugmentationParameter.num\', index=12,\n      number=82, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'chromatic_eigvec\', full_name=\'caffe.AugmentationParameter.chromatic_eigvec\', index=13,\n      number=83, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.AugmentationParameter.mirror\', index=14,\n      number=10, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'translate\', full_name=\'caffe.AugmentationParameter.translate\', index=15,\n      number=11, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rotate\', full_name=\'caffe.AugmentationParameter.rotate\', index=16,\n      number=12, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'zoom\', full_name=\'caffe.AugmentationParameter.zoom\', index=17,\n      number=13, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'squeeze\', full_name=\'caffe.AugmentationParameter.squeeze\', index=18,\n      number=14, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'translate_x\', full_name=\'caffe.AugmentationParameter.translate_x\', index=19,\n      number=15, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'translate_y\', full_name=\'caffe.AugmentationParameter.translate_y\', index=20,\n      number=16, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'gamma\', full_name=\'caffe.AugmentationParameter.gamma\', index=21,\n      number=35, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'brightness\', full_name=\'caffe.AugmentationParameter.brightness\', index=22,\n      number=36, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'contrast\', full_name=\'caffe.AugmentationParameter.contrast\', index=23,\n      number=37, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'color\', full_name=\'caffe.AugmentationParameter.color\', index=24,\n      number=38, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lmult_pow\', full_name=\'caffe.AugmentationParameter.lmult_pow\', index=25,\n      number=20, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lmult_mult\', full_name=\'caffe.AugmentationParameter.lmult_mult\', index=26,\n      number=21, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lmult_add\', full_name=\'caffe.AugmentationParameter.lmult_add\', index=27,\n      number=22, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'sat_pow\', full_name=\'caffe.AugmentationParameter.sat_pow\', index=28,\n      number=23, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'sat_mult\', full_name=\'caffe.AugmentationParameter.sat_mult\', index=29,\n      number=24, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'sat_add\', full_name=\'caffe.AugmentationParameter.sat_add\', index=30,\n      number=25, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'col_pow\', full_name=\'caffe.AugmentationParameter.col_pow\', index=31,\n      number=26, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'col_mult\', full_name=\'caffe.AugmentationParameter.col_mult\', index=32,\n      number=27, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'col_add\', full_name=\'caffe.AugmentationParameter.col_add\', index=33,\n      number=28, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'ladd_pow\', full_name=\'caffe.AugmentationParameter.ladd_pow\', index=34,\n      number=29, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'ladd_mult\', full_name=\'caffe.AugmentationParameter.ladd_mult\', index=35,\n      number=30, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'ladd_add\', full_name=\'caffe.AugmentationParameter.ladd_add\', index=36,\n      number=31, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'col_rotate\', full_name=\'caffe.AugmentationParameter.col_rotate\', index=37,\n      number=32, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'fog_amount\', full_name=\'caffe.AugmentationParameter.fog_amount\', index=38,\n      number=100, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'fog_size\', full_name=\'caffe.AugmentationParameter.fog_size\', index=39,\n      number=101, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'motion_blur_angle\', full_name=\'caffe.AugmentationParameter.motion_blur_angle\', index=40,\n      number=102, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'motion_blur_size\', full_name=\'caffe.AugmentationParameter.motion_blur_size\', index=41,\n      number=103, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shadow_angle\', full_name=\'caffe.AugmentationParameter.shadow_angle\', index=42,\n      number=104, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shadow_distance\', full_name=\'caffe.AugmentationParameter.shadow_distance\', index=43,\n      number=105, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shadow_strength\', full_name=\'caffe.AugmentationParameter.shadow_strength\', index=44,\n      number=106, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'noise\', full_name=\'caffe.AugmentationParameter.noise\', index=45,\n      number=107, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=7027,\n  serialized_end=9055,\n)\n\n\n_RANDOMGENERATORPARAMETER = _descriptor.Descriptor(\n  name=\'RandomGeneratorParameter\',\n  full_name=\'caffe.RandomGeneratorParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'rand_type\', full_name=\'caffe.RandomGeneratorParameter.rand_type\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""uniform"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'exp\', full_name=\'caffe.RandomGeneratorParameter.exp\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean\', full_name=\'caffe.RandomGeneratorParameter.mean\', index=2,\n      number=4, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'spread\', full_name=\'caffe.RandomGeneratorParameter.spread\', index=3,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'prob\', full_name=\'caffe.RandomGeneratorParameter.prob\', index=4,\n      number=6, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'apply_schedule\', full_name=\'caffe.RandomGeneratorParameter.apply_schedule\', index=5,\n      number=7, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'discretize\', full_name=\'caffe.RandomGeneratorParameter.discretize\', index=6,\n      number=8, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'multiplier\', full_name=\'caffe.RandomGeneratorParameter.multiplier\', index=7,\n      number=9, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=9058,\n  serialized_end=9265,\n)\n\n\n_L1LOSSPARAMETER = _descriptor.Descriptor(\n  name=\'L1LossParameter\',\n  full_name=\'caffe.L1LossParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'l2_per_location\', full_name=\'caffe.L1LossParameter.l2_per_location\', index=0,\n      number=1, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'l2_prescale_by_channels\', full_name=\'caffe.L1LossParameter.l2_prescale_by_channels\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'normalize_by_num_entries\', full_name=\'caffe.L1LossParameter.normalize_by_num_entries\', index=2,\n      number=3, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'epsilon\', full_name=\'caffe.L1LossParameter.epsilon\', index=3,\n      number=4, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.01,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'plateau\', full_name=\'caffe.L1LossParameter.plateau\', index=4,\n      number=3001, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'power\', full_name=\'caffe.L1LossParameter.power\', index=5,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=9268,\n  serialized_end=9462,\n)\n\n\n_CORRELATIONPARAMETER = _descriptor.Descriptor(\n  name=\'CorrelationParameter\',\n  full_name=\'caffe.CorrelationParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'pad\', full_name=\'caffe.CorrelationParameter.pad\', index=0,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_size\', full_name=\'caffe.CorrelationParameter.kernel_size\', index=1,\n      number=3, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'max_displacement\', full_name=\'caffe.CorrelationParameter.max_displacement\', index=2,\n      number=4, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride_1\', full_name=\'caffe.CorrelationParameter.stride_1\', index=3,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride_2\', full_name=\'caffe.CorrelationParameter.stride_2\', index=4,\n      number=6, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'single_direction\', full_name=\'caffe.CorrelationParameter.single_direction\', index=5,\n      number=8, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'do_abs\', full_name=\'caffe.CorrelationParameter.do_abs\', index=6,\n      number=7, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'correlation_type\', full_name=\'caffe.CorrelationParameter.correlation_type\', index=7,\n      number=15, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _CORRELATIONPARAMETER_CORRELATIONTYPE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=9465,\n  serialized_end=9772,\n)\n\n\n_DOWNSAMPLEPARAMETER = _descriptor.Descriptor(\n  name=\'DownsampleParameter\',\n  full_name=\'caffe.DownsampleParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'top_height\', full_name=\'caffe.DownsampleParameter.top_height\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'top_width\', full_name=\'caffe.DownsampleParameter.top_width\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=9774,\n  serialized_end=9840,\n)\n\n\n_READERPARAMETER = _descriptor.Descriptor(\n  name=\'ReaderParameter\',\n  full_name=\'caffe.ReaderParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'file\', full_name=\'caffe.ReaderParameter.file\', index=0,\n      number=1, type=9, cpp_type=9, label=2,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num\', full_name=\'caffe.ReaderParameter.num\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=9842,\n  serialized_end=9889,\n)\n\n\n_WRITERPARAMETER = _descriptor.Descriptor(\n  name=\'WriterParameter\',\n  full_name=\'caffe.WriterParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'file\', full_name=\'caffe.WriterParameter.file\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'folder\', full_name=\'caffe.WriterParameter.folder\', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'prefix\', full_name=\'caffe.WriterParameter.prefix\', index=2,\n      number=3, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'suffix\', full_name=\'caffe.WriterParameter.suffix\', index=3,\n      number=4, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'normalize\', full_name=\'caffe.WriterParameter.normalize\', index=4,\n      number=5, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.WriterParameter.scale\', index=5,\n      number=6, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=9892,\n  serialized_end=10023,\n)\n\n\n_RESAMPLEPARAMETER = _descriptor.Descriptor(\n  name=\'ResampleParameter\',\n  full_name=\'caffe.ResampleParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'antialias\', full_name=\'caffe.ResampleParameter.antialias\', index=0,\n      number=4, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'width\', full_name=\'caffe.ResampleParameter.width\', index=1,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'height\', full_name=\'caffe.ResampleParameter.height\', index=2,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'type\', full_name=\'caffe.ResampleParameter.type\', index=3,\n      number=3, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=2,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _RESAMPLEPARAMETER_RESAMPLETYPE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10026,\n  serialized_end=10224,\n)\n\n\n_MEANPARAMETER = _descriptor.Descriptor(\n  name=\'MeanParameter\',\n  full_name=\'caffe.MeanParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'operation\', full_name=\'caffe.MeanParameter.operation\', index=0,\n      number=1, type=14, cpp_type=8, label=2,\n      has_default_value=False, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'file\', full_name=\'caffe.MeanParameter.file\', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'value\', full_name=\'caffe.MeanParameter.value\', index=2,\n      number=3, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_scale\', full_name=\'caffe.MeanParameter.mean_scale\', index=3,\n      number=4, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'input_scale\', full_name=\'caffe.MeanParameter.input_scale\', index=4,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'output_scale\', full_name=\'caffe.MeanParameter.output_scale\', index=5,\n      number=6, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _MEANPARAMETER_MEANOPERATION,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10227,\n  serialized_end=10438,\n)\n\n\n_COEFFSCHEDULEPARAMETER = _descriptor.Descriptor(\n  name=\'CoeffScheduleParameter\',\n  full_name=\'caffe.CoeffScheduleParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'half_life\', full_name=\'caffe.CoeffScheduleParameter.half_life\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'initial_coeff\', full_name=\'caffe.CoeffScheduleParameter.initial_coeff\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'final_coeff\', full_name=\'caffe.CoeffScheduleParameter.final_coeff\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10440,\n  serialized_end=10536,\n)\n\n\n_TRANSFORMATIONPARAMETER = _descriptor.Descriptor(\n  name=\'TransformationParameter\',\n  full_name=\'caffe.TransformationParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.TransformationParameter.scale\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.TransformationParameter.mirror\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_size\', full_name=\'caffe.TransformationParameter.crop_size\', index=2,\n      number=3, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_file\', full_name=\'caffe.TransformationParameter.mean_file\', index=3,\n      number=4, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_value\', full_name=\'caffe.TransformationParameter.mean_value\', index=4,\n      number=5, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'force_color\', full_name=\'caffe.TransformationParameter.force_color\', index=5,\n      number=6, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'force_gray\', full_name=\'caffe.TransformationParameter.force_gray\', index=6,\n      number=7, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10539,\n  serialized_end=10721,\n)\n\n\n_LOSSPARAMETER = _descriptor.Descriptor(\n  name=\'LossParameter\',\n  full_name=\'caffe.LossParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'ignore_label\', full_name=\'caffe.LossParameter.ignore_label\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'normalization\', full_name=\'caffe.LossParameter.normalization\', index=1,\n      number=3, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'normalize\', full_name=\'caffe.LossParameter.normalize\', index=2,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=False, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _LOSSPARAMETER_NORMALIZATIONMODE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10724,\n  serialized_end=10918,\n)\n\n\n_ACCURACYPARAMETER = _descriptor.Descriptor(\n  name=\'AccuracyParameter\',\n  full_name=\'caffe.AccuracyParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'top_k\', full_name=\'caffe.AccuracyParameter.top_k\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.AccuracyParameter.axis\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'ignore_label\', full_name=\'caffe.AccuracyParameter.ignore_label\', index=2,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10920,\n  serialized_end=10996,\n)\n\n\n_ARGMAXPARAMETER = _descriptor.Descriptor(\n  name=\'ArgMaxParameter\',\n  full_name=\'caffe.ArgMaxParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'out_max_val\', full_name=\'caffe.ArgMaxParameter.out_max_val\', index=0,\n      number=1, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'top_k\', full_name=\'caffe.ArgMaxParameter.top_k\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.ArgMaxParameter.axis\', index=2,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=10998,\n  serialized_end=11075,\n)\n\n\n_CONCATPARAMETER = _descriptor.Descriptor(\n  name=\'ConcatParameter\',\n  full_name=\'caffe.ConcatParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.ConcatParameter.axis\', index=0,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'concat_dim\', full_name=\'caffe.ConcatParameter.concat_dim\', index=1,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11077,\n  serialized_end=11134,\n)\n\n\n_BATCHNORMPARAMETER = _descriptor.Descriptor(\n  name=\'BatchNormParameter\',\n  full_name=\'caffe.BatchNormParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'use_global_stats\', full_name=\'caffe.BatchNormParameter.use_global_stats\', index=0,\n      number=1, type=8, cpp_type=7, label=1,\n      has_default_value=False, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'moving_average_fraction\', full_name=\'caffe.BatchNormParameter.moving_average_fraction\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.999,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'eps\', full_name=\'caffe.BatchNormParameter.eps\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1e-05,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11136,\n  serialized_end=11242,\n)\n\n\n_BIASPARAMETER = _descriptor.Descriptor(\n  name=\'BiasParameter\',\n  full_name=\'caffe.BiasParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.BiasParameter.axis\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num_axes\', full_name=\'caffe.BiasParameter.num_axes\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'filler\', full_name=\'caffe.BiasParameter.filler\', index=2,\n      number=3, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11244,\n  serialized_end=11337,\n)\n\n\n_CONTRASTIVELOSSPARAMETER = _descriptor.Descriptor(\n  name=\'ContrastiveLossParameter\',\n  full_name=\'caffe.ContrastiveLossParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'margin\', full_name=\'caffe.ContrastiveLossParameter.margin\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'legacy_version\', full_name=\'caffe.ContrastiveLossParameter.legacy_version\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11339,\n  serialized_end=11415,\n)\n\n\n_CONVOLUTIONPARAMETER = _descriptor.Descriptor(\n  name=\'ConvolutionParameter\',\n  full_name=\'caffe.ConvolutionParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'num_output\', full_name=\'caffe.ConvolutionParameter.num_output\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_term\', full_name=\'caffe.ConvolutionParameter.bias_term\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad\', full_name=\'caffe.ConvolutionParameter.pad\', index=2,\n      number=3, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_size\', full_name=\'caffe.ConvolutionParameter.kernel_size\', index=3,\n      number=4, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride\', full_name=\'caffe.ConvolutionParameter.stride\', index=4,\n      number=6, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dilation\', full_name=\'caffe.ConvolutionParameter.dilation\', index=5,\n      number=18, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad_h\', full_name=\'caffe.ConvolutionParameter.pad_h\', index=6,\n      number=9, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad_w\', full_name=\'caffe.ConvolutionParameter.pad_w\', index=7,\n      number=10, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_h\', full_name=\'caffe.ConvolutionParameter.kernel_h\', index=8,\n      number=11, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_w\', full_name=\'caffe.ConvolutionParameter.kernel_w\', index=9,\n      number=12, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride_h\', full_name=\'caffe.ConvolutionParameter.stride_h\', index=10,\n      number=13, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride_w\', full_name=\'caffe.ConvolutionParameter.stride_w\', index=11,\n      number=14, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'group\', full_name=\'caffe.ConvolutionParameter.group\', index=12,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_filler\', full_name=\'caffe.ConvolutionParameter.weight_filler\', index=13,\n      number=7, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_filler\', full_name=\'caffe.ConvolutionParameter.bias_filler\', index=14,\n      number=8, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.ConvolutionParameter.engine\', index=15,\n      number=15, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.ConvolutionParameter.axis\', index=16,\n      number=16, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'force_nd_im2col\', full_name=\'caffe.ConvolutionParameter.force_nd_im2col\', index=17,\n      number=17, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _CONVOLUTIONPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11418,\n  serialized_end=11926,\n)\n\n\n_CROPPARAMETER = _descriptor.Descriptor(\n  name=\'CropParameter\',\n  full_name=\'caffe.CropParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.CropParameter.axis\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=2,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'offset\', full_name=\'caffe.CropParameter.offset\', index=1,\n      number=2, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11928,\n  serialized_end=11976,\n)\n\n\n_DATAPARAMETER = _descriptor.Descriptor(\n  name=\'DataParameter\',\n  full_name=\'caffe.DataParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'source\', full_name=\'caffe.DataParameter.source\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batch_size\', full_name=\'caffe.DataParameter.batch_size\', index=1,\n      number=4, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rand_skip\', full_name=\'caffe.DataParameter.rand_skip\', index=2,\n      number=7, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'backend\', full_name=\'caffe.DataParameter.backend\', index=3,\n      number=8, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.DataParameter.scale\', index=4,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_file\', full_name=\'caffe.DataParameter.mean_file\', index=5,\n      number=3, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_size\', full_name=\'caffe.DataParameter.crop_size\', index=6,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.DataParameter.mirror\', index=7,\n      number=6, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'force_encoded_color\', full_name=\'caffe.DataParameter.force_encoded_color\', index=8,\n      number=9, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'prefetch\', full_name=\'caffe.DataParameter.prefetch\', index=9,\n      number=10, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=4,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'disk_reader_threads\', full_name=\'caffe.DataParameter.disk_reader_threads\', index=10,\n      number=4001, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'huge_video_dataset\', full_name=\'caffe.DataParameter.huge_video_dataset\', index=11,\n      number=7000, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'limit_samples\', full_name=\'caffe.DataParameter.limit_samples\', index=12,\n      number=7001, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'preselection_file\', full_name=\'caffe.DataParameter.preselection_file\', index=13,\n      number=3001, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'preselection_label\', full_name=\'caffe.DataParameter.preselection_label\', index=14,\n      number=3002, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'range_start\', full_name=\'caffe.DataParameter.range_start\', index=15,\n      number=3003, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'range_end\', full_name=\'caffe.DataParameter.range_end\', index=16,\n      number=3004, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rand_permute\', full_name=\'caffe.DataParameter.rand_permute\', index=17,\n      number=3005, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rand_permute_order\', full_name=\'caffe.DataParameter.rand_permute_order\', index=18,\n      number=3006, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rand_permute_seed\', full_name=\'caffe.DataParameter.rand_permute_seed\', index=19,\n      number=3007, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'slice_point\', full_name=\'caffe.DataParameter.slice_point\', index=20,\n      number=3008, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'encoding\', full_name=\'caffe.DataParameter.encoding\', index=21,\n      number=3009, type=14, cpp_type=8, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'verbose\', full_name=\'caffe.DataParameter.verbose\', index=22,\n      number=3010, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'subtract\', full_name=\'caffe.DataParameter.subtract\', index=23,\n      number=3011, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'permute_every_iter\', full_name=\'caffe.DataParameter.permute_every_iter\', index=24,\n      number=3012, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'block_size\', full_name=\'caffe.DataParameter.block_size\', index=25,\n      number=3013, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _DATAPARAMETER_DB,\n    _DATAPARAMETER_CHANNELENCODING,\n    _DATAPARAMETER_RANDPERMORDER,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=11979,\n  serialized_end=12942,\n)\n\n\n_DROPOUTPARAMETER = _descriptor.Descriptor(\n  name=\'DropoutParameter\',\n  full_name=\'caffe.DropoutParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'dropout_ratio\', full_name=\'caffe.DropoutParameter.dropout_ratio\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=12944,\n  serialized_end=12990,\n)\n\n\n_DUMMYDATAPARAMETER = _descriptor.Descriptor(\n  name=\'DummyDataParameter\',\n  full_name=\'caffe.DummyDataParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'data_filler\', full_name=\'caffe.DummyDataParameter.data_filler\', index=0,\n      number=1, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shape\', full_name=\'caffe.DummyDataParameter.shape\', index=1,\n      number=6, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num\', full_name=\'caffe.DummyDataParameter.num\', index=2,\n      number=2, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'channels\', full_name=\'caffe.DummyDataParameter.channels\', index=3,\n      number=3, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'height\', full_name=\'caffe.DummyDataParameter.height\', index=4,\n      number=4, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'width\', full_name=\'caffe.DummyDataParameter.width\', index=5,\n      number=5, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=12993,\n  serialized_end=13153,\n)\n\n\n_ELTWISEPARAMETER = _descriptor.Descriptor(\n  name=\'EltwiseParameter\',\n  full_name=\'caffe.EltwiseParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'operation\', full_name=\'caffe.EltwiseParameter.operation\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'coeff\', full_name=\'caffe.EltwiseParameter.coeff\', index=1,\n      number=2, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stable_prod_grad\', full_name=\'caffe.EltwiseParameter.stable_prod_grad\', index=2,\n      number=3, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _ELTWISEPARAMETER_ELTWISEOP,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13156,\n  serialized_end=13321,\n)\n\n\n_ELUPARAMETER = _descriptor.Descriptor(\n  name=\'ELUParameter\',\n  full_name=\'caffe.ELUParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'alpha\', full_name=\'caffe.ELUParameter.alpha\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13323,\n  serialized_end=13355,\n)\n\n\n_EMBEDPARAMETER = _descriptor.Descriptor(\n  name=\'EmbedParameter\',\n  full_name=\'caffe.EmbedParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'num_output\', full_name=\'caffe.EmbedParameter.num_output\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'input_dim\', full_name=\'caffe.EmbedParameter.input_dim\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_term\', full_name=\'caffe.EmbedParameter.bias_term\', index=2,\n      number=3, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_filler\', full_name=\'caffe.EmbedParameter.weight_filler\', index=3,\n      number=4, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_filler\', full_name=\'caffe.EmbedParameter.bias_filler\', index=4,\n      number=5, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13358,\n  serialized_end=13530,\n)\n\n\n_EXPPARAMETER = _descriptor.Descriptor(\n  name=\'ExpParameter\',\n  full_name=\'caffe.ExpParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'base\', full_name=\'caffe.ExpParameter.base\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.ExpParameter.scale\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shift\', full_name=\'caffe.ExpParameter.shift\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13532,\n  serialized_end=13600,\n)\n\n\n_EXPMAXPARAMETER = _descriptor.Descriptor(\n  name=\'ExpMaxParameter\',\n  full_name=\'caffe.ExpMaxParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'base\', full_name=\'caffe.ExpMaxParameter.base\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.ExpMaxParameter.scale\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shift\', full_name=\'caffe.ExpMaxParameter.shift\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13602,\n  serialized_end=13673,\n)\n\n\n_FLATTENPARAMETER = _descriptor.Descriptor(\n  name=\'FlattenParameter\',\n  full_name=\'caffe.FlattenParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.FlattenParameter.axis\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'end_axis\', full_name=\'caffe.FlattenParameter.end_axis\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13675,\n  serialized_end=13732,\n)\n\n\n_HDF5DATAPARAMETER = _descriptor.Descriptor(\n  name=\'HDF5DataParameter\',\n  full_name=\'caffe.HDF5DataParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'source\', full_name=\'caffe.HDF5DataParameter.source\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batch_size\', full_name=\'caffe.HDF5DataParameter.batch_size\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shuffle\', full_name=\'caffe.HDF5DataParameter.shuffle\', index=2,\n      number=3, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13734,\n  serialized_end=13813,\n)\n\n\n_HDF5OUTPUTPARAMETER = _descriptor.Descriptor(\n  name=\'HDF5OutputParameter\',\n  full_name=\'caffe.HDF5OutputParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'file_name\', full_name=\'caffe.HDF5OutputParameter.file_name\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13815,\n  serialized_end=13855,\n)\n\n\n_HINGELOSSPARAMETER = _descriptor.Descriptor(\n  name=\'HingeLossParameter\',\n  full_name=\'caffe.HingeLossParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'norm\', full_name=\'caffe.HingeLossParameter.norm\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _HINGELOSSPARAMETER_NORM,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13857,\n  serialized_end=13951,\n)\n\n\n_IMAGEDATAPARAMETER = _descriptor.Descriptor(\n  name=\'ImageDataParameter\',\n  full_name=\'caffe.ImageDataParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'source\', full_name=\'caffe.ImageDataParameter.source\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batch_size\', full_name=\'caffe.ImageDataParameter.batch_size\', index=1,\n      number=4, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rand_skip\', full_name=\'caffe.ImageDataParameter.rand_skip\', index=2,\n      number=7, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shuffle\', full_name=\'caffe.ImageDataParameter.shuffle\', index=3,\n      number=8, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'new_height\', full_name=\'caffe.ImageDataParameter.new_height\', index=4,\n      number=9, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'new_width\', full_name=\'caffe.ImageDataParameter.new_width\', index=5,\n      number=10, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'is_color\', full_name=\'caffe.ImageDataParameter.is_color\', index=6,\n      number=11, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.ImageDataParameter.scale\', index=7,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_file\', full_name=\'caffe.ImageDataParameter.mean_file\', index=8,\n      number=3, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_size\', full_name=\'caffe.ImageDataParameter.crop_size\', index=9,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.ImageDataParameter.mirror\', index=10,\n      number=6, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'root_folder\', full_name=\'caffe.ImageDataParameter.root_folder\', index=11,\n      number=12, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=13954,\n  serialized_end=14233,\n)\n\n\n_INFOGAINLOSSPARAMETER = _descriptor.Descriptor(\n  name=\'InfogainLossParameter\',\n  full_name=\'caffe.InfogainLossParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'source\', full_name=\'caffe.InfogainLossParameter.source\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=14235,\n  serialized_end=14274,\n)\n\n\n_INNERPRODUCTPARAMETER = _descriptor.Descriptor(\n  name=\'InnerProductParameter\',\n  full_name=\'caffe.InnerProductParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'num_output\', full_name=\'caffe.InnerProductParameter.num_output\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_term\', full_name=\'caffe.InnerProductParameter.bias_term\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_filler\', full_name=\'caffe.InnerProductParameter.weight_filler\', index=2,\n      number=3, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_filler\', full_name=\'caffe.InnerProductParameter.bias_filler\', index=3,\n      number=4, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.InnerProductParameter.axis\', index=4,\n      number=5, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'transpose\', full_name=\'caffe.InnerProductParameter.transpose\', index=5,\n      number=6, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=14277,\n  serialized_end=14480,\n)\n\n\n_INPUTPARAMETER = _descriptor.Descriptor(\n  name=\'InputParameter\',\n  full_name=\'caffe.InputParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'shape\', full_name=\'caffe.InputParameter.shape\', index=0,\n      number=1, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=14482,\n  serialized_end=14531,\n)\n\n\n_LOGPARAMETER = _descriptor.Descriptor(\n  name=\'LogParameter\',\n  full_name=\'caffe.LogParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'base\', full_name=\'caffe.LogParameter.base\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.LogParameter.scale\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shift\', full_name=\'caffe.LogParameter.shift\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=14533,\n  serialized_end=14601,\n)\n\n\n_LRNPARAMETER = _descriptor.Descriptor(\n  name=\'LRNParameter\',\n  full_name=\'caffe.LRNParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'local_size\', full_name=\'caffe.LRNParameter.local_size\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'alpha\', full_name=\'caffe.LRNParameter.alpha\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'beta\', full_name=\'caffe.LRNParameter.beta\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.75,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'norm_region\', full_name=\'caffe.LRNParameter.norm_region\', index=3,\n      number=4, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'k\', full_name=\'caffe.LRNParameter.k\', index=4,\n      number=5, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.LRNParameter.engine\', index=5,\n      number=6, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shift\', full_name=\'caffe.LRNParameter.shift\', index=6,\n      number=7, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _LRNPARAMETER_NORMREGION,\n    _LRNPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=14604,\n  serialized_end=14934,\n)\n\n\n_MEMORYDATAPARAMETER = _descriptor.Descriptor(\n  name=\'MemoryDataParameter\',\n  full_name=\'caffe.MemoryDataParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'batch_size\', full_name=\'caffe.MemoryDataParameter.batch_size\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'channels\', full_name=\'caffe.MemoryDataParameter.channels\', index=1,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'height\', full_name=\'caffe.MemoryDataParameter.height\', index=2,\n      number=3, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'width\', full_name=\'caffe.MemoryDataParameter.width\', index=3,\n      number=4, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=14936,\n  serialized_end=15026,\n)\n\n\n_MVNPARAMETER = _descriptor.Descriptor(\n  name=\'MVNParameter\',\n  full_name=\'caffe.MVNParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'normalize_variance\', full_name=\'caffe.MVNParameter.normalize_variance\', index=0,\n      number=1, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'across_channels\', full_name=\'caffe.MVNParameter.across_channels\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'eps\', full_name=\'caffe.MVNParameter.eps\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1e-09,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15028,\n  serialized_end=15128,\n)\n\n\n_PARAMETERPARAMETER = _descriptor.Descriptor(\n  name=\'ParameterParameter\',\n  full_name=\'caffe.ParameterParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'shape\', full_name=\'caffe.ParameterParameter.shape\', index=0,\n      number=1, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15130,\n  serialized_end=15183,\n)\n\n\n_POOLINGPARAMETER = _descriptor.Descriptor(\n  name=\'PoolingParameter\',\n  full_name=\'caffe.PoolingParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'pool\', full_name=\'caffe.PoolingParameter.pool\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad\', full_name=\'caffe.PoolingParameter.pad\', index=1,\n      number=4, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad_h\', full_name=\'caffe.PoolingParameter.pad_h\', index=2,\n      number=9, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad_w\', full_name=\'caffe.PoolingParameter.pad_w\', index=3,\n      number=10, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_size\', full_name=\'caffe.PoolingParameter.kernel_size\', index=4,\n      number=2, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_h\', full_name=\'caffe.PoolingParameter.kernel_h\', index=5,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernel_w\', full_name=\'caffe.PoolingParameter.kernel_w\', index=6,\n      number=6, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride\', full_name=\'caffe.PoolingParameter.stride\', index=7,\n      number=3, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride_h\', full_name=\'caffe.PoolingParameter.stride_h\', index=8,\n      number=7, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride_w\', full_name=\'caffe.PoolingParameter.stride_w\', index=9,\n      number=8, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.PoolingParameter.engine\', index=10,\n      number=11, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'global_pooling\', full_name=\'caffe.PoolingParameter.global_pooling\', index=11,\n      number=12, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _POOLINGPARAMETER_POOLMETHOD,\n    _POOLINGPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15186,\n  serialized_end=15604,\n)\n\n\n_POWERPARAMETER = _descriptor.Descriptor(\n  name=\'PowerParameter\',\n  full_name=\'caffe.PowerParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'power\', full_name=\'caffe.PowerParameter.power\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.PowerParameter.scale\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shift\', full_name=\'caffe.PowerParameter.shift\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15606,\n  serialized_end=15676,\n)\n\n\n_NEGSQUAREPARAMETER = _descriptor.Descriptor(\n  name=\'NegSquareParameter\',\n  full_name=\'caffe.NegSquareParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15678,\n  serialized_end=15698,\n)\n\n\n_PYTHONPARAMETER = _descriptor.Descriptor(\n  name=\'PythonParameter\',\n  full_name=\'caffe.PythonParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'module\', full_name=\'caffe.PythonParameter.module\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'layer\', full_name=\'caffe.PythonParameter.layer\', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'param_str\', full_name=\'caffe.PythonParameter.param_str\', index=2,\n      number=3, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'share_in_parallel\', full_name=\'caffe.PythonParameter.share_in_parallel\', index=3,\n      number=4, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15700,\n  serialized_end=15803,\n)\n\n\n_RECURRENTPARAMETER = _descriptor.Descriptor(\n  name=\'RecurrentParameter\',\n  full_name=\'caffe.RecurrentParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'num_output\', full_name=\'caffe.RecurrentParameter.num_output\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_filler\', full_name=\'caffe.RecurrentParameter.weight_filler\', index=1,\n      number=2, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_filler\', full_name=\'caffe.RecurrentParameter.bias_filler\', index=2,\n      number=3, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'debug_info\', full_name=\'caffe.RecurrentParameter.debug_info\', index=3,\n      number=4, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'expose_hidden\', full_name=\'caffe.RecurrentParameter.expose_hidden\', index=4,\n      number=5, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=15806,\n  serialized_end=15998,\n)\n\n\n_REDUCTIONPARAMETER = _descriptor.Descriptor(\n  name=\'ReductionParameter\',\n  full_name=\'caffe.ReductionParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'operation\', full_name=\'caffe.ReductionParameter.operation\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.ReductionParameter.axis\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'coeff\', full_name=\'caffe.ReductionParameter.coeff\', index=2,\n      number=3, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _REDUCTIONPARAMETER_REDUCTIONOP,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16001,\n  serialized_end=16174,\n)\n\n\n_RELUPARAMETER = _descriptor.Descriptor(\n  name=\'ReLUParameter\',\n  full_name=\'caffe.ReLUParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'negative_slope\', full_name=\'caffe.ReLUParameter.negative_slope\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.ReLUParameter.engine\', index=1,\n      number=2, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _RELUPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16177,\n  serialized_end=16318,\n)\n\n\n_RESHAPEPARAMETER = _descriptor.Descriptor(\n  name=\'ReshapeParameter\',\n  full_name=\'caffe.ReshapeParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'shape\', full_name=\'caffe.ReshapeParameter.shape\', index=0,\n      number=1, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.ReshapeParameter.axis\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num_axes\', full_name=\'caffe.ReshapeParameter.num_axes\', index=2,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=-1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16320,\n  serialized_end=16410,\n)\n\n\n_SCALEPARAMETER = _descriptor.Descriptor(\n  name=\'ScaleParameter\',\n  full_name=\'caffe.ScaleParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.ScaleParameter.axis\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num_axes\', full_name=\'caffe.ScaleParameter.num_axes\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'filler\', full_name=\'caffe.ScaleParameter.filler\', index=2,\n      number=3, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_term\', full_name=\'caffe.ScaleParameter.bias_term\', index=3,\n      number=4, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_filler\', full_name=\'caffe.ScaleParameter.bias_filler\', index=4,\n      number=5, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16413,\n  serialized_end=16578,\n)\n\n\n_SIGMOIDPARAMETER = _descriptor.Descriptor(\n  name=\'SigmoidParameter\',\n  full_name=\'caffe.SigmoidParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.SigmoidParameter.engine\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _SIGMOIDPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16580,\n  serialized_end=16700,\n)\n\n\n_SLICEPARAMETER = _descriptor.Descriptor(\n  name=\'SliceParameter\',\n  full_name=\'caffe.SliceParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.SliceParameter.axis\', index=0,\n      number=3, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'slice_point\', full_name=\'caffe.SliceParameter.slice_point\', index=1,\n      number=2, type=13, cpp_type=3, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'slice_dim\', full_name=\'caffe.SliceParameter.slice_dim\', index=2,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16702,\n  serialized_end=16778,\n)\n\n\n_SOFTMAXPARAMETER = _descriptor.Descriptor(\n  name=\'SoftmaxParameter\',\n  full_name=\'caffe.SoftmaxParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.SoftmaxParameter.engine\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.SoftmaxParameter.axis\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _SOFTMAXPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16781,\n  serialized_end=16918,\n)\n\n\n_TANHPARAMETER = _descriptor.Descriptor(\n  name=\'TanHParameter\',\n  full_name=\'caffe.TanHParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.TanHParameter.engine\', index=0,\n      number=1, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _TANHPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=16920,\n  serialized_end=17034,\n)\n\n\n_TILEPARAMETER = _descriptor.Descriptor(\n  name=\'TileParameter\',\n  full_name=\'caffe.TileParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'axis\', full_name=\'caffe.TileParameter.axis\', index=0,\n      number=1, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'tiles\', full_name=\'caffe.TileParameter.tiles\', index=1,\n      number=2, type=5, cpp_type=1, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=17036,\n  serialized_end=17083,\n)\n\n\n_THRESHOLDPARAMETER = _descriptor.Descriptor(\n  name=\'ThresholdParameter\',\n  full_name=\'caffe.ThresholdParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'threshold\', full_name=\'caffe.ThresholdParameter.threshold\', index=0,\n      number=1, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=17085,\n  serialized_end=17127,\n)\n\n\n_WINDOWDATAPARAMETER = _descriptor.Descriptor(\n  name=\'WindowDataParameter\',\n  full_name=\'caffe.WindowDataParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'source\', full_name=\'caffe.WindowDataParameter.source\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.WindowDataParameter.scale\', index=1,\n      number=2, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mean_file\', full_name=\'caffe.WindowDataParameter.mean_file\', index=2,\n      number=3, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batch_size\', full_name=\'caffe.WindowDataParameter.batch_size\', index=3,\n      number=4, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_size\', full_name=\'caffe.WindowDataParameter.crop_size\', index=4,\n      number=5, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.WindowDataParameter.mirror\', index=5,\n      number=6, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'fg_threshold\', full_name=\'caffe.WindowDataParameter.fg_threshold\', index=6,\n      number=7, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bg_threshold\', full_name=\'caffe.WindowDataParameter.bg_threshold\', index=7,\n      number=8, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'fg_fraction\', full_name=\'caffe.WindowDataParameter.fg_fraction\', index=8,\n      number=9, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.25,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'context_pad\', full_name=\'caffe.WindowDataParameter.context_pad\', index=9,\n      number=10, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'crop_mode\', full_name=\'caffe.WindowDataParameter.crop_mode\', index=10,\n      number=11, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""warp"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'cache_images\', full_name=\'caffe.WindowDataParameter.cache_images\', index=11,\n      number=12, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'root_folder\', full_name=\'caffe.WindowDataParameter.root_folder\', index=12,\n      number=13, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=17130,\n  serialized_end=17451,\n)\n\n\n_SPPPARAMETER = _descriptor.Descriptor(\n  name=\'SPPParameter\',\n  full_name=\'caffe.SPPParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'pyramid_height\', full_name=\'caffe.SPPParameter.pyramid_height\', index=0,\n      number=1, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pool\', full_name=\'caffe.SPPParameter.pool\', index=1,\n      number=2, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'engine\', full_name=\'caffe.SPPParameter.engine\', index=2,\n      number=6, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _SPPPARAMETER_POOLMETHOD,\n    _SPPPARAMETER_ENGINE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=17454,\n  serialized_end=17689,\n)\n\n\n_V1LAYERPARAMETER = _descriptor.Descriptor(\n  name=\'V1LayerParameter\',\n  full_name=\'caffe.V1LayerParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'bottom\', full_name=\'caffe.V1LayerParameter.bottom\', index=0,\n      number=2, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'top\', full_name=\'caffe.V1LayerParameter.top\', index=1,\n      number=3, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'name\', full_name=\'caffe.V1LayerParameter.name\', index=2,\n      number=4, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'include\', full_name=\'caffe.V1LayerParameter.include\', index=3,\n      number=32, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'exclude\', full_name=\'caffe.V1LayerParameter.exclude\', index=4,\n      number=33, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'type\', full_name=\'caffe.V1LayerParameter.type\', index=5,\n      number=5, type=14, cpp_type=8, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'blobs\', full_name=\'caffe.V1LayerParameter.blobs\', index=6,\n      number=6, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'param\', full_name=\'caffe.V1LayerParameter.param\', index=7,\n      number=1001, type=9, cpp_type=9, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'blob_share_mode\', full_name=\'caffe.V1LayerParameter.blob_share_mode\', index=8,\n      number=1002, type=14, cpp_type=8, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'blobs_lr\', full_name=\'caffe.V1LayerParameter.blobs_lr\', index=9,\n      number=7, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_decay\', full_name=\'caffe.V1LayerParameter.weight_decay\', index=10,\n      number=8, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'loss_weight\', full_name=\'caffe.V1LayerParameter.loss_weight\', index=11,\n      number=35, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'accuracy_param\', full_name=\'caffe.V1LayerParameter.accuracy_param\', index=12,\n      number=27, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'argmax_param\', full_name=\'caffe.V1LayerParameter.argmax_param\', index=13,\n      number=23, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'concat_param\', full_name=\'caffe.V1LayerParameter.concat_param\', index=14,\n      number=9, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'contrastive_loss_param\', full_name=\'caffe.V1LayerParameter.contrastive_loss_param\', index=15,\n      number=40, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'convolution_param\', full_name=\'caffe.V1LayerParameter.convolution_param\', index=16,\n      number=10, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'data_param\', full_name=\'caffe.V1LayerParameter.data_param\', index=17,\n      number=11, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dropout_param\', full_name=\'caffe.V1LayerParameter.dropout_param\', index=18,\n      number=12, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dummy_data_param\', full_name=\'caffe.V1LayerParameter.dummy_data_param\', index=19,\n      number=26, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'eltwise_param\', full_name=\'caffe.V1LayerParameter.eltwise_param\', index=20,\n      number=24, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'exp_param\', full_name=\'caffe.V1LayerParameter.exp_param\', index=21,\n      number=41, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hdf5_data_param\', full_name=\'caffe.V1LayerParameter.hdf5_data_param\', index=22,\n      number=13, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hdf5_output_param\', full_name=\'caffe.V1LayerParameter.hdf5_output_param\', index=23,\n      number=14, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hinge_loss_param\', full_name=\'caffe.V1LayerParameter.hinge_loss_param\', index=24,\n      number=29, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'image_data_param\', full_name=\'caffe.V1LayerParameter.image_data_param\', index=25,\n      number=15, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'infogain_loss_param\', full_name=\'caffe.V1LayerParameter.infogain_loss_param\', index=26,\n      number=16, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'inner_product_param\', full_name=\'caffe.V1LayerParameter.inner_product_param\', index=27,\n      number=17, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'lrn_param\', full_name=\'caffe.V1LayerParameter.lrn_param\', index=28,\n      number=18, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'memory_data_param\', full_name=\'caffe.V1LayerParameter.memory_data_param\', index=29,\n      number=22, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mvn_param\', full_name=\'caffe.V1LayerParameter.mvn_param\', index=30,\n      number=34, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pooling_param\', full_name=\'caffe.V1LayerParameter.pooling_param\', index=31,\n      number=19, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'power_param\', full_name=\'caffe.V1LayerParameter.power_param\', index=32,\n      number=21, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'relu_param\', full_name=\'caffe.V1LayerParameter.relu_param\', index=33,\n      number=30, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'sigmoid_param\', full_name=\'caffe.V1LayerParameter.sigmoid_param\', index=34,\n      number=38, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'softmax_param\', full_name=\'caffe.V1LayerParameter.softmax_param\', index=35,\n      number=39, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'slice_param\', full_name=\'caffe.V1LayerParameter.slice_param\', index=36,\n      number=31, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'tanh_param\', full_name=\'caffe.V1LayerParameter.tanh_param\', index=37,\n      number=37, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'threshold_param\', full_name=\'caffe.V1LayerParameter.threshold_param\', index=38,\n      number=25, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'window_data_param\', full_name=\'caffe.V1LayerParameter.window_data_param\', index=39,\n      number=20, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'transform_param\', full_name=\'caffe.V1LayerParameter.transform_param\', index=40,\n      number=36, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'loss_param\', full_name=\'caffe.V1LayerParameter.loss_param\', index=41,\n      number=42, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'layer\', full_name=\'caffe.V1LayerParameter.layer\', index=42,\n      number=1, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _V1LAYERPARAMETER_LAYERTYPE,\n    _V1LAYERPARAMETER_DIMCHECKMODE,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=17692,\n  serialized_end=20220,\n)\n\n\n_V0LAYERPARAMETER = _descriptor.Descriptor(\n  name=\'V0LayerParameter\',\n  full_name=\'caffe.V0LayerParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'name\', full_name=\'caffe.V0LayerParameter.name\', index=0,\n      number=1, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'type\', full_name=\'caffe.V0LayerParameter.type\', index=1,\n      number=2, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'num_output\', full_name=\'caffe.V0LayerParameter.num_output\', index=2,\n      number=3, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'biasterm\', full_name=\'caffe.V0LayerParameter.biasterm\', index=3,\n      number=4, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=True,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_filler\', full_name=\'caffe.V0LayerParameter.weight_filler\', index=4,\n      number=5, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'bias_filler\', full_name=\'caffe.V0LayerParameter.bias_filler\', index=5,\n      number=6, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pad\', full_name=\'caffe.V0LayerParameter.pad\', index=6,\n      number=7, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'kernelsize\', full_name=\'caffe.V0LayerParameter.kernelsize\', index=7,\n      number=8, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'group\', full_name=\'caffe.V0LayerParameter.group\', index=8,\n      number=9, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'stride\', full_name=\'caffe.V0LayerParameter.stride\', index=9,\n      number=10, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'pool\', full_name=\'caffe.V0LayerParameter.pool\', index=10,\n      number=11, type=14, cpp_type=8, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'dropout_ratio\', full_name=\'caffe.V0LayerParameter.dropout_ratio\', index=11,\n      number=12, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'local_size\', full_name=\'caffe.V0LayerParameter.local_size\', index=12,\n      number=13, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'alpha\', full_name=\'caffe.V0LayerParameter.alpha\', index=13,\n      number=14, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'beta\', full_name=\'caffe.V0LayerParameter.beta\', index=14,\n      number=15, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.75,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'k\', full_name=\'caffe.V0LayerParameter.k\', index=15,\n      number=22, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'source\', full_name=\'caffe.V0LayerParameter.source\', index=16,\n      number=16, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'scale\', full_name=\'caffe.V0LayerParameter.scale\', index=17,\n      number=17, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'meanfile\', full_name=\'caffe.V0LayerParameter.meanfile\', index=18,\n      number=18, type=9, cpp_type=9, label=1,\n      has_default_value=False, default_value=unicode("""", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'batchsize\', full_name=\'caffe.V0LayerParameter.batchsize\', index=19,\n      number=19, type=13, cpp_type=3, label=1,\n      has_default_value=False, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'cropsize\', full_name=\'caffe.V0LayerParameter.cropsize\', index=20,\n      number=20, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'mirror\', full_name=\'caffe.V0LayerParameter.mirror\', index=21,\n      number=21, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'blobs\', full_name=\'caffe.V0LayerParameter.blobs\', index=22,\n      number=50, type=11, cpp_type=10, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'blobs_lr\', full_name=\'caffe.V0LayerParameter.blobs_lr\', index=23,\n      number=51, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'weight_decay\', full_name=\'caffe.V0LayerParameter.weight_decay\', index=24,\n      number=52, type=2, cpp_type=6, label=3,\n      has_default_value=False, default_value=[],\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'rand_skip\', full_name=\'caffe.V0LayerParameter.rand_skip\', index=25,\n      number=53, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'det_fg_threshold\', full_name=\'caffe.V0LayerParameter.det_fg_threshold\', index=26,\n      number=54, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'det_bg_threshold\', full_name=\'caffe.V0LayerParameter.det_bg_threshold\', index=27,\n      number=55, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.5,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'det_fg_fraction\', full_name=\'caffe.V0LayerParameter.det_fg_fraction\', index=28,\n      number=56, type=2, cpp_type=6, label=1,\n      has_default_value=True, default_value=0.25,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'det_context_pad\', full_name=\'caffe.V0LayerParameter.det_context_pad\', index=29,\n      number=58, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'det_crop_mode\', full_name=\'caffe.V0LayerParameter.det_crop_mode\', index=30,\n      number=59, type=9, cpp_type=9, label=1,\n      has_default_value=True, default_value=unicode(""warp"", ""utf-8""),\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'new_num\', full_name=\'caffe.V0LayerParameter.new_num\', index=31,\n      number=60, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'new_channels\', full_name=\'caffe.V0LayerParameter.new_channels\', index=32,\n      number=61, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'new_height\', full_name=\'caffe.V0LayerParameter.new_height\', index=33,\n      number=62, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'new_width\', full_name=\'caffe.V0LayerParameter.new_width\', index=34,\n      number=63, type=5, cpp_type=1, label=1,\n      has_default_value=True, default_value=0,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'shuffle_images\', full_name=\'caffe.V0LayerParameter.shuffle_images\', index=35,\n      number=64, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'concat_dim\', full_name=\'caffe.V0LayerParameter.concat_dim\', index=36,\n      number=65, type=13, cpp_type=3, label=1,\n      has_default_value=True, default_value=1,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'hdf5_output_param\', full_name=\'caffe.V0LayerParameter.hdf5_output_param\', index=37,\n      number=1001, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n    _V0LAYERPARAMETER_POOLMETHOD,\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=20223,\n  serialized_end=21244,\n)\n\n\n_PRELUPARAMETER = _descriptor.Descriptor(\n  name=\'PReLUParameter\',\n  full_name=\'caffe.PReLUParameter\',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name=\'filler\', full_name=\'caffe.PReLUParameter.filler\', index=0,\n      number=1, type=11, cpp_type=10, label=1,\n      has_default_value=False, default_value=None,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n    _descriptor.FieldDescriptor(\n      name=\'channel_shared\', full_name=\'caffe.PReLUParameter.channel_shared\', index=1,\n      number=2, type=8, cpp_type=7, label=1,\n      has_default_value=True, default_value=False,\n      message_type=None, enum_type=None, containing_type=None,\n      is_extension=False, extension_scope=None,\n      options=None),\n  ],\n  extensions=[\n  ],\n  nested_types=[],\n  enum_types=[\n  ],\n  options=None,\n  is_extendable=False,\n  extension_ranges=[],\n  serialized_start=21246,\n  serialized_end=21333,\n)\n\n_BLOBPROTO.fields_by_name[\'shape\'].message_type = _BLOBSHAPE\n_BLOBPROTOVECTOR.fields_by_name[\'blobs\'].message_type = _BLOBPROTO\n_FILLERPARAMETER.fields_by_name[\'variance_norm\'].enum_type = _FILLERPARAMETER_VARIANCENORM\n_FILLERPARAMETER_VARIANCENORM.containing_type = _FILLERPARAMETER;\n_NETPARAMETER.fields_by_name[\'input_shape\'].message_type = _BLOBSHAPE\n_NETPARAMETER.fields_by_name[\'state\'].message_type = _NETSTATE\n_NETPARAMETER.fields_by_name[\'layer\'].message_type = _LAYERPARAMETER\n_NETPARAMETER.fields_by_name[\'layers\'].message_type = _V1LAYERPARAMETER\n_SOLVERPARAMETER.fields_by_name[\'net_param\'].message_type = _NETPARAMETER\n_SOLVERPARAMETER.fields_by_name[\'train_net_param\'].message_type = _NETPARAMETER\n_SOLVERPARAMETER.fields_by_name[\'test_net_param\'].message_type = _NETPARAMETER\n_SOLVERPARAMETER.fields_by_name[\'train_state\'].message_type = _NETSTATE\n_SOLVERPARAMETER.fields_by_name[\'test_state\'].message_type = _NETSTATE\n_SOLVERPARAMETER.fields_by_name[\'snapshot_format\'].enum_type = _SOLVERPARAMETER_SNAPSHOTFORMAT\n_SOLVERPARAMETER.fields_by_name[\'solver_mode\'].enum_type = _SOLVERPARAMETER_SOLVERMODE\n_SOLVERPARAMETER.fields_by_name[\'solver_type\'].enum_type = _SOLVERPARAMETER_SOLVERTYPE\n_SOLVERPARAMETER_SNAPSHOTFORMAT.containing_type = _SOLVERPARAMETER;\n_SOLVERPARAMETER_SOLVERMODE.containing_type = _SOLVERPARAMETER;\n_SOLVERPARAMETER_SOLVERTYPE.containing_type = _SOLVERPARAMETER;\n_SOLVERSTATE.fields_by_name[\'history\'].message_type = _BLOBPROTO\n_NETSTATE.fields_by_name[\'phase\'].enum_type = _PHASE\n_NETSTATERULE.fields_by_name[\'phase\'].enum_type = _PHASE\n_PARAMSPEC.fields_by_name[\'share_mode\'].enum_type = _PARAMSPEC_DIMCHECKMODE\n_PARAMSPEC_DIMCHECKMODE.containing_type = _PARAMSPEC;\n_LAYERPARAMETER.fields_by_name[\'phase\'].enum_type = _PHASE\n_LAYERPARAMETER.fields_by_name[\'param\'].message_type = _PARAMSPEC\n_LAYERPARAMETER.fields_by_name[\'blobs\'].message_type = _BLOBPROTO\n_LAYERPARAMETER.fields_by_name[\'include\'].message_type = _NETSTATERULE\n_LAYERPARAMETER.fields_by_name[\'exclude\'].message_type = _NETSTATERULE\n_LAYERPARAMETER.fields_by_name[\'transform_param\'].message_type = _TRANSFORMATIONPARAMETER\n_LAYERPARAMETER.fields_by_name[\'loss_param\'].message_type = _LOSSPARAMETER\n_LAYERPARAMETER.fields_by_name[\'accuracy_param\'].message_type = _ACCURACYPARAMETER\n_LAYERPARAMETER.fields_by_name[\'argmax_param\'].message_type = _ARGMAXPARAMETER\n_LAYERPARAMETER.fields_by_name[\'batch_norm_param\'].message_type = _BATCHNORMPARAMETER\n_LAYERPARAMETER.fields_by_name[\'bias_param\'].message_type = _BIASPARAMETER\n_LAYERPARAMETER.fields_by_name[\'concat_param\'].message_type = _CONCATPARAMETER\n_LAYERPARAMETER.fields_by_name[\'contrastive_loss_param\'].message_type = _CONTRASTIVELOSSPARAMETER\n_LAYERPARAMETER.fields_by_name[\'convolution_param\'].message_type = _CONVOLUTIONPARAMETER\n_LAYERPARAMETER.fields_by_name[\'crop_param\'].message_type = _CROPPARAMETER\n_LAYERPARAMETER.fields_by_name[\'data_param\'].message_type = _DATAPARAMETER\n_LAYERPARAMETER.fields_by_name[\'dropout_param\'].message_type = _DROPOUTPARAMETER\n_LAYERPARAMETER.fields_by_name[\'dummy_data_param\'].message_type = _DUMMYDATAPARAMETER\n_LAYERPARAMETER.fields_by_name[\'eltwise_param\'].message_type = _ELTWISEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'elu_param\'].message_type = _ELUPARAMETER\n_LAYERPARAMETER.fields_by_name[\'embed_param\'].message_type = _EMBEDPARAMETER\n_LAYERPARAMETER.fields_by_name[\'exp_param\'].message_type = _EXPPARAMETER\n_LAYERPARAMETER.fields_by_name[\'expmax_param\'].message_type = _EXPMAXPARAMETER\n_LAYERPARAMETER.fields_by_name[\'flatten_param\'].message_type = _FLATTENPARAMETER\n_LAYERPARAMETER.fields_by_name[\'hdf5_data_param\'].message_type = _HDF5DATAPARAMETER\n_LAYERPARAMETER.fields_by_name[\'hdf5_output_param\'].message_type = _HDF5OUTPUTPARAMETER\n_LAYERPARAMETER.fields_by_name[\'hinge_loss_param\'].message_type = _HINGELOSSPARAMETER\n_LAYERPARAMETER.fields_by_name[\'image_data_param\'].message_type = _IMAGEDATAPARAMETER\n_LAYERPARAMETER.fields_by_name[\'infogain_loss_param\'].message_type = _INFOGAINLOSSPARAMETER\n_LAYERPARAMETER.fields_by_name[\'inner_product_param\'].message_type = _INNERPRODUCTPARAMETER\n_LAYERPARAMETER.fields_by_name[\'input_param\'].message_type = _INPUTPARAMETER\n_LAYERPARAMETER.fields_by_name[\'log_param\'].message_type = _LOGPARAMETER\n_LAYERPARAMETER.fields_by_name[\'lrn_param\'].message_type = _LRNPARAMETER\n_LAYERPARAMETER.fields_by_name[\'memory_data_param\'].message_type = _MEMORYDATAPARAMETER\n_LAYERPARAMETER.fields_by_name[\'mvn_param\'].message_type = _MVNPARAMETER\n_LAYERPARAMETER.fields_by_name[\'parameter_param\'].message_type = _PARAMETERPARAMETER\n_LAYERPARAMETER.fields_by_name[\'pooling_param\'].message_type = _POOLINGPARAMETER\n_LAYERPARAMETER.fields_by_name[\'power_param\'].message_type = _POWERPARAMETER\n_LAYERPARAMETER.fields_by_name[\'prelu_param\'].message_type = _PRELUPARAMETER\n_LAYERPARAMETER.fields_by_name[\'python_param\'].message_type = _PYTHONPARAMETER\n_LAYERPARAMETER.fields_by_name[\'recurrent_param\'].message_type = _RECURRENTPARAMETER\n_LAYERPARAMETER.fields_by_name[\'reduction_param\'].message_type = _REDUCTIONPARAMETER\n_LAYERPARAMETER.fields_by_name[\'relu_param\'].message_type = _RELUPARAMETER\n_LAYERPARAMETER.fields_by_name[\'reshape_param\'].message_type = _RESHAPEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'scale_param\'].message_type = _SCALEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'sigmoid_param\'].message_type = _SIGMOIDPARAMETER\n_LAYERPARAMETER.fields_by_name[\'softmax_param\'].message_type = _SOFTMAXPARAMETER\n_LAYERPARAMETER.fields_by_name[\'spp_param\'].message_type = _SPPPARAMETER\n_LAYERPARAMETER.fields_by_name[\'slice_param\'].message_type = _SLICEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'tanh_param\'].message_type = _TANHPARAMETER\n_LAYERPARAMETER.fields_by_name[\'threshold_param\'].message_type = _THRESHOLDPARAMETER\n_LAYERPARAMETER.fields_by_name[\'tile_param\'].message_type = _TILEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'window_data_param\'].message_type = _WINDOWDATAPARAMETER\n_LAYERPARAMETER.fields_by_name[\'coeff_schedule_param\'].message_type = _COEFFSCHEDULEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'augmentation_param\'].message_type = _AUGMENTATIONPARAMETER\n_LAYERPARAMETER.fields_by_name[\'correlation_param\'].message_type = _CORRELATIONPARAMETER\n_LAYERPARAMETER.fields_by_name[\'l1_loss_param\'].message_type = _L1LOSSPARAMETER\n_LAYERPARAMETER.fields_by_name[\'writer_param\'].message_type = _WRITERPARAMETER\n_LAYERPARAMETER.fields_by_name[\'reader_param\'].message_type = _READERPARAMETER\n_LAYERPARAMETER.fields_by_name[\'mean_param\'].message_type = _MEANPARAMETER\n_LAYERPARAMETER.fields_by_name[\'resample_param\'].message_type = _RESAMPLEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'downsample_param\'].message_type = _DOWNSAMPLEPARAMETER\n_LAYERPARAMETER.fields_by_name[\'negsquare_param\'].message_type = _NEGSQUAREPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'mirror\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'translate\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'rotate\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'zoom\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'squeeze\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'translate_x\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'translate_y\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'gamma\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'brightness\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'contrast\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'color\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'lmult_pow\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'lmult_mult\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'lmult_add\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'sat_pow\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'sat_mult\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'sat_add\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'col_pow\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'col_mult\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'col_add\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'ladd_pow\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'ladd_mult\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'ladd_add\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'col_rotate\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'fog_amount\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'fog_size\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'motion_blur_angle\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'motion_blur_size\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'shadow_angle\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'shadow_distance\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'shadow_strength\'].message_type = _RANDOMGENERATORPARAMETER\n_AUGMENTATIONPARAMETER.fields_by_name[\'noise\'].message_type = _RANDOMGENERATORPARAMETER\n_CORRELATIONPARAMETER.fields_by_name[\'correlation_type\'].enum_type = _CORRELATIONPARAMETER_CORRELATIONTYPE\n_CORRELATIONPARAMETER_CORRELATIONTYPE.containing_type = _CORRELATIONPARAMETER;\n_RESAMPLEPARAMETER.fields_by_name[\'type\'].enum_type = _RESAMPLEPARAMETER_RESAMPLETYPE\n_RESAMPLEPARAMETER_RESAMPLETYPE.containing_type = _RESAMPLEPARAMETER;\n_MEANPARAMETER.fields_by_name[\'operation\'].enum_type = _MEANPARAMETER_MEANOPERATION\n_MEANPARAMETER_MEANOPERATION.containing_type = _MEANPARAMETER;\n_LOSSPARAMETER.fields_by_name[\'normalization\'].enum_type = _LOSSPARAMETER_NORMALIZATIONMODE\n_LOSSPARAMETER_NORMALIZATIONMODE.containing_type = _LOSSPARAMETER;\n_BIASPARAMETER.fields_by_name[\'filler\'].message_type = _FILLERPARAMETER\n_CONVOLUTIONPARAMETER.fields_by_name[\'weight_filler\'].message_type = _FILLERPARAMETER\n_CONVOLUTIONPARAMETER.fields_by_name[\'bias_filler\'].message_type = _FILLERPARAMETER\n_CONVOLUTIONPARAMETER.fields_by_name[\'engine\'].enum_type = _CONVOLUTIONPARAMETER_ENGINE\n_CONVOLUTIONPARAMETER_ENGINE.containing_type = _CONVOLUTIONPARAMETER;\n_DATAPARAMETER.fields_by_name[\'backend\'].enum_type = _DATAPARAMETER_DB\n_DATAPARAMETER.fields_by_name[\'rand_permute_order\'].enum_type = _DATAPARAMETER_RANDPERMORDER\n_DATAPARAMETER.fields_by_name[\'encoding\'].enum_type = _DATAPARAMETER_CHANNELENCODING\n_DATAPARAMETER_DB.containing_type = _DATAPARAMETER;\n_DATAPARAMETER_CHANNELENCODING.containing_type = _DATAPARAMETER;\n_DATAPARAMETER_RANDPERMORDER.containing_type = _DATAPARAMETER;\n_DUMMYDATAPARAMETER.fields_by_name[\'data_filler\'].message_type = _FILLERPARAMETER\n_DUMMYDATAPARAMETER.fields_by_name[\'shape\'].message_type = _BLOBSHAPE\n_ELTWISEPARAMETER.fields_by_name[\'operation\'].enum_type = _ELTWISEPARAMETER_ELTWISEOP\n_ELTWISEPARAMETER_ELTWISEOP.containing_type = _ELTWISEPARAMETER;\n_EMBEDPARAMETER.fields_by_name[\'weight_filler\'].message_type = _FILLERPARAMETER\n_EMBEDPARAMETER.fields_by_name[\'bias_filler\'].message_type = _FILLERPARAMETER\n_HINGELOSSPARAMETER.fields_by_name[\'norm\'].enum_type = _HINGELOSSPARAMETER_NORM\n_HINGELOSSPARAMETER_NORM.containing_type = _HINGELOSSPARAMETER;\n_INNERPRODUCTPARAMETER.fields_by_name[\'weight_filler\'].message_type = _FILLERPARAMETER\n_INNERPRODUCTPARAMETER.fields_by_name[\'bias_filler\'].message_type = _FILLERPARAMETER\n_INPUTPARAMETER.fields_by_name[\'shape\'].message_type = _BLOBSHAPE\n_LRNPARAMETER.fields_by_name[\'norm_region\'].enum_type = _LRNPARAMETER_NORMREGION\n_LRNPARAMETER.fields_by_name[\'engine\'].enum_type = _LRNPARAMETER_ENGINE\n_LRNPARAMETER_NORMREGION.containing_type = _LRNPARAMETER;\n_LRNPARAMETER_ENGINE.containing_type = _LRNPARAMETER;\n_PARAMETERPARAMETER.fields_by_name[\'shape\'].message_type = _BLOBSHAPE\n_POOLINGPARAMETER.fields_by_name[\'pool\'].enum_type = _POOLINGPARAMETER_POOLMETHOD\n_POOLINGPARAMETER.fields_by_name[\'engine\'].enum_type = _POOLINGPARAMETER_ENGINE\n_POOLINGPARAMETER_POOLMETHOD.containing_type = _POOLINGPARAMETER;\n_POOLINGPARAMETER_ENGINE.containing_type = _POOLINGPARAMETER;\n_RECURRENTPARAMETER.fields_by_name[\'weight_filler\'].message_type = _FILLERPARAMETER\n_RECURRENTPARAMETER.fields_by_name[\'bias_filler\'].message_type = _FILLERPARAMETER\n_REDUCTIONPARAMETER.fields_by_name[\'operation\'].enum_type = _REDUCTIONPARAMETER_REDUCTIONOP\n_REDUCTIONPARAMETER_REDUCTIONOP.containing_type = _REDUCTIONPARAMETER;\n_RELUPARAMETER.fields_by_name[\'engine\'].enum_type = _RELUPARAMETER_ENGINE\n_RELUPARAMETER_ENGINE.containing_type = _RELUPARAMETER;\n_RESHAPEPARAMETER.fields_by_name[\'shape\'].message_type = _BLOBSHAPE\n_SCALEPARAMETER.fields_by_name[\'filler\'].message_type = _FILLERPARAMETER\n_SCALEPARAMETER.fields_by_name[\'bias_filler\'].message_type = _FILLERPARAMETER\n_SIGMOIDPARAMETER.fields_by_name[\'engine\'].enum_type = _SIGMOIDPARAMETER_ENGINE\n_SIGMOIDPARAMETER_ENGINE.containing_type = _SIGMOIDPARAMETER;\n_SOFTMAXPARAMETER.fields_by_name[\'engine\'].enum_type = _SOFTMAXPARAMETER_ENGINE\n_SOFTMAXPARAMETER_ENGINE.containing_type = _SOFTMAXPARAMETER;\n_TANHPARAMETER.fields_by_name[\'engine\'].enum_type = _TANHPARAMETER_ENGINE\n_TANHPARAMETER_ENGINE.containing_type = _TANHPARAMETER;\n_SPPPARAMETER.fields_by_name[\'pool\'].enum_type = _SPPPARAMETER_POOLMETHOD\n_SPPPARAMETER.fields_by_name[\'engine\'].enum_type = _SPPPARAMETER_ENGINE\n_SPPPARAMETER_POOLMETHOD.containing_type = _SPPPARAMETER;\n_SPPPARAMETER_ENGINE.containing_type = _SPPPARAMETER;\n_V1LAYERPARAMETER.fields_by_name[\'include\'].message_type = _NETSTATERULE\n_V1LAYERPARAMETER.fields_by_name[\'exclude\'].message_type = _NETSTATERULE\n_V1LAYERPARAMETER.fields_by_name[\'type\'].enum_type = _V1LAYERPARAMETER_LAYERTYPE\n_V1LAYERPARAMETER.fields_by_name[\'blobs\'].message_type = _BLOBPROTO\n_V1LAYERPARAMETER.fields_by_name[\'blob_share_mode\'].enum_type = _V1LAYERPARAMETER_DIMCHECKMODE\n_V1LAYERPARAMETER.fields_by_name[\'accuracy_param\'].message_type = _ACCURACYPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'argmax_param\'].message_type = _ARGMAXPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'concat_param\'].message_type = _CONCATPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'contrastive_loss_param\'].message_type = _CONTRASTIVELOSSPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'convolution_param\'].message_type = _CONVOLUTIONPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'data_param\'].message_type = _DATAPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'dropout_param\'].message_type = _DROPOUTPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'dummy_data_param\'].message_type = _DUMMYDATAPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'eltwise_param\'].message_type = _ELTWISEPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'exp_param\'].message_type = _EXPPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'hdf5_data_param\'].message_type = _HDF5DATAPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'hdf5_output_param\'].message_type = _HDF5OUTPUTPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'hinge_loss_param\'].message_type = _HINGELOSSPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'image_data_param\'].message_type = _IMAGEDATAPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'infogain_loss_param\'].message_type = _INFOGAINLOSSPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'inner_product_param\'].message_type = _INNERPRODUCTPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'lrn_param\'].message_type = _LRNPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'memory_data_param\'].message_type = _MEMORYDATAPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'mvn_param\'].message_type = _MVNPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'pooling_param\'].message_type = _POOLINGPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'power_param\'].message_type = _POWERPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'relu_param\'].message_type = _RELUPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'sigmoid_param\'].message_type = _SIGMOIDPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'softmax_param\'].message_type = _SOFTMAXPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'slice_param\'].message_type = _SLICEPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'tanh_param\'].message_type = _TANHPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'threshold_param\'].message_type = _THRESHOLDPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'window_data_param\'].message_type = _WINDOWDATAPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'transform_param\'].message_type = _TRANSFORMATIONPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'loss_param\'].message_type = _LOSSPARAMETER\n_V1LAYERPARAMETER.fields_by_name[\'layer\'].message_type = _V0LAYERPARAMETER\n_V1LAYERPARAMETER_LAYERTYPE.containing_type = _V1LAYERPARAMETER;\n_V1LAYERPARAMETER_DIMCHECKMODE.containing_type = _V1LAYERPARAMETER;\n_V0LAYERPARAMETER.fields_by_name[\'weight_filler\'].message_type = _FILLERPARAMETER\n_V0LAYERPARAMETER.fields_by_name[\'bias_filler\'].message_type = _FILLERPARAMETER\n_V0LAYERPARAMETER.fields_by_name[\'pool\'].enum_type = _V0LAYERPARAMETER_POOLMETHOD\n_V0LAYERPARAMETER.fields_by_name[\'blobs\'].message_type = _BLOBPROTO\n_V0LAYERPARAMETER.fields_by_name[\'hdf5_output_param\'].message_type = _HDF5OUTPUTPARAMETER\n_V0LAYERPARAMETER_POOLMETHOD.containing_type = _V0LAYERPARAMETER;\n_PRELUPARAMETER.fields_by_name[\'filler\'].message_type = _FILLERPARAMETER\nDESCRIPTOR.message_types_by_name[\'BlobShape\'] = _BLOBSHAPE\nDESCRIPTOR.message_types_by_name[\'BlobProto\'] = _BLOBPROTO\nDESCRIPTOR.message_types_by_name[\'BlobProtoVector\'] = _BLOBPROTOVECTOR\nDESCRIPTOR.message_types_by_name[\'Datum\'] = _DATUM\nDESCRIPTOR.message_types_by_name[\'FillerParameter\'] = _FILLERPARAMETER\nDESCRIPTOR.message_types_by_name[\'NetParameter\'] = _NETPARAMETER\nDESCRIPTOR.message_types_by_name[\'SolverParameter\'] = _SOLVERPARAMETER\nDESCRIPTOR.message_types_by_name[\'SolverState\'] = _SOLVERSTATE\nDESCRIPTOR.message_types_by_name[\'NetState\'] = _NETSTATE\nDESCRIPTOR.message_types_by_name[\'NetStateRule\'] = _NETSTATERULE\nDESCRIPTOR.message_types_by_name[\'ParamSpec\'] = _PARAMSPEC\nDESCRIPTOR.message_types_by_name[\'LayerParameter\'] = _LAYERPARAMETER\nDESCRIPTOR.message_types_by_name[\'GridParameter\'] = _GRIDPARAMETER\nDESCRIPTOR.message_types_by_name[\'AugmentationCoeff\'] = _AUGMENTATIONCOEFF\nDESCRIPTOR.message_types_by_name[\'AugmentationParameter\'] = _AUGMENTATIONPARAMETER\nDESCRIPTOR.message_types_by_name[\'RandomGeneratorParameter\'] = _RANDOMGENERATORPARAMETER\nDESCRIPTOR.message_types_by_name[\'L1LossParameter\'] = _L1LOSSPARAMETER\nDESCRIPTOR.message_types_by_name[\'CorrelationParameter\'] = _CORRELATIONPARAMETER\nDESCRIPTOR.message_types_by_name[\'DownsampleParameter\'] = _DOWNSAMPLEPARAMETER\nDESCRIPTOR.message_types_by_name[\'ReaderParameter\'] = _READERPARAMETER\nDESCRIPTOR.message_types_by_name[\'WriterParameter\'] = _WRITERPARAMETER\nDESCRIPTOR.message_types_by_name[\'ResampleParameter\'] = _RESAMPLEPARAMETER\nDESCRIPTOR.message_types_by_name[\'MeanParameter\'] = _MEANPARAMETER\nDESCRIPTOR.message_types_by_name[\'CoeffScheduleParameter\'] = _COEFFSCHEDULEPARAMETER\nDESCRIPTOR.message_types_by_name[\'TransformationParameter\'] = _TRANSFORMATIONPARAMETER\nDESCRIPTOR.message_types_by_name[\'LossParameter\'] = _LOSSPARAMETER\nDESCRIPTOR.message_types_by_name[\'AccuracyParameter\'] = _ACCURACYPARAMETER\nDESCRIPTOR.message_types_by_name[\'ArgMaxParameter\'] = _ARGMAXPARAMETER\nDESCRIPTOR.message_types_by_name[\'ConcatParameter\'] = _CONCATPARAMETER\nDESCRIPTOR.message_types_by_name[\'BatchNormParameter\'] = _BATCHNORMPARAMETER\nDESCRIPTOR.message_types_by_name[\'BiasParameter\'] = _BIASPARAMETER\nDESCRIPTOR.message_types_by_name[\'ContrastiveLossParameter\'] = _CONTRASTIVELOSSPARAMETER\nDESCRIPTOR.message_types_by_name[\'ConvolutionParameter\'] = _CONVOLUTIONPARAMETER\nDESCRIPTOR.message_types_by_name[\'CropParameter\'] = _CROPPARAMETER\nDESCRIPTOR.message_types_by_name[\'DataParameter\'] = _DATAPARAMETER\nDESCRIPTOR.message_types_by_name[\'DropoutParameter\'] = _DROPOUTPARAMETER\nDESCRIPTOR.message_types_by_name[\'DummyDataParameter\'] = _DUMMYDATAPARAMETER\nDESCRIPTOR.message_types_by_name[\'EltwiseParameter\'] = _ELTWISEPARAMETER\nDESCRIPTOR.message_types_by_name[\'ELUParameter\'] = _ELUPARAMETER\nDESCRIPTOR.message_types_by_name[\'EmbedParameter\'] = _EMBEDPARAMETER\nDESCRIPTOR.message_types_by_name[\'ExpParameter\'] = _EXPPARAMETER\nDESCRIPTOR.message_types_by_name[\'ExpMaxParameter\'] = _EXPMAXPARAMETER\nDESCRIPTOR.message_types_by_name[\'FlattenParameter\'] = _FLATTENPARAMETER\nDESCRIPTOR.message_types_by_name[\'HDF5DataParameter\'] = _HDF5DATAPARAMETER\nDESCRIPTOR.message_types_by_name[\'HDF5OutputParameter\'] = _HDF5OUTPUTPARAMETER\nDESCRIPTOR.message_types_by_name[\'HingeLossParameter\'] = _HINGELOSSPARAMETER\nDESCRIPTOR.message_types_by_name[\'ImageDataParameter\'] = _IMAGEDATAPARAMETER\nDESCRIPTOR.message_types_by_name[\'InfogainLossParameter\'] = _INFOGAINLOSSPARAMETER\nDESCRIPTOR.message_types_by_name[\'InnerProductParameter\'] = _INNERPRODUCTPARAMETER\nDESCRIPTOR.message_types_by_name[\'InputParameter\'] = _INPUTPARAMETER\nDESCRIPTOR.message_types_by_name[\'LogParameter\'] = _LOGPARAMETER\nDESCRIPTOR.message_types_by_name[\'LRNParameter\'] = _LRNPARAMETER\nDESCRIPTOR.message_types_by_name[\'MemoryDataParameter\'] = _MEMORYDATAPARAMETER\nDESCRIPTOR.message_types_by_name[\'MVNParameter\'] = _MVNPARAMETER\nDESCRIPTOR.message_types_by_name[\'ParameterParameter\'] = _PARAMETERPARAMETER\nDESCRIPTOR.message_types_by_name[\'PoolingParameter\'] = _POOLINGPARAMETER\nDESCRIPTOR.message_types_by_name[\'PowerParameter\'] = _POWERPARAMETER\nDESCRIPTOR.message_types_by_name[\'NegSquareParameter\'] = _NEGSQUAREPARAMETER\nDESCRIPTOR.message_types_by_name[\'PythonParameter\'] = _PYTHONPARAMETER\nDESCRIPTOR.message_types_by_name[\'RecurrentParameter\'] = _RECURRENTPARAMETER\nDESCRIPTOR.message_types_by_name[\'ReductionParameter\'] = _REDUCTIONPARAMETER\nDESCRIPTOR.message_types_by_name[\'ReLUParameter\'] = _RELUPARAMETER\nDESCRIPTOR.message_types_by_name[\'ReshapeParameter\'] = _RESHAPEPARAMETER\nDESCRIPTOR.message_types_by_name[\'ScaleParameter\'] = _SCALEPARAMETER\nDESCRIPTOR.message_types_by_name[\'SigmoidParameter\'] = _SIGMOIDPARAMETER\nDESCRIPTOR.message_types_by_name[\'SliceParameter\'] = _SLICEPARAMETER\nDESCRIPTOR.message_types_by_name[\'SoftmaxParameter\'] = _SOFTMAXPARAMETER\nDESCRIPTOR.message_types_by_name[\'TanHParameter\'] = _TANHPARAMETER\nDESCRIPTOR.message_types_by_name[\'TileParameter\'] = _TILEPARAMETER\nDESCRIPTOR.message_types_by_name[\'ThresholdParameter\'] = _THRESHOLDPARAMETER\nDESCRIPTOR.message_types_by_name[\'WindowDataParameter\'] = _WINDOWDATAPARAMETER\nDESCRIPTOR.message_types_by_name[\'SPPParameter\'] = _SPPPARAMETER\nDESCRIPTOR.message_types_by_name[\'V1LayerParameter\'] = _V1LAYERPARAMETER\nDESCRIPTOR.message_types_by_name[\'V0LayerParameter\'] = _V0LAYERPARAMETER\nDESCRIPTOR.message_types_by_name[\'PReLUParameter\'] = _PRELUPARAMETER\n\nclass BlobShape(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _BLOBSHAPE\n\n  # @@protoc_insertion_point(class_scope:caffe.BlobShape)\n\nclass BlobProto(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _BLOBPROTO\n\n  # @@protoc_insertion_point(class_scope:caffe.BlobProto)\n\nclass BlobProtoVector(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _BLOBPROTOVECTOR\n\n  # @@protoc_insertion_point(class_scope:caffe.BlobProtoVector)\n\nclass Datum(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _DATUM\n\n  # @@protoc_insertion_point(class_scope:caffe.Datum)\n\nclass FillerParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _FILLERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.FillerParameter)\n\nclass NetParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _NETPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.NetParameter)\n\nclass SolverParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SOLVERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.SolverParameter)\n\nclass SolverState(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SOLVERSTATE\n\n  # @@protoc_insertion_point(class_scope:caffe.SolverState)\n\nclass NetState(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _NETSTATE\n\n  # @@protoc_insertion_point(class_scope:caffe.NetState)\n\nclass NetStateRule(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _NETSTATERULE\n\n  # @@protoc_insertion_point(class_scope:caffe.NetStateRule)\n\nclass ParamSpec(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _PARAMSPEC\n\n  # @@protoc_insertion_point(class_scope:caffe.ParamSpec)\n\nclass LayerParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _LAYERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.LayerParameter)\n\nclass GridParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _GRIDPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.GridParameter)\n\nclass AugmentationCoeff(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _AUGMENTATIONCOEFF\n\n  # @@protoc_insertion_point(class_scope:caffe.AugmentationCoeff)\n\nclass AugmentationParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _AUGMENTATIONPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.AugmentationParameter)\n\nclass RandomGeneratorParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _RANDOMGENERATORPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.RandomGeneratorParameter)\n\nclass L1LossParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _L1LOSSPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.L1LossParameter)\n\nclass CorrelationParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _CORRELATIONPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.CorrelationParameter)\n\nclass DownsampleParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _DOWNSAMPLEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.DownsampleParameter)\n\nclass ReaderParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _READERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ReaderParameter)\n\nclass WriterParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _WRITERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.WriterParameter)\n\nclass ResampleParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _RESAMPLEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ResampleParameter)\n\nclass MeanParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _MEANPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.MeanParameter)\n\nclass CoeffScheduleParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _COEFFSCHEDULEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.CoeffScheduleParameter)\n\nclass TransformationParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _TRANSFORMATIONPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.TransformationParameter)\n\nclass LossParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _LOSSPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.LossParameter)\n\nclass AccuracyParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _ACCURACYPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.AccuracyParameter)\n\nclass ArgMaxParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _ARGMAXPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ArgMaxParameter)\n\nclass ConcatParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _CONCATPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ConcatParameter)\n\nclass BatchNormParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _BATCHNORMPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.BatchNormParameter)\n\nclass BiasParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _BIASPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.BiasParameter)\n\nclass ContrastiveLossParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _CONTRASTIVELOSSPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ContrastiveLossParameter)\n\nclass ConvolutionParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _CONVOLUTIONPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)\n\nclass CropParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _CROPPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.CropParameter)\n\nclass DataParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _DATAPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.DataParameter)\n\nclass DropoutParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _DROPOUTPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.DropoutParameter)\n\nclass DummyDataParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _DUMMYDATAPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.DummyDataParameter)\n\nclass EltwiseParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _ELTWISEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.EltwiseParameter)\n\nclass ELUParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _ELUPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ELUParameter)\n\nclass EmbedParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _EMBEDPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.EmbedParameter)\n\nclass ExpParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _EXPPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ExpParameter)\n\nclass ExpMaxParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _EXPMAXPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ExpMaxParameter)\n\nclass FlattenParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _FLATTENPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.FlattenParameter)\n\nclass HDF5DataParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _HDF5DATAPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.HDF5DataParameter)\n\nclass HDF5OutputParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _HDF5OUTPUTPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.HDF5OutputParameter)\n\nclass HingeLossParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _HINGELOSSPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.HingeLossParameter)\n\nclass ImageDataParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _IMAGEDATAPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ImageDataParameter)\n\nclass InfogainLossParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _INFOGAINLOSSPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.InfogainLossParameter)\n\nclass InnerProductParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _INNERPRODUCTPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.InnerProductParameter)\n\nclass InputParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _INPUTPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.InputParameter)\n\nclass LogParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _LOGPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.LogParameter)\n\nclass LRNParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _LRNPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.LRNParameter)\n\nclass MemoryDataParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _MEMORYDATAPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.MemoryDataParameter)\n\nclass MVNParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _MVNPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.MVNParameter)\n\nclass ParameterParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _PARAMETERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ParameterParameter)\n\nclass PoolingParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _POOLINGPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.PoolingParameter)\n\nclass PowerParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _POWERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.PowerParameter)\n\nclass NegSquareParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _NEGSQUAREPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.NegSquareParameter)\n\nclass PythonParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _PYTHONPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.PythonParameter)\n\nclass RecurrentParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _RECURRENTPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.RecurrentParameter)\n\nclass ReductionParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _REDUCTIONPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ReductionParameter)\n\nclass ReLUParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _RELUPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ReLUParameter)\n\nclass ReshapeParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _RESHAPEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ReshapeParameter)\n\nclass ScaleParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SCALEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ScaleParameter)\n\nclass SigmoidParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SIGMOIDPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.SigmoidParameter)\n\nclass SliceParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SLICEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.SliceParameter)\n\nclass SoftmaxParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SOFTMAXPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.SoftmaxParameter)\n\nclass TanHParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _TANHPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.TanHParameter)\n\nclass TileParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _TILEPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.TileParameter)\n\nclass ThresholdParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _THRESHOLDPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.ThresholdParameter)\n\nclass WindowDataParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _WINDOWDATAPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.WindowDataParameter)\n\nclass SPPParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _SPPPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.SPPParameter)\n\nclass V1LayerParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _V1LAYERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.V1LayerParameter)\n\nclass V0LayerParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _V0LAYERPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.V0LayerParameter)\n\nclass PReLUParameter(_message.Message):\n  __metaclass__ = _reflection.GeneratedProtocolMessageType\n  DESCRIPTOR = _PRELUPARAMETER\n\n  # @@protoc_insertion_point(class_scope:caffe.PReLUParameter)\n\n\n_BLOBSHAPE.fields_by_name[\'dim\'].has_options = True\n_BLOBSHAPE.fields_by_name[\'dim\']._options = _descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')\n_BLOBPROTO.fields_by_name[\'data\'].has_options = True\n_BLOBPROTO.fields_by_name[\'data\']._options = _descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')\n_BLOBPROTO.fields_by_name[\'diff\'].has_options = True\n_BLOBPROTO.fields_by_name[\'diff\']._options = _descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')\n_BLOBPROTO.fields_by_name[\'double_data\'].has_options = True\n_BLOBPROTO.fields_by_name[\'double_data\']._options = _descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')\n_BLOBPROTO.fields_by_name[\'double_diff\'].has_options = True\n_BLOBPROTO.fields_by_name[\'double_diff\']._options = _descriptor._ParseOptions(descriptor_pb2.FieldOptions(), \'\\020\\001\')\n# @@protoc_insertion_point(module_scope)\n'"
python/caffe/test/test_coord_map.py,0,"b'import unittest\n\nimport numpy as np\nimport random\n\nimport caffe\nfrom caffe import layers as L\nfrom caffe import params as P\nfrom caffe.coord_map import coord_map_from_to, crop\n\n\ndef coord_net_spec(ks=3, stride=1, pad=0, pool=2, dstride=2, dpad=0):\n    """"""\n    Define net spec for simple conv-pool-deconv pattern common to all\n    coordinate mapping tests.\n    """"""\n    n = caffe.NetSpec()\n    n.data = L.Input(shape=dict(dim=[2, 1, 100, 100]))\n    n.aux = L.Input(shape=dict(dim=[2, 1, 20, 20]))\n    n.conv = L.Convolution(\n        n.data, num_output=10, kernel_size=ks, stride=stride, pad=pad)\n    n.pool = L.Pooling(\n        n.conv, pool=P.Pooling.MAX, kernel_size=pool, stride=pool, pad=0)\n    # for upsampling kernel size is 2x stride\n    try:\n        deconv_ks = [s*2 for s in dstride]\n    except:\n        deconv_ks = dstride*2\n    n.deconv = L.Deconvolution(\n        n.pool, num_output=10, kernel_size=deconv_ks, stride=dstride, pad=dpad)\n    return n\n\n\nclass TestCoordMap(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def test_conv_pool_deconv(self):\n        """"""\n        Map through conv, pool, and deconv.\n        """"""\n        n = coord_net_spec()\n        # identity for 2x pool, 2x deconv\n        ax, a, b = coord_map_from_to(n.deconv, n.data)\n        self.assertEquals(ax, 1)\n        self.assertEquals(a, 1)\n        self.assertEquals(b, 0)\n        # shift-by-one for 4x pool, 4x deconv\n        n = coord_net_spec(pool=4, dstride=4)\n        ax, a, b = coord_map_from_to(n.deconv, n.data)\n        self.assertEquals(ax, 1)\n        self.assertEquals(a, 1)\n        self.assertEquals(b, -1)\n\n    def test_pass(self):\n        """"""\n        A pass-through layer (ReLU) and conv (1x1, stride 1, pad 0)\n        both do identity mapping.\n        """"""\n        n = coord_net_spec()\n        ax, a, b = coord_map_from_to(n.deconv, n.data)\n        n.relu = L.ReLU(n.deconv)\n        n.conv1x1 = L.Convolution(\n            n.relu, num_output=10, kernel_size=1, stride=1, pad=0)\n        for top in [n.relu, n.conv1x1]:\n            ax_pass, a_pass, b_pass = coord_map_from_to(top, n.data)\n            self.assertEquals(ax, ax_pass)\n            self.assertEquals(a, a_pass)\n            self.assertEquals(b, b_pass)\n\n    def test_padding(self):\n        """"""\n        Padding conv adds offset while padding deconv subtracts offset.\n        """"""\n        n = coord_net_spec()\n        ax, a, b = coord_map_from_to(n.deconv, n.data)\n        pad = random.randint(0, 10)\n        # conv padding\n        n = coord_net_spec(pad=pad)\n        _, a_pad, b_pad = coord_map_from_to(n.deconv, n.data)\n        self.assertEquals(a, a_pad)\n        self.assertEquals(b - pad, b_pad)\n        # deconv padding\n        n = coord_net_spec(dpad=pad)\n        _, a_pad, b_pad = coord_map_from_to(n.deconv, n.data)\n        self.assertEquals(a, a_pad)\n        self.assertEquals(b + pad, b_pad)\n        # pad both to cancel out\n        n = coord_net_spec(pad=pad, dpad=pad)\n        _, a_pad, b_pad = coord_map_from_to(n.deconv, n.data)\n        self.assertEquals(a, a_pad)\n        self.assertEquals(b, b_pad)\n\n    def test_multi_conv(self):\n        """"""\n        Multiple bottoms/tops of a layer are identically mapped.\n        """"""\n        n = coord_net_spec()\n        # multi bottom/top\n        n.conv_data, n.conv_aux = L.Convolution(\n            n.data, n.aux, ntop=2, num_output=10, kernel_size=5, stride=2,\n            pad=0)\n        ax1, a1, b1 = coord_map_from_to(n.conv_data, n.data)\n        ax2, a2, b2 = coord_map_from_to(n.conv_aux, n.aux)\n        self.assertEquals(ax1, ax2)\n        self.assertEquals(a1, a2)\n        self.assertEquals(b1, b2)\n\n    def test_rect(self):\n        """"""\n        Anisotropic mapping is equivalent to its isotropic parts.\n        """"""\n        n3x3 = coord_net_spec(ks=3, stride=1, pad=0)\n        n5x5 = coord_net_spec(ks=5, stride=2, pad=10)\n        n3x5 = coord_net_spec(ks=[3, 5], stride=[1, 2], pad=[0, 10])\n        ax_3x3, a_3x3, b_3x3 = coord_map_from_to(n3x3.deconv, n3x3.data)\n        ax_5x5, a_5x5, b_5x5 = coord_map_from_to(n5x5.deconv, n5x5.data)\n        ax_3x5, a_3x5, b_3x5 = coord_map_from_to(n3x5.deconv, n3x5.data)\n        self.assertTrue(ax_3x3 == ax_5x5 == ax_3x5)\n        self.assertEquals(a_3x3, a_3x5[0])\n        self.assertEquals(b_3x3, b_3x5[0])\n        self.assertEquals(a_5x5, a_3x5[1])\n        self.assertEquals(b_5x5, b_3x5[1])\n\n    def test_nd_conv(self):\n        """"""\n        ND conv maps the same way in more dimensions.\n        """"""\n        n = caffe.NetSpec()\n        # define data with 3 spatial dimensions, otherwise the same net\n        n.data = L.Input(shape=dict(dim=[2, 3, 100, 100, 100]))\n        n.conv = L.Convolution(\n            n.data, num_output=10, kernel_size=[3, 3, 3], stride=[1, 1, 1],\n            pad=[0, 1, 2])\n        n.pool = L.Pooling(\n            n.conv, pool=P.Pooling.MAX, kernel_size=2, stride=2, pad=0)\n        n.deconv = L.Deconvolution(\n            n.pool, num_output=10, kernel_size=4, stride=2, pad=0)\n        ax, a, b = coord_map_from_to(n.deconv, n.data)\n        self.assertEquals(ax, 1)\n        self.assertTrue(len(a) == len(b))\n        self.assertTrue(np.all(a == 1))\n        self.assertEquals(b[0] - 1, b[1])\n        self.assertEquals(b[1] - 1, b[2])\n\n    def test_crop_of_crop(self):\n        """"""\n        Map coordinates through Crop layer:\n        crop an already-cropped output to the input and check change in offset.\n        """"""\n        n = coord_net_spec()\n        offset = random.randint(0, 10)\n        ax, a, b = coord_map_from_to(n.deconv, n.data)\n        n.crop = L.Crop(n.deconv, n.data, axis=2, offset=offset)\n        ax_crop, a_crop, b_crop = coord_map_from_to(n.crop, n.data)\n        self.assertEquals(ax, ax_crop)\n        self.assertEquals(a, a_crop)\n        self.assertEquals(b + offset, b_crop)\n\n    def test_crop_helper(self):\n        """"""\n        Define Crop layer by crop().\n        """"""\n        n = coord_net_spec()\n        crop(n.deconv, n.data)\n\n    def test_catch_unconnected(self):\n        """"""\n        Catch mapping spatially unconnected tops.\n        """"""\n        n = coord_net_spec()\n        n.ip = L.InnerProduct(n.deconv, num_output=10)\n        with self.assertRaises(RuntimeError):\n            coord_map_from_to(n.ip, n.data)\n\n    def test_catch_scale_mismatch(self):\n        """"""\n        Catch incompatible scales, such as when the top to be cropped\n        is mapped to a differently strided reference top.\n        """"""\n        n = coord_net_spec(pool=3, dstride=2)  # pool 3x but deconv 2x\n        with self.assertRaises(AssertionError):\n            crop(n.deconv, n.data)\n\n    def test_catch_negative_crop(self):\n        """"""\n        Catch impossible offsets, such as when the top to be cropped\n        is mapped to a larger reference top.\n        """"""\n        n = coord_net_spec(dpad=10)  # make output smaller than input\n        with self.assertRaises(AssertionError):\n            crop(n.deconv, n.data)\n'"
python/caffe/test/test_io.py,0,"b""import numpy as np\nimport unittest\n\nimport caffe\n\nclass TestBlobProtoToArray(unittest.TestCase):\n\n    def test_old_format(self):\n        data = np.zeros((10,10))\n        blob = caffe.proto.caffe_pb2.BlobProto()\n        blob.data.extend(list(data.flatten()))\n        shape = (1,1,10,10)\n        blob.num, blob.channels, blob.height, blob.width = shape\n\n        arr = caffe.io.blobproto_to_array(blob)\n        self.assertEqual(arr.shape, shape)\n\n    def test_new_format(self):\n        data = np.zeros((10,10))\n        blob = caffe.proto.caffe_pb2.BlobProto()\n        blob.data.extend(list(data.flatten()))\n        blob.shape.dim.extend(list(data.shape))\n\n        arr = caffe.io.blobproto_to_array(blob)\n        self.assertEqual(arr.shape, data.shape)\n\n    def test_no_shape(self):\n        data = np.zeros((10,10))\n        blob = caffe.proto.caffe_pb2.BlobProto()\n        blob.data.extend(list(data.flatten()))\n\n        with self.assertRaises(ValueError):\n            caffe.io.blobproto_to_array(blob)\n\n    def test_scalar(self):\n        data = np.ones((1)) * 123\n        blob = caffe.proto.caffe_pb2.BlobProto()\n        blob.data.extend(list(data.flatten()))\n\n        arr = caffe.io.blobproto_to_array(blob)\n        self.assertEqual(arr, 123)\n\n\nclass TestArrayToDatum(unittest.TestCase):\n\n    def test_label_none_size(self):\n        # Set label\n        d1 = caffe.io.array_to_datum(\n            np.ones((10,10,3)), label=1)\n        # Don't set label\n        d2 = caffe.io.array_to_datum(\n            np.ones((10,10,3)))\n        # Not setting the label should result in a smaller object\n        self.assertGreater(\n            len(d1.SerializeToString()),\n            len(d2.SerializeToString()))\n"""
python/caffe/test/test_layer_type_list.py,0,"b""import unittest\n\nimport caffe\n\nclass TestLayerTypeList(unittest.TestCase):\n\n    def test_standard_types(self):\n        #removing 'Data' from list \n        for type_name in ['Data', 'Convolution', 'InnerProduct']:\n            self.assertIn(type_name, caffe.layer_type_list(),\n                    '%s not in layer_type_list()' % type_name)\n"""
python/caffe/test/test_net.py,0,"b'import unittest\nimport tempfile\nimport os\nimport numpy as np\nimport six\n\nimport caffe\n\n\ndef simple_net_file(num_output):\n    """"""Make a simple net prototxt, based on test_net.cpp, returning the name\n    of the (temporary) file.""""""\n\n    f = tempfile.NamedTemporaryFile(mode=\'w+\', delete=False)\n    f.write(""""""name: \'testnet\' force_backward: true\n    layer { type: \'DummyData\' name: \'data\' top: \'data\' top: \'label\'\n      dummy_data_param { num: 5 channels: 2 height: 3 width: 4\n        num: 5 channels: 1 height: 1 width: 1\n        data_filler { type: \'gaussian\' std: 1 }\n        data_filler { type: \'constant\' } } }\n    layer { type: \'Convolution\' name: \'conv\' bottom: \'data\' top: \'conv\'\n      convolution_param { num_output: 11 kernel_size: 2 pad: 3\n        weight_filler { type: \'gaussian\' std: 1 }\n        bias_filler { type: \'constant\' value: 2 } }\n        param { decay_mult: 1 } param { decay_mult: 0 }\n        }\n    layer { type: \'InnerProduct\' name: \'ip\' bottom: \'conv\' top: \'ip\'\n      inner_product_param { num_output: """""" + str(num_output) + """"""\n        weight_filler { type: \'gaussian\' std: 2.5 }\n        bias_filler { type: \'constant\' value: -3 } } }\n    layer { type: \'SoftmaxWithLoss\' name: \'loss\' bottom: \'ip\' bottom: \'label\'\n      top: \'loss\' }"""""")\n    f.close()\n    return f.name\n\n\nclass TestNet(unittest.TestCase):\n    def setUp(self):\n        self.num_output = 13\n        net_file = simple_net_file(self.num_output)\n        self.net = caffe.Net(net_file, caffe.TRAIN)\n        # fill in valid labels\n        self.net.blobs[\'label\'].data[...] = \\\n                np.random.randint(self.num_output,\n                    size=self.net.blobs[\'label\'].data.shape)\n        os.remove(net_file)\n\n    def test_memory(self):\n        """"""Check that holding onto blob data beyond the life of a Net is OK""""""\n\n        params = sum(map(list, six.itervalues(self.net.params)), [])\n        blobs = self.net.blobs.values()\n        del self.net\n\n        # now sum everything (forcing all memory to be read)\n        total = 0\n        for p in params:\n            total += p.data.sum() + p.diff.sum()\n        for bl in blobs:\n            total += bl.data.sum() + bl.diff.sum()\n\n    def test_forward_backward(self):\n        self.net.forward()\n        self.net.backward()\n\n    def test_inputs_outputs(self):\n        self.assertEqual(self.net.inputs, [])\n        self.assertEqual(self.net.outputs, [\'loss\'])\n\n    def test_save_and_read(self):\n        f = tempfile.NamedTemporaryFile(mode=\'w+\', delete=False)\n        f.close()\n        self.net.save(f.name)\n        net_file = simple_net_file(self.num_output)\n        net2 = caffe.Net(net_file, f.name, caffe.TRAIN)\n        os.remove(net_file)\n        os.remove(f.name)\n        for name in self.net.params:\n            for i in range(len(self.net.params[name])):\n                self.assertEqual(abs(self.net.params[name][i].data\n                    - net2.params[name][i].data).sum(), 0)\n\n    def test_save_hdf5(self):\n        f = tempfile.NamedTemporaryFile(mode=\'w+\', delete=False)\n        f.close()\n        self.net.save_hdf5(f.name)\n        net_file = simple_net_file(self.num_output)\n        net2 = caffe.Net(net_file, caffe.TRAIN)\n        net2.load_hdf5(f.name)\n        os.remove(net_file)\n        os.remove(f.name)\n        for name in self.net.params:\n            for i in range(len(self.net.params[name])):\n                self.assertEqual(abs(self.net.params[name][i].data\n                    - net2.params[name][i].data).sum(), 0)\n'"
python/caffe/test/test_net_spec.py,0,"b'import unittest\nimport tempfile\nimport caffe\nfrom caffe import layers as L\nfrom caffe import params as P\n\ndef lenet(batch_size):\n    n = caffe.NetSpec()\n    n.data, n.label = L.DummyData(shape=[dict(dim=[batch_size, 1, 28, 28]),\n                                         dict(dim=[batch_size, 1, 1, 1])],\n                                  transform_param=dict(scale=1./255), ntop=2)\n    n.conv1 = L.Convolution(n.data, kernel_size=5, num_output=20,\n        weight_filler=dict(type=\'xavier\'))\n    n.pool1 = L.Pooling(n.conv1, kernel_size=2, stride=2, pool=P.Pooling.MAX)\n    n.conv2 = L.Convolution(n.pool1, kernel_size=5, num_output=50,\n        weight_filler=dict(type=\'xavier\'))\n    n.pool2 = L.Pooling(n.conv2, kernel_size=2, stride=2, pool=P.Pooling.MAX)\n    n.ip1 = L.InnerProduct(n.pool2, num_output=500,\n        weight_filler=dict(type=\'xavier\'))\n    n.relu1 = L.ReLU(n.ip1, in_place=True)\n    n.ip2 = L.InnerProduct(n.relu1, num_output=10,\n        weight_filler=dict(type=\'xavier\'))\n    n.loss = L.SoftmaxWithLoss(n.ip2, n.label)\n    return n.to_proto()\n\ndef anon_lenet(batch_size):\n    data, label = L.DummyData(shape=[dict(dim=[batch_size, 1, 28, 28]),\n                                     dict(dim=[batch_size, 1, 1, 1])],\n                              transform_param=dict(scale=1./255), ntop=2)\n    conv1 = L.Convolution(data, kernel_size=5, num_output=20,\n        weight_filler=dict(type=\'xavier\'))\n    pool1 = L.Pooling(conv1, kernel_size=2, stride=2, pool=P.Pooling.MAX)\n    conv2 = L.Convolution(pool1, kernel_size=5, num_output=50,\n        weight_filler=dict(type=\'xavier\'))\n    pool2 = L.Pooling(conv2, kernel_size=2, stride=2, pool=P.Pooling.MAX)\n    ip1 = L.InnerProduct(pool2, num_output=500,\n        weight_filler=dict(type=\'xavier\'))\n    relu1 = L.ReLU(ip1, in_place=True)\n    ip2 = L.InnerProduct(relu1, num_output=10,\n        weight_filler=dict(type=\'xavier\'))\n    loss = L.SoftmaxWithLoss(ip2, label)\n    return loss.to_proto()\n\ndef silent_net():\n    n = caffe.NetSpec()\n    n.data, n.data2 = L.DummyData(shape=dict(dim=3), ntop=2)\n    n.silence_data = L.Silence(n.data, ntop=0)\n    n.silence_data2 = L.Silence(n.data2, ntop=0)\n    return n.to_proto()\n\nclass TestNetSpec(unittest.TestCase):\n    def load_net(self, net_proto):\n        f = tempfile.NamedTemporaryFile(mode=\'w+\', delete=False)\n        f.write(str(net_proto))\n        f.close()\n        return caffe.Net(f.name, caffe.TEST)\n\n    def test_lenet(self):\n        """"""Construct and build the Caffe version of LeNet.""""""\n\n        net_proto = lenet(50)\n        # check that relu is in-place\n        self.assertEqual(net_proto.layer[6].bottom,\n                net_proto.layer[6].top)\n        net = self.load_net(net_proto)\n        # check that all layers are present\n        self.assertEqual(len(net.layers), 9)\n\n        # now the check the version with automatically-generated layer names\n        net_proto = anon_lenet(50)\n        self.assertEqual(net_proto.layer[6].bottom,\n                net_proto.layer[6].top)\n        net = self.load_net(net_proto)\n        self.assertEqual(len(net.layers), 9)\n\n    def test_zero_tops(self):\n        """"""Test net construction for top-less layers.""""""\n\n        net_proto = silent_net()\n        net = self.load_net(net_proto)\n        self.assertEqual(len(net.forward()), 0)\n'"
python/caffe/test/test_python_layer.py,0,"b'import unittest\nimport tempfile\nimport os\nimport six\n\nimport caffe\n\n\nclass SimpleLayer(caffe.Layer):\n    """"""A layer that just multiplies by ten""""""\n\n    def setup(self, bottom, top):\n        pass\n\n    def reshape(self, bottom, top):\n        top[0].reshape(*bottom[0].data.shape)\n\n    def forward(self, bottom, top):\n        top[0].data[...] = 10 * bottom[0].data\n\n    def backward(self, top, propagate_down, bottom):\n        bottom[0].diff[...] = 10 * top[0].diff\n\n\nclass ExceptionLayer(caffe.Layer):\n    """"""A layer for checking exceptions from Python""""""\n\n    def setup(self, bottom, top):\n        raise RuntimeError\n\nclass ParameterLayer(caffe.Layer):\n    """"""A layer that just multiplies by ten""""""\n\n    def setup(self, bottom, top):\n        self.blobs.add_blob(1)\n        self.blobs[0].data[0] = 0\n\n    def reshape(self, bottom, top):\n        top[0].reshape(*bottom[0].data.shape)\n\n    def forward(self, bottom, top):\n        pass\n\n    def backward(self, top, propagate_down, bottom):\n        self.blobs[0].diff[0] = 1\n\nclass PhaseLayer(caffe.Layer):\n    """"""A layer for checking attribute `phase`""""""\n\n    def setup(self, bottom, top):\n        pass\n\n    def reshape(self, bootom, top):\n        top[0].reshape()\n\n    def forward(self, bottom, top):\n        top[0].data[()] = self.phase\n\ndef python_net_file():\n    with tempfile.NamedTemporaryFile(mode=\'w+\', delete=False) as f:\n        f.write(""""""name: \'pythonnet\' force_backward: true\n        input: \'data\' input_shape { dim: 10 dim: 9 dim: 8 }\n        layer { type: \'Python\' name: \'one\' bottom: \'data\' top: \'one\'\n          python_param { module: \'test_python_layer\' layer: \'SimpleLayer\' } }\n        layer { type: \'Python\' name: \'two\' bottom: \'one\' top: \'two\'\n          python_param { module: \'test_python_layer\' layer: \'SimpleLayer\' } }\n        layer { type: \'Python\' name: \'three\' bottom: \'two\' top: \'three\'\n          python_param { module: \'test_python_layer\' layer: \'SimpleLayer\' } }"""""")\n        return f.name\n\n\ndef exception_net_file():\n    with tempfile.NamedTemporaryFile(mode=\'w+\', delete=False) as f:\n        f.write(""""""name: \'pythonnet\' force_backward: true\n        input: \'data\' input_shape { dim: 10 dim: 9 dim: 8 }\n        layer { type: \'Python\' name: \'layer\' bottom: \'data\' top: \'top\'\n          python_param { module: \'test_python_layer\' layer: \'ExceptionLayer\' } }\n          """""")\n        return f.name\n\n\ndef parameter_net_file():\n    with tempfile.NamedTemporaryFile(mode=\'w+\', delete=False) as f:\n        f.write(""""""name: \'pythonnet\' force_backward: true\n        input: \'data\' input_shape { dim: 10 dim: 9 dim: 8 }\n        layer { type: \'Python\' name: \'layer\' bottom: \'data\' top: \'top\'\n          python_param { module: \'test_python_layer\' layer: \'ParameterLayer\' } }\n          """""")\n        return f.name\n\ndef phase_net_file():\n    with tempfile.NamedTemporaryFile(mode=\'w+\', delete=False) as f:\n        f.write(""""""name: \'pythonnet\' force_backward: true\n        layer { type: \'Python\' name: \'layer\' top: \'phase\'\n          python_param { module: \'test_python_layer\' layer: \'PhaseLayer\' } }\n          """""")\n        return f.name\n\n\n@unittest.skipIf(\'Python\' not in caffe.layer_type_list(),\n    \'Caffe built without Python layer support\')\nclass TestPythonLayer(unittest.TestCase):\n    def setUp(self):\n        net_file = python_net_file()\n        self.net = caffe.Net(net_file, caffe.TRAIN)\n        os.remove(net_file)\n\n    def test_forward(self):\n        x = 8\n        self.net.blobs[\'data\'].data[...] = x\n        self.net.forward()\n        for y in self.net.blobs[\'three\'].data.flat:\n            self.assertEqual(y, 10**3 * x)\n\n    def test_backward(self):\n        x = 7\n        self.net.blobs[\'three\'].diff[...] = x\n        self.net.backward()\n        for y in self.net.blobs[\'data\'].diff.flat:\n            self.assertEqual(y, 10**3 * x)\n\n    def test_reshape(self):\n        s = 4\n        self.net.blobs[\'data\'].reshape(s, s, s, s)\n        self.net.forward()\n        for blob in six.itervalues(self.net.blobs):\n            for d in blob.data.shape:\n                self.assertEqual(s, d)\n\n    def test_exception(self):\n        net_file = exception_net_file()\n        self.assertRaises(RuntimeError, caffe.Net, net_file, caffe.TEST)\n        os.remove(net_file)\n\n    def test_parameter(self):\n        net_file = parameter_net_file()\n        net = caffe.Net(net_file, caffe.TRAIN)\n        # Test forward and backward\n        net.forward()\n        net.backward()\n        layer = net.layers[list(net._layer_names).index(\'layer\')]\n        self.assertEqual(layer.blobs[0].data[0], 0)\n        self.assertEqual(layer.blobs[0].diff[0], 1)\n        layer.blobs[0].data[0] += layer.blobs[0].diff[0]\n        self.assertEqual(layer.blobs[0].data[0], 1)\n\n        # Test saving and loading\n        h, caffemodel_file = tempfile.mkstemp()\n        net.save(caffemodel_file)\n        layer.blobs[0].data[0] = -1\n        self.assertEqual(layer.blobs[0].data[0], -1)\n        net.copy_from(caffemodel_file)\n        self.assertEqual(layer.blobs[0].data[0], 1)\n        os.remove(caffemodel_file)\n        \n        # Test weight sharing\n        net2 = caffe.Net(net_file, caffe.TRAIN)\n        net2.share_with(net)\n        layer = net.layers[list(net2._layer_names).index(\'layer\')]\n        self.assertEqual(layer.blobs[0].data[0], 1)\n\n        os.remove(net_file)\n\n    def test_phase(self):\n        net_file = phase_net_file()\n        for phase in caffe.TRAIN, caffe.TEST:\n            net = caffe.Net(net_file, phase)\n            self.assertEqual(net.forward()[\'phase\'], phase)\n'"
python/caffe/test/test_python_layer_with_param_str.py,0,"b'import unittest\nimport tempfile\nimport os\nimport six\n\nimport caffe\n\n\nclass SimpleParamLayer(caffe.Layer):\n    """"""A layer that just multiplies by the numeric value of its param string""""""\n\n    def setup(self, bottom, top):\n        try:\n            self.value = float(self.param_str)\n        except ValueError:\n            raise ValueError(""Parameter string must be a legible float"")\n\n    def reshape(self, bottom, top):\n        top[0].reshape(*bottom[0].data.shape)\n\n    def forward(self, bottom, top):\n        top[0].data[...] = self.value * bottom[0].data\n\n    def backward(self, top, propagate_down, bottom):\n        bottom[0].diff[...] = self.value * top[0].diff\n\n\ndef python_param_net_file():\n    with tempfile.NamedTemporaryFile(mode=\'w+\', delete=False) as f:\n        f.write(""""""name: \'pythonnet\' force_backward: true\n        input: \'data\' input_shape { dim: 10 dim: 9 dim: 8 }\n        layer { type: \'Python\' name: \'mul10\' bottom: \'data\' top: \'mul10\'\n          python_param { module: \'test_python_layer_with_param_str\'\n                layer: \'SimpleParamLayer\' param_str: \'10\' } }\n        layer { type: \'Python\' name: \'mul2\' bottom: \'mul10\' top: \'mul2\'\n          python_param { module: \'test_python_layer_with_param_str\'\n                layer: \'SimpleParamLayer\' param_str: \'2\' } }"""""")\n        return f.name\n\n\n@unittest.skipIf(\'Python\' not in caffe.layer_type_list(),\n    \'Caffe built without Python layer support\')\nclass TestLayerWithParam(unittest.TestCase):\n    def setUp(self):\n        net_file = python_param_net_file()\n        self.net = caffe.Net(net_file, caffe.TRAIN)\n        os.remove(net_file)\n\n    def test_forward(self):\n        x = 8\n        self.net.blobs[\'data\'].data[...] = x\n        self.net.forward()\n        for y in self.net.blobs[\'mul2\'].data.flat:\n            self.assertEqual(y, 2 * 10 * x)\n\n    def test_backward(self):\n        x = 7\n        self.net.blobs[\'mul2\'].diff[...] = x\n        self.net.backward()\n        for y in self.net.blobs[\'data\'].diff.flat:\n            self.assertEqual(y, 2 * 10 * x)\n'"
python/caffe/test/test_solver.py,0,"b'import unittest\nimport tempfile\nimport os\nimport numpy as np\nimport six\n\nimport caffe\nfrom test_net import simple_net_file\n\n\nclass TestSolver(unittest.TestCase):\n    def setUp(self):\n        self.num_output = 13\n        net_f = simple_net_file(self.num_output)\n        f = tempfile.NamedTemporaryFile(mode=\'w+\', delete=False)\n        f.write(""""""net: \'"""""" + net_f + """"""\'\n        test_iter: 10 test_interval: 10 base_lr: 0.01 momentum: 0.9\n        weight_decay: 0.0005 lr_policy: \'inv\' gamma: 0.0001 power: 0.75\n        display: 100 max_iter: 100 snapshot_after_train: false\n        snapshot_prefix: ""model"" """""")\n        f.close()\n        self.solver = caffe.SGDSolver(f.name)\n        # also make sure get_solver runs\n        caffe.get_solver(f.name)\n        caffe.set_mode_cpu()\n        # fill in valid labels\n        self.solver.net.blobs[\'label\'].data[...] = \\\n                np.random.randint(self.num_output,\n                    size=self.solver.net.blobs[\'label\'].data.shape)\n        self.solver.test_nets[0].blobs[\'label\'].data[...] = \\\n                np.random.randint(self.num_output,\n                    size=self.solver.test_nets[0].blobs[\'label\'].data.shape)\n        os.remove(f.name)\n        os.remove(net_f)\n\n    def test_solve(self):\n        self.assertEqual(self.solver.iter, 0)\n        self.solver.solve()\n        self.assertEqual(self.solver.iter, 100)\n\n    def test_net_memory(self):\n        """"""Check that nets survive after the solver is destroyed.""""""\n\n        nets = [self.solver.net] + list(self.solver.test_nets)\n        self.assertEqual(len(nets), 2)\n        del self.solver\n\n        total = 0\n        for net in nets:\n            for ps in six.itervalues(net.params):\n                for p in ps:\n                    total += p.data.sum() + p.diff.sum()\n            for bl in six.itervalues(net.blobs):\n                total += bl.data.sum() + bl.diff.sum()\n\n    def test_snapshot(self):\n        self.solver.snapshot()\n        # Check that these files exist and then remove them\n        files = [\'model_iter_0.caffemodel\', \'model_iter_0.solverstate\']\n        for fn in files:\n            assert os.path.isfile(fn)\n            os.remove(fn)\n'"
src/caffe/test/test_data/generate_sample_data.py,0,"b'""""""\nGenerate data used in the HDF5DataLayer and GradientBasedSolver tests.\n""""""\nimport os\nimport numpy as np\nimport h5py\n\nscript_dir = os.path.dirname(os.path.abspath(__file__))\n\n# Generate HDF5DataLayer sample_data.h5\n\nnum_cols = 8\nnum_rows = 10\nheight = 6\nwidth = 5\ntotal_size = num_cols * num_rows * height * width\n\ndata = np.arange(total_size)\ndata = data.reshape(num_rows, num_cols, height, width)\ndata = data.astype(\'float32\')\n\n# We had a bug where data was copied into label, but the tests weren\'t\n# catching it, so let\'s make label 1-indexed.\nlabel = 1 + np.arange(num_rows)[:, np.newaxis]\nlabel = label.astype(\'float32\')\n\n# We add an extra label2 dataset to test HDF5 layer\'s ability\n# to handle arbitrary number of output (""top"") Blobs.\nlabel2 = label + 1\n\nprint data\nprint label\n\nwith h5py.File(script_dir + \'/sample_data.h5\', \'w\') as f:\n    f[\'data\'] = data\n    f[\'label\'] = label\n    f[\'label2\'] = label2\n\nwith h5py.File(script_dir + \'/sample_data_2_gzip.h5\', \'w\') as f:\n    f.create_dataset(\n        \'data\', data=data + total_size,\n        compression=\'gzip\', compression_opts=1\n    )\n    f.create_dataset(\n        \'label\', data=label,\n        compression=\'gzip\', compression_opts=1,\n        dtype=\'uint8\',\n    )\n    f.create_dataset(\n        \'label2\', data=label2,\n        compression=\'gzip\', compression_opts=1,\n        dtype=\'uint8\',\n    )\n\nwith open(script_dir + \'/sample_data_list.txt\', \'w\') as f:\n    f.write(\'src/caffe/test/test_data/sample_data.h5\\n\')\n    f.write(\'src/caffe/test/test_data/sample_data_2_gzip.h5\\n\')\n\n# Generate GradientBasedSolver solver_data.h5\n\nnum_cols = 3\nnum_rows = 8\nheight = 10\nwidth = 10\n\ndata = np.random.randn(num_rows, num_cols, height, width)\ndata = data.reshape(num_rows, num_cols, height, width)\ndata = data.astype(\'float32\')\n\ntargets = np.random.randn(num_rows, 1)\ntargets = targets.astype(\'float32\')\n\nprint data\nprint targets\n\nwith h5py.File(script_dir + \'/solver_data.h5\', \'w\') as f:\n    f[\'data\'] = data\n    f[\'targets\'] = targets\n\nwith open(script_dir + \'/solver_data_list.txt\', \'w\') as f:\n    f.write(\'src/caffe/test/test_data/solver_data.h5\\n\')\n'"
