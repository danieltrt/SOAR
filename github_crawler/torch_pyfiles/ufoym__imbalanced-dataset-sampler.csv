file_path,api_count,code
setup.py,0,"b'""""""A setuptools based setup module.""""""\n\n# Always prefer setuptools over distutils\nfrom os import path\nfrom setuptools import setup\n# io.open is needed for projects that support Python 2.7\n# It ensures open() defaults to text mode with universal newlines, and accepts an argument\n#  to specify the text encoding Python 3 only projects can skip this import\nfrom io import open\n\ntry:\n    import builtins\nexcept ImportError:\n    import __builtin__ as builtins\n\nbuiltins.__LIGHTNING_SETUP__ = True\nPATH_HERE = path.abspath(path.dirname(__file__))\n\nimport torchsampler\n\nwith open(path.join(PATH_HERE, \'requirements.txt\'), encoding=\'utf-8\') as fp:\n    requirements = [rq.rstrip() for rq in fp.readlines() if not rq.startswith(\'#\')]\n\n# Arguments marked as ""Required"" below must be included for upload to PyPI.\n# Fields marked as ""Optional"" may be commented out.\nsetup(\n    name=\'torchsampler\',\n    version=torchsampler.__version__,\n    url=torchsampler.__homepage__,\n\n    author=torchsampler.__author__,\n    author_email=torchsampler.__author_email__,\n    license=torchsampler.__license__,\n    description=torchsampler.__doc__,\n\n    packages=[\'torchsampler\'],\n\n    keywords=\'sampler\',\n    install_requires=requirements,\n    include_package_data=True,\n    classifiers=[\n        \'Environment :: Console\',\n        \'Natural Language :: English\',\n        # How mature is this project? Common values are\n        #   3 - Alpha, 4 - Beta, 5 - Production/Stable\n        \'Development Status :: 4 - Beta\',\n        # Indicate who your project is intended for\n        \'Intended Audience :: Developers\',\n        # Pick your license as you wish\n        \'License :: OSI Approved :: MIT License\',\n        \'Operating System :: OS Independent\',\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        \'Programming Language :: Python :: 2\',\n        \'Programming Language :: Python :: 3\',\n    ],\n)\n'"
torchsampler/__init__.py,0,"b'__version__ = ""0.1""\n__author__ = ""Ming""\n__author_email__ = ""a@ufoym.com""\n__license__ = ""MIT""\n__homepage__ = ""https://github.com/ufoym/imbalanced-dataset-sampler"",\n__doc__ = \'A (PyTorch) imbalanced dataset sampler for oversampling low frequent classes and undersampling high frequent ones.\'\n\ntry:\n    # This variable is injected in the __builtins__ by the build\n    # process. It used to enable importing subpackages of skimage when\n    # the binaries are not built\n    __LIGHTNING_SETUP__\nexcept NameError:\n    __LIGHTNING_SETUP__ = False\n\nif __LIGHTNING_SETUP__:\n    import sys\n    sys.stderr.write(\'Partial import during the build process.\\n\')\nelse:\n    from torchsampler.imbalanced import ImbalancedDatasetSampler\n\n    __all__ = [\n        \'ImbalancedDatasetSampler\',\n    ]\n'"
torchsampler/imbalanced.py,5,"b'import torch\nimport torch.utils.data\nimport torchvision\n\n\nclass ImbalancedDatasetSampler(torch.utils.data.sampler.Sampler):\n    """"""Samples elements randomly from a given list of indices for imbalanced dataset\n    Arguments:\n        indices (list, optional): a list of indices\n        num_samples (int, optional): number of samples to draw\n        callback_get_label func: a callback-like function which takes two arguments - dataset and index\n    """"""\n\n    def __init__(self, dataset, indices=None, num_samples=None, callback_get_label=None):\n                \n        # if indices is not provided, \n        # all elements in the dataset will be considered\n        self.indices = list(range(len(dataset))) \\\n            if indices is None else indices\n\n        # define custom callback\n        self.callback_get_label = callback_get_label\n\n        # if num_samples is not provided, \n        # draw `len(indices)` samples in each iteration\n        self.num_samples = len(self.indices) \\\n            if num_samples is None else num_samples\n            \n        # distribution of classes in the dataset \n        label_to_count = {}\n        for idx in self.indices:\n            label = self._get_label(dataset, idx)\n            if label in label_to_count:\n                label_to_count[label] += 1\n            else:\n                label_to_count[label] = 1\n                \n        # weight for each sample\n        weights = [1.0 / label_to_count[self._get_label(dataset, idx)]\n                   for idx in self.indices]\n        self.weights = torch.DoubleTensor(weights)\n\n    def _get_label(self, dataset, idx):\n        if isinstance(dataset, torchvision.datasets.MNIST):\n            return dataset.train_labels[idx].item()\n        elif isinstance(dataset, torchvision.datasets.ImageFolder):\n            return dataset.imgs[idx][1]\n        elif isinstance(dataset, torch.utils.data.Subset):\n            return dataset.dataset.imgs[idx][1]\n        elif self.callback_get_label:\n            return self.callback_get_label(dataset, idx)\n        else:\n            raise NotImplementedError\n                \n    def __iter__(self):\n        return (self.indices[i] for i in torch.multinomial(\n            self.weights, self.num_samples, replacement=True))\n\n    def __len__(self):\n        return self.num_samples\n'"
